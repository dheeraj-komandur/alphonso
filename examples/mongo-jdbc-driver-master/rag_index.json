{
  "Main.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\demo\\src\\main\\java\\com\\mongodb\\jdbc\\demo\\Main.java",
    "chunks": [
      {
        "file_path": "demo\\src\\main\\java\\com\\mongodb\\jdbc\\demo\\Main.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\demo\\src\\main\\java\\com\\mongodb\\jdbc\\demo\\Main.java",
        "chunk_id": "Main_1",
        "content": "<line_number-1>package com.mongodb.jdbc.demo;\n<line_number-2>\n<line_number-3>import java.sql.*;\n<line_number-4>import java.util.TimeZone;\n<line_number-5>import java.util.Calendar;\n<line_number-6>import java.util.GregorianCalendar;\n<line_number-7>\n<line_number-8>public class Main {\n<line_number-9>   // JDBC driver name and database URL\n<line_number-10>   static final String JDBC_DRIVER = \"com.mongodb.jdbc.MongoDriver\";\n<line_number-11>   static final String URL = \"jdbc:mongodb://mhuser:pencil@localhost:27017/admin\";\n<line_number-12>   private static final TimeZone UTC = TimeZone.getTimeZone(\"UTC\");\n<line_number-13>\n<line_number-14>   // Data used for test, in the test.test and test2.test collections:\n<line_number-15>   //\n<line_number-16>   //{ \"values\" : [\n<line_number-17>   //    { \"database\" : \"myDB\", \"table\" : \"foo\", \"tableAlias\" : \"foo\", \"column\" : \"a\", \"columnAlias\" : \"a\", \"value\" : 1 },\n<line_number-18>   //    { \"database\" : \"myDB\", \"table\" : \"foo\", \"tableAlias\" : \"foo\", \"column\" : \"b\", \"columnAlias\" : \"b\", \"value\" : \"hello\" } ]\n<line_number-19>   //    }\n<line_number-20>   //{ \"values\" : [\n<line_number-21>   //    { \"database\" : \"myDB\", \"table\" : \"foo\", \"tableAlias\" : \"foo\", \"column\" : \"a\", \"columnAlias\" : \"a\", \"value\" : 42 },\n<line_number-22>   //    { \"database\" : \"myDB\", \"table\" : \"foo\", \"tableAlias\" : \"foo\", \"column\" : \"b\", \"columnAlias\" : \"b\", \"value\" : \"hello 2\" } ]\n<line_number-23>   //    }\n<line_number-24>   //\n<line_number-25>   public static void main(String[] args) {\n<line_number-26>\n<line_number-27>      try{\n<line_number-28>         java.util.Properties p = new java.util.Properties();\n<line_number-29>         // These properties will be added to the URI.\n<line_number-30>         // Uncomment if you wish to specify user and password.\n<line_number-31>         // p.setProperty(\"user\", \"user\");\n<line_number-32>         // p.setProperty(\"password\", \"foo\");\n<line_number-33>         p.setProperty(\"database\", \"test\");\n<line_number-34>         System.out.println(\"Connecting to database test...\");\n<line_number-35>         Connection conn = DriverManager.getConnection(URL, p);\n<line_number-36>\n<line_number-37>        DatabaseMetaData dbmd = conn.getMetaData();\n<line_number-38>        System.out.println(dbmd.getDriverVersion());\n<line_number-39>        System.out.println(dbmd.getDriverMajorVersion());\n<line_number-40>        System.out.println(dbmd.getDriverMinorVersion());\n<line_number-41>//         System.out.println(\"Creating statement...\");\n<line_number-42>//         Statement stmt = conn.createStatement();\n<line_number-43>//         ResultSet rs = stmt.executeQuery(\"select * from foo\");\n<line_number-44>//         System.out.println(\"++++++ Showing contents for test.foo ++++++++\");\n<line_number-45>//         displayResultSet(rs);\n<line_number-46>      } catch (Exception e) {\n<line_number-47>          throw new RuntimeException(e);\n<line_number-48>      }\n<line_number-49>   }\n<line_number-50>\n<line_number-51>   public static void displayResultSet(ResultSet rs) throws java.sql.SQLException {\n<line_number-52>\t   Calendar c = new GregorianCalendar();\n<line_number-53>\t   c.setTimeZone(UTC);\n<line_number-54>       while(rs.next()){\n<line_number-55>          //Retrieve by column name\n<line_number-56>          double a = rs.getDouble(\"a\");\n<line_number-57>\t\t  String as = rs.getString(\"a\");\n<line_number-58>          String b = rs.getString(\"b\");\n<line_number-59>\t\t  java.sql.Timestamp bd;\n<line_number-60>\t\t  try {\n<line_number-61>\t\t  \t\tbd = rs.getTimestamp(\"b\", c);\n<line_number-62>\t\t\t\tSystem.out.println(\"b as a Timestamp is: \" + bd);\n<line_number-63>\t\t  } catch (SQLException e) {\n<line_number-64>\t\t\t\tSystem.out.println(e);\n<line_number-65>\t\t  } catch (Exception e) {\n<line_number-66>\t\t\t\tthrow new RuntimeException(e);\n<line_number-67>\t\t  }\n<line_number-68>          ResultSetMetaData metaData = rs.getMetaData();\n<line_number-69>\t\t  System.out.println(\"a is: \" + a + \" as double\"\n<line_number-70>\t\t\t\t  + \" b is: \" + b + \" as string\");\n<line_number-71>\t\t  System.out.println(\"a as a string is: \" + as);\n<line_number-72>       }\n<line_number-73>   }\n<line_number-74>}\n",
        "comments": [
          {
            "comment_code_range": "8-74",
            "comment_linenumber": "7",
            "comment": "Main class responsible for connecting to a MongoDB database and displaying results from a specified collection.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "25-49",
            "comment_linenumber": "24",
            "comment": "Main method that establishes a connection to the MongoDB database using JDBC and retrieves metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "27-48",
            "comment_linenumber": "26",
            "comment": "Try-catch block for handling exceptions during database connection and metadata retrieval.",
            "comment_kind": "try"
          },
          {
            "comment_code_range": "51-73",
            "comment_linenumber": "50",
            "comment": "Displays the contents of a ResultSet, retrieving values by column name and handling potential exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "54-72",
            "comment_linenumber": "53",
            "comment": "Loop through the ResultSet to retrieve and print values for columns 'a' and 'b'.",
            "comment_kind": "loop"
          },
          {
            "comment_code_range": "60-66",
            "comment_linenumber": "59",
            "comment": "Try-catch block for handling exceptions when retrieving a Timestamp from the ResultSet.",
            "comment_kind": "try"
          }
        ],
        "structural_analysis": "The file 'Main.java' serves as a demonstration of connecting to a MongoDB database using JDBC. It follows a straightforward structure with a single public class named 'Main'. The class contains two primary static methods: 'main' and 'displayResultSet'. The 'main' method is responsible for establishing a connection to the MongoDB database using a JDBC URL and properties, while the 'displayResultSet' method processes and displays the results from a SQL query executed against the database. The class utilizes Java's JDBC API for database interactions, including handling exceptions that may arise during connection and data retrieval. The 'main' method includes a try-catch block to manage exceptions, ensuring that any issues during the connection process are appropriately handled. The 'displayResultSet' method includes a loop to iterate through the ResultSet, retrieving values by column names and printing them to the console. Additionally, it contains a nested try-catch block to handle potential exceptions when retrieving a Timestamp value. Overall, the file demonstrates basic database connectivity and data retrieval using JDBC with MongoDB.",
        "file_summary": "This file demonstrates how to connect to a MongoDB database using JDBC, retrieve metadata, and display results from a specified collection. It includes exception handling for database operations and showcases the use of ResultSet to access and print data."
      }
    ]
  },
  "MongoSQLTestUtils.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\demo\\src\\test\\java\\com\\mongodb\\jdbc\\utils\\MongoSQLTestUtils.java",
    "chunks": [
      {
        "file_path": "demo\\src\\test\\java\\com\\mongodb\\jdbc\\utils\\MongoSQLTestUtils.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\demo\\src\\test\\java\\com\\mongodb\\jdbc\\utils\\MongoSQLTestUtils.java",
        "chunk_id": "MongoSQLTestUtils_1",
        "content": "<line_number-1>package com.mongodb.jdbc.utils;\n<line_number-2>\n<line_number-3>import java.sql.Connection;\n<line_number-4>import java.sql.DriverManager;\n<line_number-5>import java.sql.Statement;\n<line_number-6>\n<line_number-7>public class MongoSQLTestUtils extends TestUtils {\n<line_number-8>    static final String URL = \"jdbc:mongodb://localhost\";\n<line_number-9>    public static final String TEST_DB = \"integration_test\";\n<line_number-10>    public static final String DEFAULT_TEST_COLLECTION = \"test_collection\";\n<line_number-11>\n<line_number-12>    @Override\n<line_number-13>    protected Connection connect() throws Exception {\n<line_number-14>        // Connects to local ADF instance\n<line_number-15>        java.util.Properties p = new java.util.Properties();\n<line_number-16>        p.setProperty(\"user\", System.getenv(\"ADF_TEST_LOCAL_USER\"));\n<line_number-17>        p.setProperty(\"password\", System.getenv(\"ADF_TEST_LOCAL_PWD\"));\n<line_number-18>        p.setProperty(\"authSource\", System.getenv(\"ADF_TEST_LOCAL_AUTH_DB\"));\n<line_number-19>        p.setProperty(\"database\", TEST_DB);\n<line_number-20>        p.setProperty(\"ssl\", \"false\");\n<line_number-21>        Connection conn = DriverManager.getConnection(URL, p);\n<line_number-22>        try {\n<line_number-23>            Statement stmt = conn.createStatement();\n<line_number-24>            stmt.executeQuery(\"select 1 from \" + DEFAULT_TEST_COLLECTION);\n<line_number-25>        } catch (Exception e) {\n<line_number-26>            e.printStackTrace();\n<line_number-27>            throw e;\n<line_number-28>        }\n<line_number-29>\n<line_number-30>        return conn;\n<line_number-31>    }\n<line_number-32>}\n",
        "comments": [
          {
            "comment_code_range": "1-1",
            "comment_linenumber": "0",
            "comment": "Defines the package for MongoDB JDBC utility functions.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "7-31",
            "comment_linenumber": "6",
            "comment": "Utility class for testing MongoDB SQL connections, extending TestUtils. It provides a method to establish a connection to a MongoDB instance.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "12-30",
            "comment_linenumber": "11",
            "comment": "Establishes a connection to the MongoDB database using credentials from environment variables and returns the connection object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "14-20",
            "comment_linenumber": "13",
            "comment": "Sets up connection properties for MongoDB, including user credentials and database name.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "22-28",
            "comment_linenumber": "21",
            "comment": "Executes a test query to validate the connection to the specified collection and handles any exceptions that occur.",
            "comment_kind": "block"
          }
        ],
        "structural_analysis": "The file 'MongoSQLTestUtils.java' serves as a utility class for testing MongoDB SQL connections, extending a base class 'TestUtils'. It follows a standard Java class structure with a package declaration, imports, and a public class definition. The class contains static final fields for the database URL, test database name, and default test collection name. The primary method, 'connect()', overrides a method from the superclass to establish a connection to a MongoDB instance. It utilizes Java's JDBC API to manage the connection and execute a simple query to ensure the connection is valid. The method handles exceptions by printing the stack trace and rethrowing the exception. The class does not implement any complex design patterns but relies on standard JDBC practices for database connectivity.",
        "file_summary": "The 'MongoSQLTestUtils' class provides utility functions for establishing and validating connections to a MongoDB database for testing purposes, leveraging JDBC for database interactions."
      }
    ]
  },
  "PrintUtils.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\demo\\src\\test\\java\\com\\mongodb\\jdbc\\utils\\PrintUtils.java",
    "chunks": [
      {
        "file_path": "demo\\src\\test\\java\\com\\mongodb\\jdbc\\utils\\PrintUtils.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\demo\\src\\test\\java\\com\\mongodb\\jdbc\\utils\\PrintUtils.java",
        "chunk_id": "PrintUtils_1",
        "content": "<line_number-1>package com.mongodb.jdbc.utils;\n<line_number-2>\n<line_number-3>import java.sql.ResultSet;\n<line_number-4>import java.sql.ResultSetMetaData;\n<line_number-5>import java.sql.SQLException;\n<line_number-6>import java.util.ArrayList;\n<line_number-7>import java.util.Arrays;\n<line_number-8>import java.util.List;\n<line_number-9>\n<line_number-10>public class PrintUtils {\n<line_number-11>    private static final String NULL_STR = \"null\";\n<line_number-12>    private static int MAX_RS_META_COL_WIDTH = 12;\n<line_number-13>    public static int MAX_COL_WIDTH = 20;\n<line_number-14>\n<line_number-15>    public static void printResultSetMetadata(ResultSetMetaData rsMeta)  throws SQLException {\n<line_number-16>        try {\n<line_number-17>            int columnCount = rsMeta.getColumnCount();\n<line_number-18>            StringBuilder sb = new StringBuilder();\n<line_number-19>            List<String> colNames = new ArrayList<String>();\n<line_number-20>            colNames.add(\"TABLE_CAT\");\n<line_number-21>            colNames.add(\"TABLE_SCHEMA\");\n<line_number-22>            colNames.add(\"TABLE_NAME\");\n<line_number-23>            colNames.add(\"COLUMN_NAME\");\n<line_number-24>            colNames.add(\"DATA_TYPE\");\n<line_number-25>            colNames.add(\"TYPE_NAME\");\n<line_number-26>            colNames.add(\"DISPLAY_SIZE\");\n<line_number-27>            colNames.add(\"PRECISION\");\n<line_number-28>            colNames.add(\"SCALE\");\n<line_number-29>            colNames.add(\"CLASS_NAME\");\n<line_number-30>            colNames.add(\"LABEL\");\n<line_number-31>\n<line_number-32>            printRowSeparator(sb, colNames.size(), MAX_RS_META_COL_WIDTH);\n<line_number-33>            for (int i = 0; i < colNames.size(); i++) {\n<line_number-34>                sb.append(String.format(getFormat(MAX_RS_META_COL_WIDTH), colNames.get(i)));\n<line_number-35>            }\n<line_number-36>            sb.append(\"|\\n\");\n<line_number-37>            printRowSeparator(sb, colNames.size(), MAX_RS_META_COL_WIDTH);\n<line_number-38>\n<line_number-39>            for (int i = 1; i <= columnCount; i++) {\n<line_number-40>                boolean hasMoreData = true;\n<line_number-41>                String[] row =  new String[11];\n<line_number-42>                row[0] = rsMeta.getCatalogName(i);\n<line_number-43>                row[1] = rsMeta.getSchemaName(i);\n<line_number-44>                row[2] = rsMeta.getTableName(i);\n<line_number-45>                row[3] = rsMeta.getColumnName(i);\n<line_number-46>                row[4] = String.valueOf(rsMeta.getColumnType(i));\n<line_number-47>                row[5] = rsMeta.getColumnTypeName(i);\n<line_number-48>                row[6] = String.valueOf(rsMeta.getColumnDisplaySize(i));\n<line_number-49>                row[7] = String.valueOf(rsMeta.getPrecision(i));\n<line_number-50>                row[8] = String.valueOf(rsMeta.getScale(i));\n<line_number-51>                row[9] = rsMeta.getColumnClassName(i);\n<line_number-52>                row[10] = rsMeta.getColumnLabel(i);\n<line_number-53>\n<line_number-54>                while (hasMoreData) {\n<line_number-55>                    hasMoreData = false;\n<line_number-56>                    for (int j = 0; j < row.length; j++) {\n<line_number-57>                        String data = row[j];\n<line_number-58>                        int cutIndex = Math.min(data.length(), MAX_RS_META_COL_WIDTH);\n<line_number-59>                        sb.append(String.format(getFormat(MAX_RS_META_COL_WIDTH), data.substring(0, cutIndex)));\n<line_number-60>                        if (cutIndex == MAX_RS_META_COL_WIDTH) {\n<line_number-61>                            row[j] = data.substring(cutIndex);\n<line_number-62>                            hasMoreData = true;\n<line_number-63>                        }\n<line_number-64>                        else\n<line_number-65>                        {\n<line_number-66>                            row[j] = \"\";\n<line_number-67>                        }\n<line_number-68>                    }\n<line_number-69>                    sb.append(\"|\\n\");\n<line_number-70>                }\n<line_number-71>            }\n<line_number-72>            printRowSeparator(sb, colNames.size(), MAX_RS_META_COL_WIDTH);\n<line_number-73>\n<line_number-74>            System.out.println(sb.toString());\n<line_number-75>        }\n<line_number-76>        catch (Exception e) {\n<line_number-77>            e.printStackTrace();\n<line_number-78>            throw e;\n<line_number-79>        }\n<line_number-80>    }\n<line_number-81>\n<line_number-82>    public static void printResultSet(ResultSet rs) throws SQLException {\n<line_number-83>        try {\n<line_number-84>            // Get the metadata of this rs.\n<line_number-85>            ResultSetMetaData rsMeta;\n<line_number-86>            rsMeta = rs.getMetaData();\n<line_number-87>            int columnCount = rsMeta.getColumnCount();\n<line_number-88>            StringBuilder sb = new StringBuilder();\n<line_number-89>            int[] maxColsWidth = printRsHeader(sb, columnCount, rsMeta);\n<line_number-90>            printRsContents(sb, columnCount, rs, maxColsWidth);\n<line_number-91>\n<line_number-92>            System.out.println(sb.toString());\n<line_number-93>        }\n<line_number-94>        catch (Exception e) {\n<line_number-95>            e.printStackTrace();\n<line_number-96>            throw e;\n<line_number-97>        }\n<line_number-98>    }\n<line_number-99>\n<line_number-100>    private static String getFormat(int maxColWidth) {\n<line_number-101>        return \"| %-\" + maxColWidth + \"s \";\n<line_number-102>    }\n<line_number-103>\n<line_number-104>    private static void printRsContents(StringBuilder sb, int columnCount, ResultSet rs, int[] maxColsWidth) throws SQLException {\n<line_number-105>        String data = null;\n<line_number-106>        String cellValue;\n<line_number-107>        while (rs.next()) {\n<line_number-108>            String[] row = new String[columnCount];\n<line_number-109>\n<line_number-110>            boolean hasMoreData;\n<line_number-111>            do {\n<line_number-112>                hasMoreData = false;\n<line_number-113>                for (int i = 0; i < columnCount; i++) {\n<line_number-114>                    if (row[i] == null) {\n<line_number-115>                        cellValue = rs.getString(i + 1);\n<line_number-116>                        row[i] = (cellValue == null ? NULL_STR : cellValue);\n<line_number-117>                    }\n<line_number-118>                    int cutIndex = Math.min(row[i].length(), maxColsWidth[i]);\n<line_number-119>                    data = row[i].substring(0, cutIndex);\n<line_number-120>                    if (cutIndex == maxColsWidth[i]) {\n<line_number-121>                        row[i] = row[i].substring(cutIndex);\n<line_number-122>                        hasMoreData = true;\n<line_number-123>                    }\n<line_number-124>                    else {\n<line_number-125>                        row[i] = \"\";\n<line_number-126>                    }\n<line_number-127>                    sb.append(String.format(getFormat(maxColsWidth[i]), data));\n<line_number-128>                }\n<line_number-129>                sb.append(\"|\\n\");\n<line_number-130>            } while (hasMoreData);\n<line_number-131>        }\n<line_number-132>        printRowSeparator(sb, columnCount, maxColsWidth);\n<line_number-133>    }\n<line_number-134>\n<line_number-135>    private static int[] printRsHeader(StringBuilder sb, int columnCount, ResultSetMetaData rsMeta) throws SQLException {\n<line_number-136>        String[] col_names = new String[columnCount];\n<line_number-137>        int[] maxColWidth = new int[columnCount];\n<line_number-138>        for (int i = 0; i < columnCount; i++) {\n<line_number-139>            maxColWidth[i] = MAX_COL_WIDTH;\n<line_number-140>            col_names[i] =  rsMeta.getColumnName(i+1);\n<line_number-141>            if (col_names[i].length() > maxColWidth[i]) {\n<line_number-142>                maxColWidth[i] = col_names[i].length();\n<line_number-143>            }\n<line_number-144>        }\n<line_number-145>\n<line_number-146>        printRowSeparator(sb, columnCount, maxColWidth);\n<line_number-147>        for (int i = 0; i < columnCount; i++) {\n<line_number-148>            sb.append(String.format(getFormat(maxColWidth[i]), col_names[i]));\n<line_number-149>        }\n<line_number-150>        sb.append(\"|\\n\");\n<line_number-151>        printRowSeparator(sb, columnCount, maxColWidth);\n<line_number-152>\n<line_number-153>        return maxColWidth;\n<line_number-154>    }\n<line_number-155>\n<line_number-156>    private static void printRowSeparator(StringBuilder sb, int columnCount, int[] maxColsWidth) {\n<line_number-157>        sb.append(\"+\");\n<line_number-158>        for (int i = 0; i < columnCount; i++) {\n<line_number-159>            sb.append(new String(new char[maxColsWidth[i] + 2]).replace(\"\\0\", \"-\"));\n<line_number-160>            sb.append(\"|\");\n<line_number-161>        }\n<line_number-162>        sb.replace(sb.length() - 1, sb.length(), \"+\\n\");\n<line_number-163>    }\n<line_number-164>\n<line_number-165>    private static void printRowSeparator(StringBuilder sb, int columnCount, int maxColsWidth) {\n<line_number-166>        sb.append(\"+\");\n<line_number-167>        for (int i = 0; i < columnCount; i++) {\n<line_number-168>            sb.append(new String(new char[maxColsWidth + 2]).replace(\"\\0\", \"-\"));\n<line_number-169>            sb.append(\"|\");\n<line_number-170>        }\n<line_number-171>        sb.replace(sb.length() - 1, sb.length(), \"+\\n\");\n<line_number-172>    }\n<line_number-173>}\n",
        "comments": [
          {
            "comment_code_range": "10-173",
            "comment_linenumber": "9",
            "comment": "Utility class for printing SQL ResultSet metadata and contents in a formatted manner.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "15-80",
            "comment_linenumber": "14",
            "comment": "Prints the metadata of a ResultSet, including column names and types, formatted in a table.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "32-72",
            "comment_linenumber": "31",
            "comment": "Prints a separator line for the metadata table.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "82-98",
            "comment_linenumber": "81",
            "comment": "Prints the contents of a ResultSet, formatted according to the metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "104-132",
            "comment_linenumber": "103",
            "comment": "Handles the printing of each row's contents from the ResultSet, managing data width.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "135-153",
            "comment_linenumber": "134",
            "comment": "Prints the header of the ResultSet, including column names and adjusts column widths.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "156-172",
            "comment_linenumber": "155",
            "comment": "Prints a row separator for the table, based on the number of columns and their widths.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "165-172",
            "comment_linenumber": "164",
            "comment": "Overloaded method to print a row separator with a fixed maximum column width.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'PrintUtils.java' serves as a utility class for formatting and printing SQL ResultSet metadata and its contents. It employs a procedural style with static methods to handle various aspects of ResultSet printing. The primary methods include 'printResultSetMetadata' for displaying metadata, 'printResultSet' for printing the actual data, and helper methods like 'printRsContents', 'printRsHeader', and 'printRowSeparator' to manage the formatting and layout of the output. The class maintains constants for maximum column widths and handles exceptions related to SQL operations. It does not maintain any state and is designed to be thread-safe due to its stateless nature. The methods interact with the ResultSet and ResultSetMetaData classes from the java.sql package, ensuring that the output is structured and readable. The class does not expose any public APIs or external dependencies beyond standard Java libraries.",
        "file_summary": "The 'PrintUtils' class provides utility functions to print SQL ResultSet metadata and data in a formatted table layout, enhancing readability for debugging and logging purposes."
      }
    ]
  },
  "TestUtils.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\demo\\src\\test\\java\\com\\mongodb\\jdbc\\utils\\TestUtils.java",
    "chunks": [
      {
        "file_path": "demo\\src\\test\\java\\com\\mongodb\\jdbc\\utils\\TestUtils.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\demo\\src\\test\\java\\com\\mongodb\\jdbc\\utils\\TestUtils.java",
        "chunk_id": "TestUtils_1",
        "content": "<line_number-1>package com.mongodb.jdbc.utils;\n<line_number-2>\n<line_number-3>import java.sql.Connection;\n<line_number-4>import java.sql.DatabaseMetaData;\n<line_number-5>import java.sql.ResultSet;\n<line_number-6>import java.sql.SQLException;\n<line_number-7>import java.sql.Statement;\n<line_number-8>import org.junit.jupiter.api.AfterEach;\n<line_number-9>import org.junit.jupiter.api.BeforeEach;\n<line_number-10>import org.junit.jupiter.api.Test;\n<line_number-11>\n<line_number-12>/***\n<line_number-13> * This class provides the baseline for common things that applications built on top of JDBC use.\n<line_number-14> * - Connecting to the database: testConnection\n<line_number-15> * - Executing a query and printing out the result set information: testExecute, testExecutePrintMetadata.\n<line_number-16> * - Retrieving database metadata information to check the driver information and capability: testDBMeta.\n<line_number-17> * - Retrieving catalog information: testGetCatalogs, testGetSchemas, testGetTables, testGetTablePrivileges...\n<line_number-18> * - Cancelling a long running query: testCancel\n<line_number-19> *\n<line_number-20> * It does not cover everything an application can/will do (there is no prepare/execute flow for example).\n<line_number-21> *\n<line_number-22> * It is expected that you will modify the code here based on your need when you want to try out or debug something.\n<line_number-23> * The version in the GitHub repository is only a first minimalistic version to help you get started.\n<line_number-24> * This class must live and its content evolve with you.\n<line_number-25> *\n<line_number-26> * Please note that in order to run one of the helper you need to uncomment the \"exclude 'com/mongodb/jdbc/utils/**'\" line\n<line_number-27> * in the build.gradle file.\n<line_number-28> */\n<line_number-29>public abstract class TestUtils {\n<line_number-30>\n<line_number-31>    protected Connection m_conn;\n<line_number-32>    protected DatabaseMetaData m_dbMeta;\n<line_number-33>\n<line_number-34>    protected abstract Connection connect() throws Exception;\n<line_number-35>\n<line_number-36>    @BeforeEach\n<line_number-37>    private void execConnection() throws Exception {\n<line_number-38>        m_conn = connect();\n<line_number-39>        m_dbMeta = m_conn.getMetaData();\n<line_number-40>    }\n<line_number-41>\n<line_number-42>    @AfterEach\n<line_number-43>    private void execDeconnection() throws Exception {\n<line_number-44>        m_conn.close();\n<line_number-45>    }\n<line_number-46>\n<line_number-47>    @Test\n<line_number-48>    void tryConnecting() throws Exception {\n<line_number-49>        System.out.println(m_dbMeta.getDriverName());\n<line_number-50>        System.out.println(m_dbMeta.getDriverVersion());\n<line_number-51>\n<line_number-52>        System.out.println(\"Connected !\");\n<line_number-53>    }\n<line_number-54>\n<line_number-55>    @Test\n<line_number-56>    void tryExecute() throws Exception {\n<line_number-57>        runExecuteQuery(\"select * from bar\", true);\n<line_number-58>    }\n<line_number-59>\n<line_number-60>    @Test\n<line_number-61>    void tryExecutePrintMetadata() throws Exception {\n<line_number-62>        runExecuteQuery(\"select * from foo\", false);\n<line_number-63>    }\n<line_number-64>\n<line_number-65>    @Test\n<line_number-66>    void tryGetCatalogs() throws Exception {\n<line_number-67>        ResultSet rs = m_dbMeta.getCatalogs();\n<line_number-68>        printRsInfo(rs);\n<line_number-69>    }\n<line_number-70>\n<line_number-71>    @Test\n<line_number-72>    void tryGetTables() throws Exception {\n<line_number-73>        //ResultSet rs = m_dbMeta.getTables(null, null, null, null);\n<line_number-74>        ResultSet rs = m_dbMeta.getTables(null, null, \"%\", new String[]{\"table\", \"view\"});\n<line_number-75>        printRsInfo(rs);\n<line_number-76>    }\n<line_number-77>\n<line_number-78>    @Test\n<line_number-79>    void tryGetColumns() throws Exception {\n<line_number-80>        //ResultSet rs = m_dbMeta.getColumns(null, null, null, null);\n<line_number-81>        ResultSet rs = m_dbMeta.getColumns(null, \"%\", \"%\", \"%\");\n<line_number-82>        printRsInfo(rs);\n<line_number-83>    }\n<line_number-84>\n<line_number-85>    @Test\n<line_number-86>    void tryGetSchemas() throws Exception {\n<line_number-87>        ResultSet rs = m_dbMeta.getSchemas();\n<line_number-88>        //ResultSet rs = m_dbMeta.getSchemas(null, \"filter\");\n<line_number-89>        printRsInfo(rs);\n<line_number-90>    }\n<line_number-91>\n<line_number-92>    @Test\n<line_number-93>    void tryGetTablePrivileges() throws Exception {\n<line_number-94>        //ResultSet rs = m_dbMeta.getTablePrivileges(null, null, null);\n<line_number-95>        ResultSet rs = m_dbMeta.getTablePrivileges(null, \"%\", \"%\");\n<line_number-96>        printRsInfo(rs);\n<line_number-97>    }\n<line_number-98>\n<line_number-99>    @Test\n<line_number-100>    void tryGetTableTypes() throws Exception {\n<line_number-101>        ResultSet rs = m_dbMeta.getTableTypes();\n<line_number-102>        printRsInfo(rs);\n<line_number-103>    }\n<line_number-104>\n<line_number-105>    @Test\n<line_number-106>    void tryVersionColumns() throws Exception {\n<line_number-107>        //ResultSet rs = m_dbMeta.getVersionColumns(null, null, null);\n<line_number-108>        ResultSet rs = m_dbMeta.getVersionColumns(null, \"%\", \"%\");\n<line_number-109>        printRsInfo(rs);\n<line_number-110>    }\n<line_number-111>\n<line_number-112>    @Test\n<line_number-113>    void tryGetFunctions() throws Exception {\n<line_number-114>        ResultSet rs = m_dbMeta.getFunctions(null, null, null);\n<line_number-115>        //ResultSet rs = m_dbMeta.getFunctions(null, \"%\", \"%\");\n<line_number-116>\n<line_number-117>        printRsInfo(rs);\n<line_number-118>    }\n<line_number-119>\n<line_number-120>    @Test\n<line_number-121>    void tryGetFunctionColumns() throws Exception {\n<line_number-122>        //ResultSet rs = m_dbMeta.getFunctionColumns(null, null, null, null);\n<line_number-123>        ResultSet rs = m_dbMeta.getFunctionColumns(null, \"%\", \"%\", \"%\");\n<line_number-124>        printRsInfo(rs);\n<line_number-125>    }\n<line_number-126>\n<line_number-127>    @Test\n<line_number-128>    void tryGetProcedures() throws Exception {\n<line_number-129>        //ResultSet rs = m_dbMeta.getProcedures(null,null,null);\n<line_number-130>        ResultSet rs = m_dbMeta.getProcedures(null,\"%\",\"%\");\n<line_number-131>        printRsInfo(rs);\n<line_number-132>    }\n<line_number-133>\n<line_number-134>    @Test\n<line_number-135>    void tryGetProcedureColumns() throws Exception {\n<line_number-136>        //ResultSet rs = m_dbMeta.getProcedureColumns(null,null,null, null);\n<line_number-137>        ResultSet rs = m_dbMeta.getProcedureColumns(null,\"%\",\"%\", \"%\");\n<line_number-138>        printRsInfo(rs);\n<line_number-139>    }\n<line_number-140>\n<line_number-141>    @Test\n<line_number-142>    void tryGetClientInfoProperties() throws Exception {\n<line_number-143>        ResultSet rs = m_dbMeta.getClientInfoProperties();\n<line_number-144>        printRsInfo(rs);\n<line_number-145>    }\n<line_number-146>\n<line_number-147>    @Test\n<line_number-148>    void tryGetAttributes() throws Exception {\n<line_number-149>        //ResultSet rs = m_dbMeta.getAttributes(null, null,null,null);\n<line_number-150>        ResultSet rs = m_dbMeta.getAttributes(null, \"%\",\"%\",\"%\");\n<line_number-151>        printRsInfo(rs);\n<line_number-152>    }\n<line_number-153>\n<line_number-154>    @Test\n<line_number-155>    void tryGetBestRowIdentifier() throws Exception {\n<line_number-156>        //ResultSet rs = m_dbMeta.getBestRowIdentifier(null,null,null,0,false);\n<line_number-157>        ResultSet rs = m_dbMeta.getBestRowIdentifier(null,null,\"myTable\",0,false);\n<line_number-158>        printRsInfo(rs);\n<line_number-159>    }\n<line_number-160>\n<line_number-161>    @Test\n<line_number-162>    void tryGetColumnPrivileges() throws Exception {\n<line_number-163>        //ResultSet rs = m_dbMeta.getColumnPrivileges(null,null,null,null);\n<line_number-164>        ResultSet rs = m_dbMeta.getColumnPrivileges(null,null,\"myTable\",\"%\");\n<line_number-165>        printRsInfo(rs);\n<line_number-166>    }\n<line_number-167>\n<line_number-168>    @Test\n<line_number-169>    void tryGetCrossReference() throws Exception {\n<line_number-170>        //ResultSet rs = m_dbMeta.getCrossReference(null,null,null,null,null, null);\n<line_number-171>        ResultSet rs = m_dbMeta.getCrossReference(null,null,\"parentTable\",\"foreignCatalog\",null,\"foreignTable\");\n<line_number-172>        printRsInfo(rs);\n<line_number-173>    }\n<line_number-174>\n<line_number-175>    @Test\n<line_number-176>    void tryGetExportedKeys() throws Exception {\n<line_number-177>        //ResultSet rs = m_dbMeta.getExportedKeys(null,null,null);\n<line_number-178>        ResultSet rs = m_dbMeta.getExportedKeys(null,null,\"myTable\");\n<line_number-179>        printRsInfo(rs);\n<line_number-180>    }\n<line_number-181>\n<line_number-182>    @Test\n<line_number-183>    void getImportedKeys() throws Exception {\n<line_number-184>        //ResultSet rs = m_dbMeta.getImportedKeys(null,null,null);\n<line_number-185>        ResultSet rs = m_dbMeta.getImportedKeys(null,null,\"myTable\");\n<line_number-186>        printRsInfo(rs);\n<line_number-187>    }\n<line_number-188>\n<line_number-189>    @Test\n<line_number-190>    void tryGetIndexInfo() throws Exception {\n<line_number-191>        ResultSet rs = m_dbMeta.getIndexInfo(null,null,null,false, false);\n<line_number-192>        printRsInfo(rs);\n<line_number-193>    }\n<line_number-194>\n<line_number-195>    @Test\n<line_number-196>    void tryGetPrimaryKeys() throws Exception {\n<line_number-197>        //ResultSet rs = m_dbMeta.getPrimaryKeys(null,null,null);\n<line_number-198>        ResultSet rs = m_dbMeta.getPrimaryKeys(null,null,\"myTable\");\n<line_number-199>        printRsInfo(rs);\n<line_number-200>    }\n<line_number-201>\n<line_number-202>    @Test\n<line_number-203>    void tryGetPseudoColumns() throws Exception {\n<line_number-204>        //ResultSet rs = m_dbMeta.getPseudoColumns(null,null,null,null);\n<line_number-205>        ResultSet rs = m_dbMeta.getPseudoColumns(null,\"%\",\"%\",\"%\");\n<line_number-206>        printRsInfo(rs);\n<line_number-207>    }\n<line_number-208>\n<line_number-209>    @Test\n<line_number-210>    void tryGetSuperTables() throws Exception {\n<line_number-211>        ResultSet rs = m_dbMeta.getSuperTables(null,null,null);\n<line_number-212>        printRsInfo(rs);\n<line_number-213>    }\n<line_number-214>\n<line_number-215>    @Test\n<line_number-216>    void tryGetSuperTypes() throws Exception {\n<line_number-217>        ResultSet rs = m_dbMeta.getSuperTypes(null,null,null);\n<line_number-218>        printRsInfo(rs);\n<line_number-219>    }\n<line_number-220>\n<line_number-221>    @Test\n<line_number-222>    void tryGetTypeInfo() throws Exception {\n<line_number-223>        ResultSet rs = m_dbMeta.getTypeInfo();\n<line_number-224>        printRsInfo(rs);\n<line_number-225>    }\n<line_number-226>\n<line_number-227>    @Test\n<line_number-228>    void tryGetUDTs() throws Exception {\n<line_number-229>        ResultSet rs = m_dbMeta.getUDTs(null,null,null, new int[]{1});\n<line_number-230>        printRsInfo(rs);\n<line_number-231>    }\n<line_number-232>\n<line_number-233>    @Test\n<line_number-234>    void tryDBMeta() throws Exception {\n<line_number-235>        System.out\n<line_number-236>                .println(\"-----------------------------------------------------------------------\");\n<line_number-237>        System.out\n<line_number-238>                .println(\"-----------------------------------------------------------------------\");\n<line_number-239>        System.out.println(\"API databases metadata\");\n<line_number-240>        System.out.println(\"Driver Name: \" + m_dbMeta.getDriverName());\n<line_number-241>        System.out.println(\"Driver Version: \" + m_dbMeta.getDriverVersion());\n<line_number-242>        System.out.println(\"Driver Major Version: \"\n<line_number-243>                + m_dbMeta.getDriverMajorVersion());\n<line_number-244>        System.out.println(\"Driver Minor Version: \"\n<line_number-245>                + m_dbMeta.getDriverMinorVersion());\n<line_number-246>        System.out.println(\"Database Product Name: \"\n<line_number-247>                + m_dbMeta.getDatabaseProductName());\n<line_number-248>        System.out.println(\"Database Product version: \"\n<line_number-249>                + m_dbMeta.getDatabaseProductVersion());\n<line_number-250>        System.out.println(\"Database Major version: \"\n<line_number-251>                + m_dbMeta.getDatabaseMajorVersion());\n<line_number-252>        System.out.println(\"Database Minor version : \"\n<line_number-253>                + m_dbMeta.getDatabaseMinorVersion());\n<line_number-254>        System.out.println(\"Supports Mixed Case Quoted Identifiers: \"\n<line_number-255>                + m_dbMeta.supportsMixedCaseQuotedIdentifiers());\n<line_number-256>        System.out.println(\"Supports Mixed Case Identifiers: \"\n<line_number-257>                + m_dbMeta.supportsMixedCaseIdentifiers());\n<line_number-258>        System.out.println(\"Stores UpperCase Quoted Identifiers: \"\n<line_number-259>                + m_dbMeta.storesUpperCaseQuotedIdentifiers());\n<line_number-260>        System.out.println(\"Stores LowerCase Quoted Identifiers: \"\n<line_number-261>                + m_dbMeta.storesLowerCaseQuotedIdentifiers());\n<line_number-262>        System.out.println(\"Stores Mixed Case Quoted Identifiers: \"\n<line_number-263>                + m_dbMeta.storesMixedCaseQuotedIdentifiers());\n<line_number-264>        System.out.println(\"Stores Upper Case Identifiers: \"\n<line_number-265>                + m_dbMeta.storesUpperCaseIdentifiers());\n<line_number-266>        System.out.println(\"Stores Lower Case Identifiers: \"\n<line_number-267>                + m_dbMeta.storesLowerCaseIdentifiers());\n<line_number-268>        System.out.println(\"Stores Mixed Case Identifiers: \"\n<line_number-269>                + m_dbMeta.storesMixedCaseIdentifiers());\n<line_number-270>        System.out.println(\"Identifier Quote String: \"\n<line_number-271>                + m_dbMeta.getIdentifierQuoteString());\n<line_number-272>        System.out.println(\"Is ReadOnly: \" + m_dbMeta.isReadOnly());\n<line_number-273>        System.out.println(\"Supports ResultSet Concurrency: \"\n<line_number-274>                + m_dbMeta.supportsResultSetConcurrency(ResultSet.TYPE_FORWARD_ONLY,\n<line_number-275>                ResultSet.FETCH_UNKNOWN));\n<line_number-276>\n<line_number-277>        System.out.println(\"get Identifier Quote String: \"\n<line_number-278>                + m_dbMeta.getJDBCMajorVersion());\n<line_number-279>        System.out.println(\"get Identifier Quote String: \"\n<line_number-280>                + m_dbMeta.getTimeDateFunctions());\n<line_number-281>        System.out.println(\"get Identifier Quote String: \"\n<line_number-282>                + m_dbMeta.getStringFunctions());\n<line_number-283>        System.out.println(\"get Identifier Quote String: \"\n<line_number-284>                + m_dbMeta.getNumericFunctions());\n<line_number-285>    }\n<line_number-286>\n<line_number-287>    @Test\n<line_number-288>    void tryGetUrl() throws Exception {\n<line_number-289>        System.out.println(m_dbMeta.getURL());\n<line_number-290>    }\n<line_number-291>\n<line_number-292>    @Test\n<line_number-293>    void trySetCatalog() throws SQLException {\n<line_number-294>        m_conn.setCatalog(\"test_set_catalog\");\n<line_number-295>        System.out.println(m_conn.getCatalog());\n<line_number-296>    }\n<line_number-297>\n<line_number-298>    //@Test\n<line_number-299>    // TODO : Cancel is not supported yet\n<line_number-300>    void tryCancel() throws SQLException {\n<line_number-301>        // The query must be a long running query for cancel to be effective\n<line_number-302>        String query = \"select * from class\";\n<line_number-303>        System.out.println(\"-----------------------------------------------------------------------\");\n<line_number-304>\n<line_number-305>        class QueryExecutor implements Runnable\n<line_number-306>        {\n<line_number-307>            private boolean m_isExecuting;\n<line_number-308>            private final String m_query;\n<line_number-309>            private ResultSet m_result;\n<line_number-310>            private final Statement m_statement;\n<line_number-311>\n<line_number-312>            public QueryExecutor(Statement statement, String query) {\n<line_number-313>                m_statement = statement;\n<line_number-314>                m_query = query;\n<line_number-315>                m_isExecuting = false;\n<line_number-316>            }\n<line_number-317>\n<line_number-318>            public boolean getIsExecuting() {\n<line_number-319>                return m_isExecuting;\n<line_number-320>            }\n<line_number-321>\n<line_number-322>            public ResultSet getResultSet() {\n<line_number-323>                return m_result;\n<line_number-324>            }\n<line_number-325>\n<line_number-326>            @Override\n<line_number-327>            public void run()\n<line_number-328>            {\n<line_number-329>                try {\n<line_number-330>                    System.out.println(\"Executing '\" + m_query + \"'\");\n<line_number-331>                    m_isExecuting = true;\n<line_number-332>                    m_result = m_statement.executeQuery(m_query);\n<line_number-333>                    m_isExecuting = false;\n<line_number-334>                }\n<line_number-335>                catch (SQLException e) {\n<line_number-336>                    e.printStackTrace();\n<line_number-337>                }\n<line_number-338>                finally {\n<line_number-339>                    try {\n<line_number-340>                        m_result.close();\n<line_number-341>                    } catch (SQLException e) {\n<line_number-342>                        e.printStackTrace();\n<line_number-343>                    }\n<line_number-344>                }\n<line_number-345>            }\n<line_number-346>        }\n<line_number-347>\n<line_number-348>        Statement statement = m_conn.createStatement();\n<line_number-349>        ResultSet result = null;\n<line_number-350>\n<line_number-351>        QueryExecutor queryExecutor = new QueryExecutor(statement, query);\n<line_number-352>        Thread execThread = new Thread(queryExecutor);\n<line_number-353>        execThread.start();\n<line_number-354>\n<line_number-355>        while (!queryExecutor.getIsExecuting()) {\n<line_number-356>            ;\n<line_number-357>        }\n<line_number-358>        if (execThread.isAlive()) {\n<line_number-359>            try {\n<line_number-360>                // Still need to wait because the m_isExecuting flag is set  before statement.executeQuery is called.\n<line_number-361>                // Need to wait until an executor object is created.\n<line_number-362>                Thread.sleep(2000);\n<line_number-363>            }\n<line_number-364>            catch (InterruptedException e) {\n<line_number-365>                e.printStackTrace();\n<line_number-366>            }\n<line_number-367>            System.out.println(\"Calling cancel\");\n<line_number-368>            statement.cancel();\n<line_number-369>            System.out.println(\"The query cancelled successfully.\");\n<line_number-370>\n<line_number-371>            // Try to use the statement again\n<line_number-372>            queryExecutor = new QueryExecutor(statement, query);\n<line_number-373>            execThread = new Thread(queryExecutor);\n<line_number-374>            execThread.start();\n<line_number-375>        }\n<line_number-376>        else {\n<line_number-377>            System.out.println(\"The execution finished before cancel\");\n<line_number-378>            queryExecutor.getResultSet().close();\n<line_number-379>        }\n<line_number-380>\n<line_number-381>        System.out.println(\"-----------------------------------------------------------------------\");\n<line_number-382>    }\n<line_number-383>\n<line_number-384>    /**\n<line_number-385>     * Execute the given query and print either the resultset contents or its metadata.\n<line_number-386>     * @param query             The query to execute.\n<line_number-387>     * @param printRs           A flag to turn on printing the resultset content when true or the resultset metadata when false.\n<line_number-388>     * @throws Exception        If an error occurs while executing the query or retrieving the values to display.\n<line_number-389>     */\n<line_number-390>    private void runExecuteQuery(String query, boolean printRs) throws Exception {\n<line_number-391>        try {\n<line_number-392>            Statement stmt = m_conn.createStatement();\n<line_number-393>            ResultSet rs = stmt.executeQuery(query);\n<line_number-394>            if (printRs) {\n<line_number-395>                PrintUtils.printResultSet(rs);\n<line_number-396>            }\n<line_number-397>            else {\n<line_number-398>                PrintUtils.printResultSetMetadata(rs.getMetaData());\n<line_number-399>            }\n<line_number-400>        }\n<line_number-401>        catch (Exception e) {\n<line_number-402>            e.printStackTrace();\n<line_number-403>            throw e;\n<line_number-404>        }\n<line_number-405>    }\n<line_number-406>\n<line_number-407>    /**\n<line_number-408>     * Prints the resultset metadata followed by its contents.\n<line_number-409>     * @param rs            The result set to display information for.\n<line_number-410>     * @throws Exception    If an error occurs when retrieving the information to display.\n<line_number-411>     */\n<line_number-412>    private void printRsInfo(ResultSet rs) throws Exception {\n<line_number-413>        try {\n<line_number-414>            PrintUtils.printResultSetMetadata(rs.getMetaData());\n<line_number-415>            PrintUtils.printResultSet(rs);\n<line_number-416>        }\n<line_number-417>        catch (Exception e) {\n<line_number-418>            e.printStackTrace();\n<line_number-419>            throw e;\n<line_number-420>        }\n<line_number-421>    }\n<line_number-422>}\n",
        "comments": [
          {
            "comment_code_range": "12-28",
            "comment_linenumber": "11",
            "comment": "This class provides the baseline for common things that applications built on top of JDBC use, including connecting to the database, executing queries, retrieving metadata, and cancelling long-running queries.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "34-34",
            "comment_linenumber": "34",
            "comment": "Abstract method to establish a connection to the database, must be implemented by subclasses.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "36-40",
            "comment_linenumber": "36",
            "comment": "Sets up the database connection and retrieves metadata before each test.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "42-45",
            "comment_linenumber": "42",
            "comment": "Closes the database connection after each test.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "48-52",
            "comment_linenumber": "48",
            "comment": "Tests the connection by printing the driver name and version.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "56-57",
            "comment_linenumber": "56",
            "comment": "Executes a sample query and prints the result set when successful.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "61-62",
            "comment_linenumber": "61",
            "comment": "Executes a sample query and prints the metadata of the result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "66-68",
            "comment_linenumber": "66",
            "comment": "Retrieves and prints catalog information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "72-75",
            "comment_linenumber": "72",
            "comment": "Retrieves and prints table information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "79-82",
            "comment_linenumber": "79",
            "comment": "Retrieves and prints column information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "86-89",
            "comment_linenumber": "86",
            "comment": "Retrieves and prints schema information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "93-96",
            "comment_linenumber": "93",
            "comment": "Retrieves and prints table privileges from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "100-102",
            "comment_linenumber": "100",
            "comment": "Retrieves and prints table types from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "106-109",
            "comment_linenumber": "106",
            "comment": "Retrieves and prints version columns from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "113-117",
            "comment_linenumber": "113",
            "comment": "Retrieves and prints function information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "121-124",
            "comment_linenumber": "121",
            "comment": "Retrieves and prints function column information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "128-131",
            "comment_linenumber": "128",
            "comment": "Retrieves and prints procedure information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "135-138",
            "comment_linenumber": "135",
            "comment": "Retrieves and prints procedure column information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "142-145",
            "comment_linenumber": "142",
            "comment": "Retrieves and prints client info properties from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "148-151",
            "comment_linenumber": "148",
            "comment": "Retrieves and prints attribute information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "155-158",
            "comment_linenumber": "155",
            "comment": "Retrieves and prints best row identifier information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "162-165",
            "comment_linenumber": "162",
            "comment": "Retrieves and prints column privileges from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "169-172",
            "comment_linenumber": "169",
            "comment": "Retrieves and prints cross-reference information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "176-179",
            "comment_linenumber": "176",
            "comment": "Retrieves and prints exported keys from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "183-186",
            "comment_linenumber": "183",
            "comment": "Retrieves and prints imported keys from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "190-193",
            "comment_linenumber": "190",
            "comment": "Retrieves and prints index information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "196-199",
            "comment_linenumber": "196",
            "comment": "Retrieves and prints primary key information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "203-206",
            "comment_linenumber": "203",
            "comment": "Retrieves and prints pseudo column information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "209-212",
            "comment_linenumber": "209",
            "comment": "Retrieves and prints super table information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "216-219",
            "comment_linenumber": "216",
            "comment": "Retrieves and prints super type information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "222-225",
            "comment_linenumber": "222",
            "comment": "Retrieves and prints type information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "228-231",
            "comment_linenumber": "228",
            "comment": "Retrieves and prints user-defined type (UDT) information from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "234-285",
            "comment_linenumber": "234",
            "comment": "Retrieves and prints comprehensive database metadata information including driver and database details.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "288-289",
            "comment_linenumber": "288",
            "comment": "Prints the database connection URL.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "293-295",
            "comment_linenumber": "293",
            "comment": "Sets and prints the current catalog for the database connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "300-382",
            "comment_linenumber": "300",
            "comment": "Attempts to cancel a long-running query by executing it in a separate thread and cancelling it if still running.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "390-404",
            "comment_linenumber": "390",
            "comment": "Executes the given query and prints either the result set contents or its metadata based on the provided flag.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "408-421",
            "comment_linenumber": "408",
            "comment": "Prints the result set metadata followed by its contents.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'TestUtils.java' serves as a utility class for JDBC-based applications, providing a framework for testing database connections and executing queries. It is designed as an abstract class, requiring subclasses to implement the connection logic. The class contains several test methods annotated with JUnit's @Test, which facilitate various database operations such as retrieving metadata, executing queries, and handling results. The lifecycle methods @BeforeEach and @AfterEach ensure that a connection is established before each test and closed afterward. The class also includes a nested Runnable class, QueryExecutor, which is used to execute queries in a separate thread, allowing for cancellation of long-running queries. The methods leverage JDBC's DatabaseMetaData to gather and print information about the database, including driver details, supported features, and schema information. Overall, the class encapsulates common JDBC operations, making it easier for developers to test and debug database interactions.",
        "file_summary": "The 'TestUtils.java' file provides a base class for testing JDBC connections and executing SQL queries, including retrieving metadata and handling long-running queries. It is intended for use in applications that require database interaction, offering a structured approach to testing various database functionalities."
      }
    ]
  },
  "SmokeTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\smoketest\\src\\test\\java\\com\\mongodb\\jdbc\\smoketest\\SmokeTest.java",
    "chunks": [
      {
        "file_path": "smoketest\\src\\test\\java\\com\\mongodb\\jdbc\\smoketest\\SmokeTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\smoketest\\src\\test\\java\\com\\mongodb\\jdbc\\smoketest\\SmokeTest.java",
        "chunk_id": "SmokeTest_1",
        "content": "<line_number-1>package com.mongodb.jdbc.smoketest;\n<line_number-2>\n<line_number-3>import org.junit.jupiter.api.AfterEach;\n<line_number-4>import org.junit.jupiter.api.BeforeEach;\n<line_number-5>import org.junit.jupiter.api.Test;\n<line_number-6>import static org.junit.jupiter.api.Assertions.assertTrue;\n<line_number-7>\n<line_number-8>import java.sql.Connection;\n<line_number-9>import java.sql.DatabaseMetaData;\n<line_number-10>import java.sql.DriverManager;\n<line_number-11>import java.sql.ResultSet;\n<line_number-12>import java.sql.SQLException;\n<line_number-13>import java.sql.Statement;\n<line_number-14>import java.util.HashMap;\n<line_number-15>import java.util.Map;\n<line_number-16>import java.util.Properties;\n<line_number-17>\n<line_number-18>/**\n<line_number-19> * SmokeTest runs a test on built artifacts to verify that connection,\n<line_number-20> * metadata retrieval, and querying is successful\n<line_number-21> */\n<line_number-22>public class SmokeTest {\n<line_number-23>    static final String URL = \"jdbc:mongodb://localhost\";\n<line_number-24>    static final String DB = \"integration_test\";\n<line_number-25>\n<line_number-26>    // Connection and simple query to use for sanity check.\n<line_number-27>    private Map<Connection, String> connections = new HashMap<>();\n<line_number-28>\n<line_number-29>    public static Connection getADFInstanceConnection(String url, String db)\n<line_number-30>            throws SQLException {\n<line_number-31>        Properties p = new java.util.Properties();\n<line_number-32>        p.setProperty(\"user\", System.getenv(\"ADF_TEST_LOCAL_USER\"));\n<line_number-33>        p.setProperty(\"password\", System.getenv(\"ADF_TEST_LOCAL_PWD\"));\n<line_number-34>        p.setProperty(\"authSource\", System.getenv(\"ADF_TEST_LOCAL_AUTH_DB\"));\n<line_number-35>        p.setProperty(\"ssl\", \"false\");\n<line_number-36>        p.setProperty(\"database\", db);\n<line_number-37>        return DriverManager.getConnection(URL, p);\n<line_number-38>    }\n<line_number-39>\n<line_number-40>    private Connection getDirectRemoteInstanceConnection() throws SQLException {\n<line_number-41>        String mongoHost = System.getenv(\"SRV_TEST_HOST\");\n<line_number-42>        String mongoURI =\n<line_number-43>                \"mongodb+srv://\"\n<line_number-44>                        + mongoHost\n<line_number-45>                        + \"/?readPreference=secondaryPreferred&connectTimeoutMS=300000\";\n<line_number-46>        String fullURI = \"jdbc:\" + mongoURI;\n<line_number-47>\n<line_number-48>        String user = System.getenv(\"SRV_TEST_USER\");\n<line_number-49>        String pwd = System.getenv(\"SRV_TEST_PWD\");\n<line_number-50>        String authSource = System.getenv(\"SRV_TEST_AUTH_DB\");\n<line_number-51>\n<line_number-52>        Properties p = new java.util.Properties();\n<line_number-53>        p.setProperty(\"user\", user);\n<line_number-54>        p.setProperty(\"password\", pwd);\n<line_number-55>        p.setProperty(\"authSource\", authSource);\n<line_number-56>        p.setProperty(\"database\", \"test\");\n<line_number-57>\n<line_number-58>        return DriverManager.getConnection(fullURI, p);\n<line_number-59>    }\n<line_number-60>\n<line_number-61>    @BeforeEach\n<line_number-62>    public void setupConnection() throws SQLException {\n<line_number-63>        String buildType = System.getenv(\"BUILD_TYPE\");\n<line_number-64>        boolean isEapBuild = \"eap\".equalsIgnoreCase(buildType);\n<line_number-65>        System.out.println(\"Read environment variable BUILD_TYPE: '\" + buildType + \"', Detected EAP build: \" + isEapBuild);\n<line_number-66>\n<line_number-67>        connections.put(getADFInstanceConnection(URL, DB), \"SELECT * from class\");\n<line_number-68>\n<line_number-69>        if (isEapBuild) {\n<line_number-70>            try {\n<line_number-71>                Connection directConnection = getDirectRemoteInstanceConnection();\n<line_number-72>                connections.put(directConnection, \"Select * from accounts limit 5\");\n<line_number-73>            } catch (SQLException e) {\n<line_number-74>                System.err.println(\"Failed to connect to direct remote instance: \" + e.getMessage());\n<line_number-75>                throw e;\n<line_number-76>            }\n<line_number-77>        } else {\n<line_number-78>            try {\n<line_number-79>                Connection directConnection = getDirectRemoteInstanceConnection();\n<line_number-80>                directConnection.close();\n<line_number-81>                throw new AssertionError(\"Expected direct remote connection to fail for non-EAP build\");\n<line_number-82>            } catch (SQLException e) {\n<line_number-83>                if (!\"Connection failed.\".equals(e.getMessage())) {\n<line_number-84>                    throw new AssertionError(\"Expected 'Connection failed.' but got: \" + e.getMessage());\n<line_number-85>                }\n<line_number-86>            }\n<line_number-87>        }\n<line_number-88>    }\n<line_number-89>\n<line_number-90>    @AfterEach\n<line_number-91>    protected void cleanupTest() throws SQLException {\n<line_number-92>        for (Connection conn : connections.keySet()) {\n<line_number-93>            conn.close();\n<line_number-94>        }\n<line_number-95>    }\n<line_number-96>\n<line_number-97>    @Test\n<line_number-98>    public void databaseMetadataTest() throws SQLException {\n<line_number-99>        System.out.println(\"Running databaseMetadataTest\");\n<line_number-100>        for (Connection conn : connections.keySet()) {\n<line_number-101>            DatabaseMetaData dbMetadata = conn.getMetaData();\n<line_number-102>            System.out.println(dbMetadata.getDriverName());\n<line_number-103>            System.out.println(dbMetadata.getDriverVersion());\n<line_number-104>\n<line_number-105>            ResultSet rs = dbMetadata.getColumns(null, \"%\", \"%\", \"%\");\n<line_number-106>            rowsReturnedCheck(rs);\n<line_number-107>        }\n<line_number-108>    }\n<line_number-109>\n<line_number-110>    @Test\n<line_number-111>    public  void queryTest() throws SQLException {\n<line_number-112>        System.out.println(\"Running queryTest\");\n<line_number-113>        for (Map.Entry<Connection, String> entry : connections.entrySet()) {\n<line_number-114>            try (Statement stmt = entry.getKey().createStatement()) {\n<line_number-115>                ResultSet rs = stmt.executeQuery(entry.getValue());\n<line_number-116>                rowsReturnedCheck(rs);\n<line_number-117>            }\n<line_number-118>        }\n<line_number-119>    }\n<line_number-120>\n<line_number-121>    public static void rowsReturnedCheck(ResultSet rs) throws SQLException {\n<line_number-122>        int actualCount = 0;\n<line_number-123>        while (rs.next()) {\n<line_number-124>            actualCount++;\n<line_number-125>        }\n<line_number-126>        System.out.println(\"Rows returned count: \" + actualCount);\n<line_number-127>        assertTrue(actualCount >= 1, \"No rows returned in result set\");\n<line_number-128>    }\n<line_number-129>}\n",
        "comments": [
          {
            "comment_code_range": "18-21",
            "comment_linenumber": "21",
            "comment": "SmokeTest runs a test on built artifacts to verify that connection, metadata retrieval, and querying is successful",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "29-37",
            "comment_linenumber": "28",
            "comment": "Establishes a connection to the ADF instance using provided URL and database name, utilizing environment variables for authentication.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "40-58",
            "comment_linenumber": "39",
            "comment": "Establishes a direct connection to a remote MongoDB instance using environment variables for authentication and connection details.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "61-87",
            "comment_linenumber": "60",
            "comment": "Sets up connections for testing based on the build type, handling both EAP and non-EAP scenarios with appropriate error handling.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "90-95",
            "comment_linenumber": "89",
            "comment": "Cleans up connections after each test to prevent resource leaks.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "97-108",
            "comment_linenumber": "96",
            "comment": "Tests database metadata retrieval for each established connection, printing driver details and checking column metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "110-119",
            "comment_linenumber": "109",
            "comment": "Executes a query for each connection and verifies that rows are returned, ensuring the query functionality works as expected.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "121-128",
            "comment_linenumber": "120",
            "comment": "Checks the number of rows returned from a ResultSet and asserts that at least one row is present.",
            "comment_kind": "function"
          }
        ],
        "structural_analysis": "The file 'SmokeTest.java' is a JUnit test class designed to validate the functionality of MongoDB connections and queries. It employs a straightforward structure with methods for setting up connections, executing tests, and cleaning up resources. The class contains static final fields for the database URL and name, and utilizes environment variables for sensitive information such as user credentials. \n\n**Top-level types:** \n- **Signature:** SmokeTest, class \n  - **Role:** Responsible for testing MongoDB connections and metadata retrieval. \n  - **Lifecycle notes:** Not a singleton, not immutable, not thread-safe. \n\n**Members:** \n- **Fields:** \n  - `connections`: Map<Connection, String>, private, stores active connections and associated queries. \n\n- **Constructors / factories:** \n  - No explicit constructors; relies on default constructor. \n\n**Method deep-dive:** \n- **getADFInstanceConnection(String url, String db)**: \n  - **Parameters:** String url, String db \n  - **Return type:** Connection \n  - **Behaviour:** Establishes a connection to the ADF instance using provided credentials. \n  - **Internal calls:** None. \n  - **External calls:** DriverManager.getConnection. \n  - **Key control flow:** Uses environment variables for user credentials. \n\n- **getDirectRemoteInstanceConnection()**: \n  - **Return type:** Connection \n  - **Behaviour:** Establishes a connection to a remote MongoDB instance. \n  - **Internal calls:** None. \n  - **External calls:** DriverManager.getConnection. \n  - **Key control flow:** Constructs a MongoDB URI from environment variables. \n\n- **setupConnection()**: \n  - **Return type:** void \n  - **Behaviour:** Sets up connections based on the build type, handling EAP and non-EAP scenarios. \n  - **Internal calls:** getADFInstanceConnection, getDirectRemoteInstanceConnection. \n  - **External calls:** System.getenv. \n  - **Key control flow:** Conditional logic based on build type. \n\n- **cleanupTest()**: \n  - **Return type:** void \n  - **Behaviour:** Closes all active connections. \n  - **Internal calls:** None. \n  - **External calls:** None. \n  - **Key control flow:** Iterates over connections. \n\n- **databaseMetadataTest()**: \n  - **Return type:** void \n  - **Behaviour:** Tests retrieval of database metadata. \n  - **Internal calls:** rowsReturnedCheck. \n  - **External calls:** None. \n  - **Key control flow:** Iterates over connections to fetch metadata. \n\n- **queryTest()**: \n  - **Return type:** void \n  - **Behaviour:** Executes queries and checks results. \n  - **Internal calls:** rowsReturnedCheck. \n  - **External calls:** None. \n  - **Key control flow:** Iterates over connections and executes queries. \n\n- **rowsReturnedCheck(ResultSet rs)**: \n  - **Parameters:** ResultSet rs \n  - **Return type:** void \n  - **Behaviour:** Asserts that at least one row is returned from the ResultSet. \n  - **Internal calls:** None. \n  - **External calls:** assertTrue. \n  - **Key control flow:** Loops through ResultSet to count rows. \n\n**Relationships:** \n- Invokes DriverManager for connection establishment. \n- Uses JUnit annotations for test lifecycle management. \n\n**External touchpoints:** \n- Public APIs: JUnit 5 for testing. \n- External frameworks/services: MongoDB JDBC driver. \n\n**Algorithms / domain logic:** \n- Validates connection and query execution against a MongoDB instance. \n\n**Observations & caveats:** \n- The class relies heavily on environment variables for configuration, which may lead to issues if not set correctly. \n- Error handling is present but could be enhanced for better clarity.",
        "file_summary": "The SmokeTest class is designed to validate MongoDB connections and query execution through JUnit tests. It establishes connections based on environment variables, performs metadata retrieval, and executes sample queries to ensure the database is functioning as expected."
      }
    ]
  },
  "ADFIntegrationTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\ADFIntegrationTest.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\ADFIntegrationTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\ADFIntegrationTest.java",
        "chunk_id": "ADFIntegrationTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.MongoDriver.MongoJDBCProperty.*;\n<line_number-20>import static org.junit.jupiter.api.Assertions.assertEquals;\n<line_number-21>import static org.junit.jupiter.api.Assertions.assertTrue;\n<line_number-22>import static org.junit.jupiter.api.Assertions.fail;\n<line_number-23>\n<line_number-24>import com.mongodb.jdbc.MongoConnection;\n<line_number-25>import com.mongodb.jdbc.integration.testharness.IntegrationTestUtils;\n<line_number-26>import com.mongodb.jdbc.integration.testharness.models.TestEntry;\n<line_number-27>import java.io.File;\n<line_number-28>import java.io.IOException;\n<line_number-29>import java.nio.file.Files;\n<line_number-30>import java.nio.file.Path;\n<line_number-31>import java.nio.file.Paths;\n<line_number-32>import java.sql.Connection;\n<line_number-33>import java.sql.DriverManager;\n<line_number-34>import java.sql.ResultSet;\n<line_number-35>import java.sql.SQLException;\n<line_number-36>import java.sql.Statement;\n<line_number-37>import java.util.ArrayList;\n<line_number-38>import java.util.Collection;\n<line_number-39>import java.util.HashSet;\n<line_number-40>import java.util.List;\n<line_number-41>import java.util.Properties;\n<line_number-42>import java.util.Set;\n<line_number-43>import java.util.concurrent.Callable;\n<line_number-44>import java.util.concurrent.ExecutorService;\n<line_number-45>import java.util.concurrent.Executors;\n<line_number-46>import java.util.concurrent.TimeUnit;\n<line_number-47>import java.util.logging.Level;\n<line_number-48>import java.util.stream.Collectors;\n<line_number-49>import org.junit.jupiter.api.BeforeAll;\n<line_number-50>import org.junit.jupiter.api.DynamicTest;\n<line_number-51>import org.junit.jupiter.api.Test;\n<line_number-52>import org.junit.jupiter.api.TestFactory;\n<line_number-53>import org.junit.jupiter.api.TestInstance;\n<line_number-54>\n<line_number-55>@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n<line_number-56>public class ADFIntegrationTest {\n<line_number-57>    private static final String CURRENT_DIR =\n<line_number-58>            Paths.get(\".\").toAbsolutePath().normalize().toString();\n<line_number-59>\n<line_number-60>    private static final String LOCAL_HOST = \"jdbc:mongodb://localhost\";\n<line_number-61>    private static final String URL =\n<line_number-62>            System.getenv(\"ADF_TEST_LOCAL_HOST\") != null\n<line_number-63>                    ? System.getenv(\"ADF_TEST_LOCAL_HOST\")\n<line_number-64>                    : LOCAL_HOST;\n<line_number-65>    static final String DEFAULT_TEST_DB = \"integration_test\";\n<line_number-66>    public static final String TEST_DIRECTORY = \"resources/integration_test/tests\";\n<line_number-67>    private static final String EXPECTED_UUID =\n<line_number-68>            \"{\\\"$uuid\\\":\\\"71bf369b-2c60-4e6f-b23f-f9e88167cc96\\\"}\";\n<line_number-69>    private static final String[] UUID_REPRESENTATIONS = {\n<line_number-70>        \"standard\", \"javalegacy\", \"csharplegacy\", \"pythonlegacy\", \"default\"\n<line_number-71>    };\n<line_number-72>    private static final String UUID_COLLECTION = \"uuid\";\n<line_number-73>\n<line_number-74>    private static List<TestEntry> testEntries;\n<line_number-75>\n<line_number-76>    /**\n<line_number-77>     * Creates a new connection.\n<line_number-78>     *\n<line_number-79>     * @param extraProps Extra properties on top of the default ones that the class implementating\n<line_number-80>     *     it is using.\n<line_number-81>     * @return The connection.\n<line_number-82>     * @throws SQLException If the connection can not be created.\n<line_number-83>     */\n<line_number-84>    public MongoConnection getBasicConnection(Properties extraProps) throws SQLException {\n<line_number-85>        return getBasicConnection(DEFAULT_TEST_DB, extraProps);\n<line_number-86>    }\n<line_number-87>\n<line_number-88>    public MongoConnection getBasicConnection(String db, Properties extraProps)\n<line_number-89>            throws SQLException {\n<line_number-90>        return getBasicConnection(db, extraProps, null);\n<line_number-91>    }\n<line_number-92>\n<line_number-93>    public MongoConnection getBasicConnection(String db, Properties extraProps, String uriOptions)\n<line_number-94>            throws SQLException {\n<line_number-95>        String fullUrl = URL;\n<line_number-96>        Properties p = new java.util.Properties(extraProps);\n<line_number-97>        p.setProperty(\"user\", System.getenv(\"ADF_TEST_LOCAL_USER\"));\n<line_number-98>        p.setProperty(\"password\", System.getenv(\"ADF_TEST_LOCAL_PWD\"));\n<line_number-99>        p.setProperty(\"authSource\", System.getenv(\"ADF_TEST_LOCAL_AUTH_DB\"));\n<line_number-100>        p.setProperty(\"database\", db);\n<line_number-101>        p.setProperty(\"ssl\", \"false\");\n<line_number-102>\n<line_number-103>        if (uriOptions != null && !uriOptions.isEmpty()) {\n<line_number-104>            fullUrl += (URL.contains(\"?\") ? \"&\" : \"/?\") + uriOptions;\n<line_number-105>        }\n<line_number-106>\n<line_number-107>        return (MongoConnection) DriverManager.getConnection(fullUrl, p);\n<line_number-108>    }\n<line_number-109>\n<line_number-110>    @BeforeAll\n<line_number-111>    public static void loadTestConfigs() throws IOException {\n<line_number-112>        testEntries = IntegrationTestUtils.loadTestConfigs(TEST_DIRECTORY);\n<line_number-113>    }\n<line_number-114>\n<line_number-115>    @TestFactory\n<line_number-116>    Collection<DynamicTest> runIntegrationTests() {\n<line_number-117>        List<DynamicTest> dynamicTests = new ArrayList<>();\n<line_number-118>        for (TestEntry testEntry : testEntries) {\n<line_number-119>            if (testEntry.skip_reason != null) {\n<line_number-120>                continue;\n<line_number-121>            }\n<line_number-122>            dynamicTests.add(\n<line_number-123>                    DynamicTest.dynamicTest(\n<line_number-124>                            testEntry.description,\n<line_number-125>                            () -> {\n<line_number-126>                                try (Connection conn = getBasicConnection(testEntry.db, null)) {\n<line_number-127>                                    IntegrationTestUtils.runTest(testEntry, conn, false);\n<line_number-128>                                }\n<line_number-129>                            }));\n<line_number-130>        }\n<line_number-131>        return dynamicTests;\n<line_number-132>    }\n<line_number-133>\n<line_number-134>    /** Simple callable used to spawn a new statement and execute a query. */\n<line_number-135>    public static class SimpleQueryExecutor implements Callable<Void> {\n<line_number-136>        private final Connection conn;\n<line_number-137>        private final String query;\n<line_number-138>\n<line_number-139>        public SimpleQueryExecutor(Connection conn, String query) {\n<line_number-140>            this.conn = conn;\n<line_number-141>            this.query = query;\n<line_number-142>        }\n<line_number-143>\n<line_number-144>        @Override\n<line_number-145>        public Void call() throws Exception {\n<line_number-146>            try (Statement stmt = conn.createStatement()) {\n<line_number-147>                stmt.executeQuery(query);\n<line_number-148>            }\n<line_number-149>            return null;\n<line_number-150>        }\n<line_number-151>    }\n<line_number-152>\n<line_number-153>    /**\n<line_number-154>     * Verifies that concurrent connections and statements are not impacting the logging\n<line_number-155>     * capabilities. Concurrent connection must be able to create log files with no issues.\n<line_number-156>     * Concurrent statements must be able to write their messages in the same log file.\n<line_number-157>     */\n<line_number-158>    @Test\n<line_number-159>    public void testLoggingWithParallelConnectionAndStatementExec() throws Exception {\n<line_number-160>        ExecutorService executor = Executors.newFixedThreadPool(4);\n<line_number-161>        List<Callable<Void>> tasks = new ArrayList<>();\n<line_number-162>\n<line_number-163>        // Connection with no logging.\n<line_number-164>        MongoConnection noLogging = connect(null);\n<line_number-165>        // Connection only logging exceptions.\n<line_number-166>        MongoConnection logErrorOnly = connect(Level.SEVERE);\n<line_number-167>        // Connection logging all public method entries of the JDBC interface.\n<line_number-168>        MongoConnection logEntries = connect(Level.FINER);\n<line_number-169>        try {\n<line_number-170>            addSimpleQueryExecTasks(tasks, noLogging);\n<line_number-171>            addSimpleQueryExecTasks(tasks, logErrorOnly);\n<line_number-172>            addSimpleQueryExecTasks(tasks, logEntries);\n<line_number-173>            executor.invokeAll(tasks);\n<line_number-174>        } finally {\n<line_number-175>            executor.awaitTermination(1, TimeUnit.SECONDS);\n<line_number-176>\n<line_number-177>            // Verify that there is only one log file\n<line_number-178>            List<File> logFiles =\n<line_number-179>                    Files.list(Paths.get(CURRENT_DIR))\n<line_number-180>                            .map(Path::toFile)\n<line_number-181>                            .filter(\n<line_number-182>                                    p ->\n<line_number-183>                                            p.isFile()\n<line_number-184>                                                    && p.getName()\n<line_number-185>                                                            .matches(\"connection.log(.\\\\d+)*\"))\n<line_number-186>                            .collect(Collectors.toList());\n<line_number-187>\n<line_number-188>            assertEquals(\n<line_number-189>                    1, logFiles.size(), \"Expected only one log file, but found \" + logFiles.size());\n<line_number-190>\n<line_number-191>            if (noLogging != null) {\n<line_number-192>                cleanUp(noLogging);\n<line_number-193>            }\n<line_number-194>            if (logErrorOnly != null) {\n<line_number-195>                cleanUp(logErrorOnly);\n<line_number-196>            }\n<line_number-197>            if (logEntries != null) {\n<line_number-198>                cleanUp(logEntries);\n<line_number-199>            }\n<line_number-200>        }\n<line_number-201>    }\n<line_number-202>\n<line_number-203>    /**\n<line_number-204>     * Connect with the given logging level.\n<line_number-205>     *\n<line_number-206>     * @param logLevel The log level or null if not logging.\n<line_number-207>     * @return the connection.\n<line_number-208>     * @throws SQLException If an error occurs during the connection process.\n<line_number-209>     */\n<line_number-210>    private MongoConnection connect(Level logLevel) throws SQLException {\n<line_number-211>        Properties loggingProps = new Properties();\n<line_number-212>        if (null != logLevel) {\n<line_number-213>            loggingProps.setProperty(LOG_LEVEL.getPropertyName(), logLevel.getName());\n<line_number-214>        }\n<line_number-215>\n<line_number-216>        // Log files will be created in the current directory\n<line_number-217>        loggingProps.setProperty(LOG_DIR.getPropertyName(), CURRENT_DIR);\n<line_number-218>        return getBasicConnection(loggingProps);\n<line_number-219>    }\n<line_number-220>\n<line_number-221>    /**\n<line_number-222>     * Add taks to execute a valid and an invalid statement via the given connection.\n<line_number-223>     *\n<line_number-224>     * @param tasks The tasks list to add new tasks to.\n<line_number-225>     * @param conn The connection to use to create new statements.\n<line_number-226>     * @throws SQLException If an error occurs when creating a new statement.\n<line_number-227>     */\n<line_number-228>    private void addSimpleQueryExecTasks(List<Callable<Void>> tasks, Connection conn)\n<line_number-229>            throws SQLException {\n<line_number-230>        // Connection with no logging and a valid query to execute.\n<line_number-231>        tasks.add(new ADFIntegrationTest.SimpleQueryExecutor(conn, \"SELECT 1\"));\n<line_number-232>        // Connection with no logging and an invalid query to execute.\n<line_number-233>        tasks.add(new ADFIntegrationTest.SimpleQueryExecutor(conn, \"INVALID QUERY TO EXECUTE\"));\n<line_number-234>    }\n<line_number-235>\n<line_number-236>    /**\n<line_number-237>     * Clean-up after the logging test. It will close the connection and delete the log file if it\n<line_number-238>     * exists.\n<line_number-239>     *\n<line_number-240>     * @param conn The connection.\n<line_number-241>     */\n<line_number-242>    private void cleanUp(MongoConnection conn) {\n<line_number-243>        try {\n<line_number-244>            conn.close();\n<line_number-245>            File logFile = new File(CURRENT_DIR + File.separator + \"connection.log\");\n<line_number-246>            if (logFile.exists()) {\n<line_number-247>                logFile.delete();\n<line_number-248>            }\n<line_number-249>        } catch (Exception e) {\n<line_number-250>            // Ignore clean-up exceptions\n<line_number-251>            System.out.println(\"Clean-up error ignored.\");\n<line_number-252>            e.printStackTrace();\n<line_number-253>        }\n<line_number-254>    }\n<line_number-255>\n<line_number-256>    /**\n<line_number-257>     * Tests the handling of different UUID representations specified in the URI. The uuid fields\n<line_number-258>     * have been pre-loaded into the database, stored in their respective uuid representations\n<line_number-259>     * according to their type. This test verifies that each representation is correctly retrieved\n<line_number-260>     * and converted to the expected string format.\n<line_number-261>     */\n<line_number-262>    @Test\n<line_number-263>    public void testUUIDRepresentationInURI() {\n<line_number-264>        for (String representation : UUID_REPRESENTATIONS) {\n<line_number-265>            System.out.println(\"Testing with UUID representation: \" + representation);\n<line_number-266>\n<line_number-267>            try (MongoConnection conn =\n<line_number-268>                            representation.equals(\"default\")\n<line_number-269>                                    ? getBasicConnection(DEFAULT_TEST_DB, null)\n<line_number-270>                                    : getBasicConnection(\n<line_number-271>                                            DEFAULT_TEST_DB,\n<line_number-272>                                            null,\n<line_number-273>                                            \"uuidRepresentation=\" + representation);\n<line_number-274>                    Statement stmt = conn.createStatement()) {\n<line_number-275>\n<line_number-276>                // If no uuidRepresentation is specified in the URI, default to `pythonlegacy`\n<line_number-277>                String type = representation.equals(\"default\") ? \"pythonlegacy\" : representation;\n<line_number-278>                String query = \"SELECT * FROM \" + UUID_COLLECTION + \" WHERE type = '\" + type + \"'\";\n<line_number-279>\n<line_number-280>                try (ResultSet rs = stmt.executeQuery(query)) {\n<line_number-281>                    if (rs.next()) {\n<line_number-282>                        String uuid = rs.getString(\"uuid\");\n<line_number-283>                        System.out.println(\n<line_number-284>                                \"Representation: \"\n<line_number-285>                                        + representation\n<line_number-286>                                        + \", Type: \"\n<line_number-287>                                        + type\n<line_number-288>                                        + \", UUID: \"\n<line_number-289>                                        + uuid);\n<line_number-290>                        assertEquals(\n<line_number-291>                                EXPECTED_UUID,\n<line_number-292>                                uuid,\n<line_number-293>                                \"Mismatch for \" + representation + \" representation\");\n<line_number-294>                    } else {\n<line_number-295>                        fail(\"No result found for type: \" + type);\n<line_number-296>                    }\n<line_number-297>                }\n<line_number-298>            } catch (SQLException e) {\n<line_number-299>                fail(\"Failed to execute query for \" + representation + \": \" + e.getMessage());\n<line_number-300>            }\n<line_number-301>        }\n<line_number-302>    }\n<line_number-303>\n<line_number-304>    /**\n<line_number-305>     * Tests the behavior of standard UUID representation when querying legacy UUID types. This test\n<line_number-306>     * ensures that when using the standard representation, legacy UUID types are correctly\n<line_number-307>     * retrieved and represented in the expected $binary format.\n<line_number-308>     */\n<line_number-309>    @Test\n<line_number-310>    public void testStandardRepresentationWithLegacyTypes() {\n<line_number-311>        try (MongoConnection conn =\n<line_number-312>                        getBasicConnection(DEFAULT_TEST_DB, null, \"uuidRepresentation=STANDARD\");\n<line_number-313>                Statement stmt = conn.createStatement()) {\n<line_number-314>\n<line_number-315>            for (String legacyType : UUID_REPRESENTATIONS) {\n<line_number-316>                if (legacyType.equals(\"standard\") || legacyType.equals(\"default\")) continue;\n<line_number-317>\n<line_number-318>                String query =\n<line_number-319>                        \"SELECT * FROM \" + UUID_COLLECTION + \" WHERE type = '\" + legacyType + \"'\";\n<line_number-320>                try (ResultSet rs = stmt.executeQuery(query)) {\n<line_number-321>                    if (rs.next()) {\n<line_number-322>                        String uuid = rs.getString(\"uuid\");\n<line_number-323>                        System.out.println(\n<line_number-324>                                \"STANDARD representation - Type: \"\n<line_number-325>                                        + legacyType\n<line_number-326>                                        + \", UUID: \"\n<line_number-327>                                        + uuid);\n<line_number-328>                        assertTrue(\n<line_number-329>                                uuid.startsWith(\"{\\\"$binary\\\":\"),\n<line_number-330>                                \"Expected $binary format for \"\n<line_number-331>                                        + legacyType\n<line_number-332>                                        + \" type with STANDARD representation\");\n<line_number-333>                        assertTrue(\n<line_number-334>                                uuid.contains(\"\\\"base64\\\":\"),\n<line_number-335>                                \"Expected base64 field in $binary format\");\n<line_number-336>                        assertTrue(\n<line_number-337>                                uuid.contains(\"\\\"subType\\\":\"),\n<line_number-338>                                \"Expected subType field in $binary format\");\n<line_number-339>                    } else {\n<line_number-340>                        fail(\"No result found for type: \" + legacyType);\n<line_number-341>                    }\n<line_number-342>                }\n<line_number-343>            }\n<line_number-344>        } catch (SQLException e) {\n<line_number-345>            fail(\"Failed to execute query: \" + e.getMessage());\n<line_number-346>        }\n<line_number-347>    }\n<line_number-348>\n<line_number-349>    /**\n<line_number-350>     * Tests the behavior of different UUID representations when querying the 'javalegacy' UUID\n<line_number-351>     * type. This test verifies that each representation retrieves the 'javalegacy' UUID correctly,\n<line_number-352>     * and that the value of the UUID are different.\n<line_number-353>     */\n<line_number-354>    @Test\n<line_number-355>    public void testDifferentRepresentationsForJavaLegacy() {\n<line_number-356>        Set<String> uuidValues = new HashSet<>();\n<line_number-357>        for (String representation : UUID_REPRESENTATIONS) {\n<line_number-358>            if (representation.equals(\"default\")) continue;\n<line_number-359>            try (MongoConnection conn =\n<line_number-360>                            getBasicConnection(\n<line_number-361>                                    DEFAULT_TEST_DB, null, \"uuidRepresentation=\" + representation);\n<line_number-362>                    Statement stmt = conn.createStatement();\n<line_number-363>                    ResultSet rs =\n<line_number-364>                            stmt.executeQuery(\n<line_number-365>                                    \"SELECT * FROM \"\n<line_number-366>                                            + UUID_COLLECTION\n<line_number-367>                                            + \" WHERE type = 'javalegacy'\")) {\n<line_number-368>                if (rs.next()) {\n<line_number-369>                    String uuid = rs.getString(\"uuid\");\n<line_number-370>                    System.out.println(representation + \" representation - UUID: \" + uuid);\n<line_number-371>                    if (representation.equals(\"standard\")) {\n<line_number-372>                        assertTrue(\n<line_number-373>                                uuid.startsWith(\"{\\\"$binary\\\":\"),\n<line_number-374>                                \"Expected $binary format for standard representation\");\n<line_number-375>                    } else {\n<line_number-376>                        assertTrue(\n<line_number-377>                                uuid.startsWith(\"{\\\"$uuid\\\":\"),\n<line_number-378>                                \"Expected $uuid format for non-standard representation\");\n<line_number-379>                    }\n<line_number-380>                    uuidValues.add(uuid);\n<line_number-381>                } else {\n<line_number-382>                    fail(\n<line_number-383>                            \"No result found for 'javalegacy' type with \"\n<line_number-384>                                    + representation\n<line_number-385>                                    + \" representation\");\n<line_number-386>                }\n<line_number-387>            } catch (SQLException e) {\n<line_number-388>                fail(\"Failed to execute query for \" + representation + \": \" + e.getMessage());\n<line_number-389>            }\n<line_number-390>        }\n<line_number-391>        assertEquals(4, uuidValues.size(), \"Expected 4 different UUID values (including standard)\");\n<line_number-392>    }\n<line_number-393>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for integration tests related to MongoDB JDBC.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "56-56",
            "comment_linenumber": "55",
            "comment": "Integration test class for validating MongoDB JDBC functionality, utilizing JUnit 5 for testing.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "60-64",
            "comment_linenumber": "59",
            "comment": "Defines the JDBC connection URL, allowing for environment variable overrides.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "74-74",
            "comment_linenumber": "73",
            "comment": "List to hold test entries loaded from configuration files.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "76-84",
            "comment_linenumber": "75",
            "comment": "Creates a new MongoDB connection with optional properties.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "110-112",
            "comment_linenumber": "109",
            "comment": "Loads test configurations before all tests are executed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "115-131",
            "comment_linenumber": "114",
            "comment": "Runs integration tests dynamically based on loaded test entries.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "134-135",
            "comment_linenumber": "133",
            "comment": "Callable class for executing SQL queries in a separate thread.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "158-200",
            "comment_linenumber": "157",
            "comment": "Tests logging behavior with concurrent connections and statement executions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "203-209",
            "comment_linenumber": "202",
            "comment": "Establishes a connection with a specified logging level.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "221-227",
            "comment_linenumber": "220",
            "comment": "Adds tasks for executing valid and invalid SQL statements.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "236-240",
            "comment_linenumber": "235",
            "comment": "Cleans up resources after tests, closing connections and deleting log files.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "256-260",
            "comment_linenumber": "255",
            "comment": "Tests UUID representation handling in MongoDB URI.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "304-308",
            "comment_linenumber": "303",
            "comment": "Tests standard UUID representation with legacy UUID types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "349-353",
            "comment_linenumber": "348",
            "comment": "Tests behavior of different UUID representations for the 'javalegacy' type.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'ADFIntegrationTest.java' is part of the 'com.mongodb.jdbc.integration' package and serves as an integration test suite for the MongoDB JDBC driver. It employs JUnit 5 for testing various functionalities, particularly focusing on connection handling and UUID representation. The primary class, 'ADFIntegrationTest', is annotated with '@TestInstance(TestInstance.Lifecycle.PER_CLASS)', indicating that test instances are created per class rather than per method, allowing for shared state across tests. \n\nThe class contains several static final fields for configuration, including the JDBC URL, test database name, and expected UUID formats. It also maintains a list of 'TestEntry' objects that are loaded from a specified directory before tests are executed. \n\nKey methods include 'getBasicConnection', which establishes a connection to the MongoDB database with optional properties, and 'runIntegrationTests', which dynamically generates tests based on the loaded configurations. The 'SimpleQueryExecutor' inner class is a callable that executes SQL queries in a separate thread, facilitating concurrent testing. \n\nThe test methods validate various aspects of the MongoDB JDBC driver, including logging behavior during concurrent executions, UUID representation handling, and the correctness of SQL query results. Each test method is designed to assert expected outcomes and handle exceptions appropriately, ensuring robust testing of the integration points with the MongoDB database. \n\nOverall, the file encapsulates a comprehensive suite of integration tests aimed at ensuring the reliability and correctness of the MongoDB JDBC driver under various scenarios.",
        "file_summary": "The 'ADFIntegrationTest.java' file contains integration tests for the MongoDB JDBC driver, focusing on connection handling, logging behavior, and UUID representation. It utilizes JUnit 5 to dynamically generate tests based on configurations and validates the driver's functionality against expected outcomes."
      }
    ]
  },
  "AuthX509IntegrationTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\AuthX509IntegrationTest.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\AuthX509IntegrationTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\AuthX509IntegrationTest.java",
        "chunk_id": "AuthX509IntegrationTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.MongoConnection.MONGODB_JDBC_X509_CLIENT_CERT_PATH;\n<line_number-20>import static org.junit.jupiter.api.Assertions.*;\n<line_number-21>\n<line_number-22>import java.io.File;\n<line_number-23>import java.io.FileNotFoundException;\n<line_number-24>import java.security.GeneralSecurityException;\n<line_number-25>import java.sql.*;\n<line_number-26>import java.util.Properties;\n<line_number-27>import org.junit.jupiter.api.Test;\n<line_number-28>\n<line_number-29>public class AuthX509IntegrationTest {\n<line_number-30>\n<line_number-31>    private static final String LOCAL_PORT_ENV_VAR = \"LOCAL_MDB_PORT_ENT\";\n<line_number-32>    private static final String PASSWORD_ENV_VAR = \"ADF_TEST_LOCAL_PWD\";\n<line_number-33>    private static final String X509_CERT_PATH_PROPERTY = \"x509PemPath\";\n<line_number-34>\n<line_number-35>    private static Connection connectWithX509(String pemPath, String passphrase)\n<line_number-36>            throws SQLException {\n<line_number-37>        String mongoPort = System.getenv(LOCAL_PORT_ENV_VAR);\n<line_number-38>        assertNotNull(mongoPort, \"Environment variable \" + LOCAL_PORT_ENV_VAR + \" must be set\");\n<line_number-39>\n<line_number-40>        String uri =\n<line_number-41>                \"jdbc:mongodb://localhost:\"\n<line_number-42>                        + mongoPort\n<line_number-43>                        + \"/?authSource=$external&authMechanism=MONGODB-X509&tls=true\";\n<line_number-44>\n<line_number-45>        Properties properties = new Properties();\n<line_number-46>        properties.setProperty(\"database\", \"test\");\n<line_number-47>\n<line_number-48>        if (pemPath != null) {\n<line_number-49>            properties.setProperty(X509_CERT_PATH_PROPERTY, pemPath);\n<line_number-50>        }\n<line_number-51>        if (passphrase != null) {\n<line_number-52>            properties.setProperty(\"password\", passphrase);\n<line_number-53>        }\n<line_number-54>\n<line_number-55>        return DriverManager.getConnection(uri, properties);\n<line_number-56>    }\n<line_number-57>\n<line_number-58>    /**\n<line_number-59>     * Tests that when x509PemPath property is set, it takes precedence over the\n<line_number-60>     * X509_CLIENT_CERT_PATH environment variable. The X509_CLIENT_CERT_PATH points to a valid file,\n<line_number-61>     * but the property points to an invalid path. Should fail with FileNotFound.\n<line_number-62>     */\n<line_number-63>    @Test\n<line_number-64>    public void testPropertyPrecedenceFailsIfWrong() {\n<line_number-65>        String certPathEnvVar = System.getenv(MONGODB_JDBC_X509_CLIENT_CERT_PATH);\n<line_number-66>        assertNotNull(\n<line_number-67>                certPathEnvVar,\n<line_number-68>                \"Environment variable \" + MONGODB_JDBC_X509_CLIENT_CERT_PATH + \" must be set\");\n<line_number-69>        File certFile = new File(certPathEnvVar);\n<line_number-70>        assertTrue(certFile.exists(), \"File at \" + certPathEnvVar + \" does not exist\");\n<line_number-71>\n<line_number-72>        String mongoPort = System.getenv(LOCAL_PORT_ENV_VAR);\n<line_number-73>        assertNotNull(mongoPort, \"Environment variable \" + LOCAL_PORT_ENV_VAR + \" must be set\");\n<line_number-74>\n<line_number-75>        String wrongPemPath = \"invalid-path.pem\";\n<line_number-76>        Properties properties = new Properties();\n<line_number-77>        properties.setProperty(\"database\", \"test\");\n<line_number-78>        properties.setProperty(X509_CERT_PATH_PROPERTY, wrongPemPath);\n<line_number-79>\n<line_number-80>        String uri =\n<line_number-81>                \"jdbc:mongodb://localhost:\"\n<line_number-82>                        + mongoPort\n<line_number-83>                        + \"/?authSource=$external&authMechanism=MONGODB-X509&tls=true\";\n<line_number-84>\n<line_number-85>        Exception exception =\n<line_number-86>                assertThrows(\n<line_number-87>                        RuntimeException.class, () -> DriverManager.getConnection(uri, properties));\n<line_number-88>\n<line_number-89>        Throwable cause = exception.getCause();\n<line_number-90>        assertNotNull(cause, \"Expected a cause in the exception\");\n<line_number-91>        assertTrue(\n<line_number-92>                cause instanceof FileNotFoundException,\n<line_number-93>                \"Expected FileNotFoundException, but got: \" + cause.getClass().getName());\n<line_number-94>    }\n<line_number-95>\n<line_number-96>    /** Tests that PEM file without passphrase connects */\n<line_number-97>    @Test\n<line_number-98>    public void testPropertySetCorrectly() throws SQLException {\n<line_number-99>        try (Connection connection =\n<line_number-100>                connectWithX509(\n<line_number-101>                        \"resources/authentication_test/X509/client-unencrypted.pem\", null)) {\n<line_number-102>            assertNotNull(connection, \"Connection should succeed\");\n<line_number-103>            connection.getMetaData().getDriverVersion();\n<line_number-104>        }\n<line_number-105>    }\n<line_number-106>\n<line_number-107>    /** Tests that PEM file encrypted with passphrase connects */\n<line_number-108>    @Test\n<line_number-109>    public void testEncryptedCertWithPassphrase() throws SQLException {\n<line_number-110>        String passphrase = System.getenv(PASSWORD_ENV_VAR);\n<line_number-111>\n<line_number-112>        try (Connection connection =\n<line_number-113>                connectWithX509(\n<line_number-114>                        \"resources/authentication_test/X509/client-encrypted.pem\", passphrase)) {\n<line_number-115>            assertNotNull(connection, \"Connection with encrypted cert should succeed\");\n<line_number-116>            connection.getMetaData().getDriverVersion();\n<line_number-117>        }\n<line_number-118>    }\n<line_number-119>\n<line_number-120>    /** Tests that an incorrect passphrase fails with exception */\n<line_number-121>    @Test\n<line_number-122>    public void testEncryptedCertWithIncorrectPassphraseFails() {\n<line_number-123>        String passphrase = \"incorrectPassphrase\";\n<line_number-124>\n<line_number-125>        Exception exception =\n<line_number-126>                assertThrows(\n<line_number-127>                        RuntimeException.class,\n<line_number-128>                        () ->\n<line_number-129>                                connectWithX509(\n<line_number-130>                                        \"resources/authentication_test/X509/client-encrypted.pem\",\n<line_number-131>                                        passphrase));\n<line_number-132>\n<line_number-133>        Throwable cause = exception.getCause();\n<line_number-134>        assertNotNull(cause, \"Expected a cause in the exception\");\n<line_number-135>        assertTrue(\n<line_number-136>                cause instanceof GeneralSecurityException,\n<line_number-137>                \"Expected GeneralSecurityException, but got: \" + cause.getClass().getName());\n<line_number-138>    }\n<line_number-139>\n<line_number-140>    /**\n<line_number-141>     * Tests that without the x509PemPath property set, the X509_CLIENT_CERT_PATH will be used and\n<line_number-142>     * successfully connects\n<line_number-143>     */\n<line_number-144>    @Test\n<line_number-145>    public void testNoPropertyReliesOnEnvVariable() throws SQLException {\n<line_number-146>        String certPathEnvVar = System.getenv(MONGODB_JDBC_X509_CLIENT_CERT_PATH);\n<line_number-147>        assertNotNull(\n<line_number-148>                certPathEnvVar,\n<line_number-149>                \"Environment variable \" + MONGODB_JDBC_X509_CLIENT_CERT_PATH + \" must be set\");\n<line_number-150>\n<line_number-151>        String mongoPort = System.getenv(LOCAL_PORT_ENV_VAR);\n<line_number-152>        assertNotNull(mongoPort, \"Environment variable \" + LOCAL_PORT_ENV_VAR + \" must be set\");\n<line_number-153>\n<line_number-154>        String uri =\n<line_number-155>                \"jdbc:mongodb://localhost:\"\n<line_number-156>                        + mongoPort\n<line_number-157>                        + \"/?authSource=$external&authMechanism=MONGODB-X509&tls=true\";\n<line_number-158>\n<line_number-159>        Properties properties = new Properties();\n<line_number-160>        properties.setProperty(\"database\", \"test\");\n<line_number-161>\n<line_number-162>        try (Connection connection = DriverManager.getConnection(uri, properties)) {\n<line_number-163>            assertNotNull(connection, \"Connection relying on environment variables should succeed\");\n<line_number-164>            connection.getMetaData().getDriverVersion();\n<line_number-165>        }\n<line_number-166>    }\n<line_number-167>}\n",
        "comments": [
          {
            "comment_code_range": "29-167",
            "comment_linenumber": "28",
            "comment": "This class contains integration tests for MongoDB authentication using X.509 certificates, ensuring correct behavior when using properties and environment variables.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "35-55",
            "comment_linenumber": "34",
            "comment": "Establishes a connection to MongoDB using X.509 certificate authentication, requiring a PEM file path and an optional passphrase.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "58-94",
            "comment_linenumber": "57",
            "comment": "Tests that when x509PemPath property is set, it takes precedence over the X509_CLIENT_CERT_PATH environment variable. Should fail with FileNotFound.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "96-104",
            "comment_linenumber": "105",
            "comment": "Tests that a PEM file without a passphrase connects successfully to MongoDB.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "107-117",
            "comment_linenumber": "106",
            "comment": "Tests that a PEM file encrypted with a passphrase connects successfully to MongoDB.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "120-138",
            "comment_linenumber": "119",
            "comment": "Tests that an incorrect passphrase fails with a GeneralSecurityException when attempting to connect.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "140-166",
            "comment_linenumber": "139",
            "comment": "Tests that without the x509PemPath property set, the X509_CLIENT_CERT_PATH will be used and successfully connects.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'AuthX509IntegrationTest.java' is a JUnit test class designed to validate the integration of MongoDB's X.509 authentication mechanism. It follows a typical structure for unit tests, including setup, execution, and assertions. The class imports necessary libraries for database connections and assertions, and it defines several constants for environment variable names and property keys. The primary method, 'connectWithX509', establishes a connection to a MongoDB instance using X.509 certificates, taking a PEM file path and an optional passphrase as parameters. The class contains multiple test methods that verify different scenarios: checking property precedence, successful connections with and without passphrases, and handling of incorrect passphrases. Each test method uses assertions to validate expected outcomes, ensuring that the integration behaves as intended under various conditions. The tests rely on environment variables for configuration, emphasizing the importance of proper setup in the testing environment.",
        "file_summary": "This file contains integration tests for MongoDB's X.509 authentication, ensuring that the connection logic behaves correctly with various configurations of certificate paths and passphrases."
      }
    ]
  },
  "DCIntegrationTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\DCIntegrationTest.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\DCIntegrationTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\DCIntegrationTest.java",
        "chunk_id": "DCIntegrationTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.MongoDriver.AUTHENTICATION_ERROR_SQLSTATE;\n<line_number-20>import static org.junit.jupiter.api.Assertions.*;\n<line_number-21>\n<line_number-22>import com.mongodb.jdbc.MongoConnection;\n<line_number-23>import com.mongodb.jdbc.MongoDatabaseMetaData;\n<line_number-24>import com.mongodb.jdbc.Pair;\n<line_number-25>import com.mongodb.jdbc.mongosql.MongoSQLException;\n<line_number-26>import java.sql.*;\n<line_number-27>import java.util.Properties;\n<line_number-28>import org.junit.jupiter.api.Test;\n<line_number-29>import org.junit.jupiter.api.TestInstance;\n<line_number-30>\n<line_number-31>@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n<line_number-32>public class DCIntegrationTest {\n<line_number-33>\n<line_number-34>    /**\n<line_number-35>     * Connect to a remote cluster to use for the tests.\n<line_number-36>     *\n<line_number-37>     * @return the connection to the enterprise cluster to use for the tests.\n<line_number-38>     * @throws SQLException If the connection failed.\n<line_number-39>     */\n<line_number-40>    private Connection remoteTestInstanceConnect() throws SQLException {\n<line_number-41>        String mongoHost = System.getenv(\"SRV_TEST_HOST\");\n<line_number-42>        assertNotNull(mongoHost, \"SRV_TEST_HOST variable not set in environment\");\n<line_number-43>        String mongoURI =\n<line_number-44>                \"mongodb+srv://\"\n<line_number-45>                        + mongoHost\n<line_number-46>                        + \"/?readPreference=secondaryPreferred&connectTimeoutMS=300000\";\n<line_number-47>        String fullURI = \"jdbc:\" + mongoURI;\n<line_number-48>\n<line_number-49>        String user = System.getenv(\"SRV_TEST_USER\");\n<line_number-50>        assertNotNull(user, \"SRV_TEST_USER variable not set in environment\");\n<line_number-51>        String pwd = System.getenv(\"SRV_TEST_PWD\");\n<line_number-52>        assertNotNull(pwd, \"SRV_TEST_PWD variable not set in environment\");\n<line_number-53>        String authSource = System.getenv(\"SRV_TEST_AUTH_DB\");\n<line_number-54>        assertNotNull(authSource, \"SRV_TEST_AUTH_DB variable not set in environment\");\n<line_number-55>\n<line_number-56>        Properties p = new java.util.Properties();\n<line_number-57>        p.setProperty(\"user\", user);\n<line_number-58>        p.setProperty(\"password\", pwd);\n<line_number-59>        p.setProperty(\"authSource\", authSource);\n<line_number-60>        p.setProperty(\"database\", \"test\");\n<line_number-61>\n<line_number-62>        return DriverManager.getConnection(fullURI, p);\n<line_number-63>    }\n<line_number-64>\n<line_number-65>    /** Tests that the driver can work with SRV-style URIs. */\n<line_number-66>    @Test\n<line_number-67>    public void testConnectWithSRVURI() throws SQLException {\n<line_number-68>        try (Connection conn = remoteTestInstanceConnect(); ) {\n<line_number-69>            // Let's use the connection to make sure everything is working fine.\n<line_number-70>            conn.getMetaData().getDriverVersion();\n<line_number-71>        }\n<line_number-72>    }\n<line_number-73>\n<line_number-74>    /**\n<line_number-75>     * Gets information from the environment to create a connection to a local mongod.\n<line_number-76>     *\n<line_number-77>     * @param typeEnvVar Either \"MDB_LOCAL_PORT_COM\" or \"MDB_LOCAL_PORT_ENT\"\n<line_number-78>     * @return A (jdbc_uri, properties) pair with which to create a MongoConnection\n<line_number-79>     */\n<line_number-80>    private Pair<String, Properties> createLocalMongodConnInfo(String typeEnvVar) {\n<line_number-81>        String mongoPort = System.getenv(typeEnvVar);\n<line_number-82>        assertNotNull(mongoPort, typeEnvVar + \" variable not set in environment\");\n<line_number-83>\n<line_number-84>        String uri = \"jdbc:mongodb://localhost:\" + mongoPort + \"/test\";\n<line_number-85>\n<line_number-86>        String user = System.getenv(\"LOCAL_MDB_USER\");\n<line_number-87>        assertNotNull(user, \"LOCAL_MDB_USER variable not set in environment\");\n<line_number-88>        String pwd = System.getenv(\"LOCAL_MDB_PWD\");\n<line_number-89>        assertNotNull(pwd, \"LOCAL_MDB_PWD variable not set in environment\");\n<line_number-90>\n<line_number-91>        Properties p = new java.util.Properties();\n<line_number-92>        p.setProperty(\"user\", user);\n<line_number-93>        p.setProperty(\"password\", pwd);\n<line_number-94>        p.setProperty(\"authSource\", \"test\");\n<line_number-95>        p.setProperty(\"database\", \"test\");\n<line_number-96>\n<line_number-97>        return new Pair<>(uri, p);\n<line_number-98>    }\n<line_number-99>\n<line_number-100>    /**\n<line_number-101>     * Execute the given SQL query and checks the table and column names from the metadata, also\n<line_number-102>     * verifies that the cursor return is working Ok.\n<line_number-103>     *\n<line_number-104>     * @param query The SQL query to execute.\n<line_number-105>     * @param expectedTableNames The expected table names in the metadata.\n<line_number-106>     * @param expectedColumnLabels The expected column names in the metadata.\n<line_number-107>     * @throws SQLException if an error occurs.\n<line_number-108>     */\n<line_number-109>    private void executeQueryAndValidateResults(\n<line_number-110>            String query, String[] expectedTableNames, String[] expectedColumnLabels)\n<line_number-111>            throws SQLException {\n<line_number-112>        try (Connection conn = remoteTestInstanceConnect();\n<line_number-113>                Statement stmt = conn.createStatement(); ) {\n<line_number-114>            ResultSet rs = stmt.executeQuery(query);\n<line_number-115>            ResultSetMetaData rsmd = rs.getMetaData();\n<line_number-116>\n<line_number-117>            assert (rsmd.getColumnCount() == expectedColumnLabels.length);\n<line_number-118>            int i = 1;\n<line_number-119>            for (String expectColumnLabel : expectedColumnLabels) {\n<line_number-120>                assertEquals(\n<line_number-121>                        rsmd.getColumnName(i),\n<line_number-122>                        (expectColumnLabel),\n<line_number-123>                        rsmd.getColumnName(1) + \" != \" + expectColumnLabel);\n<line_number-124>                i++;\n<line_number-125>            }\n<line_number-126>            assert (rs.next());\n<line_number-127>            // Let's also check that we can access the data and don't blow up.\n<line_number-128>            rs.getString(1);\n<line_number-129>            rs.close();\n<line_number-130>        }\n<line_number-131>    }\n<line_number-132>\n<line_number-133>    /** Tests that the driver rejects the community edition of the server. */\n<line_number-134>    @Test\n<line_number-135>    public void testConnectionToCommunityServerFails() {\n<line_number-136>        Pair<String, Properties> info = createLocalMongodConnInfo(\"LOCAL_MDB_PORT_COM\");\n<line_number-137>        try (MongoConnection conn =\n<line_number-138>                (MongoConnection) DriverManager.getConnection(info.left(), info.right()); ) {\n<line_number-139>            assertThrows(java.sql.SQLException.class, () -> {});\n<line_number-140>\n<line_number-141>        } catch (SQLException e) {\n<line_number-142>            assertTrue(\n<line_number-143>                    e.getCause().getMessage().contains(\"Community edition detected\"),\n<line_number-144>                    e.getCause().getMessage() + \" doesn't contain \\\"Community edition detected\\\"\");\n<line_number-145>        }\n<line_number-146>    }\n<line_number-147>\n<line_number-148>    /** Tests that the driver connects to the enterprise edition of the server. */\n<line_number-149>    @Test\n<line_number-150>    public void testConnectionToEnterpriseServerSucceeds() throws SQLException {\n<line_number-151>        Pair<String, Properties> info = createLocalMongodConnInfo(\"LOCAL_MDB_PORT_ENT\");\n<line_number-152>        try (Connection conn = DriverManager.getConnection(info.left(), info.right()); ) {\n<line_number-153>            // Let's use the connection to make sure everything is working fine.\n<line_number-154>            conn.getMetaData().getDriverVersion();\n<line_number-155>        }\n<line_number-156>    }\n<line_number-157>\n<line_number-158>    @Test\n<line_number-159>    public void testInvalidQueryShouldFail() throws SQLException {\n<line_number-160>        try (Connection conn = remoteTestInstanceConnect();\n<line_number-161>                Statement stmt = conn.createStatement(); ) {\n<line_number-162>            // Invalid SQL query should fail\n<line_number-163>            Exception exception =\n<line_number-164>                    assertThrows(\n<line_number-165>                            RuntimeException.class,\n<line_number-166>                            () -> {\n<line_number-167>                                stmt.executeQuery(\"This is not valid SQL\");\n<line_number-168>                            });\n<line_number-169>            // Let's make sure that we fail for the reason we expect it to.\n<line_number-170>            assertTrue(exception.getCause() instanceof MongoSQLException);\n<line_number-171>            assertTrue(exception.getMessage().contains(\"Error 2001\"));\n<line_number-172>        }\n<line_number-173>    }\n<line_number-174>\n<line_number-175>    @Test\n<line_number-176>    public void testValidSimpleQueryShouldSucceed() throws SQLException {\n<line_number-177>        String[] expectedTableNames = {\"acc\", \"acc\", \"acc\", \"acc\", \"t\", \"t\", \"t\", \"t\", \"t\", \"t\"};\n<line_number-178>        String[] expectedColumnLabels = {\n<line_number-179>            \"_id\",\n<line_number-180>            \"account_id\",\n<line_number-181>            \"limit\",\n<line_number-182>            \"products\",\n<line_number-183>            \"_id\",\n<line_number-184>            \"account_id\",\n<line_number-185>            \"bucket_end_date\",\n<line_number-186>            \"bucket_start_date\",\n<line_number-187>            \"transaction_count\",\n<line_number-188>            \"transactions\"\n<line_number-189>        };\n<line_number-190>        executeQueryAndValidateResults(\n<line_number-191>                \"SELECT * from accounts acc JOIN transactions t on acc.account_id = t.account_id limit 5\",\n<line_number-192>                expectedTableNames,\n<line_number-193>                expectedColumnLabels);\n<line_number-194>    }\n<line_number-195>\n<line_number-196>    @Test\n<line_number-197>    public void testCollectionLessQueryShouldSucceed() throws SQLException {\n<line_number-198>        String[] expectedTableNames = {\"\"};\n<line_number-199>        String[] expectedColumnLabels = {\"_1\"};\n<line_number-200>        executeQueryAndValidateResults(\"SELECT 1\", expectedTableNames, expectedColumnLabels);\n<line_number-201>    }\n<line_number-202>\n<line_number-203>    @Test\n<line_number-204>    public void testValidSimpleQueryNoSchemaForCollectionShouldSucceed() throws SQLException {\n<line_number-205>        String[] expectedTableNames = {\"\"};\n<line_number-206>        String[] expectedColumnLabels = {\"account_id\"};\n<line_number-207>        executeQueryAndValidateResults(\n<line_number-208>                \"SELECT account_id from acc_limit_over_1000 limit 5\",\n<line_number-209>                expectedTableNames,\n<line_number-210>                expectedColumnLabels);\n<line_number-211>    }\n<line_number-212>\n<line_number-213>    @Test\n<line_number-214>    public void testListDatabase() throws SQLException {\n<line_number-215>        try (Connection conn = remoteTestInstanceConnect(); ) {\n<line_number-216>            ResultSet rs = conn.getMetaData().getCatalogs();\n<line_number-217>            while (rs.next()) {\n<line_number-218>                // Verify that none of the system databases are returned\n<line_number-219>                assert (!MongoDatabaseMetaData.DISALLOWED_DB_NAMES\n<line_number-220>                        .matcher(rs.getString(1))\n<line_number-221>                        .matches());\n<line_number-222>            }\n<line_number-223>            rs.close();\n<line_number-224>        }\n<line_number-225>    }\n<line_number-226>\n<line_number-227>    @Test\n<line_number-228>    public void testListTables() throws SQLException {\n<line_number-229>        try (Connection conn = remoteTestInstanceConnect(); ) {\n<line_number-230>            ResultSet rs = conn.getMetaData().getTables(null, null, \"%\", null);\n<line_number-231>            while (rs.next()) {\n<line_number-232>                // Verify that none of the system collections are returned\n<line_number-233>                assert (!MongoDatabaseMetaData.DISALLOWED_COLLECTION_NAMES\n<line_number-234>                        .matcher(rs.getString(3))\n<line_number-235>                        .matches());\n<line_number-236>            }\n<line_number-237>            rs.close();\n<line_number-238>        }\n<line_number-239>    }\n<line_number-240>\n<line_number-241>    @Test\n<line_number-242>    public void testColumnsMetadataForCollectionWithSchema() throws SQLException {\n<line_number-243>        String[] expectedColumnLabels = {\"_id\", \"account_id\", \"limit\", \"products\"};\n<line_number-244>        try (Connection conn = remoteTestInstanceConnect(); ) {\n<line_number-245>            ResultSet rs = conn.getMetaData().getColumns(null, null, \"accounts\", \"%\");\n<line_number-246>            for (String expectColumnLabel : expectedColumnLabels) {\n<line_number-247>                assert (rs.next());\n<line_number-248>                assertEquals(\n<line_number-249>                        rs.getString(4),\n<line_number-250>                        (expectColumnLabel),\n<line_number-251>                        rs.getString(4) + \" != \" + expectColumnLabel);\n<line_number-252>            }\n<line_number-253>            rs.close();\n<line_number-254>        }\n<line_number-255>    }\n<line_number-256>\n<line_number-257>    @Test\n<line_number-258>    public void testColumnsMetadataForCollectionWithNoSchema() throws SQLException {\n<line_number-259>        try (Connection conn = remoteTestInstanceConnect(); ) {\n<line_number-260>            ResultSet rs = conn.getMetaData().getColumns(null, null, \"acc_limit_over_1000\", \"%\");\n<line_number-261>            // Check that the result set is empty and we don't blow up when calling next.\n<line_number-262>            assert (!rs.next());\n<line_number-263>            rs.close();\n<line_number-264>        }\n<line_number-265>    }\n<line_number-266>\n<line_number-267>    @Test\n<line_number-268>    public void testInvalidCredentialsOnEnterpriseServer() throws SQLException {\n<line_number-269>        Pair<String, Properties> info = createLocalMongodConnInfo(\"LOCAL_MDB_PORT_ENT\");\n<line_number-270>        info.right().setProperty(\"password\", \"invalid-password\");\n<line_number-271>\n<line_number-272>        SQLException thrown =\n<line_number-273>                assertThrows(\n<line_number-274>                        SQLException.class,\n<line_number-275>                        () -> DriverManager.getConnection(info.left(), info.right()),\n<line_number-276>                        \"A SQLException should be thrown due to invalid credentials.\");\n<line_number-277>\n<line_number-278>        String message = thrown.getMessage().toLowerCase();\n<line_number-279>        assertTrue(\n<line_number-280>                message.contains(\"authentication failed\"),\n<line_number-281>                \"The error message should indicate that authentication failed.\");\n<line_number-282>        assertEquals(\n<line_number-283>                AUTHENTICATION_ERROR_SQLSTATE,\n<line_number-284>                thrown.getSQLState(),\n<line_number-285>                \"SQLSTATE should indicate an authentication failure (\"\n<line_number-286>                        + AUTHENTICATION_ERROR_SQLSTATE\n<line_number-287>                        + \")\");\n<line_number-288>    }\n<line_number-289>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC integration tests.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "32-32",
            "comment_linenumber": "31",
            "comment": "Integration test class for validating MongoDB JDBC driver functionality.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "34-39",
            "comment_linenumber": "33",
            "comment": "Establishes a connection to a remote MongoDB cluster for testing purposes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "65-65",
            "comment_linenumber": "66",
            "comment": "Tests the driver's ability to connect using SRV-style URIs.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "74-79",
            "comment_linenumber": "73",
            "comment": "Retrieves connection information from the environment for a local MongoDB instance.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "100-107",
            "comment_linenumber": "99",
            "comment": "Executes a SQL query and validates the results against expected metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "133-133",
            "comment_linenumber": "134",
            "comment": "Tests that the driver fails to connect to a community edition MongoDB server.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "148-148",
            "comment_linenumber": "149",
            "comment": "Tests successful connection to an enterprise edition MongoDB server.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "158-173",
            "comment_linenumber": "157",
            "comment": "Tests that an invalid SQL query results in an appropriate exception.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "175-175",
            "comment_linenumber": "176",
            "comment": "Tests a valid simple SQL query execution.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "196-196",
            "comment_linenumber": "197",
            "comment": "Tests execution of a query that does not require a collection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "204-204",
            "comment_linenumber": "205",
            "comment": "Tests execution of a valid query without schema for the collection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "213-213",
            "comment_linenumber": "214",
            "comment": "Tests listing of databases to ensure no system databases are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "227-227",
            "comment_linenumber": "228",
            "comment": "Tests listing of tables to ensure no system collections are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "241-241",
            "comment_linenumber": "242",
            "comment": "Tests retrieval of column metadata for a collection with schema.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "258-258",
            "comment_linenumber": "259",
            "comment": "Tests retrieval of column metadata for a collection without schema.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "267-267",
            "comment_linenumber": "268",
            "comment": "Tests that invalid credentials on an enterprise server result in an appropriate exception.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'DCIntegrationTest.java' is a test suite for validating the functionality of the MongoDB JDBC driver, specifically focusing on connection handling and SQL query execution. It employs JUnit for testing and follows a structured approach to ensure that various scenarios are covered, including successful connections, failure cases, and metadata validation. The class 'DCIntegrationTest' is annotated with @TestInstance, indicating that it uses a per-class lifecycle for test instances. The class contains multiple private methods for establishing connections and executing queries, as well as public test methods that are annotated with @Test to indicate they are test cases. The methods utilize assertions to validate expected outcomes against actual results, ensuring that the driver behaves correctly under different conditions. The file imports necessary classes from the JDBC and MongoDB libraries, as well as JUnit for testing functionalities. It also handles environment variables for configuration, ensuring that tests can be run in different environments without hardcoding sensitive information.",
        "file_summary": "This file contains integration tests for the MongoDB JDBC driver, validating connection capabilities and SQL query execution against both remote and local MongoDB instances. It ensures that the driver correctly handles various scenarios, including successful connections, error handling for invalid queries, and metadata retrieval."
      }
    ]
  },
  "DataLoader.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\DataLoader.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\DataLoader.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\DataLoader.java",
        "chunk_id": "DataLoader_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration.testharness;\n<line_number-18>\n<line_number-19>import com.mongodb.ConnectionString;\n<line_number-20>import com.mongodb.MongoClientSettings;\n<line_number-21>import com.mongodb.MongoException;\n<line_number-22>import com.mongodb.client.MongoClient;\n<line_number-23>import com.mongodb.client.MongoClients;\n<line_number-24>import com.mongodb.client.MongoCollection;\n<line_number-25>import com.mongodb.client.MongoDatabase;\n<line_number-26>import com.mongodb.jdbc.Pair;\n<line_number-27>import com.mongodb.jdbc.integration.testharness.models.TestData;\n<line_number-28>import com.mongodb.jdbc.integration.testharness.models.TestDataEntry;\n<line_number-29>import java.io.File;\n<line_number-30>import java.io.FileInputStream;\n<line_number-31>import java.io.FileNotFoundException;\n<line_number-32>import java.io.IOException;\n<line_number-33>import java.io.InputStream;\n<line_number-34>import java.util.ArrayList;\n<line_number-35>import java.util.HashMap;\n<line_number-36>import java.util.HashSet;\n<line_number-37>import java.util.List;\n<line_number-38>import java.util.Map;\n<line_number-39>import java.util.Objects;\n<line_number-40>import java.util.Set;\n<line_number-41>import org.bson.BsonArray;\n<line_number-42>import org.bson.BsonBoolean;\n<line_number-43>import org.bson.BsonDocument;\n<line_number-44>import org.bson.BsonInt32;\n<line_number-45>import org.bson.BsonString;\n<line_number-46>import org.bson.Document;\n<line_number-47>import org.yaml.snakeyaml.LoaderOptions;\n<line_number-48>import org.yaml.snakeyaml.Yaml;\n<line_number-49>import org.yaml.snakeyaml.constructor.Constructor;\n<line_number-50>import org.yaml.snakeyaml.inspector.TagInspector;\n<line_number-51>import org.yaml.snakeyaml.nodes.Tag;\n<line_number-52>\n<line_number-53>public class DataLoader {\n<line_number-54>    public static final String TEST_DATA_DIRECTORY = \"resources/integration_test/testdata\";\n<line_number-55>    public static final String LOCAL_MDB_URL =\n<line_number-56>            \"mongodb://localhost:\"\n<line_number-57>                    + System.getenv(\"MDB_TEST_LOCAL_PORT\")\n<line_number-58>                    + \"/?uuidRepresentation=standard\";\n<line_number-59>    public static final String LOCAL_ADF_URL =\n<line_number-60>            \"mongodb://\"\n<line_number-61>                    + System.getenv(\"ADF_TEST_LOCAL_USER\")\n<line_number-62>                    + \":\"\n<line_number-63>                    + System.getenv(\"ADF_TEST_LOCAL_PWD\")\n<line_number-64>                    + \"@localhost\";\n<line_number-65>    private static Yaml yaml;\n<line_number-66>\n<line_number-67>    static {\n<line_number-68>        TagInspector allowGlobalTags =\n<line_number-69>                new TagInspector() {\n<line_number-70>                    @Override\n<line_number-71>                    public boolean isGlobalTagAllowed(Tag tag) {\n<line_number-72>                        return true;\n<line_number-73>                    }\n<line_number-74>                };\n<line_number-75>        LoaderOptions loaderOptions = new LoaderOptions();\n<line_number-76>        loaderOptions.setTagInspector(allowGlobalTags);\n<line_number-77>        yaml = new Yaml(new Constructor(TestData.class, loaderOptions));\n<line_number-78>    };\n<line_number-79>\n<line_number-80>    private List<TestDataEntry> datasets;\n<line_number-81>    private Set<Pair<String, String>> collections;\n<line_number-82>    private Set<String> databases;\n<line_number-83>    private ConnectionString mdbUri;\n<line_number-84>    private ConnectionString adfUri;\n<line_number-85>\n<line_number-86>    public DataLoader(String dataDirectory) throws IOException {\n<line_number-87>        this.datasets = new ArrayList<>();\n<line_number-88>        this.collections = new HashSet<>();\n<line_number-89>        this.databases = new HashSet<>();\n<line_number-90>        this.mdbUri = new ConnectionString(LOCAL_MDB_URL);\n<line_number-91>        System.out.println(this.mdbUri);\n<line_number-92>        this.adfUri = new ConnectionString(LOCAL_ADF_URL);\n<line_number-93>        System.out.println(\"Local ADF url\" + this.adfUri);\n<line_number-94>\n<line_number-95>        readDataFiles(dataDirectory);\n<line_number-96>    }\n<line_number-97>\n<line_number-98>    private void readDataFiles(String dataDirectory) throws IOException {\n<line_number-99>        File folder = new File(dataDirectory);\n<line_number-100>        for (final File fileEntry : Objects.requireNonNull(folder.listFiles())) {\n<line_number-101>            if (isValidTestDataFile(fileEntry)) {\n<line_number-102>                try (InputStream is = new FileInputStream(fileEntry.getPath())) {\n<line_number-103>                    TestData testData = yaml.load(is);\n<line_number-104>                    for (TestDataEntry entry : testData.dataset) {\n<line_number-105>                        datasets.add(entry);\n<line_number-106>                        databases.add(entry.db);\n<line_number-107>                        if (entry.collection != null) {\n<line_number-108>                            collections.add(new Pair<>(entry.db, entry.collection));\n<line_number-109>                        } else if (entry.view == null) {\n<line_number-110>                            System.out.println(\n<line_number-111>                                    \"One entry in \"\n<line_number-112>                                            + fileEntry.getName()\n<line_number-113>                                            + \" has no collection or view associated.\");\n<line_number-114>                        }\n<line_number-115>                    }\n<line_number-116>                }\n<line_number-117>            }\n<line_number-118>        }\n<line_number-119>    }\n<line_number-120>\n<line_number-121>    private boolean isValidTestDataFile(File file) {\n<line_number-122>        return file.isFile()\n<line_number-123>                && (file.getName().endsWith(\".yml\") || file.getName().endsWith(\".yaml\"));\n<line_number-124>    }\n<line_number-125>\n<line_number-126>    /** Drops collections specified in test data files */\n<line_number-127>    public void dropCollections() {\n<line_number-128>        try (MongoClient mongoClient = MongoClients.create(mdbUri)) {\n<line_number-129>            for (Pair<String, String> collection : collections) {\n<line_number-130>                MongoDatabase database = mongoClient.getDatabase(collection.left());\n<line_number-131>                database.getCollection(collection.right()).drop();\n<line_number-132>                System.out.println(\"Dropped \" + collection.left() + \".\" + collection.right());\n<line_number-133>            }\n<line_number-134>        }\n<line_number-135>    }\n<line_number-136>\n<line_number-137>    private void setSchema(String database, String collection, Map<String, Object> jsonSchema) {\n<line_number-138>        System.out.println(\"Set schema for  \" + database + \".\" + collection);\n<line_number-139>        BsonDocument command = new BsonDocument();\n<line_number-140>        BsonDocument schema = new BsonDocument();\n<line_number-141>        command.put(\"sqlSetSchema\", new BsonString(collection));\n<line_number-142>        command.put(\"schema\", schema);\n<line_number-143>        schema.put(\"version\", new BsonInt32(1));\n<line_number-144>\n<line_number-145>        Document doc = new Document(jsonSchema);\n<line_number-146>        schema.put(\n<line_number-147>                \"jsonSchema\",\n<line_number-148>                doc.toBsonDocument(\n<line_number-149>                        BsonDocument.class, MongoClientSettings.getDefaultCodecRegistry()));\n<line_number-150>        try (MongoClient mongoClient = MongoClients.create(adfUri)) {\n<line_number-151>            MongoDatabase db = mongoClient.getDatabase(database);\n<line_number-152>            db.runCommand(command);\n<line_number-153>        }\n<line_number-154>    }\n<line_number-155>\n<line_number-156>    private void generateSchema(String database, String collection) {\n<line_number-157>        System.out.println(\"Generate schema for  \" + database + \".\" + collection);\n<line_number-158>        BsonDocument command = new BsonDocument();\n<line_number-159>        command.put(\"sqlGenerateSchema\", new BsonInt32(1));\n<line_number-160>        command.put(\"setSchemas\", new BsonBoolean(true));\n<line_number-161>\n<line_number-162>        BsonArray coll = new BsonArray();\n<line_number-163>        coll.add(new BsonString(database + \".\" + collection));\n<line_number-164>        command.put(\"sampleNamespaces\", coll);\n<line_number-165>\n<line_number-166>        try (MongoClient mongoClient = MongoClients.create(adfUri)) {\n<line_number-167>            MongoDatabase db = mongoClient.getDatabase(\"admin\");\n<line_number-168>            db.runCommand(command);\n<line_number-169>        }\n<line_number-170>    }\n<line_number-171>\n<line_number-172>    /**\n<line_number-173>     * Loads integration test data files from dataDirectory to database in specified url\n<line_number-174>     *\n<line_number-175>     * @return Count of rows inserted\n<line_number-176>     * @throws FileNotFoundException\n<line_number-177>     */\n<line_number-178>    @SuppressWarnings(\"unchecked\")\n<line_number-179>    public void loadTestData() throws IOException {\n<line_number-180>        try {\n<line_number-181>            try (MongoClient mongoClient = MongoClients.create(mdbUri)) {\n<line_number-182>                Map<String, String> views = new HashMap<>();\n<line_number-183>                for (TestDataEntry entry : datasets) {\n<line_number-184>                    MongoDatabase database = mongoClient.getDatabase(entry.db);\n<line_number-185>                    if (entry.collection != null) {\n<line_number-186>                        loadCollection(entry, database);\n<line_number-187>                    } else if (entry.view != null) {\n<line_number-188>                        views.put(entry.db, entry.view);\n<line_number-189>                    }\n<line_number-190>                }\n<line_number-191>\n<line_number-192>                // Generate views schema after all collections have been setup\n<line_number-193>                // to make sure a view schema is not generated before the\n<line_number-194>                // collection data and schema are there.\n<line_number-195>                for (Map.Entry<String, String> view : views.entrySet()) {\n<line_number-196>                    generateSchema(view.getKey(), view.getValue());\n<line_number-197>                }\n<line_number-198>            }\n<line_number-199>        } catch (MongoException e) {\n<line_number-200>            dropCollections();\n<line_number-201>            throw e;\n<line_number-202>        }\n<line_number-203>    }\n<line_number-204>\n<line_number-205>    /**\n<line_number-206>     * Loads a collection with the information provided in the TestDataEntry.\n<line_number-207>     *\n<line_number-208>     * @param entry the collection entry.\n<line_number-209>     * @param database The database to add the collection to.\n<line_number-210>     */\n<line_number-211>    private void loadCollection(TestDataEntry entry, MongoDatabase database) {\n<line_number-212>        MongoCollection<Document> collection = database.getCollection(entry.collection);\n<line_number-213>\n<line_number-214>        if (entry.docsExtJson != null) {\n<line_number-215>            // Process extended json format\n<line_number-216>            for (Map<String, Object> row : entry.docsExtJson) {\n<line_number-217>                Document d = Document.parse(new Document(row).toJson());\n<line_number-218>                collection.insertOne(new Document(d));\n<line_number-219>            }\n<line_number-220>            System.out.println(\n<line_number-221>                    \"Inserted \"\n<line_number-222>                            + entry.docsExtJson.size()\n<line_number-223>                            + \" rows into \"\n<line_number-224>                            + entry.db\n<line_number-225>                            + \".\"\n<line_number-226>                            + entry.collection);\n<line_number-227>        } else if (entry.docs != null) {\n<line_number-228>            for (Map<String, Object> row : entry.docs) {\n<line_number-229>                collection.insertOne(new Document(row));\n<line_number-230>            }\n<line_number-231>            System.out.println(\n<line_number-232>                    \"Inserted \"\n<line_number-233>                            + entry.docs.size()\n<line_number-234>                            + \" rows into \"\n<line_number-235>                            + entry.db\n<line_number-236>                            + \".\"\n<line_number-237>                            + entry.collection);\n<line_number-238>        }\n<line_number-239>        if (entry.nonuniqueIndexes != null) {\n<line_number-240>            for (Map<String, Object> index : entry.nonuniqueIndexes) {\n<line_number-241>                String indexName = collection.createIndex(new Document(index));\n<line_number-242>                System.out.println(\n<line_number-243>                        \"Created index \" + indexName + \" on \" + entry.db + \".\" + entry.collection);\n<line_number-244>            }\n<line_number-245>        }\n<line_number-246>        if (entry.schema != null) {\n<line_number-247>            setSchema(entry.db, entry.collection, entry.schema);\n<line_number-248>        } else {\n<line_number-249>            generateSchema(entry.db, entry.collection);\n<line_number-250>        }\n<line_number-251>    }\n<line_number-252>\n<line_number-253>    public static void main(String[] args) throws IOException {\n<line_number-254>        DataLoader loader = new DataLoader(TEST_DATA_DIRECTORY);\n<line_number-255>        loader.dropCollections();\n<line_number-256>        loader.loadTestData();\n<line_number-257>    }\n<line_number-258>}\n",
        "comments": [
          {
            "comment_code_range": "53-257",
            "comment_linenumber": "52",
            "comment": "Handles loading and managing test data for integration tests with MongoDB, including reading YAML files, inserting data, and managing schemas.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "86-96",
            "comment_linenumber": "85",
            "comment": "Initializes the DataLoader with the specified data directory and sets up MongoDB connection strings.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "98-119",
            "comment_linenumber": "97",
            "comment": "Reads YAML data files from the specified directory and populates datasets, collections, and databases.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "121-124",
            "comment_linenumber": "120",
            "comment": "Validates if the given file is a valid test data file based on its extension.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "126-135",
            "comment_linenumber": "125",
            "comment": "Drops collections specified in the test data files from the MongoDB database.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "137-153",
            "comment_linenumber": "136",
            "comment": "Sets the schema for a specified collection in the MongoDB database.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "156-169",
            "comment_linenumber": "155",
            "comment": "Generates a schema for a specified collection in the MongoDB database.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "172-202",
            "comment_linenumber": "171",
            "comment": "Loads integration test data files into the MongoDB database, handling exceptions and ensuring data integrity.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "205-210",
            "comment_linenumber": "204",
            "comment": "Loads a collection with data provided in the TestDataEntry, including handling documents and indexes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "253-257",
            "comment_linenumber": "252",
            "comment": "Main entry point for the DataLoader, initializing the loader and executing data loading operations.",
            "comment_kind": "function"
          }
        ],
        "structural_analysis": "The file 'DataLoader.java' is part of the 'com.mongodb.jdbc.integration.testharness' package and is responsible for loading and managing test data for integration tests with MongoDB. It follows a procedural design pattern, utilizing static methods and instance methods to handle various operations related to test data management. The primary class, 'DataLoader', contains several static final fields for configuration, including MongoDB connection strings and a YAML parser instance. The constructor initializes the data loader with a specified directory and sets up the necessary MongoDB URIs. The class has methods for reading data files, validating file types, dropping collections, setting schemas, generating schemas, and loading test data into the database. It also includes a main method for executing the data loading process. The class interacts with MongoDB through the MongoClient and MongoDatabase classes, handling exceptions and ensuring data integrity throughout the loading process. Key relationships include the use of the 'TestData' and 'TestDataEntry' models for data representation, and the 'Pair' class for managing database and collection pairs. The file does not expose any public APIs or external services beyond MongoDB.",
        "file_summary": "The 'DataLoader.java' file is designed to facilitate the loading of integration test data into a MongoDB database. It reads YAML files containing test data, manages database collections and schemas, and provides functionality to drop existing collections before loading new data. The file is essential for setting up the test environment for integration tests."
      }
    ]
  },
  "IntegrationTestUtils.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\IntegrationTestUtils.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\IntegrationTestUtils.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\IntegrationTestUtils.java",
        "chunk_id": "IntegrationTestUtils_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration.testharness;\n<line_number-18>\n<line_number-19>import static org.junit.jupiter.api.Assertions.assertEquals;\n<line_number-20>import static org.junit.jupiter.api.Assertions.assertNotEquals;\n<line_number-21>import static org.junit.jupiter.api.Assertions.assertThrows;\n<line_number-22>import static org.junit.jupiter.api.Assertions.assertTrue;\n<line_number-23>import static org.junit.jupiter.api.Assertions.fail;\n<line_number-24>\n<line_number-25>import com.mongodb.jdbc.MongoBsonValue;\n<line_number-26>import com.mongodb.jdbc.MongoColumnInfo;\n<line_number-27>import com.mongodb.jdbc.MongoResultSetMetaData;\n<line_number-28>import com.mongodb.jdbc.integration.testharness.models.TestEntry;\n<line_number-29>import com.mongodb.jdbc.integration.testharness.models.Tests;\n<line_number-30>import java.io.File;\n<line_number-31>import java.io.FileInputStream;\n<line_number-32>import java.io.FileNotFoundException;\n<line_number-33>import java.io.IOException;\n<line_number-34>import java.io.InputStream;\n<line_number-35>import java.lang.reflect.InvocationTargetException;\n<line_number-36>import java.lang.reflect.Method;\n<line_number-37>import java.sql.Connection;\n<line_number-38>import java.sql.DatabaseMetaData;\n<line_number-39>import java.sql.Date;\n<line_number-40>import java.sql.ResultSet;\n<line_number-41>import java.sql.ResultSetMetaData;\n<line_number-42>import java.sql.SQLException;\n<line_number-43>import java.sql.Statement;\n<line_number-44>import java.sql.Types;\n<line_number-45>import java.util.ArrayList;\n<line_number-46>import java.util.List;\n<line_number-47>import java.util.Map;\n<line_number-48>import java.util.Objects;\n<line_number-49>import org.bson.BsonDocument;\n<line_number-50>import org.bson.BsonInt32;\n<line_number-51>import org.bson.BsonValue;\n<line_number-52>import org.bson.Document;\n<line_number-53>import org.bson.UuidRepresentation;\n<line_number-54>import org.yaml.snakeyaml.LoaderOptions;\n<line_number-55>import org.yaml.snakeyaml.Yaml;\n<line_number-56>import org.yaml.snakeyaml.constructor.Constructor;\n<line_number-57>import org.yaml.snakeyaml.inspector.TagInspector;\n<line_number-58>import org.yaml.snakeyaml.nodes.Tag;\n<line_number-59>\n<line_number-60>public class IntegrationTestUtils {\n<line_number-61>    public static int countRows(ResultSet rs) throws SQLException {\n<line_number-62>        for (int i = 0; ; ++i) {\n<line_number-63>            if (!rs.next()) {\n<line_number-64>                return i;\n<line_number-65>            }\n<line_number-66>        }\n<line_number-67>    }\n<line_number-68>\n<line_number-69>    private static Yaml yaml;\n<line_number-70>\n<line_number-71>    static {\n<line_number-72>        TagInspector allowGlobalTags =\n<line_number-73>                new TagInspector() {\n<line_number-74>                    @Override\n<line_number-75>                    public boolean isGlobalTagAllowed(Tag tag) {\n<line_number-76>                        return true;\n<line_number-77>                    }\n<line_number-78>                };\n<line_number-79>        LoaderOptions loaderOptions = new LoaderOptions();\n<line_number-80>        loaderOptions.setTagInspector(allowGlobalTags);\n<line_number-81>        yaml = new Yaml(new Constructor(Tests.class, loaderOptions));\n<line_number-82>    };\n<line_number-83>\n<line_number-84>    /**\n<line_number-85>     * loadTestConfigs will process all test yaml files in provided directory.\n<line_number-86>     *\n<line_number-87>     * @param directory The directory with test files to traverse\n<line_number-88>     * @return A List of TestEntry\n<line_number-89>     * @throws FileNotFoundException\n<line_number-90>     */\n<line_number-91>    public static List<TestEntry> loadTestConfigs(String directory) throws IOException {\n<line_number-92>        List<Tests> tests = new ArrayList<>();\n<line_number-93>        List<TestEntry> testEntries = new ArrayList<>();\n<line_number-94>        final File folder = new File(directory);\n<line_number-95>        if (!folder.exists()) {\n<line_number-96>            return testEntries;\n<line_number-97>        }\n<line_number-98>        processDirectory(folder, tests);\n<line_number-99>\n<line_number-100>        for (Tests testList : tests) {\n<line_number-101>            testEntries.addAll(testList.tests);\n<line_number-102>        }\n<line_number-103>        return testEntries;\n<line_number-104>    }\n<line_number-105>\n<line_number-106>    // processDirectory will traverse the subdirectories of 'folder'.\n<line_number-107>    // Useful to group related test files in a directory\n<line_number-108>    private static void processDirectory(final File folder, List<Tests> tests) throws IOException {\n<line_number-109>        for (final File fileEntry : Objects.requireNonNull(folder.listFiles())) {\n<line_number-110>            if (fileEntry.isDirectory()) {\n<line_number-111>                processDirectory(fileEntry, tests);\n<line_number-112>            } else {\n<line_number-113>                tests.add(processTestFile(fileEntry.getPath()));\n<line_number-114>            }\n<line_number-115>        }\n<line_number-116>    }\n<line_number-117>\n<line_number-118>    private static Tests processTestFile(String filename) throws IOException {\n<line_number-119>        try (InputStream is = new FileInputStream(filename)) {\n<line_number-120>            return yaml.load(is);\n<line_number-121>        } catch (Exception e) {\n<line_number-122>            System.err.println(\"Error processing \" + filename);\n<line_number-123>            throw e;\n<line_number-124>        }\n<line_number-125>    }\n<line_number-126>\n<line_number-127>    /**\n<line_number-128>     * runTest will execute the passed in testEntry. If generate is 'true' then baseline files will\n<line_number-129>     * be generated from the test configuration\n<line_number-130>     *\n<line_number-131>     * @param testEntry Test to run\n<line_number-132>     * @param conn Database connection\n<line_number-133>     * @param generate Generate Baseline test files instead of running test\n<line_number-134>     * @throws IOException\n<line_number-135>     * @throws SQLException\n<line_number-136>     * @throws IllegalAccessException\n<line_number-137>     * @throws InvocationTargetException\n<line_number-138>     */\n<line_number-139>    public static void runTest(TestEntry testEntry, Connection conn, Boolean generate)\n<line_number-140>            throws IOException, SQLException, IllegalAccessException, InvocationTargetException {\n<line_number-141>        ResultSet rs = null;\n<line_number-142>        // Run DatabaseMetadata function if it exists, takes precedence over query\n<line_number-143>        System.out.println(\"Running test: \" + testEntry.description);\n<line_number-144>        try {\n<line_number-145>            if (testEntry.meta_function == null) {\n<line_number-146>                rs = executeQuery(testEntry, conn);\n<line_number-147>            } else {\n<line_number-148>                rs = executeDBMetadataCommand(testEntry, conn.getMetaData());\n<line_number-149>            }\n<line_number-150>            assertNotEquals(rs, null);\n<line_number-151>            if (generate) {\n<line_number-152>                TestGenerator.generateBaselineTestFiles(testEntry, rs);\n<line_number-153>            } else {\n<line_number-154>                if (testEntry.ordered != null && testEntry.ordered) {\n<line_number-155>                    validateResultsOrdered(testEntry, rs);\n<line_number-156>                } else {\n<line_number-157>                    validateResultsUnordered(testEntry, rs);\n<line_number-158>                }\n<line_number-159>                validateResultSetMetadata(testEntry, rs.getMetaData());\n<line_number-160>            }\n<line_number-161>        } finally {\n<line_number-162>            if (rs != null) {\n<line_number-163>                Statement statement = rs.getStatement();\n<line_number-164>                if (statement != null) {\n<line_number-165>                    statement.close();\n<line_number-166>                }\n<line_number-167>            }\n<line_number-168>        }\n<line_number-169>    }\n<line_number-170>\n<line_number-171>    private static ResultSet executeQuery(TestEntry entry, Connection conn) throws SQLException {\n<line_number-172>        Statement stmt = conn.createStatement();\n<line_number-173>        return stmt.executeQuery(entry.sql);\n<line_number-174>    }\n<line_number-175>\n<line_number-176>    @SuppressWarnings(\"unchecked\")\n<line_number-177>    private static ResultSet executeDBMetadataCommand(\n<line_number-178>            TestEntry entry, DatabaseMetaData databaseMetaData)\n<line_number-179>            throws SQLException, InvocationTargetException, IllegalAccessException {\n<line_number-180>\n<line_number-181>        List<Object> metadataFunction = entry.meta_function;\n<line_number-182>        assertTrue(\n<line_number-183>                metadataFunction != null && metadataFunction.size() > 0,\n<line_number-184>                \"expected a DatabaseMetaData method but found none\");\n<line_number-185>        String functionName = (String) metadataFunction.get(0);\n<line_number-186>        Method[] m = DatabaseMetaData.class.getMethods();\n<line_number-187>\n<line_number-188>        RuntimeException possibleException = null;\n<line_number-189>        for (Method method : m) {\n<line_number-190>            if (method.getName().equalsIgnoreCase(functionName)) {\n<line_number-191>                Class<?>[] types = method.getParameterTypes();\n<line_number-192>                if (method.getReturnType() != ResultSet.class) {\n<line_number-193>                    throw new IllegalArgumentException(\n<line_number-194>                            \"expected: \"\n<line_number-195>                                    + ResultSet.class.getName()\n<line_number-196>                                    + \" found: \"\n<line_number-197>                                    + method.getReturnType());\n<line_number-198>                }\n<line_number-199>                if (method.getParameterCount() != metadataFunction.size() - 1) {\n<line_number-200>                    // Some methods may be overloaded. For such methods, we do not\n<line_number-201>                    // want to throw immediately when we encounter an incorrect\n<line_number-202>                    // argument count; instead we store the error and throw at the end\n<line_number-203>                    possibleException =\n<line_number-204>                            new IllegalArgumentException(\n<line_number-205>                                    \"expected parameter count: \"\n<line_number-206>                                            + method.getParameterCount()\n<line_number-207>                                            + \" found: \"\n<line_number-208>                                            + (metadataFunction.size() - 1));\n<line_number-209>                    continue;\n<line_number-210>                }\n<line_number-211>                if (method.getParameterCount() == 0) {\n<line_number-212>                    return (ResultSet) method.invoke(databaseMetaData);\n<line_number-213>                }\n<line_number-214>                Object[] parameters = new Object[method.getParameterCount()];\n<line_number-215>\n<line_number-216>                for (int i = 0; i < parameters.length; i++) {\n<line_number-217>                    Object currentMetaInput = metadataFunction.get(i + 1);\n<line_number-218>                    if (currentMetaInput == null) {\n<line_number-219>                        parameters[i] = null;\n<line_number-220>                        continue;\n<line_number-221>                    }\n<line_number-222>                    Class<?> parameterType = types[i];\n<line_number-223>                    if (parameterType.isArray()) {\n<line_number-224>                        if (parameterType.getComponentType() == String.class) {\n<line_number-225>                            parameters[i] =\n<line_number-226>                                    ((List<String>) currentMetaInput)\n<line_number-227>                                            .stream()\n<line_number-228>                                            .map(object -> Objects.toString(object, null))\n<line_number-229>                                            .toArray(String[]::new);\n<line_number-230>                        } else if (parameterType.getComponentType() == int.class) {\n<line_number-231>                            parameters[i] =\n<line_number-232>                                    ((List<Integer>) currentMetaInput)\n<line_number-233>                                            .stream()\n<line_number-234>                                            .mapToInt(j -> j)\n<line_number-235>                                            .toArray();\n<line_number-236>                        }\n<line_number-237>                    } else if (parameterType == String.class) {\n<line_number-238>                        parameters[i] = (String) currentMetaInput;\n<line_number-239>                    } else if (parameterType == int.class) {\n<line_number-240>                        parameters[i] = (Integer) currentMetaInput;\n<line_number-241>                    } else if (parameterType == boolean.class) {\n<line_number-242>                        parameters[i] = (Boolean) currentMetaInput;\n<line_number-243>                    }\n<line_number-244>                }\n<line_number-245>                return (ResultSet) method.invoke(databaseMetaData, parameters);\n<line_number-246>            }\n<line_number-247>        }\n<line_number-248>\n<line_number-249>        if (possibleException != null) {\n<line_number-250>            throw possibleException;\n<line_number-251>        }\n<line_number-252>\n<line_number-253>        throw new IllegalArgumentException(\"function '\" + functionName + \"' not found\");\n<line_number-254>    }\n<line_number-255>\n<line_number-256>    public static void validateResultSetMetadata(TestEntry test, ResultSetMetaData rsMetaData)\n<line_number-257>            throws SQLException, IllegalAccessException {\n<line_number-258>        int columnCount = rsMetaData.getColumnCount();\n<line_number-259>        if (test.expected_sql_type != null) {\n<line_number-260>            assertEquals(\n<line_number-261>                    test.expected_sql_type.size(),\n<line_number-262>                    columnCount,\n<line_number-263>                    \"Either the yml test specification is missing entries for 'expected_sql_type' or the data\"\n<line_number-264>                            + \" in the DB is not matching the test\");\n<line_number-265>            for (int i = 0; i < columnCount; i++) {\n<line_number-266>                int sqlType = TestTypeInfo.typesStringToInt(test.expected_sql_type.get(i));\n<line_number-267>                assertEquals(\n<line_number-268>                        sqlType,\n<line_number-269>                        rsMetaData.getColumnType(i + 1),\n<line_number-270>                        \"Invalid getColumnType result for column \" + (i + 1));\n<line_number-271>            }\n<line_number-272>        }\n<line_number-273>        if (test.expected_catalog_name != null) {\n<line_number-274>            assertEquals(\n<line_number-275>                    test.expected_catalog_name.size(),\n<line_number-276>                    columnCount,\n<line_number-277>                    \"Either the yml test specification is missing entries for 'expected_catalog_name' or the\"\n<line_number-278>                            + \" data in the DB is not matching the test\");\n<line_number-279>            for (int i = 0; i < columnCount; i++) {\n<line_number-280>                assertEquals(\n<line_number-281>                        test.expected_catalog_name.get(i),\n<line_number-282>                        rsMetaData.getCatalogName(i + 1),\n<line_number-283>                        \"Invalid getCatalogName result for column \" + (i + 1));\n<line_number-284>            }\n<line_number-285>        }\n<line_number-286>        if (test.expected_column_class_name != null) {\n<line_number-287>            assertEquals(\n<line_number-288>                    test.expected_column_class_name.size(),\n<line_number-289>                    columnCount,\n<line_number-290>                    \"Either the yml test specification is missing entries for 'expected_column_class_name' or\"\n<line_number-291>                            + \" the data in the DB is not matching the test\");\n<line_number-292>            for (int i = 0; i < columnCount; i++) {\n<line_number-293>                assertEquals(\n<line_number-294>                        test.expected_column_class_name.get(i),\n<line_number-295>                        rsMetaData.getColumnClassName(i + 1),\n<line_number-296>                        \"Invalid getColumnClassName result for column \" + (i + 1));\n<line_number-297>            }\n<line_number-298>        }\n<line_number-299>        if (test.expected_column_display_size != null) {\n<line_number-300>            assertEquals(\n<line_number-301>                    test.expected_column_display_size.size(),\n<line_number-302>                    columnCount,\n<line_number-303>                    \"Either the yml test specification is missing entries for 'expected_column_display_size'\"\n<line_number-304>                            + \" or the data in the DB is not matching the test\");\n<line_number-305>            for (int i = 0; i < columnCount; i++) {\n<line_number-306>                assertEquals(\n<line_number-307>                        test.expected_column_display_size.get(i).intValue(),\n<line_number-308>                        rsMetaData.getColumnDisplaySize(i + 1),\n<line_number-309>                        \"Invalid getColumnDisplaySize result for column \" + (i + 1));\n<line_number-310>            }\n<line_number-311>        }\n<line_number-312>        if (test.expected_column_label != null) {\n<line_number-313>            assertEquals(\n<line_number-314>                    test.expected_column_label.size(),\n<line_number-315>                    columnCount,\n<line_number-316>                    \"Either the yml test specification is missing entries for 'expected_column_label' or the\"\n<line_number-317>                            + \" data in the DB is not matching the test\");\n<line_number-318>            for (int i = 0; i < columnCount; i++) {\n<line_number-319>                assertEquals(\n<line_number-320>                        test.expected_column_label.get(i),\n<line_number-321>                        rsMetaData.getColumnLabel(i + 1),\n<line_number-322>                        \"Invalid getColumnLabel result for column \" + (i + 1));\n<line_number-323>            }\n<line_number-324>        }\n<line_number-325>        if (test.expected_precision != null) {\n<line_number-326>            assertEquals(\n<line_number-327>                    test.expected_precision.size(),\n<line_number-328>                    columnCount,\n<line_number-329>                    \"Either the yml test specification is missing entries for 'expected_precision' or the\"\n<line_number-330>                            + \" data in the DB is not matching the test\");\n<line_number-331>            for (int i = 0; i < columnCount; i++) {\n<line_number-332>                assertEquals(\n<line_number-333>                        test.expected_precision.get(i).intValue(),\n<line_number-334>                        rsMetaData.getPrecision(i + 1),\n<line_number-335>                        \"Invalid getPrecision result for column \" + (i + 1));\n<line_number-336>            }\n<line_number-337>        }\n<line_number-338>        if (test.expected_scale != null) {\n<line_number-339>            assertEquals(\n<line_number-340>                    test.expected_scale.size(),\n<line_number-341>                    columnCount,\n<line_number-342>                    \"Either the yml test specification is missing entries for 'expected_scale' or the data\"\n<line_number-343>                            + \" in the DB is not matching the test\");\n<line_number-344>            for (int i = 0; i < columnCount; i++) {\n<line_number-345>                assertEquals(\n<line_number-346>                        test.expected_scale.get(i).intValue(),\n<line_number-347>                        rsMetaData.getScale(i + 1),\n<line_number-348>                        \"Invalid getScale result for column \" + (i + 1));\n<line_number-349>            }\n<line_number-350>        }\n<line_number-351>        if (test.expected_schema_name != null) {\n<line_number-352>            assertEquals(\n<line_number-353>                    test.expected_schema_name.size(),\n<line_number-354>                    columnCount,\n<line_number-355>                    \"Either the yml test specification is missing entries for 'expected_schema_name' or the\"\n<line_number-356>                            + \" data in the DB is not matching the test\");\n<line_number-357>            for (int i = 0; i < columnCount; i++) {\n<line_number-358>                assertEquals(\n<line_number-359>                        test.expected_schema_name.get(i),\n<line_number-360>                        rsMetaData.getSchemaName(i + 1),\n<line_number-361>                        \"Invalid getSchemaName result for column \" + (i + 1));\n<line_number-362>            }\n<line_number-363>        }\n<line_number-364>        if (test.expected_is_auto_increment != null) {\n<line_number-365>            assertEquals(\n<line_number-366>                    test.expected_is_auto_increment.size(),\n<line_number-367>                    columnCount,\n<line_number-368>                    \"Either the yml test specification is missing entries for 'expected_is_auto_increment' or\"\n<line_number-369>                            + \" the data in the DB is not matching the test\");\n<line_number-370>            for (int i = 0; i < columnCount; i++) {\n<line_number-371>                assertEquals(\n<line_number-372>                        test.expected_is_auto_increment.get(i),\n<line_number-373>                        rsMetaData.isAutoIncrement(i + 1),\n<line_number-374>                        \"Invalid isAutoIncrement result for column \" + (i + 1));\n<line_number-375>            }\n<line_number-376>        }\n<line_number-377>        if (test.expected_is_case_sensitive != null) {\n<line_number-378>            assertEquals(\n<line_number-379>                    test.expected_is_case_sensitive.size(),\n<line_number-380>                    columnCount,\n<line_number-381>                    \"Either the yml test specification is missing entries for 'expected_is_case_sensitive' or\"\n<line_number-382>                            + \" the data in the DB is not matching the test\");\n<line_number-383>            for (int i = 0; i < columnCount; i++) {\n<line_number-384>                assertEquals(\n<line_number-385>                        test.expected_is_case_sensitive.get(i),\n<line_number-386>                        rsMetaData.isCaseSensitive(i + 1),\n<line_number-387>                        \"Invalid isCaseSensitive result for column \" + (i + 1));\n<line_number-388>            }\n<line_number-389>        }\n<line_number-390>        if (test.expected_is_currency != null) {\n<line_number-391>            assertEquals(\n<line_number-392>                    test.expected_is_currency.size(),\n<line_number-393>                    columnCount,\n<line_number-394>                    \"Either the yml test specification is missing entries for 'expected_is_currency' or the\"\n<line_number-395>                            + \" data in the DB is not matching the test\");\n<line_number-396>            for (int i = 0; i < columnCount; i++) {\n<line_number-397>                assertEquals(\n<line_number-398>                        test.expected_is_currency.get(i),\n<line_number-399>                        rsMetaData.isCurrency(i + 1),\n<line_number-400>                        \"Invalid isCurrency result for column \" + (i + 1));\n<line_number-401>            }\n<line_number-402>        }\n<line_number-403>        if (test.expected_is_definitely_writable != null) {\n<line_number-404>            assertEquals(\n<line_number-405>                    test.expected_is_definitely_writable.size(),\n<line_number-406>                    columnCount,\n<line_number-407>                    \"Either the yml test specification is missing entries for 'expected_is_definitely_writable'\"\n<line_number-408>                            + \" or the data in the DB is not matching the test\");\n<line_number-409>            for (int i = 0; i < columnCount; i++) {\n<line_number-410>                assertEquals(\n<line_number-411>                        test.expected_is_definitely_writable.get(i),\n<line_number-412>                        rsMetaData.isDefinitelyWritable(i + 1),\n<line_number-413>                        \"Invalid isDefinitelyWritable result for column \" + (i + 1));\n<line_number-414>            }\n<line_number-415>        }\n<line_number-416>        if (test.expected_is_nullable != null) {\n<line_number-417>            assertEquals(\n<line_number-418>                    test.expected_is_nullable.size(),\n<line_number-419>                    columnCount,\n<line_number-420>                    \"Either the yml test specification is missing entries for 'expected_is_nullable' or the\"\n<line_number-421>                            + \" data in the DB is not matching the test\");\n<line_number-422>            for (int i = 0; i < columnCount; i++) {\n<line_number-423>                int expectedNullable =\n<line_number-424>                        TestTypeInfo.nullableStringToInt(test.expected_is_nullable.get(i));\n<line_number-425>                assertEquals(\n<line_number-426>                        expectedNullable,\n<line_number-427>                        rsMetaData.isNullable(i + 1),\n<line_number-428>                        \"Invalid isNullable result for column \" + (i + 1));\n<line_number-429>            }\n<line_number-430>        }\n<line_number-431>        if (test.expected_is_read_only != null) {\n<line_number-432>            assertEquals(\n<line_number-433>                    test.expected_is_read_only.size(),\n<line_number-434>                    columnCount,\n<line_number-435>                    \"Either the yml test specification is missing entries for 'expected_is_read_only' or the\"\n<line_number-436>                            + \" data in the DB is not matching the test\");\n<line_number-437>            for (int i = 0; i < columnCount; i++) {\n<line_number-438>                assertEquals(\n<line_number-439>                        test.expected_is_read_only.get(i),\n<line_number-440>                        rsMetaData.isReadOnly(i + 1),\n<line_number-441>                        \"Invalid isReadOnly result for column \" + (i + 1));\n<line_number-442>            }\n<line_number-443>        }\n<line_number-444>        if (test.expected_is_searchable != null) {\n<line_number-445>            assertEquals(\n<line_number-446>                    test.expected_is_searchable.size(),\n<line_number-447>                    columnCount,\n<line_number-448>                    \"Either the yml test specification is missing entries for 'expected_is_searchable' or the\"\n<line_number-449>                            + \" data in the DB is not matching the test\");\n<line_number-450>            for (int i = 0; i < columnCount; i++) {\n<line_number-451>                assertEquals(\n<line_number-452>                        test.expected_is_searchable.get(i),\n<line_number-453>                        rsMetaData.isSearchable(i + 1),\n<line_number-454>                        \"Invalid isSearchable result for column \" + (i + 1));\n<line_number-455>            }\n<line_number-456>        }\n<line_number-457>        if (test.expected_is_signed != null) {\n<line_number-458>            assertEquals(\n<line_number-459>                    test.expected_is_signed.size(),\n<line_number-460>                    columnCount,\n<line_number-461>                    \"Either the yml test specification is missing entries for 'expected_is_signed' or the data\"\n<line_number-462>                            + \" in the DB is not matching the test\");\n<line_number-463>            for (int i = 0; i < columnCount; i++) {\n<line_number-464>                assertEquals(\n<line_number-465>                        test.expected_is_signed.get(i),\n<line_number-466>                        rsMetaData.isSigned(i + 1),\n<line_number-467>                        \"Invalid isSigned result for column \" + (i + 1));\n<line_number-468>            }\n<line_number-469>        }\n<line_number-470>        if (test.expected_is_writable != null) {\n<line_number-471>            assertEquals(\n<line_number-472>                    test.expected_is_writable.size(),\n<line_number-473>                    columnCount,\n<line_number-474>                    \"Either the yml test specification is missing entries for 'expected_is_writable' or the\"\n<line_number-475>                            + \" data in the DB is not matching the test\");\n<line_number-476>            for (int i = 0; i < columnCount; i++) {\n<line_number-477>                assertEquals(\n<line_number-478>                        test.expected_is_writable.get(i),\n<line_number-479>                        rsMetaData.isWritable(i + 1),\n<line_number-480>                        \"Invalid isWritable result for column \" + (i + 1));\n<line_number-481>            }\n<line_number-482>        }\n<line_number-483>        if (test.expected_bson_type != null) {\n<line_number-484>            assertEquals(test.expected_bson_type.size(), columnCount);\n<line_number-485>            for (int i = 0; i < columnCount; i++) {\n<line_number-486>                MongoResultSetMetaData mongoResultSetMetadata = (MongoResultSetMetaData) rsMetaData;\n<line_number-487>                MongoColumnInfo columnInfo = mongoResultSetMetadata.getColumnInfo(i + 1);\n<line_number-488>                assertEquals(\n<line_number-489>                        test.expected_bson_type.get(i),\n<line_number-490>                        columnInfo.getBsonTypeName(),\n<line_number-491>                        \"Bson type mismatch\");\n<line_number-492>            }\n<line_number-493>        }\n<line_number-494>    }\n<line_number-495>\n<line_number-496>    private static List<Object> processExtendedJson(Map<String, Object> entry) {\n<line_number-497>        List<Object> expectedResults = new ArrayList<>();\n<line_number-498>        String entryAsJson = new Document(entry).toJson();\n<line_number-499>        BsonDocument bsonDoc = BsonDocument.parse(entryAsJson);\n<line_number-500>        for (int i = 0; i < entry.size(); i++) {\n<line_number-501>            expectedResults.add(bsonDoc.get(String.valueOf(i)));\n<line_number-502>        }\n<line_number-503>        return expectedResults;\n<line_number-504>    }\n<line_number-505>\n<line_number-506>    @SuppressWarnings(\"unchecked\")\n<line_number-507>    private static void validateResultsOrdered(TestEntry testEntry, ResultSet rs)\n<line_number-508>            throws SQLException {\n<line_number-509>        Integer actualRowCounter = null;\n<line_number-510>        List<Object> expectedResults = null;\n<line_number-511>        if (testEntry.expected_result_extended_json != null || testEntry.expected_result != null) {\n<line_number-512>            actualRowCounter = 0;\n<line_number-513>            while (rs.next()) {\n<line_number-514>                if (testEntry.expected_result_extended_json != null) {\n<line_number-515>                    assertTrue(\n<line_number-516>                            testEntry.expected_result_extended_json.size() > actualRowCounter,\n<line_number-517>                            \"Database returned more rows than the expected amount: \"\n<line_number-518>                                    + testEntry.expected_result_extended_json.size());\n<line_number-519>                    expectedResults =\n<line_number-520>                            processExtendedJson(\n<line_number-521>                                    testEntry.expected_result_extended_json.get(actualRowCounter));\n<line_number-522>                } else {\n<line_number-523>                    assertTrue(\n<line_number-524>                            testEntry.expected_result.size() > actualRowCounter,\n<line_number-525>                            \"Database returned more rows than the expected amount: \"\n<line_number-526>                                    + testEntry.expected_result.size());\n<line_number-527>                    expectedResults =\n<line_number-528>                            (List<Object>) testEntry.expected_result.get(actualRowCounter);\n<line_number-529>                }\n<line_number-530>\n<line_number-531>                String compOutcome =\n<line_number-532>                        compareRow(expectedResults, testEntry.duplicated_columns_names, rs);\n<line_number-533>                if (compOutcome != null) {\n<line_number-534>                    fail(\"Row \" + actualRowCounter + \" does not match. \" + compOutcome);\n<line_number-535>                }\n<line_number-536>                actualRowCounter++;\n<line_number-537>            }\n<line_number-538>        }\n<line_number-539>        if (testEntry.row_count != null) {\n<line_number-540>            validateRowCount(testEntry, actualRowCounter, rs);\n<line_number-541>        }\n<line_number-542>    }\n<line_number-543>\n<line_number-544>    @SuppressWarnings(\"unchecked\")\n<line_number-545>    private static void validateResultsUnordered(TestEntry testEntry, ResultSet rs)\n<line_number-546>            throws SQLException {\n<line_number-547>        Integer actualRowCounter = null;\n<line_number-548>        List<Object> expectedResults = null;\n<line_number-549>        if (testEntry.expected_result_extended_json != null || testEntry.expected_result != null) {\n<line_number-550>            actualRowCounter = 0;\n<line_number-551>            while (rs.next()) {\n<line_number-552>                actualRowCounter++;\n<line_number-553>                boolean found = false;\n<line_number-554>                String compOutcome = null;\n<line_number-555>                if (testEntry.expected_result_extended_json != null) {\n<line_number-556>                    for (Map<String, Object> entry : testEntry.expected_result_extended_json) {\n<line_number-557>                        compOutcome =\n<line_number-558>                                compareRow(\n<line_number-559>                                        processExtendedJson(entry),\n<line_number-560>                                        testEntry.duplicated_columns_names,\n<line_number-561>                                        rs);\n<line_number-562>                        if (compOutcome == null) {\n<line_number-563>                            found = true;\n<line_number-564>                            break;\n<line_number-565>                        }\n<line_number-566>                    }\n<line_number-567>                } else {\n<line_number-568>                    for (Object expectedRow : testEntry.expected_result) {\n<line_number-569>                        compOutcome =\n<line_number-570>                                compareRow(\n<line_number-571>                                        (List<Object>) expectedRow,\n<line_number-572>                                        testEntry.duplicated_columns_names,\n<line_number-573>                                        rs);\n<line_number-574>                        if (compOutcome == null) {\n<line_number-575>                            found = true;\n<line_number-576>                            break;\n<line_number-577>                        }\n<line_number-578>                    }\n<line_number-579>                }\n<line_number-580>                assertTrue(\n<line_number-581>                        found,\n<line_number-582>                        \"Invalid row \" + actualRowCounter + \". No match found.\" + compOutcome);\n<line_number-583>            }\n<line_number-584>        }\n<line_number-585>        if (testEntry.row_count != null) {\n<line_number-586>            validateRowCount(testEntry, actualRowCounter, rs);\n<line_number-587>        }\n<line_number-588>    }\n<line_number-589>\n<line_number-590>    private static void validateRowCount(\n<line_number-591>            TestEntry testEntry, Integer actualRowCounter, ResultSet rs) throws SQLException {\n<line_number-592>        if (actualRowCounter == null) {\n<line_number-593>            actualRowCounter = IntegrationTestUtils.countRows(rs);\n<line_number-594>        }\n<line_number-595>        if (testEntry.row_count_gte != null && testEntry.row_count_gte) {\n<line_number-596>            assertTrue(actualRowCounter >= testEntry.row_count);\n<line_number-597>        } else {\n<line_number-598>            assertEquals(actualRowCounter, testEntry.row_count);\n<line_number-599>        }\n<line_number-600>    }\n<line_number-601>\n<line_number-602>    /**\n<line_number-603>     * Compare 2 rows and returns either null is the rows are identical or a message describing the\n<line_number-604>     * difference.\n<line_number-605>     *\n<line_number-606>     * @param expectedRow The expected row content.\n<line_number-607>     * @param actualRow The actual row content.\n<line_number-608>     * @return either null is the rows are identical or a message describing the difference.\n<line_number-609>     * @throws SQLException If an error occurs.\n<line_number-610>     */\n<line_number-611>    public static String compareRow(\n<line_number-612>            List<Object> expectedRow, List<String> duplicatedColumnNames, ResultSet actualRow)\n<line_number-613>            throws SQLException {\n<line_number-614>        ResultSetMetaData rsMetadata = actualRow.getMetaData();\n<line_number-615>        assertEquals(\n<line_number-616>                expectedRow.size(),\n<line_number-617>                rsMetadata.getColumnCount(),\n<line_number-618>                \"Columns count mismatch.\\nEither the yml test specification is missing columns for \"\n<line_number-619>                        + \"'expected_result' or the data in the DB is not matching the test\");\n<line_number-620>\n<line_number-621>        for (int i = 0; i < expectedRow.size(); i++) {\n<line_number-622>            // Handle expected field being null\n<line_number-623>            if (expectedRow.get(i) == null) {\n<line_number-624>                if (actualRow.getObject(i + 1) == null) {\n<line_number-625>                    continue;\n<line_number-626>                } else {\n<line_number-627>                    return \"Expected null value for column \" + (i + 1) + \" but is not\";\n<line_number-628>                }\n<line_number-629>            }\n<line_number-630>\n<line_number-631>            int columnType = rsMetadata.getColumnType(i + 1);\n<line_number-632>            String columnName = rsMetadata.getColumnName(i + 1);\n<line_number-633>            switch (columnType) {\n<line_number-634>                case Types.BIGINT:\n<line_number-635>                case Types.SMALLINT:\n<line_number-636>                case Types.TINYINT:\n<line_number-637>                case Types.INTEGER:\n<line_number-638>                    Object expectedInt = expectedRow.get(i);\n<line_number-639>                    int actualInt = actualRow.getInt(i + 1);\n<line_number-640>                    int expectedIntVal =\n<line_number-641>                            (expectedInt instanceof BsonInt32)\n<line_number-642>                                    ? ((BsonInt32) expectedInt).intValue()\n<line_number-643>                                    : ((Integer) expectedInt).intValue();\n<line_number-644>                    if (actualInt != expectedIntVal) {\n<line_number-645>                        return \"Expected numeric value \"\n<line_number-646>                                + expectedIntVal\n<line_number-647>                                + \" but it is \"\n<line_number-648>                                + actualInt\n<line_number-649>                                + \" for column \"\n<line_number-650>                                + (i + 1);\n<line_number-651>                    }\n<line_number-652>                    break;\n<line_number-653>                case Types.LONGVARCHAR:\n<line_number-654>                case Types.LONGNVARCHAR:\n<line_number-655>                case Types.NCHAR:\n<line_number-656>                case Types.CHAR:\n<line_number-657>                case Types.NVARCHAR:\n<line_number-658>                case Types.VARCHAR:\n<line_number-659>                    String expected_str = (String) expectedRow.get(i);\n<line_number-660>                    String actual_str = actualRow.getString(i + 1);\n<line_number-661>                    if (!(expected_str).equals(actual_str)) {\n<line_number-662>                        return \"Expected String value \"\n<line_number-663>                                + expected_str\n<line_number-664>                                + \" but it is \"\n<line_number-665>                                + actual_str\n<line_number-666>                                + \" for column \"\n<line_number-667>                                + (i + 1);\n<line_number-668>                    }\n<line_number-669>                    break;\n<line_number-670>                case Types.BOOLEAN:\n<line_number-671>                case Types.BIT:\n<line_number-672>                    boolean expected_bool = (Boolean) expectedRow.get(i);\n<line_number-673>                    boolean actual_bool = actualRow.getBoolean(i + 1);\n<line_number-674>                    if (expected_bool != actual_bool) {\n<line_number-675>                        return \"Expected boolean value \"\n<line_number-676>                                + expected_bool\n<line_number-677>                                + \" but it is \"\n<line_number-678>                                + actual_bool\n<line_number-679>                                + \" for column \"\n<line_number-680>                                + (i + 1);\n<line_number-681>                    }\n<line_number-682>                    break;\n<line_number-683>                case Types.DOUBLE:\n<line_number-684>                    double expected_double = (double) expectedRow.get(i);\n<line_number-685>                    double actual_double = actualRow.getDouble(i + 1);\n<line_number-686>                    if (expected_double != actual_double) {\n<line_number-687>                        return \"Expected double value \"\n<line_number-688>                                + expected_double\n<line_number-689>                                + \" but it is \"\n<line_number-690>                                + actual_double\n<line_number-691>                                + \" for column \"\n<line_number-692>                                + (i + 1);\n<line_number-693>                    }\n<line_number-694>                    break;\n<line_number-695>                case Types.NULL:\n<line_number-696>                    Object expected_null = expectedRow.get(i);\n<line_number-697>                    Object actual_null = actualRow.getObject(i + 1);\n<line_number-698>                    if (expected_null != actual_null) {\n<line_number-699>                        return \"Expected Bson Null value \"\n<line_number-700>                                + expected_null\n<line_number-701>                                + \" but is \"\n<line_number-702>                                + actual_null\n<line_number-703>                                + \" for column \"\n<line_number-704>                                + (i + 1);\n<line_number-705>                    }\n<line_number-706>                    break;\n<line_number-707>                case Types.TIMESTAMP:\n<line_number-708>                    Object expected_date = expectedRow.get(i);\n<line_number-709>                    Date actual_date = actualRow.getDate(i + 1);\n<line_number-710>                    if (!expected_date.equals(actual_date)) {\n<line_number-711>                        return \"Expected date value\"\n<line_number-712>                                + expected_date.toString()\n<line_number-713>                                + \" but is \"\n<line_number-714>                                + actual_date.toString()\n<line_number-715>                                + \" for column \"\n<line_number-716>                                + (i + 1);\n<line_number-717>                    }\n<line_number-718>                    break;\n<line_number-719>                case Types.OTHER:\n<line_number-720>                    Object expected_obj = expectedRow.get(i);\n<line_number-721>                    if (expected_obj instanceof String) {\n<line_number-722>                        String actual_obj = actualRow.getString(i + 1);\n<line_number-723>                        if (!expected_obj.equals(actual_obj)) {\n<line_number-724>                            return \"Expected Bson Other String value \"\n<line_number-725>                                    + expected_obj\n<line_number-726>                                    + \" but is \"\n<line_number-727>                                    + actual_obj\n<line_number-728>                                    + \" for column \"\n<line_number-729>                                    + (i + 1);\n<line_number-730>                        }\n<line_number-731>                    } else if (expected_obj instanceof BsonValue) {\n<line_number-732>                        Object actual_obj = actualRow.getObject(i + 1);\n<line_number-733>                        MongoBsonValue expectedAsExtJsonValue =\n<line_number-734>                                new MongoBsonValue(\n<line_number-735>                                        (BsonValue) expected_obj,\n<line_number-736>                                        false,\n<line_number-737>                                        UuidRepresentation.STANDARD);\n<line_number-738>                        if (!expectedAsExtJsonValue.equals(actual_obj)) {\n<line_number-739>                            return \"Expected Bson Other BsonValue value \"\n<line_number-740>                                    + expected_obj\n<line_number-741>                                    + \" but is \"\n<line_number-742>                                    + actual_obj\n<line_number-743>                                    + \" for column \"\n<line_number-744>                                    + (i + 1);\n<line_number-745>                        }\n<line_number-746>                    } else {\n<line_number-747>                        throw new IllegalArgumentException(\n<line_number-748>                                \"unsupported expected value class: \" + expected_obj.getClass());\n<line_number-749>                    }\n<line_number-750>                    break;\n<line_number-751>                default:\n<line_number-752>                    throw new IllegalArgumentException(\"unsupported column type:\" + columnType);\n<line_number-753>            }\n<line_number-754>\n<line_number-755>            // Verify that getting the value by id or name yield the same result\n<line_number-756>            if (duplicatedColumnNames != null\n<line_number-757>                    && duplicatedColumnNames.size() > 0\n<line_number-758>                    && duplicatedColumnNames.contains(columnName)) {\n<line_number-759>                assertThrows(SQLException.class, () -> actualRow.getString(columnName));\n<line_number-760>            } else {\n<line_number-761>                String valById = actualRow.getString(i + 1);\n<line_number-762>                String valByColName = actualRow.getString(columnName);\n<line_number-763>                if (!valById.equals(valByColName)) {\n<line_number-764>                    return \"Value doesn't match between get by id and get by name. By id \"\n<line_number-765>                            + (i + 1)\n<line_number-766>                            + \" is '\"\n<line_number-767>                            + valById\n<line_number-768>                            + \" ' and by name \"\n<line_number-769>                            + columnName\n<line_number-770>                            + \" is ' \"\n<line_number-771>                            + valByColName\n<line_number-772>                            + \" ' for column \"\n<line_number-773>                            + (i + 1);\n<line_number-774>                }\n<line_number-775>            }\n<line_number-776>        }\n<line_number-777>        return null;\n<line_number-778>    }\n<line_number-779>}\n",
        "comments": [
          {
            "comment_code_range": "60-60",
            "comment_linenumber": "59",
            "comment": "IntegrationTestUtils provides utility methods for running and validating database integration tests, including loading test configurations and comparing results.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "61-67",
            "comment_linenumber": "60",
            "comment": "countRows counts the number of rows in a ResultSet by iterating through it until no more rows are available.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "84-104",
            "comment_linenumber": "83",
            "comment": "loadTestConfigs processes all test YAML files in the specified directory and returns a list of TestEntry objects.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "106-116",
            "comment_linenumber": "105",
            "comment": "processDirectory traverses the subdirectories of the specified folder to gather test configurations.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "118-124",
            "comment_linenumber": "117",
            "comment": "processTestFile reads a test file and loads its content into a Tests object using YAML.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "127-139",
            "comment_linenumber": "126",
            "comment": "runTest executes a test entry against a database connection, optionally generating baseline files.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "171-173",
            "comment_linenumber": "140",
            "comment": "executeQuery executes a SQL query from a TestEntry and returns the resulting ResultSet.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "176-246",
            "comment_linenumber": "175",
            "comment": "executeDBMetadataCommand invokes a method on DatabaseMetaData based on the provided TestEntry and returns the ResultSet.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "256-494",
            "comment_linenumber": "255",
            "comment": "validateResultSetMetadata checks the metadata of a ResultSet against expected values defined in a TestEntry.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "496-503",
            "comment_linenumber": "495",
            "comment": "processExtendedJson converts a Map entry into a list of expected results in BSON format.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "506-588",
            "comment_linenumber": "505",
            "comment": "validateResultsOrdered validates that the results from a ResultSet match expected results in order.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "544-588",
            "comment_linenumber": "543",
            "comment": "validateResultsUnordered validates that the results from a ResultSet match expected results without considering order.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "590-600",
            "comment_linenumber": "589",
            "comment": "validateRowCount checks that the actual row count from a ResultSet matches the expected count defined in a TestEntry.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "602-778",
            "comment_linenumber": "601",
            "comment": "compareRow compares two rows of data and returns a message if they differ, or null if they are identical.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file named IntegrationTestUtils.java serves as a utility class for integration testing within the MongoDB JDBC framework. It employs a procedural design pattern to facilitate the execution and validation of database tests. The primary class, IntegrationTestUtils, contains static methods that handle various aspects of test execution, including loading configurations from YAML files, executing SQL queries, and validating results against expected outcomes. \n\nThe class has several key methods:\n- countRows(ResultSet rs): Counts the number of rows in a ResultSet.\n- loadTestConfigs(String directory): Loads test configurations from YAML files in the specified directory.\n- processDirectory(File folder, List<Tests> tests): Recursively processes directories to gather test files.\n- processTestFile(String filename): Loads a single test file into a Tests object.\n- runTest(TestEntry testEntry, Connection conn, Boolean generate): Executes a test entry against a database connection.\n- executeQuery(TestEntry entry, Connection conn): Executes a SQL query and returns the ResultSet.\n- executeDBMetadataCommand(TestEntry entry, DatabaseMetaData databaseMetaData): Invokes a method on DatabaseMetaData and returns the ResultSet.\n- validateResultSetMetadata(TestEntry test, ResultSetMetaData rsMetaData): Validates the metadata of a ResultSet against expected values.\n- validateResultsOrdered(TestEntry testEntry, ResultSet rs): Validates ordered results from a ResultSet.\n- validateResultsUnordered(TestEntry testEntry, ResultSet rs): Validates unordered results from a ResultSet.\n- validateRowCount(TestEntry testEntry, Integer actualRowCounter, ResultSet rs): Validates the row count of a ResultSet.\n- compareRow(List<Object> expectedRow, List<String> duplicatedColumnNames, ResultSet actualRow): Compares two rows of data and returns a message if they differ.\n\nThe class relies on external libraries such as JUnit for assertions and BSON for handling MongoDB data types. It also utilizes reflection to dynamically invoke methods on DatabaseMetaData, allowing for flexible testing of various database functionalities. The methods are designed to handle exceptions gracefully, providing error messages for easier debugging. Overall, IntegrationTestUtils encapsulates the logic necessary for robust database integration testing, ensuring that the results align with expected outcomes defined in YAML configurations.",
        "file_summary": "IntegrationTestUtils.java provides utility methods for executing and validating database integration tests within the MongoDB JDBC framework. It facilitates loading test configurations from YAML files, executing SQL queries, and comparing results against expected values, ensuring the integrity of database interactions."
      }
    ]
  },
  "TestGenerator.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\TestGenerator.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\TestGenerator.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\TestGenerator.java",
        "chunk_id": "TestGenerator_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration.testharness;\n<line_number-18>\n<line_number-19>import com.mongodb.jdbc.MongoResultSetMetaData;\n<line_number-20>import com.mongodb.jdbc.integration.ADFIntegrationTest;\n<line_number-21>import com.mongodb.jdbc.integration.testharness.models.TestEntry;\n<line_number-22>import java.io.File;\n<line_number-23>import java.io.FileWriter;\n<line_number-24>import java.io.IOException;\n<line_number-25>import java.lang.reflect.InvocationTargetException;\n<line_number-26>import java.sql.Connection;\n<line_number-27>import java.sql.ResultSet;\n<line_number-28>import java.sql.ResultSetMetaData;\n<line_number-29>import java.sql.SQLException;\n<line_number-30>import java.text.SimpleDateFormat;\n<line_number-31>import java.util.ArrayList;\n<line_number-32>import java.util.Date;\n<line_number-33>import java.util.LinkedHashMap;\n<line_number-34>import java.util.List;\n<line_number-35>import java.util.Map;\n<line_number-36>import org.yaml.snakeyaml.DumperOptions;\n<line_number-37>import org.yaml.snakeyaml.Yaml;\n<line_number-38>\n<line_number-39>public class TestGenerator {\n<line_number-40>    private static final String GENERATED_TEST_DIR = \"resources/generated_test\";\n<line_number-41>\n<line_number-42>    public static void generateBaselineTestFiles(TestEntry testEntry, ResultSet rs)\n<line_number-43>            throws IOException, SQLException, IllegalAccessException {\n<line_number-44>\n<line_number-45>        String description = testEntry.description.replace(' ', '_');\n<line_number-46>        List<String> expectedSqlType = new ArrayList<>();\n<line_number-47>        List<String> expectedBsonType = new ArrayList();\n<line_number-48>        List<String> expectedCatalogName = new ArrayList<>();\n<line_number-49>        List<String> expectedColumnClassName = new ArrayList<>();\n<line_number-50>        List<String> expectedColumnLabel = new ArrayList<>();\n<line_number-51>        List<String> expectedIsNullable = new ArrayList<>();\n<line_number-52>        List<String> expectedSchemaName = new ArrayList<>();\n<line_number-53>        List<Integer> expectedColumnDisplaySize = new ArrayList<>();\n<line_number-54>        List<Integer> expectedPrecision = new ArrayList<>();\n<line_number-55>        List<Integer> expectedScale = new ArrayList<>();\n<line_number-56>        List<Boolean> expectedIsAutoIncrement = new ArrayList<>();\n<line_number-57>        List<Boolean> expectedIsCaseSensitive = new ArrayList<>();\n<line_number-58>        List<Boolean> expectedIsCurrency = new ArrayList<>();\n<line_number-59>        List<Boolean> expectedIsDefinitelyWritable = new ArrayList<>();\n<line_number-60>        List<Boolean> expectedIsReadOnly = new ArrayList<>();\n<line_number-61>        List<Boolean> expectedIsSearchable = new ArrayList<>();\n<line_number-62>        List<Boolean> expectedIsSigned = new ArrayList<>();\n<line_number-63>        List<Boolean> expectedIsWritable = new ArrayList<>();\n<line_number-64>\n<line_number-65>        File directory = new File(GENERATED_TEST_DIR);\n<line_number-66>        ResultSetMetaData resultSetMetadata = rs.getMetaData();\n<line_number-67>        MongoResultSetMetaData mongoResultSetMetaData = (MongoResultSetMetaData) resultSetMetadata;\n<line_number-68>        Map<String, Object> tests = new LinkedHashMap<String, Object>();\n<line_number-69>        List<Map<String, Object>> testCases = new ArrayList<>();\n<line_number-70>        Map<String, Object> testCase = new LinkedHashMap<String, Object>();\n<line_number-71>        testCases.add(testCase);\n<line_number-72>        tests.put(\"tests\", testCases);\n<line_number-73>\n<line_number-74>        if (!directory.exists()) {\n<line_number-75>            directory.mkdir();\n<line_number-76>        }\n<line_number-77>\n<line_number-78>        String fileName =\n<line_number-79>                new SimpleDateFormat(\"'\" + description + \"'MMddHHmmss'.yaml'\").format(new Date());\n<line_number-80>        ArrayList<List<Object>> result = new ArrayList<>();\n<line_number-81>        while (rs.next()) {\n<line_number-82>            List<Object> row = new ArrayList<>();\n<line_number-83>            for (int i = 1; i <= resultSetMetadata.getColumnCount(); i++) {\n<line_number-84>                row.add(rs.getObject(i));\n<line_number-85>            }\n<line_number-86>            result.add(row);\n<line_number-87>        }\n<line_number-88>\n<line_number-89>        // generating expected resultset metadata\n<line_number-90>        for (int i = 1; i <= resultSetMetadata.getColumnCount(); i++) {\n<line_number-91>            expectedSqlType.add(TestTypeInfo.typesIntToString(resultSetMetadata.getColumnType(i)));\n<line_number-92>            expectedCatalogName.add(resultSetMetadata.getCatalogName(i));\n<line_number-93>            expectedColumnClassName.add(resultSetMetadata.getColumnClassName(i));\n<line_number-94>            expectedColumnLabel.add(resultSetMetadata.getColumnLabel(i));\n<line_number-95>            expectedColumnDisplaySize.add(resultSetMetadata.getColumnDisplaySize(i));\n<line_number-96>            expectedPrecision.add(resultSetMetadata.getPrecision(i));\n<line_number-97>            expectedScale.add(resultSetMetadata.getScale(i));\n<line_number-98>            expectedSchemaName.add(resultSetMetadata.getSchemaName(i));\n<line_number-99>            expectedIsAutoIncrement.add(resultSetMetadata.isAutoIncrement(i));\n<line_number-100>            expectedIsCaseSensitive.add(resultSetMetadata.isCaseSensitive(i));\n<line_number-101>            expectedIsCurrency.add(resultSetMetadata.isCurrency(i));\n<line_number-102>            expectedIsDefinitelyWritable.add(resultSetMetadata.isDefinitelyWritable(i));\n<line_number-103>            expectedIsNullable.add(\n<line_number-104>                    TestTypeInfo.nullableIntToString(resultSetMetadata.isNullable(i)));\n<line_number-105>            expectedIsReadOnly.add(resultSetMetadata.isReadOnly(i));\n<line_number-106>            expectedIsSearchable.add(resultSetMetadata.isSearchable(i));\n<line_number-107>            expectedIsSigned.add(resultSetMetadata.isSigned(i));\n<line_number-108>            expectedIsWritable.add(resultSetMetadata.isWritable(i));\n<line_number-109>            expectedBsonType.add(mongoResultSetMetaData.getColumnInfo(i).getBsonTypeName());\n<line_number-110>        }\n<line_number-111>\n<line_number-112>        testCase.put(\"description\", description);\n<line_number-113>        testCase.put(\"db\", testEntry.db);\n<line_number-114>        if (testEntry.meta_function != null) {\n<line_number-115>            testCase.put(\"meta_function\", testEntry.meta_function);\n<line_number-116>        } else {\n<line_number-117>            testCase.put(\"sql\", testEntry.sql);\n<line_number-118>        }\n<line_number-119>        testCase.put(\"expected_result\", result);\n<line_number-120>        testCase.put(\"row_count\", result.size());\n<line_number-121>        testCase.put(\"row_count_gte\", testEntry.row_count_gte);\n<line_number-122>        testCase.put(\"ordered\", testEntry.ordered);\n<line_number-123>\n<line_number-124>        testCase.put(\"expected_sql_type\", expectedSqlType);\n<line_number-125>        testCase.put(\"expected_bson_type\", expectedBsonType);\n<line_number-126>        testCase.put(\"expected_catalog_name\", expectedCatalogName);\n<line_number-127>        testCase.put(\"expected_column_class_name\", expectedColumnClassName);\n<line_number-128>        testCase.put(\"expected_column_label\", expectedColumnLabel);\n<line_number-129>        testCase.put(\"expected_column_display_size\", expectedColumnDisplaySize);\n<line_number-130>        testCase.put(\"expected_precision\", expectedPrecision);\n<line_number-131>        testCase.put(\"expected_scale\", expectedScale);\n<line_number-132>        testCase.put(\"expected_schema_name\", expectedSchemaName);\n<line_number-133>        testCase.put(\"expected_is_auto_increment\", expectedIsAutoIncrement);\n<line_number-134>        testCase.put(\"expected_is_case_sensitive\", expectedIsCaseSensitive);\n<line_number-135>        testCase.put(\"expected_is_currency\", expectedIsCurrency);\n<line_number-136>        testCase.put(\"expected_is_definitely_writable\", expectedIsDefinitelyWritable);\n<line_number-137>        testCase.put(\"expected_is_nullable\", expectedIsNullable);\n<line_number-138>        testCase.put(\"expected_is_read_only\", expectedIsReadOnly);\n<line_number-139>        testCase.put(\"expected_is_searchable\", expectedIsSearchable);\n<line_number-140>        testCase.put(\"expected_is_signed\", expectedIsSigned);\n<line_number-141>        testCase.put(\"expected_is_writable\", expectedIsWritable);\n<line_number-142>\n<line_number-143>        DumperOptions options = new DumperOptions();\n<line_number-144>        options.setIndent(2);\n<line_number-145>        options.setIndicatorIndent(2);\n<line_number-146>        options.setIndentWithIndicator(true);\n<line_number-147>        Yaml yaml = new Yaml(options);\n<line_number-148>        FileWriter writer = new FileWriter(GENERATED_TEST_DIR + \"/\" + fileName);\n<line_number-149>        yaml.dump(tests, writer);\n<line_number-150>    }\n<line_number-151>\n<line_number-152>    public static void main(String[] args)\n<line_number-153>            throws SQLException, IOException, InvocationTargetException, IllegalAccessException {\n<line_number-154>        ADFIntegrationTest integrationTest = new ADFIntegrationTest();\n<line_number-155>        List<TestEntry> tests =\n<line_number-156>                IntegrationTestUtils.loadTestConfigs(ADFIntegrationTest.TEST_DIRECTORY);\n<line_number-157>        for (TestEntry testEntry : tests) {\n<line_number-158>            try (Connection conn = integrationTest.getBasicConnection(testEntry.db, null)) {\n<line_number-159>                if (testEntry.skip_reason != null) {\n<line_number-160>                    continue;\n<line_number-161>                }\n<line_number-162>                IntegrationTestUtils.runTest(testEntry, conn, true);\n<line_number-163>            }\n<line_number-164>        }\n<line_number-165>    }\n<line_number-166>}\n",
        "comments": [
          {
            "comment_code_range": "39-150",
            "comment_linenumber": "38",
            "comment": "This class generates baseline test files for MongoDB integration tests based on provided test entries and result sets. It handles the creation of YAML files that describe expected results and metadata.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "42-150",
            "comment_linenumber": "41",
            "comment": "Generates baseline test files from a TestEntry and a ResultSet, capturing expected metadata and results in a structured YAML format.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "81-87",
            "comment_linenumber": "80",
            "comment": "Iterates through the ResultSet to collect all rows of data into a list for expected results.",
            "comment_kind": "loop"
          },
          {
            "comment_code_range": "89-109",
            "comment_linenumber": "88",
            "comment": "Populates expected metadata lists by iterating through the ResultSetMetaData to gather information about each column.",
            "comment_kind": "loop"
          },
          {
            "comment_code_range": "152-165",
            "comment_linenumber": "151",
            "comment": "Main method that initializes the integration test framework, loads test configurations, and executes tests for each TestEntry.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "158-164",
            "comment_linenumber": "157",
            "comment": "Establishes a database connection for each test entry and runs the corresponding test, skipping any tests marked with a reason.",
            "comment_kind": "loop"
          }
        ],
        "structural_analysis": "The file 'TestGenerator.java' is part of the MongoDB JDBC integration testing framework. It primarily serves to generate YAML files that represent baseline test cases based on the results of SQL queries executed against a MongoDB database. The class 'TestGenerator' contains a static method 'generateBaselineTestFiles' which takes a 'TestEntry' object and a 'ResultSet' as parameters. This method is responsible for creating a structured YAML file that includes expected results and metadata for each test case. The method collects various metadata attributes from the ResultSetMetaData and MongoResultSetMetaData, such as SQL types, BSON types, and column labels, and organizes them into lists. The main method of the class initializes the integration test framework, loads test configurations, and iterates through each test entry to execute the tests. It handles database connections and skips tests that have a specified reason for being skipped. The class relies on external libraries such as SnakeYAML for YAML file generation and includes exception handling for IO and SQL operations.",
        "file_summary": "The 'TestGenerator.java' file is responsible for generating baseline test files in YAML format for MongoDB integration tests. It captures expected results and metadata from SQL queries, facilitating automated testing and validation of database interactions."
      }
    ]
  },
  "TestTypeInfo.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\TestTypeInfo.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\TestTypeInfo.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\TestTypeInfo.java",
        "chunk_id": "TestTypeInfo_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration.testharness;\n<line_number-18>\n<line_number-19>import java.lang.reflect.Field;\n<line_number-20>import java.sql.DatabaseMetaData;\n<line_number-21>import java.sql.Types;\n<line_number-22>\n<line_number-23>public class TestTypeInfo {\n<line_number-24>    private static final String COLUMN_NO_NULLS = \"columnNoNulls\";\n<line_number-25>    private static final String COLUMN_NULLABLE = \"columnNullable\";\n<line_number-26>    private static final String COLUMN_NULLABLE_UNKNOWN = \"columnNullableUnknown\";\n<line_number-27>\n<line_number-28>    public static int typesStringToInt(String type) throws IllegalAccessException {\n<line_number-29>        for (Field field : Types.class.getFields()) {\n<line_number-30>            if (field.getName().equalsIgnoreCase(type)) {\n<line_number-31>                return (field.getInt(new Object()));\n<line_number-32>            }\n<line_number-33>        }\n<line_number-34>        throw new IllegalArgumentException(\"unknown type: \" + type);\n<line_number-35>    }\n<line_number-36>\n<line_number-37>    public static String typesIntToString(int type) throws IllegalAccessException {\n<line_number-38>        for (Field field : Types.class.getFields()) {\n<line_number-39>            if (type == field.getInt(new Object())) {\n<line_number-40>                return (field.getName());\n<line_number-41>            }\n<line_number-42>        }\n<line_number-43>        throw new IllegalArgumentException(\"unknown type: \" + type);\n<line_number-44>    }\n<line_number-45>\n<line_number-46>    public static int nullableStringToInt(String type) {\n<line_number-47>        if (type.toUpperCase().equals(COLUMN_NO_NULLS.toUpperCase())) {\n<line_number-48>            return DatabaseMetaData.columnNoNulls;\n<line_number-49>        } else if (type.toUpperCase().equals(COLUMN_NULLABLE.toUpperCase())) {\n<line_number-50>            return DatabaseMetaData.columnNullable;\n<line_number-51>        } else if (type.toUpperCase().equals(COLUMN_NULLABLE_UNKNOWN.toUpperCase())) {\n<line_number-52>            return DatabaseMetaData.columnNullableUnknown;\n<line_number-53>        }\n<line_number-54>        throw new IllegalArgumentException(\"unknown nullable type: \" + type);\n<line_number-55>    }\n<line_number-56>\n<line_number-57>    public static String nullableIntToString(int type) {\n<line_number-58>        switch (type) {\n<line_number-59>            case DatabaseMetaData.columnNoNulls:\n<line_number-60>                return COLUMN_NO_NULLS;\n<line_number-61>            case DatabaseMetaData.columnNullable:\n<line_number-62>                return COLUMN_NULLABLE;\n<line_number-63>            case DatabaseMetaData.columnNullableUnknown:\n<line_number-64>                return COLUMN_NULLABLE_UNKNOWN;\n<line_number-65>        }\n<line_number-66>        throw new IllegalArgumentException(\"unknown nullable type: \" + type);\n<line_number-67>    }\n<line_number-68>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for the TestTypeInfo class, which contains methods for converting SQL type information.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "23-68",
            "comment_linenumber": "22",
            "comment": "The TestTypeInfo class provides static methods to convert between SQL type names and their corresponding integer values, as well as nullable type representations.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "28-35",
            "comment_linenumber": "27",
            "comment": "Converts a SQL type name string to its corresponding integer value using reflection on the Types class; throws IllegalArgumentException for unknown types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "37-44",
            "comment_linenumber": "36",
            "comment": "Converts a SQL type integer value to its corresponding name string using reflection on the Types class; throws IllegalArgumentException for unknown types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "46-54",
            "comment_linenumber": "45",
            "comment": "Converts a nullable type name string to its corresponding integer value based on predefined constants; throws IllegalArgumentException for unknown types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "57-66",
            "comment_linenumber": "56",
            "comment": "Converts a nullable type integer value to its corresponding name string based on predefined constants; throws IllegalArgumentException for unknown types.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file named TestTypeInfo.java is part of the com.mongodb.jdbc.integration.testharness package and serves the primary role of providing utility methods for converting SQL type information between string and integer representations. It employs reflection to access fields in the java.sql.Types class, allowing for dynamic retrieval of SQL type constants. The class is designed to be stateless and thread-safe, as all methods are static and do not maintain any internal state. \n\nThe TestTypeInfo class contains several static methods: \n1. typesStringToInt(String type): Converts a SQL type name to its corresponding integer value. It iterates through the fields of the Types class and matches the name, throwing an IllegalArgumentException if the type is unknown. \n2. typesIntToString(int type): Converts an integer SQL type back to its string representation, using a similar reflection-based approach. \n3. nullableStringToInt(String type): Converts nullable type names to their corresponding integer values based on constants defined in DatabaseMetaData. It also throws an IllegalArgumentException for unknown types. \n4. nullableIntToString(int type): Converts integer representations of nullable types back to their string names, throwing an exception for unknown values. \n\nThe class does not have any constructors or fields that maintain state, making it suitable for use in a variety of contexts where SQL type information is needed. It relies on the java.sql package for type definitions and constants, ensuring compatibility with standard SQL operations.",
        "file_summary": "The TestTypeInfo.java file provides utility methods for converting between SQL type names and their corresponding integer values, as well as handling nullable type representations. It is designed to facilitate integration testing with SQL databases by providing a clear mapping between string and integer representations of SQL types."
      }
    ]
  },
  "TestData.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\TestData.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\TestData.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\TestData.java",
        "chunk_id": "TestData_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration.testharness.models;\n<line_number-18>\n<line_number-19>import java.util.List;\n<line_number-20>\n<line_number-21>public class TestData {\n<line_number-22>    public List<TestDataEntry> dataset;\n<line_number-23>}\n",
        "comments": [
          {
            "comment_code_range": "21-23",
            "comment_linenumber": "20",
            "comment": "Represents a collection of test data entries used for integration testing.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "22-22",
            "comment_linenumber": "21",
            "comment": "Holds a list of TestDataEntry objects representing individual entries in the dataset.",
            "comment_kind": "field"
          }
        ],
        "structural_analysis": "The file 'TestData.java' is part of the 'com.mongodb.jdbc.integration.testharness.models' package and serves as a model for integration testing data. It defines a single public class, 'TestData', which encapsulates a list of 'TestDataEntry' objects. This class is designed to hold test data that can be utilized in various integration tests, facilitating the testing of database interactions. The class does not implement any specific design patterns but serves a straightforward data-holding purpose. The 'dataset' field is public, allowing direct access to the list of test entries, which may be populated and manipulated during testing scenarios. There are no constructors defined, implying that the default constructor is used, and no additional initialization logic is present. The file does not contain any methods or complex logic, focusing solely on data representation.",
        "file_summary": "The 'TestData.java' file defines a model class for holding a collection of test data entries, which are utilized in integration testing scenarios for MongoDB JDBC interactions."
      }
    ]
  },
  "TestDataEntry.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\TestDataEntry.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\TestDataEntry.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\TestDataEntry.java",
        "chunk_id": "TestDataEntry_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration.testharness.models;\n<line_number-18>\n<line_number-19>import java.util.List;\n<line_number-20>import java.util.Map;\n<line_number-21>\n<line_number-22>public class TestDataEntry {\n<line_number-23>    public String db;\n<line_number-24>    public String collection;\n<line_number-25>    public String view;\n<line_number-26>    public List<Map<String, Object>> docs;\n<line_number-27>    public List<Map<String, Object>> docsExtJson;\n<line_number-28>    public Map<String, Object> schema;\n<line_number-29>    public List<Map<String, Object>> nonuniqueIndexes;\n<line_number-30>}\n",
        "comments": [
          {
            "comment_code_range": "22-30",
            "comment_linenumber": "21",
            "comment": "Represents a data entry for testing, encapsulating database, collection, view, documents, schema, and indexes.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "23-23",
            "comment_linenumber": "22",
            "comment": "The name of the database associated with this test data entry.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "24-24",
            "comment_linenumber": "23",
            "comment": "The name of the collection associated with this test data entry.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "25-25",
            "comment_linenumber": "24",
            "comment": "The name of the view associated with this test data entry.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "26-26",
            "comment_linenumber": "25",
            "comment": "A list of documents represented as maps, containing the main data for this entry.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "27-27",
            "comment_linenumber": "26",
            "comment": "A list of documents in extended JSON format for this entry.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "28-28",
            "comment_linenumber": "27",
            "comment": "A map representing the schema of the documents in this entry.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "29-29",
            "comment_linenumber": "28",
            "comment": "A list of non-unique indexes associated with this test data entry.",
            "comment_kind": "field"
          }
        ],
        "structural_analysis": "The file 'TestDataEntry.java' defines a single public class named 'TestDataEntry' within the package 'com.mongodb.jdbc.integration.testharness.models'. This class serves as a data model for test entries, encapsulating various attributes related to MongoDB collections. It includes fields for the database name, collection name, view name, a list of documents, extended JSON documents, schema information, and non-unique indexes. The class does not contain any methods or constructors, indicating that it is likely used as a simple data holder. All fields are public, allowing direct access, which may suggest a focus on simplicity and ease of use in testing scenarios. The design does not enforce encapsulation, which is typical in data transfer objects (DTOs) or similar structures used in testing frameworks.",
        "file_summary": "This file defines the 'TestDataEntry' class, which is used to represent a test data entry for MongoDB integration tests. It encapsulates essential attributes such as database, collection, view, documents, schema, and indexes, facilitating the management of test data."
      }
    ]
  },
  "TestEntry.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\TestEntry.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\TestEntry.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\TestEntry.java",
        "chunk_id": "TestEntry_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration.testharness.models;\n<line_number-18>\n<line_number-19>import java.util.List;\n<line_number-20>import java.util.Map;\n<line_number-21>\n<line_number-22>public class TestEntry {\n<line_number-23>    public String description;\n<line_number-24>    public String db;\n<line_number-25>    public String sql;\n<line_number-26>    public List<Object> meta_function;\n<line_number-27>    public String skip_reason;\n<line_number-28>    public Integer row_count;\n<line_number-29>    public Boolean row_count_gte;\n<line_number-30>    public Boolean ordered;\n<line_number-31>    public List<String> duplicated_columns_names;\n<line_number-32>    public List<Object> expected_result;\n<line_number-33>    public List<Map<String, Object>> expected_result_extended_json;\n<line_number-34>    public List<String> expected_sql_type;\n<line_number-35>    public List<String> expected_bson_type;\n<line_number-36>    public List<String> expected_catalog_name;\n<line_number-37>    public List<String> expected_column_class_name;\n<line_number-38>    public List<String> expected_column_label;\n<line_number-39>    public List<Integer> expected_column_display_size;\n<line_number-40>    public List<Integer> expected_precision;\n<line_number-41>    public List<Integer> expected_scale;\n<line_number-42>    public List<String> expected_schema_name;\n<line_number-43>    public List<Boolean> expected_is_auto_increment;\n<line_number-44>    public List<Boolean> expected_is_case_sensitive;\n<line_number-45>    public List<Boolean> expected_is_currency;\n<line_number-46>    public List<Boolean> expected_is_definitely_writable;\n<line_number-47>    public List<String> expected_is_nullable;\n<line_number-48>    public List<Boolean> expected_is_read_only;\n<line_number-49>    public List<Boolean> expected_is_searchable;\n<line_number-50>    public List<Boolean> expected_is_signed;\n<line_number-51>    public List<Boolean> expected_is_writable;\n<line_number-52>}\n",
        "comments": [
          {
            "comment_code_range": "22-52",
            "comment_linenumber": "21",
            "comment": "Represents a test entry for database integration tests, encapsulating various attributes related to the test case.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "23-23",
            "comment_linenumber": "22",
            "comment": "A description of the test case.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "24-24",
            "comment_linenumber": "23",
            "comment": "The database name to be used in the test.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "25-25",
            "comment_linenumber": "24",
            "comment": "The SQL query to be executed during the test.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "26-26",
            "comment_linenumber": "25",
            "comment": "A list of meta functions associated with the test.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "27-27",
            "comment_linenumber": "26",
            "comment": "Reason for skipping the test, if applicable.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "28-28",
            "comment_linenumber": "27",
            "comment": "Expected number of rows returned by the SQL query.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "29-29",
            "comment_linenumber": "28",
            "comment": "Indicates if the row count should be greater than or equal to the expected value.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "30-30",
            "comment_linenumber": "29",
            "comment": "Indicates if the test should be executed in an ordered manner.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "31-31",
            "comment_linenumber": "30",
            "comment": "Names of columns that are expected to have duplicate values.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "32-32",
            "comment_linenumber": "31",
            "comment": "Expected results of the SQL query.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "33-33",
            "comment_linenumber": "32",
            "comment": "Expected results in extended JSON format.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "34-34",
            "comment_linenumber": "33",
            "comment": "Expected SQL types for the columns.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "35-35",
            "comment_linenumber": "34",
            "comment": "Expected BSON types for the columns.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "36-36",
            "comment_linenumber": "35",
            "comment": "Expected catalog names for the columns.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "37-37",
            "comment_linenumber": "36",
            "comment": "Expected class names for the columns.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "38-38",
            "comment_linenumber": "37",
            "comment": "Expected labels for the columns.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "39-39",
            "comment_linenumber": "38",
            "comment": "Expected display sizes for the columns.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "40-40",
            "comment_linenumber": "39",
            "comment": "Expected precision for the columns.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "41-41",
            "comment_linenumber": "40",
            "comment": "Expected scale for the columns.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "42-42",
            "comment_linenumber": "41",
            "comment": "Expected schema names for the columns.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "43-43",
            "comment_linenumber": "42",
            "comment": "Indicates if the column is expected to be auto-incremented.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "44-44",
            "comment_linenumber": "43",
            "comment": "Indicates if the column is expected to be case-sensitive.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "45-45",
            "comment_linenumber": "44",
            "comment": "Indicates if the column is expected to represent currency.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "46-46",
            "comment_linenumber": "45",
            "comment": "Indicates if the column is expected to be definitely writable.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "47-47",
            "comment_linenumber": "46",
            "comment": "Expected nullability of the column.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "48-48",
            "comment_linenumber": "47",
            "comment": "Indicates if the column is expected to be read-only.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "49-49",
            "comment_linenumber": "48",
            "comment": "Indicates if the column is expected to be searchable.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "50-50",
            "comment_linenumber": "49",
            "comment": "Indicates if the column is expected to be signed.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "51-51",
            "comment_linenumber": "50",
            "comment": "Indicates if the column is expected to be writable.",
            "comment_kind": "other"
          }
        ],
        "structural_analysis": "The file named 'TestEntry.java' serves as a model for integration tests within the MongoDB JDBC framework. It defines a single public class, TestEntry, which encapsulates various attributes that describe a test case for database operations. The class contains multiple public fields, each representing different aspects of a test entry, such as the SQL query to be executed, expected results, and metadata about the test. The fields are primarily of type String, List, or Boolean, allowing for flexible representation of test data. There are no methods defined in this class, indicating that it is purely a data structure intended for holding test case information. The class does not implement any interfaces or extend any other classes, making it a standalone entity. The design is straightforward, focusing on data encapsulation without additional behavior or logic. This structure allows for easy instantiation and manipulation of test entries in the context of integration testing.",
        "file_summary": "The TestEntry class is designed to represent a single test case for database integration tests, encapsulating various attributes such as SQL queries, expected results, and metadata. It serves as a data model to facilitate the organization and execution of integration tests within the MongoDB JDBC framework."
      }
    ]
  },
  "Tests.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\Tests.java",
    "chunks": [
      {
        "file_path": "src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\Tests.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\integration-test\\java\\com\\mongodb\\jdbc\\integration\\testharness\\models\\Tests.java",
        "chunk_id": "Tests_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.integration.testharness.models;\n<line_number-18>\n<line_number-19>import java.util.List;\n<line_number-20>\n<line_number-21>public class Tests {\n<line_number-22>    public List<TestEntry> tests;\n<line_number-23>}\n",
        "comments": [
          {
            "comment_code_range": "21-23",
            "comment_linenumber": "20",
            "comment": "Represents a collection of test entries for integration testing.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "22-22",
            "comment_linenumber": "21",
            "comment": "A list of test entries that will be executed during the testing process.",
            "comment_kind": "field"
          }
        ],
        "structural_analysis": "File overview: The file 'Tests.java' is part of the 'com.mongodb.jdbc.integration.testharness.models' package and serves as a model for integration testing within the MongoDB JDBC framework. It follows a simple data structure pattern to hold test entries. \n\nTop-level types: \n- Signature: Tests, class. \n  Role: This class encapsulates a collection of test entries that are used in integration tests. \n  Lifecycle notes: Instances of this class are mutable and can be modified to add or remove test entries. \n\nMembers: \n- Field: tests, type List<TestEntry>, visibility public, purpose: Holds a list of test entries to be executed. \n\nRelationships: The class does not have any external dependencies or relationships defined in this snippet. \n\nExternal touchpoints: None identified in this file. \n\nObservations & caveats: The class is straightforward and does not contain complex logic or methods. It is primarily a data holder for test entries.",
        "file_summary": "The 'Tests.java' file defines a class that serves as a container for a list of test entries used in integration testing for the MongoDB JDBC framework."
      }
    ]
  },
  "BsonExplicitCursor.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\BsonExplicitCursor.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\BsonExplicitCursor.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\BsonExplicitCursor.java",
        "chunk_id": "BsonExplicitCursor_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import com.mongodb.ServerAddress;\n<line_number-20>import com.mongodb.ServerCursor;\n<line_number-21>import com.mongodb.client.MongoCursor;\n<line_number-22>import java.util.ArrayList;\n<line_number-23>import java.util.List;\n<line_number-24>import org.bson.BsonDocument;\n<line_number-25>\n<line_number-26>/**\n<line_number-27> * BsonExplicitCursor allows for creating an instance of MongoCursor from an explicit list of BSON\n<line_number-28> * docs. Useful for testing or for any place static results are necessary.\n<line_number-29> */\n<line_number-30>public class BsonExplicitCursor implements MongoCursor<BsonDocument> {\n<line_number-31>    private List<BsonDocument> docs;\n<line_number-32>    private int rowNum = 0;\n<line_number-33>\n<line_number-34>    public static final BsonExplicitCursor EMPTY_CURSOR = new BsonExplicitCursor(new ArrayList<>());\n<line_number-35>\n<line_number-36>    public BsonExplicitCursor(List<BsonDocument> docs) {\n<line_number-37>        this.docs = docs;\n<line_number-38>    }\n<line_number-39>\n<line_number-40>    @Override\n<line_number-41>    public void close() {}\n<line_number-42>\n<line_number-43>    @Override\n<line_number-44>    public ServerAddress getServerAddress() {\n<line_number-45>        return new ServerAddress(\"127.0.0.1\");\n<line_number-46>    }\n<line_number-47>\n<line_number-48>    @Override\n<line_number-49>    public ServerCursor getServerCursor() {\n<line_number-50>        return null;\n<line_number-51>    }\n<line_number-52>\n<line_number-53>    @Override\n<line_number-54>    public boolean hasNext() {\n<line_number-55>        return rowNum < docs.size();\n<line_number-56>    }\n<line_number-57>\n<line_number-58>    @Override\n<line_number-59>    public BsonDocument next() {\n<line_number-60>        return docs.get(rowNum++);\n<line_number-61>    }\n<line_number-62>\n<line_number-63>    @Override\n<line_number-64>    public int available() {\n<line_number-65>        return docs.size() - rowNum;\n<line_number-66>    }\n<line_number-67>\n<line_number-68>    @Override\n<line_number-69>    public BsonDocument tryNext() {\n<line_number-70>        if (hasNext()) {\n<line_number-71>            return next();\n<line_number-72>        }\n<line_number-73>        return null;\n<line_number-74>    }\n<line_number-75>}\n",
        "comments": [
          {
            "comment_code_range": "26-29",
            "comment_linenumber": "25",
            "comment": "BsonExplicitCursor provides a way to create a MongoCursor from a predefined list of BSON documents, facilitating testing and static result scenarios.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "30-34",
            "comment_linenumber": "29",
            "comment": "Defines an empty cursor instance for cases where no documents are available.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "36-38",
            "comment_linenumber": "35",
            "comment": "Constructor initializes the cursor with a list of BSON documents.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "40-41",
            "comment_linenumber": "39",
            "comment": "Closes the cursor; no resources to release in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "43-46",
            "comment_linenumber": "42",
            "comment": "Returns the server address associated with this cursor, hardcoded to localhost.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "48-51",
            "comment_linenumber": "47",
            "comment": "Returns null as there is no server cursor associated with this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "53-56",
            "comment_linenumber": "52",
            "comment": "Checks if there are more documents to iterate over in the cursor.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "58-61",
            "comment_linenumber": "57",
            "comment": "Returns the next BSON document in the cursor and advances the cursor position.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "63-66",
            "comment_linenumber": "62",
            "comment": "Returns the number of documents remaining in the cursor.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "68-73",
            "comment_linenumber": "67",
            "comment": "Attempts to return the next document if available; returns null if no more documents exist.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'BsonExplicitCursor.java' defines a class that implements the MongoCursor interface for BSON documents. It is primarily designed to facilitate testing by allowing the creation of a cursor from a static list of BSON documents. The class contains a private list to hold the documents and an index to track the current position. It provides methods to check for the availability of documents, retrieve the next document, and obtain the server address, which is hardcoded to localhost. The class also includes a static instance representing an empty cursor. The methods are straightforward, with no complex control flow or external dependencies, making it lightweight and easy to use in testing scenarios.",
        "file_summary": "The BsonExplicitCursor class provides a MongoCursor implementation that allows for the iteration over a predefined list of BSON documents, primarily for testing purposes. It includes methods for document retrieval and cursor management, with a focus on simplicity and static results."
      }
    ]
  },
  "BsonTypeInfo.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\BsonTypeInfo.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\BsonTypeInfo.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\BsonTypeInfo.java",
        "chunk_id": "BsonTypeInfo_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.sql.SQLException;\n<line_number-20>import java.sql.Types;\n<line_number-21>import java.util.Arrays;\n<line_number-22>import java.util.HashSet;\n<line_number-23>import java.util.Set;\n<line_number-24>import org.bson.BsonType;\n<line_number-25>import org.bson.BsonValue;\n<line_number-26>\n<line_number-27>public enum BsonTypeInfo {\n<line_number-28>    BSON_DOUBLE(\"double\", BsonType.DOUBLE, Types.DOUBLE, false, 15, 15, 2, 15, 15, 8),\n<line_number-29>    BSON_STRING(\"string\", BsonType.STRING, Types.LONGVARCHAR, true, 0, 0, 0, null, null, null),\n<line_number-30>    BSON_OBJECT(\"object\", BsonType.DOCUMENT, Types.OTHER, false, 0, 0, 0, null, null, null),\n<line_number-31>    BSON_ARRAY(\"array\", BsonType.ARRAY, Types.OTHER, false, 0, 0, 0, null, null, null),\n<line_number-32>    BSON_BINDATA(\"binData\", BsonType.BINARY, Types.BINARY, false, 0, 0, 0, null, null, null),\n<line_number-33>    BSON_UNDEFINED(\"undefined\", BsonType.UNDEFINED, Types.OTHER, false, 0, 0, 0, null, null, null),\n<line_number-34>    BSON_OBJECTID(\"objectId\", BsonType.OBJECT_ID, Types.OTHER, false, 0, 0, 0, 24, null, null),\n<line_number-35>    BSON_BOOL(\"bool\", BsonType.BOOLEAN, Types.BOOLEAN, false, 0, 0, 0, 1, null, 1),\n<line_number-36>    BSON_DATE(\"date\", BsonType.DATE_TIME, Types.TIMESTAMP, false, 0, 3, 0, 24, 3, 8),\n<line_number-37>    BSON_NULL(\"null\", BsonType.NULL, Types.NULL, false, 0, 0, 0, null, null, null),\n<line_number-38>    BSON_REGEX(\"regex\", BsonType.REGULAR_EXPRESSION, Types.OTHER, true, 0, 0, 0, null, null, null),\n<line_number-39>    BSON_DBPOINTER(\"dbPointer\", BsonType.DB_POINTER, Types.OTHER, false, 0, 0, 0, null, null, null),\n<line_number-40>    BSON_JAVASCRIPT(\n<line_number-41>            \"javascript\", BsonType.JAVASCRIPT, Types.OTHER, true, 0, 0, 0, null, null, null),\n<line_number-42>    BSON_SYMBOL(\"symbol\", BsonType.SYMBOL, Types.OTHER, true, 0, 0, 0, null, null, null),\n<line_number-43>    BSON_JAVASCRIPTWITHSCOPE(\n<line_number-44>            \"javascriptWithScope\",\n<line_number-45>            BsonType.JAVASCRIPT_WITH_SCOPE,\n<line_number-46>            Types.OTHER,\n<line_number-47>            true,\n<line_number-48>            0,\n<line_number-49>            0,\n<line_number-50>            0,\n<line_number-51>            null,\n<line_number-52>            null,\n<line_number-53>            null),\n<line_number-54>    BSON_INT(\"int\", BsonType.INT32, Types.INTEGER, false, 0, 0, 2, 10, null, 4),\n<line_number-55>    BSON_TIMESTAMP(\"timestamp\", BsonType.TIMESTAMP, Types.OTHER, false, 0, 0, 0, null, null, null),\n<line_number-56>    BSON_LONG(\"long\", BsonType.INT64, Types.BIGINT, false, 0, 0, 2, 19, null, 8),\n<line_number-57>    BSON_DECIMAL(\"decimal\", BsonType.DECIMAL128, Types.DECIMAL, false, 34, 34, 10, 34, 34, 16),\n<line_number-58>    BSON_MINKEY(\"minKey\", BsonType.MIN_KEY, Types.OTHER, false, 0, 0, 0, null, null, null),\n<line_number-59>    BSON_MAXKEY(\"maxKey\", BsonType.MAX_KEY, Types.OTHER, false, 0, 0, 0, null, null, null),\n<line_number-60>    BSON_BSON(\"bson\", BsonType.UNDEFINED, Types.OTHER, false, 0, 0, 0, null, null, null);\n<line_number-61>\n<line_number-62>    // BSON_TYPE_NAMES is the set of all valid BSON type names as listed\n<line_number-63>    // here: https://mongodb.github.io/mongo-java-driver/3.12/javadoc/org/bson/BsonType.html\n<line_number-64>    // Note that BsonTypeInfo contains a BSON_BSON variant which is intentionally\n<line_number-65>    // omitted from this set. That is because \"bson\" is our catch-all for a\n<line_number-66>    // value that has \"any\" type, but is not an actual specific BSON type.\n<line_number-67>    private static final Set<String> BSON_TYPE_NAMES =\n<line_number-68>            new HashSet<>(\n<line_number-69>                    Arrays.asList(\n<line_number-70>                            BSON_DOUBLE.bsonName,\n<line_number-71>                            BSON_STRING.bsonName,\n<line_number-72>                            BSON_OBJECT.bsonName,\n<line_number-73>                            BSON_ARRAY.bsonName,\n<line_number-74>                            BSON_BINDATA.bsonName,\n<line_number-75>                            BSON_UNDEFINED.bsonName,\n<line_number-76>                            BSON_OBJECTID.bsonName,\n<line_number-77>                            BSON_BOOL.bsonName,\n<line_number-78>                            BSON_DATE.bsonName,\n<line_number-79>                            BSON_NULL.bsonName,\n<line_number-80>                            BSON_REGEX.bsonName,\n<line_number-81>                            BSON_DBPOINTER.bsonName,\n<line_number-82>                            BSON_JAVASCRIPT.bsonName,\n<line_number-83>                            BSON_SYMBOL.bsonName,\n<line_number-84>                            BSON_JAVASCRIPTWITHSCOPE.bsonName,\n<line_number-85>                            BSON_INT.bsonName,\n<line_number-86>                            BSON_TIMESTAMP.bsonName,\n<line_number-87>                            BSON_LONG.bsonName,\n<line_number-88>                            BSON_DECIMAL.bsonName,\n<line_number-89>                            BSON_MINKEY.bsonName,\n<line_number-90>                            BSON_MAXKEY.bsonName));\n<line_number-91>\n<line_number-92>    private final String bsonName;\n<line_number-93>    private final BsonType bsonType;\n<line_number-94>    private final int jdbcType;\n<line_number-95>    private final boolean caseSensitivity;\n<line_number-96>    // Minimum scale for numeric data and date time data.\n<line_number-97>    private final int minScale;\n<line_number-98>    // Maximum scale for numeric data and date time data.\n<line_number-99>    private final int maxScale;\n<line_number-100>    // Radix (typically either 10 or 2) for numeric data.\n<line_number-101>    private final int numPrecRadix;\n<line_number-102>    // The column/data size for the given type.\n<line_number-103>    //  - For numeric data, this is the maximum precision.\n<line_number-104>    //  - For character data, this is the maximum length in characters.\n<line_number-105>    //  - For datetime data types, this is the length in characters of the String representation (assuming the maximum\n<line_number-106>    //  allowed precision of the fractional seconds component).\n<line_number-107>    //  - For binary data, this is the maximum length in bytes.\n<line_number-108>    //  - For ObjectId (row id data type) data, this is the length in bytes.\n<line_number-109>    //  - Null is returned for data types where the column size is not applicable.\n<line_number-110>    private final Integer precision;\n<line_number-111>    // The number of fractional digits for numeric and date time data. Null is returned for data types where\n<line_number-112>    // DECIMAL_DIGITS is not applicable.\n<line_number-113>    // Also known as scale.\n<line_number-114>    private final Integer decimalDigits;\n<line_number-115>    // The length in bytes for fixed length data type.\n<line_number-116>    private final Integer fixedBytesLength;\n<line_number-117>\n<line_number-118>    BsonTypeInfo(\n<line_number-119>            String bsonName,\n<line_number-120>            BsonType bsonType,\n<line_number-121>            int jdbcType,\n<line_number-122>            boolean caseSensitivity,\n<line_number-123>            int minScale,\n<line_number-124>            int maxScale,\n<line_number-125>            int numPrecRadix,\n<line_number-126>            Integer precision,\n<line_number-127>            Integer decimalDigits,\n<line_number-128>            Integer fixedBytesLength) {\n<line_number-129>        this.bsonName = bsonName;\n<line_number-130>        this.bsonType = bsonType;\n<line_number-131>        this.jdbcType = jdbcType;\n<line_number-132>        this.caseSensitivity = caseSensitivity;\n<line_number-133>        this.minScale = minScale;\n<line_number-134>        this.maxScale = maxScale;\n<line_number-135>        this.numPrecRadix = numPrecRadix;\n<line_number-136>        this.precision = precision;\n<line_number-137>        this.decimalDigits = decimalDigits;\n<line_number-138>        this.fixedBytesLength = fixedBytesLength;\n<line_number-139>    }\n<line_number-140>\n<line_number-141>    public String getBsonName() {\n<line_number-142>        return bsonName;\n<line_number-143>    }\n<line_number-144>\n<line_number-145>    public BsonType getBsonType() {\n<line_number-146>        return bsonType;\n<line_number-147>    }\n<line_number-148>\n<line_number-149>    public int getJdbcType() {\n<line_number-150>        return jdbcType;\n<line_number-151>    }\n<line_number-152>\n<line_number-153>    public boolean getCaseSensitivity() {\n<line_number-154>        return caseSensitivity;\n<line_number-155>    }\n<line_number-156>\n<line_number-157>    public int getMinScale() {\n<line_number-158>        return minScale;\n<line_number-159>    }\n<line_number-160>\n<line_number-161>    public int getMaxScale() {\n<line_number-162>        return maxScale;\n<line_number-163>    }\n<line_number-164>\n<line_number-165>    public int getNumPrecRadix() {\n<line_number-166>        return numPrecRadix;\n<line_number-167>    }\n<line_number-168>\n<line_number-169>    public Integer getPrecision() {\n<line_number-170>        return precision;\n<line_number-171>    }\n<line_number-172>\n<line_number-173>    public Integer getFixedBytesLength() {\n<line_number-174>        return fixedBytesLength;\n<line_number-175>    }\n<line_number-176>\n<line_number-177>    public Integer getDecimalDigits() {\n<line_number-178>        return decimalDigits;\n<line_number-179>    }\n<line_number-180>\n<line_number-181>    /**\n<line_number-182>     * CHAR_OCTET_LENGTH is the maximum length of binary and character based data in bytes. For any\n<line_number-183>     * other datatype the value is null. We can use 'precision' combined with the data type for\n<line_number-184>     * reporting the correct info.\n<line_number-185>     */\n<line_number-186>    public Integer getCharOctetLength() {\n<line_number-187>        switch (this.bsonType) {\n<line_number-188>            case BINARY:\n<line_number-189>            case STRING:\n<line_number-190>                return this.precision;\n<line_number-191>            default:\n<line_number-192>                return null;\n<line_number-193>        }\n<line_number-194>    }\n<line_number-195>\n<line_number-196>    /**\n<line_number-197>     * Converts a bson value to a BsonTypeInfo\n<line_number-198>     *\n<line_number-199>     * @param obj is the Bson value to convert.\n<line_number-200>     * @return BsonTypeInfo object corresponding to the Bson type.\n<line_number-201>     * @throws SQLException\n<line_number-202>     */\n<line_number-203>    public static BsonTypeInfo getBsonTypeInfoFromBsonValue(BsonValue obj) throws SQLException {\n<line_number-204>        if (obj == null) {\n<line_number-205>            throw new SQLException(\"Missing bson type name. Value is Null\");\n<line_number-206>        }\n<line_number-207>        BsonType type = obj.getBsonType();\n<line_number-208>        switch (type) {\n<line_number-209>            case DOUBLE:\n<line_number-210>                return BSON_DOUBLE;\n<line_number-211>            case STRING:\n<line_number-212>                return BSON_STRING;\n<line_number-213>            case DOCUMENT:\n<line_number-214>                // BsonDocument and BSON_OBJECT are synonymous. To maintain consistency within ADF,\n<line_number-215>                // BsonDocuments will be treated as BSON_OBJECTs\n<line_number-216>                return BSON_OBJECT;\n<line_number-217>            case ARRAY:\n<line_number-218>                return BSON_ARRAY;\n<line_number-219>            case BINARY:\n<line_number-220>                return BSON_BINDATA;\n<line_number-221>            case UNDEFINED:\n<line_number-222>                return BSON_UNDEFINED;\n<line_number-223>            case OBJECT_ID:\n<line_number-224>                return BSON_OBJECTID;\n<line_number-225>            case BOOLEAN:\n<line_number-226>                return BSON_BOOL;\n<line_number-227>            case DATE_TIME:\n<line_number-228>                return BSON_DATE;\n<line_number-229>            case NULL:\n<line_number-230>                return BSON_NULL;\n<line_number-231>            case REGULAR_EXPRESSION:\n<line_number-232>                return BSON_REGEX;\n<line_number-233>            case DB_POINTER:\n<line_number-234>                return BSON_DBPOINTER;\n<line_number-235>            case JAVASCRIPT:\n<line_number-236>                return BSON_JAVASCRIPT;\n<line_number-237>            case SYMBOL:\n<line_number-238>                return BSON_SYMBOL;\n<line_number-239>            case JAVASCRIPT_WITH_SCOPE:\n<line_number-240>                return BSON_JAVASCRIPTWITHSCOPE;\n<line_number-241>            case INT32:\n<line_number-242>                return BSON_INT;\n<line_number-243>            case TIMESTAMP:\n<line_number-244>                return BSON_TIMESTAMP;\n<line_number-245>            case INT64:\n<line_number-246>                return BSON_LONG;\n<line_number-247>            case DECIMAL128:\n<line_number-248>                return BSON_DECIMAL;\n<line_number-249>            case MIN_KEY:\n<line_number-250>                return BSON_MINKEY;\n<line_number-251>            case MAX_KEY:\n<line_number-252>                return BSON_MAXKEY;\n<line_number-253>            default:\n<line_number-254>                throw new SQLException(\"Unknown bson type name: \\\"\" + type.name() + \"\\\"\");\n<line_number-255>        }\n<line_number-256>    }\n<line_number-257>\n<line_number-258>    /**\n<line_number-259>     * Converts a bson type name to a BsonTypeInfo\n<line_number-260>     *\n<line_number-261>     * @param typeName is the bson type string as returned from the mongodb aggregation $type\n<line_number-262>     *     function, this list of viable inputs is in the BSON_TYPE_NAMES static Set above.\n<line_number-263>     * @return BsonTypeInfo object corresponding to bson type name.\n<line_number-264>     */\n<line_number-265>    public static BsonTypeInfo getBsonTypeInfoByName(String typeName) throws SQLException {\n<line_number-266>        if (typeName == null) {\n<line_number-267>            throw new SQLException(\"Missing bson type name. Value is Null\");\n<line_number-268>        }\n<line_number-269>        if (!BSON_TYPE_NAMES.contains(typeName)) {\n<line_number-270>            throw new SQLException(\"Unknown bson type name: \\\"\" + typeName + \"\\\"\");\n<line_number-271>        }\n<line_number-272>\n<line_number-273>        // All type names can be determined uniquely off a combination of first letter\n<line_number-274>        // and length except for \"minKey\" vs \"maxKey\" and \"string\" vs \"symbol\".\n<line_number-275>        switch (typeName.charAt(0)) {\n<line_number-276>            case 'a':\n<line_number-277>                return BSON_ARRAY;\n<line_number-278>            case 'b':\n<line_number-279>                switch (typeName.length()) {\n<line_number-280>                    case 4:\n<line_number-281>                        return BSON_BOOL;\n<line_number-282>                    case 7:\n<line_number-283>                        return BSON_BINDATA;\n<line_number-284>                }\n<line_number-285>                break;\n<line_number-286>            case 'd':\n<line_number-287>                switch (typeName.length()) {\n<line_number-288>                    case 4:\n<line_number-289>                        return BSON_DATE;\n<line_number-290>                    case 6:\n<line_number-291>                        return BSON_DOUBLE;\n<line_number-292>                    case 7:\n<line_number-293>                        return BSON_DECIMAL;\n<line_number-294>                    case 9:\n<line_number-295>                        return BSON_DBPOINTER;\n<line_number-296>                }\n<line_number-297>                break;\n<line_number-298>            case 'i':\n<line_number-299>                return BSON_INT;\n<line_number-300>            case 'j':\n<line_number-301>                switch (typeName.length()) {\n<line_number-302>                    case 10:\n<line_number-303>                        return BSON_JAVASCRIPT;\n<line_number-304>                    case 19:\n<line_number-305>                        return BSON_JAVASCRIPTWITHSCOPE;\n<line_number-306>                }\n<line_number-307>                break;\n<line_number-308>            case 'l':\n<line_number-309>                return BSON_LONG;\n<line_number-310>            case 'm':\n<line_number-311>                switch (typeName.charAt(1)) {\n<line_number-312>                    case 'a':\n<line_number-313>                        return BSON_MAXKEY;\n<line_number-314>                    case 'i':\n<line_number-315>                        return BSON_MINKEY;\n<line_number-316>                }\n<line_number-317>                break;\n<line_number-318>            case 'n':\n<line_number-319>                return BSON_NULL;\n<line_number-320>            case 'o':\n<line_number-321>                switch (typeName.length()) {\n<line_number-322>                    case 6:\n<line_number-323>                        return BSON_OBJECT;\n<line_number-324>                    case 8:\n<line_number-325>                        return BSON_OBJECTID;\n<line_number-326>                }\n<line_number-327>                break;\n<line_number-328>            case 'r':\n<line_number-329>                return BSON_REGEX;\n<line_number-330>            case 's':\n<line_number-331>                switch (typeName.charAt(1)) {\n<line_number-332>                    case 't':\n<line_number-333>                        return BSON_STRING;\n<line_number-334>                    case 'y':\n<line_number-335>                        return BSON_SYMBOL;\n<line_number-336>                }\n<line_number-337>                break;\n<line_number-338>            case 't':\n<line_number-339>                return BSON_TIMESTAMP;\n<line_number-340>            case 'u':\n<line_number-341>                return BSON_UNDEFINED;\n<line_number-342>        }\n<line_number-343>\n<line_number-344>        // This is unreachable.\n<line_number-345>        throw new SQLException(\"Unknown bson type name: \\\"\" + typeName + \"\\\"\");\n<line_number-346>    }\n<line_number-347>}\n",
        "comments": [
          {
            "comment_code_range": "27-60",
            "comment_linenumber": "26",
            "comment": "BsonTypeInfo is an enum that maps BSON types to their corresponding JDBC types and metadata, facilitating type conversion and validation.",
            "comment_kind": "enum"
          },
          {
            "comment_code_range": "28-60",
            "comment_linenumber": "27",
            "comment": "Defines various BSON types with their associated properties such as name, JDBC type, case sensitivity, and scale.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "62-90",
            "comment_linenumber": "61",
            "comment": "BSON_TYPE_NAMES is a set containing all valid BSON type names, excluding BSON_BSON which is a catch-all type.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "118-139",
            "comment_linenumber": "117",
            "comment": "Constructor for BsonTypeInfo that initializes the BSON type properties.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "141-143",
            "comment_linenumber": "140",
            "comment": "Returns the BSON name associated with this BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "145-147",
            "comment_linenumber": "144",
            "comment": "Returns the BSON type enumeration for this BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "149-151",
            "comment_linenumber": "148",
            "comment": "Returns the JDBC type associated with this BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "153-155",
            "comment_linenumber": "152",
            "comment": "Indicates whether this BSON type is case-sensitive.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "157-159",
            "comment_linenumber": "156",
            "comment": "Returns the minimum scale for numeric and date-time data.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "161-163",
            "comment_linenumber": "160",
            "comment": "Returns the maximum scale for numeric and date-time data.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "165-167",
            "comment_linenumber": "164",
            "comment": "Returns the numeric precision radix for this BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "169-171",
            "comment_linenumber": "168",
            "comment": "Returns the precision for this BSON type, if applicable.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "173-175",
            "comment_linenumber": "172",
            "comment": "Returns the fixed bytes length for this BSON type, if applicable.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "177-179",
            "comment_linenumber": "176",
            "comment": "Returns the number of decimal digits for this BSON type, if applicable.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "181-185",
            "comment_linenumber": "180",
            "comment": "Returns the maximum length of binary and character-based data in bytes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "196-256",
            "comment_linenumber": "195",
            "comment": "Converts a BsonValue to its corresponding BsonTypeInfo, throwing SQLException for null or unknown types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "258-346",
            "comment_linenumber": "257",
            "comment": "Converts a BSON type name to its corresponding BsonTypeInfo, throwing SQLException for null or unknown names.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'BsonTypeInfo.java' defines an enum that maps BSON types to their corresponding JDBC types and metadata, facilitating type conversion and validation in MongoDB JDBC operations. The enum contains constants for each BSON type, along with properties such as the BSON name, JDBC type, case sensitivity, and various numeric scales. The class also includes methods to retrieve these properties and to convert BSON values and type names into their respective BsonTypeInfo instances. The design follows an enum pattern, ensuring type safety and encapsulation of BSON type information. The file imports necessary classes from the java.sql and org.bson packages, indicating its reliance on standard SQL types and BSON representations. The methods handle exceptions related to SQL operations, ensuring robust error handling for invalid BSON types or names.",
        "file_summary": "This file defines the BsonTypeInfo enum, which maps BSON types to JDBC types and their associated metadata, enabling seamless integration between BSON data and SQL operations in MongoDB."
      }
    ]
  },
  "BuildInfo.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\BuildInfo.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\BuildInfo.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\BuildInfo.java",
        "chunk_id": "BuildInfo_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.util.List;\n<line_number-20>import java.util.Set;\n<line_number-21>import org.bson.codecs.pojo.annotations.BsonCreator;\n<line_number-22>import org.bson.codecs.pojo.annotations.BsonProperty;\n<line_number-23>\n<line_number-24>public class BuildInfo {\n<line_number-25>    private String fullVersion;\n<line_number-26>    private List<Integer> versionArray;\n<line_number-27>    public Set<String> modules;\n<line_number-28>    public int ok;\n<line_number-29>\n<line_number-30>    public DataLake dataLake;\n<line_number-31>\n<line_number-32>    @BsonCreator\n<line_number-33>    public BuildInfo(\n<line_number-34>            @BsonProperty(\"version\") String version,\n<line_number-35>            @BsonProperty(\"versionArray\") List<Integer> versionArray,\n<line_number-36>            @BsonProperty(\"modules\") Set<String> modules,\n<line_number-37>            @BsonProperty(\"ok\") int ok,\n<line_number-38>            @BsonProperty(\"dataLake\") DataLake dataLake)\n<line_number-39>            throws IndexOutOfBoundsException {\n<line_number-40>        this.fullVersion = version;\n<line_number-41>        this.versionArray = versionArray;\n<line_number-42>        if (dataLake != null) {\n<line_number-43>            this.fullVersion += \".\" + dataLake.version + \".\" + dataLake.mongoSQLVersion;\n<line_number-44>        }\n<line_number-45>        this.dataLake = dataLake;\n<line_number-46>        this.ok = ok;\n<line_number-47>        this.modules = modules;\n<line_number-48>    }\n<line_number-49>\n<line_number-50>    public String getFullVersion() {\n<line_number-51>        return this.fullVersion;\n<line_number-52>    }\n<line_number-53>\n<line_number-54>    public int getMajorVersion() throws IndexOutOfBoundsException {\n<line_number-55>        return this.versionArray.get(0);\n<line_number-56>    }\n<line_number-57>\n<line_number-58>    public int getMinorVersion() throws IndexOutOfBoundsException {\n<line_number-59>        return this.versionArray.get(1);\n<line_number-60>    }\n<line_number-61>\n<line_number-62>    // Override toString for logging\n<line_number-63>    @Override\n<line_number-64>    public String toString() {\n<line_number-65>        return \"BuildInfo{\"\n<line_number-66>                + \"fullVersion='\"\n<line_number-67>                + fullVersion\n<line_number-68>                + '\\''\n<line_number-69>                + \", versionArray=\"\n<line_number-70>                + versionArray\n<line_number-71>                + \", majorVersion=\"\n<line_number-72>                + this.getMajorVersion()\n<line_number-73>                + \", minorVersion=\"\n<line_number-74>                + this.getMinorVersion()\n<line_number-75>                + \", modules=\"\n<line_number-76>                + modules\n<line_number-77>                + \", ok=\"\n<line_number-78>                + ok\n<line_number-79>                + \", dataLake=\"\n<line_number-80>                + dataLake\n<line_number-81>                + '}';\n<line_number-82>    }\n<line_number-83>}\n",
        "comments": [
          {
            "comment_code_range": "24-82",
            "comment_linenumber": "23",
            "comment": "Represents build information including version details and associated modules, with methods to retrieve version components.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "33-48",
            "comment_linenumber": "32",
            "comment": "Constructor that initializes BuildInfo with version details, ensuring proper formatting of the full version string.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "50-52",
            "comment_linenumber": "49",
            "comment": "Returns the full version string of the build.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "54-56",
            "comment_linenumber": "53",
            "comment": "Returns the major version number from the version array.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "58-60",
            "comment_linenumber": "57",
            "comment": "Returns the minor version number from the version array.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "62-82",
            "comment_linenumber": "61",
            "comment": "Overrides toString method for logging purposes, providing a string representation of the BuildInfo object.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'BuildInfo.java' is part of the 'com.mongodb.jdbc' package and defines a class that encapsulates build information for MongoDB. It follows a simple data structure pattern, utilizing annotations from the BSON library to facilitate serialization. The class contains private fields for the full version, version array, modules, and a DataLake object, along with a public constructor that initializes these fields. The constructor ensures that the full version string is formatted correctly, especially when a DataLake object is provided. The class provides public methods to retrieve the full version, major version, and minor version, and overrides the toString method to give a comprehensive string representation of the object. The class does not implement any interfaces or extend any other classes, indicating it is a standalone data structure. The use of public fields for modules and ok suggests that these may be intended for direct access, while the encapsulated fields promote data integrity. The class is not designed for thread safety or immutability, as it allows modification of its fields after instantiation.",
        "file_summary": "The 'BuildInfo.java' file defines a class that holds and manages build-related information for MongoDB, including version details and associated modules. It provides methods to access specific version components and a formatted string representation for logging."
      }
    ]
  },
  "DataLake.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\DataLake.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\DataLake.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\DataLake.java",
        "chunk_id": "DataLake_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>public class DataLake {\n<line_number-20>    public String version;\n<line_number-21>    public String mongoSQLVersion;\n<line_number-22>\n<line_number-23>    // Override toString for logging\n<line_number-24>    @Override\n<line_number-25>    public String toString() {\n<line_number-26>        return \"DataLake{\"\n<line_number-27>                + \"version='\"\n<line_number-28>                + version\n<line_number-29>                + '\\''\n<line_number-30>                + \", mongoSQLVersion=\"\n<line_number-31>                + mongoSQLVersion\n<line_number-32>                + '}';\n<line_number-33>    }\n<line_number-34>}\n",
        "comments": [
          {
            "comment_code_range": "19-34",
            "comment_linenumber": "18",
            "comment": "Represents a DataLake configuration with versioning information for logging and tracking.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "23-33",
            "comment_linenumber": "22",
            "comment": "Overrides the toString method to provide a string representation of the DataLake object, including version and mongoSQLVersion.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'DataLake.java' defines a single public class named 'DataLake' within the package 'com.mongodb.jdbc'. This class is responsible for encapsulating the configuration details of a DataLake, specifically its version and the version of MongoDB SQL being used. The class contains two public string fields: 'version' and 'mongoSQLVersion', which store the respective version information. The class overrides the 'toString' method to provide a formatted string representation of the DataLake instance, which is useful for logging purposes. The 'toString' method concatenates the field values into a readable format, ensuring that the output includes both the version and mongoSQLVersion. There are no constructors or additional methods defined in this class, and it does not implement any interfaces or extend any other classes. The class is straightforward and does not include complex logic or dependencies, making it easy to understand and maintain.",
        "file_summary": "The 'DataLake.java' file defines a simple class that holds version information for a DataLake configuration, providing a method for logging its state."
      }
    ]
  },
  "JsonSchema.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\JsonSchema.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\JsonSchema.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\JsonSchema.java",
        "chunk_id": "JsonSchema_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.util.Map;\n<line_number-20>import java.util.Objects;\n<line_number-21>import java.util.Set;\n<line_number-22>import org.bson.BsonValue;\n<line_number-23>\n<line_number-24>// Simple POJO for deserializing jsonschema.\n<line_number-25>// For more details on jsonSchema, see https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/.\n<line_number-26>public class JsonSchema {\n<line_number-27>\n<line_number-28>    public BsonValue bsonType;\n<line_number-29>    public Map<String, JsonSchema> properties;\n<line_number-30>    public Set<JsonSchema> anyOf;\n<line_number-31>    public Set<String> required;\n<line_number-32>    public BsonValue items;\n<line_number-33>    public BsonValue additionalProperties;\n<line_number-34>\n<line_number-35>    @Override\n<line_number-36>    public boolean equals(Object obj) {\n<line_number-37>        if (!(obj instanceof MongoJsonSchema)) {\n<line_number-38>            return false;\n<line_number-39>        }\n<line_number-40>        MongoJsonSchema other = (MongoJsonSchema) obj;\n<line_number-41>        return Objects.equals(bsonType, other.bsonType)\n<line_number-42>                && Objects.equals(properties, other.properties)\n<line_number-43>                && Objects.equals(anyOf, other.anyOf)\n<line_number-44>                && Objects.equals(required, other.required)\n<line_number-45>                && Objects.equals(items, other.items)\n<line_number-46>                && Objects.equals(additionalProperties, other.additionalProperties);\n<line_number-47>    }\n<line_number-48>\n<line_number-49>    @Override\n<line_number-50>    public int hashCode() {\n<line_number-51>        return Objects.hash(bsonType, properties, anyOf, required, items, additionalProperties);\n<line_number-52>    }\n<line_number-53>}\n",
        "comments": [
          {
            "comment_code_range": "16-14",
            "comment_linenumber": "15",
            "comment": "This file defines the JsonSchema class, which serves as a simple POJO for deserializing JSON schema structures used in MongoDB.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "28-33",
            "comment_linenumber": "27",
            "comment": "Fields representing the schema's BSON type, properties, validation criteria, and additional properties.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "35-46",
            "comment_linenumber": "34",
            "comment": "Overrides the equals method to provide a custom equality check based on the schema's fields.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "49-51",
            "comment_linenumber": "48",
            "comment": "Overrides the hashCode method to ensure consistent hashing based on the schema's fields.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'JsonSchema.java' is part of the 'com.mongodb.jdbc' package and defines a class named 'JsonSchema'. This class is a Plain Old Java Object (POJO) designed for deserializing JSON schema structures, particularly in the context of MongoDB. The class does not extend any other class and does not implement any interfaces. It contains several public fields: 'bsonType' (of type BsonValue), 'properties' (a Map of String to JsonSchema), 'anyOf' (a Set of JsonSchema), 'required' (a Set of Strings), 'items' (of type BsonValue), and 'additionalProperties' (of type BsonValue). The class overrides the 'equals' and 'hashCode' methods to provide custom equality checks and consistent hashing based on its fields. The equality check ensures that two JsonSchema objects are considered equal if all their fields match. The hashCode method generates a hash code that reflects the values of the fields, ensuring that equal objects have the same hash code. There are no constructors defined, implying that the default constructor is used. The class is not thread-safe and does not enforce immutability.",
        "file_summary": "The 'JsonSchema.java' file defines a class that serves as a data structure for deserializing JSON schema representations in MongoDB, providing methods for equality comparison and hash code generation."
      }
    ]
  },
  "MongoBsonValue.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoBsonValue.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoBsonValue.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoBsonValue.java",
        "chunk_id": "MongoBsonValue_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.io.StringWriter;\n<line_number-20>import java.util.Objects;\n<line_number-21>import java.util.UUID;\n<line_number-22>import org.bson.BsonBinary;\n<line_number-23>import org.bson.BsonBinarySubType;\n<line_number-24>import org.bson.BsonDocument;\n<line_number-25>import org.bson.BsonValue;\n<line_number-26>import org.bson.UuidRepresentation;\n<line_number-27>import org.bson.codecs.BsonValueCodec;\n<line_number-28>import org.bson.codecs.EncoderContext;\n<line_number-29>import org.bson.internal.UuidHelper;\n<line_number-30>import org.bson.json.JsonMode;\n<line_number-31>import org.bson.json.JsonWriterSettings;\n<line_number-32>\n<line_number-33>/**\n<line_number-34> * MongoBsonValue is a wrapper for BsonValue. The purpose of this class is to override the\n<line_number-35> * toString() method to produce the extended JSON representation of a BsonValue rather than the java\n<line_number-36> * driver's default BsonValue.toString() output.\n<line_number-37> *\n<line_number-38> * <p>The driver's BsonValue class is abstract and intentionally cannot be extended by third\n<line_number-39> * parties. The driver explains this is to keep the BSON type system closed. Therefore, this class\n<line_number-40> * does not extend BsonValue, instead it contains a BsonValue member.\n<line_number-41> */\n<line_number-42>public class MongoBsonValue {\n<line_number-43>    private JsonWriterSettings JSON_WRITER_SETTINGS;\n<line_number-44>    static final EncoderContext ENCODER_CONTEXT = EncoderContext.builder().build();\n<line_number-45>    static final BsonValueCodec CODEC = new BsonValueCodec();\n<line_number-46>\n<line_number-47>    private final UuidRepresentation uuidRepresentation;\n<line_number-48>    private final boolean extJsonMode;\n<line_number-49>\n<line_number-50>    private BsonValue v;\n<line_number-51>\n<line_number-52>    public MongoBsonValue(BsonValue v, boolean isExtended, UuidRepresentation uuidRepresentation) {\n<line_number-53>        this.v = v;\n<line_number-54>        this.setJsonWriterSettings(isExtended);\n<line_number-55>        this.extJsonMode = isExtended;\n<line_number-56>        this.uuidRepresentation = uuidRepresentation;\n<line_number-57>    }\n<line_number-58>\n<line_number-59>    public void setJsonWriterSettings(boolean isExtended) {\n<line_number-60>        this.JSON_WRITER_SETTINGS =\n<line_number-61>                JsonWriterSettings.builder()\n<line_number-62>                        .outputMode(isExtended ? JsonMode.EXTENDED : JsonMode.RELAXED)\n<line_number-63>                        .build();\n<line_number-64>    }\n<line_number-65>\n<line_number-66>    /** @return The underlying BsonValue */\n<line_number-67>    public BsonValue getBsonValue() {\n<line_number-68>        return this.v;\n<line_number-69>    }\n<line_number-70>\n<line_number-71>    @Override\n<line_number-72>    public String toString() {\n<line_number-73>        if (this.v == null) {\n<line_number-74>            return null;\n<line_number-75>        }\n<line_number-76>\n<line_number-77>        switch (this.v.getBsonType()) {\n<line_number-78>            case NULL:\n<line_number-79>                return null;\n<line_number-80>            case UNDEFINED:\n<line_number-81>                // this is consistent with $convert in mongodb.\n<line_number-82>                return null;\n<line_number-83>\n<line_number-84>            case STRING:\n<line_number-85>                // The extended JSON representation of a string value is\n<line_number-86>                // delimited by double quotes. We do not want to include\n<line_number-87>                // those quotes in the output of this method, so we simply\n<line_number-88>                // return the underlying String value.\n<line_number-89>                return this.v.asString().getValue();\n<line_number-90>            case BINARY:\n<line_number-91>                BsonBinary binary = this.v.asBinary();\n<line_number-92>                if (binary.getType() == BsonBinarySubType.UUID_STANDARD.getValue()\n<line_number-93>                        || binary.getType() == BsonBinarySubType.UUID_LEGACY.getValue()) {\n<line_number-94>                    return formatUuid(binary);\n<line_number-95>                }\n<line_number-96>                // Fall through to toExtendedJson(this.v) for other binary types\n<line_number-97>\n<line_number-98>            case ARRAY:\n<line_number-99>            case DATE_TIME:\n<line_number-100>            case DB_POINTER:\n<line_number-101>            case DECIMAL128:\n<line_number-102>            case DOCUMENT:\n<line_number-103>            case JAVASCRIPT:\n<line_number-104>            case JAVASCRIPT_WITH_SCOPE:\n<line_number-105>            case MAX_KEY:\n<line_number-106>            case MIN_KEY:\n<line_number-107>            case OBJECT_ID:\n<line_number-108>            case REGULAR_EXPRESSION:\n<line_number-109>            case SYMBOL:\n<line_number-110>            case TIMESTAMP:\n<line_number-111>                // These types are stringified in extended JSON format.\n<line_number-112>                return toExtendedJson(this.v);\n<line_number-113>\n<line_number-114>            case BOOLEAN:\n<line_number-115>            case DOUBLE:\n<line_number-116>            case INT32:\n<line_number-117>            case INT64:\n<line_number-118>                // These types are also stringified in extended JSON\n<line_number-119>                // format. However, they cannot be written by the Java\n<line_number-120>                // driver's JsonWriter as top-level values, so we must\n<line_number-121>                // nest them in a document.\n<line_number-122>                BsonValue v = new BsonDocument(\"v\", this.v);\n<line_number-123>                String s = toExtendedJson(v);\n<line_number-124>\n<line_number-125>                // Substring starts at 6 because the extended JSON for\n<line_number-126>                // the document is:\n<line_number-127>                //   {\"v\": <this.v as extJSON>}\n<line_number-128>                // so the first 5 characters are '{\"v\": ' and the\n<line_number-129>                // actual value's serialization starts at position 6.\n<line_number-130>                // The actual value's serialization ends 1 character\n<line_number-131>                // before the end, to account for the closing '}'.\n<line_number-132>                return s.substring(6, s.length() - 1);\n<line_number-133>\n<line_number-134>            case END_OF_DOCUMENT:\n<line_number-135>            default:\n<line_number-136>                return this.v.toString();\n<line_number-137>        }\n<line_number-138>    }\n<line_number-139>\n<line_number-140>    // Formats a BSON binary object into a JSON string representation of a UUID.\n<line_number-141>    // If the BSON binary type is UUID_STANDARD, it directly converts it to a UUID.\n<line_number-142>    // Otherwise, it uses the specified or default UUID representation to decode the binary data.\n<line_number-143>    private String formatUuid(BsonBinary binary) {\n<line_number-144>        UUID uuid;\n<line_number-145>        byte binaryType = binary.getType();\n<line_number-146>        if (binaryType == BsonBinarySubType.UUID_STANDARD.getValue()) {\n<line_number-147>            uuid = binary.asUuid();\n<line_number-148>        } else {\n<line_number-149>            // When this.uuidRepresentation is UNSPECIFIED or null, set UuidRepresentation to PYTHON_LEGACY\n<line_number-150>            UuidRepresentation representationToUse =\n<line_number-151>                    (Objects.nonNull(this.uuidRepresentation)\n<line_number-152>                                    && this.uuidRepresentation != UuidRepresentation.UNSPECIFIED)\n<line_number-153>                            ? this.uuidRepresentation\n<line_number-154>                            : UuidRepresentation.PYTHON_LEGACY;\n<line_number-155>            if (binaryType == BsonBinarySubType.UUID_LEGACY.getValue()\n<line_number-156>                    && representationToUse == UuidRepresentation.STANDARD) {\n<line_number-157>                // UUID_LEGACY subtype and trying to get the standard representation causes a BSONException,\n<line_number-158>                // So we return the binary representation extended JSON instead\n<line_number-159>                return toExtendedJson(binary);\n<line_number-160>            }\n<line_number-161>            uuid =\n<line_number-162>                    UuidHelper.decodeBinaryToUuid(\n<line_number-163>                            binary.getData(), binary.getType(), representationToUse);\n<line_number-164>        }\n<line_number-165>        return String.format(\"{\\\"$uuid\\\":\\\"%s\\\"}\", uuid.toString());\n<line_number-166>    }\n<line_number-167>\n<line_number-168>    private String toExtendedJson(BsonValue v) {\n<line_number-169>        StringWriter w = new StringWriter();\n<line_number-170>        CODEC.encode(new NoCheckStateJsonWriter(w, JSON_WRITER_SETTINGS), v, ENCODER_CONTEXT);\n<line_number-171>        w.flush();\n<line_number-172>        return w.toString();\n<line_number-173>    }\n<line_number-174>\n<line_number-175>    @Override\n<line_number-176>    public int hashCode() {\n<line_number-177>        return this.v.hashCode();\n<line_number-178>    }\n<line_number-179>\n<line_number-180>    @Override\n<line_number-181>    public boolean equals(Object o) {\n<line_number-182>        if (this == o) return true;\n<line_number-183>        if (o == null || getClass() != o.getClass()) return false;\n<line_number-184>\n<line_number-185>        // Compare the wrapped BsonValue for equality\n<line_number-186>        return this.v.equals(((MongoBsonValue) o).v);\n<line_number-187>    }\n<line_number-188>}\n",
        "comments": [
          {
            "comment_code_range": "33-40",
            "comment_linenumber": "41",
            "comment": "MongoBsonValue is a wrapper for BsonValue that overrides toString() to produce an extended JSON representation instead of the default output.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "52-56",
            "comment_linenumber": "57",
            "comment": "Constructor initializes the MongoBsonValue with a BsonValue, extended JSON mode flag, and UUID representation.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "59-64",
            "comment_linenumber": "65",
            "comment": "Sets the JSON writer settings based on whether extended JSON mode is enabled.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "66-68",
            "comment_linenumber": "69",
            "comment": "Returns the underlying BsonValue wrapped by this MongoBsonValue instance.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "71-138",
            "comment_linenumber": "139",
            "comment": "Overrides toString() to return the extended JSON representation of the wrapped BsonValue based on its BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "140-144",
            "comment_linenumber": "165",
            "comment": "Formats a BSON binary object into a JSON string representation of a UUID, handling both standard and legacy UUID types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "168-172",
            "comment_linenumber": "173",
            "comment": "Converts the wrapped BsonValue to its extended JSON representation using a JSON writer.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "175-178",
            "comment_linenumber": "179",
            "comment": "Overrides hashCode() to return the hash code of the wrapped BsonValue.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "180-186",
            "comment_linenumber": "187",
            "comment": "Overrides equals() to compare this MongoBsonValue with another object based on the equality of the wrapped BsonValue.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoBsonValue.java' defines a class that serves as a wrapper for the BsonValue type from the MongoDB BSON library. The primary role of this class is to provide an extended JSON representation of BsonValue instances, which cannot be directly extended due to the abstract nature of BsonValue. The class contains several fields, including JSON_WRITER_SETTINGS for configuring JSON output, and a BsonValue instance that it wraps. The constructor initializes these fields based on the provided parameters. Key methods include 'toString()', which generates the extended JSON representation based on the BSON type of the wrapped value, and 'formatUuid()', which handles the conversion of BSON binary UUIDs to JSON format. The class also overrides 'hashCode()' and 'equals()' to ensure proper behavior in collections and comparisons. Overall, this class encapsulates BSON value handling while adhering to MongoDB's BSON type system restrictions.",
        "file_summary": "The 'MongoBsonValue.java' file defines the MongoBsonValue class, which wraps a BsonValue to provide an extended JSON representation. It handles various BSON types and formats them appropriately for JSON output, ensuring compatibility with MongoDB's BSON type system."
      }
    ]
  },
  "MongoColumnInfo.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoColumnInfo.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoColumnInfo.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoColumnInfo.java",
        "chunk_id": "MongoColumnInfo_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import org.apache.commons.lang3.builder.ToStringBuilder;\n<line_number-20>import org.apache.commons.lang3.builder.ToStringStyle;\n<line_number-21>import org.bson.BsonType;\n<line_number-22>\n<line_number-23>public class MongoColumnInfo {\n<line_number-24>    private final String datasource;\n<line_number-25>    private final String field;\n<line_number-26>    private final BsonTypeInfo bsonTypeInfo;\n<line_number-27>    private final boolean isPolymorphic;\n<line_number-28>    private final int nullable;\n<line_number-29>\n<line_number-30>    MongoColumnInfo(String datasource, String field, BsonTypeInfo bsonTypeInfo, int nullability) {\n<line_number-31>        this.datasource = datasource;\n<line_number-32>        this.field = field;\n<line_number-33>        this.bsonTypeInfo = bsonTypeInfo;\n<line_number-34>        this.nullable = nullability;\n<line_number-35>        this.isPolymorphic = bsonTypeInfo == BsonTypeInfo.BSON_BSON;\n<line_number-36>    }\n<line_number-37>\n<line_number-38>    @Override\n<line_number-39>    public String toString() {\n<line_number-40>        return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);\n<line_number-41>    }\n<line_number-42>\n<line_number-43>    public boolean isPolymorphic() {\n<line_number-44>        return isPolymorphic;\n<line_number-45>    }\n<line_number-46>\n<line_number-47>    public BsonType getBsonTypeEnum() {\n<line_number-48>        return bsonTypeInfo.getBsonType();\n<line_number-49>    }\n<line_number-50>\n<line_number-51>    public String getBsonTypeName() {\n<line_number-52>        return bsonTypeInfo.getBsonName();\n<line_number-53>    }\n<line_number-54>\n<line_number-55>    public int getJDBCType() {\n<line_number-56>        return bsonTypeInfo.getJdbcType();\n<line_number-57>    }\n<line_number-58>\n<line_number-59>    public int getNullability() {\n<line_number-60>        return nullable;\n<line_number-61>    }\n<line_number-62>\n<line_number-63>    public String getColumnName() {\n<line_number-64>        return field;\n<line_number-65>    }\n<line_number-66>\n<line_number-67>    public String getColumnAlias() {\n<line_number-68>        return field;\n<line_number-69>    }\n<line_number-70>\n<line_number-71>    public String getTableName() {\n<line_number-72>        return datasource;\n<line_number-73>    }\n<line_number-74>\n<line_number-75>    public String getTableAlias() {\n<line_number-76>        return datasource;\n<line_number-77>    }\n<line_number-78>\n<line_number-79>    public String getDatabase() {\n<line_number-80>        return \"\";\n<line_number-81>    }\n<line_number-82>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC integration.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "23-82",
            "comment_linenumber": "22",
            "comment": "Represents metadata for a MongoDB column, including its data source, field name, BSON type information, and nullability.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "30-36",
            "comment_linenumber": "29",
            "comment": "Constructor that initializes the MongoColumnInfo with the specified data source, field name, BSON type information, and nullability.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "38-41",
            "comment_linenumber": "37",
            "comment": "Returns a string representation of the MongoColumnInfo object using reflection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "43-45",
            "comment_linenumber": "42",
            "comment": "Checks if the column is polymorphic based on its BSON type information.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "47-48",
            "comment_linenumber": "46",
            "comment": "Retrieves the BSON type enumeration for the column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "51-52",
            "comment_linenumber": "50",
            "comment": "Gets the BSON type name for the column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "55-56",
            "comment_linenumber": "54",
            "comment": "Retrieves the JDBC type for the column based on its BSON type information.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "59-60",
            "comment_linenumber": "58",
            "comment": "Gets the nullability of the column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "63-64",
            "comment_linenumber": "62",
            "comment": "Returns the name of the column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "67-68",
            "comment_linenumber": "66",
            "comment": "Returns the alias of the column, which is the same as the column name.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "71-72",
            "comment_linenumber": "70",
            "comment": "Returns the name of the table associated with the column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "75-76",
            "comment_linenumber": "74",
            "comment": "Returns the alias of the table, which is the same as the data source name.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "79-80",
            "comment_linenumber": "78",
            "comment": "Returns an empty string for the database name, indicating no specific database is associated.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoColumnInfo.java' is part of the 'com.mongodb.jdbc' package and defines a class that encapsulates metadata for a MongoDB column. The class is designed to provide information such as the data source, field name, BSON type, and nullability of the column. It employs a constructor to initialize these properties and provides various getter methods to access the column's attributes. The class uses Apache Commons Lang's ToStringBuilder for generating a string representation of its instances. The class is not designed to be mutable, as all fields are declared final, ensuring thread safety and immutability. The class interacts with the 'BsonTypeInfo' class to retrieve BSON-related information, which is essential for mapping MongoDB data types to JDBC types. Overall, this class serves as a bridge between MongoDB data structures and JDBC-compatible representations.",
        "file_summary": "The 'MongoColumnInfo.java' file defines a class that holds metadata for MongoDB columns, including their data source, field names, BSON type information, and nullability. It provides methods to access this information, facilitating the integration of MongoDB with JDBC."
      }
    ]
  },
  "MongoConnection.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoConnection.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoConnection.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoConnection.java",
        "chunk_id": "MongoConnection_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static com.mongodb.AuthenticationMechanism.MONGODB_OIDC;\n<line_number-20>import static com.mongodb.AuthenticationMechanism.MONGODB_X509;\n<line_number-21>\n<line_number-22>import com.google.common.base.Preconditions;\n<line_number-23>import com.mongodb.AuthenticationMechanism;\n<line_number-24>import com.mongodb.MongoClientSettings;\n<line_number-25>import com.mongodb.MongoCredential;\n<line_number-26>import com.mongodb.MongoCredential.OidcCallback;\n<line_number-27>import com.mongodb.MongoDriverInformation;\n<line_number-28>import com.mongodb.client.MongoClient;\n<line_number-29>import com.mongodb.client.MongoClients;\n<line_number-30>import com.mongodb.client.MongoDatabase;\n<line_number-31>import com.mongodb.jdbc.logging.AutoLoggable;\n<line_number-32>import com.mongodb.jdbc.logging.DisableAutoLogging;\n<line_number-33>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-34>import com.mongodb.jdbc.logging.MongoSimpleFormatter;\n<line_number-35>import com.mongodb.jdbc.mongosql.MongoSQLException;\n<line_number-36>import com.mongodb.jdbc.mongosql.MongoSQLTranslate;\n<line_number-37>import com.mongodb.jdbc.oidc.JdbcOidcCallback;\n<line_number-38>import com.mongodb.jdbc.utils.X509Authentication;\n<line_number-39>import java.io.File;\n<line_number-40>import java.io.IOException;\n<line_number-41>import java.sql.*;\n<line_number-42>import java.util.Arrays;\n<line_number-43>import java.util.HashMap;\n<line_number-44>import java.util.Map;\n<line_number-45>import java.util.Properties;\n<line_number-46>import java.util.concurrent.*;\n<line_number-47>import java.util.concurrent.atomic.AtomicInteger;\n<line_number-48>import java.util.logging.*;\n<line_number-49>import org.bson.BsonDocument;\n<line_number-50>import org.bson.BsonInt32;\n<line_number-51>import org.bson.UuidRepresentation;\n<line_number-52>\n<line_number-53>@AutoLoggable\n<line_number-54>public class MongoConnection implements Connection {\n<line_number-55>    private MongoClientSettings mongoClientSettings;\n<line_number-56>    protected MongoClient mongoClient;\n<line_number-57>    protected String currentDB;\n<line_number-58>    protected String url;\n<line_number-59>    protected String user;\n<line_number-60>    protected char[] x509Passphrase;\n<line_number-61>    protected boolean isClosed;\n<line_number-62>    protected MongoClusterType clusterType;\n<line_number-63>    private MongoLogger logger;\n<line_number-64>    protected int connectionId;\n<line_number-65>    private static AtomicInteger connectionCounter = new AtomicInteger();\n<line_number-66>    private AtomicInteger stmtCounter = new AtomicInteger();\n<line_number-67>    private static ConsoleHandler consoleHandler;\n<line_number-68>    private static Map<String, Integer> handlerCount = new HashMap<String, Integer>();\n<line_number-69>    private static Map<String, FileHandler> fileHandlers = new HashMap<String, FileHandler>();\n<line_number-70>    private String logDirPath;\n<line_number-71>    private boolean extJsonMode;\n<line_number-72>    private UuidRepresentation uuidRepresentation;\n<line_number-73>    private String appName;\n<line_number-74>    private MongoSQLTranslate mongosqlTranslate;\n<line_number-75>\n<line_number-76>    private int serverMajorVersion;\n<line_number-77>    private int serverMinorVersion;\n<line_number-78>    private String serverVersion;\n<line_number-79>\n<line_number-80>    public static final String MONGODB_JDBC_X509_CLIENT_CERT_PATH =\n<line_number-81>            \"MONGODB_JDBC_X509_CLIENT_CERT_PATH\";\n<line_number-82>\n<line_number-83>    public int getServerMajorVersion() {\n<line_number-84>        return serverMajorVersion;\n<line_number-85>    }\n<line_number-86>\n<line_number-87>    public int getServerMinorVersion() {\n<line_number-88>        return serverMinorVersion;\n<line_number-89>    }\n<line_number-90>\n<line_number-91>    public String getServerVersion() {\n<line_number-92>        return this.serverVersion;\n<line_number-93>    }\n<line_number-94>\n<line_number-95>    protected enum MongoClusterType {\n<line_number-96>        AtlasDataFederation,\n<line_number-97>        Community,\n<line_number-98>        Enterprise,\n<line_number-99>        UnknownTarget\n<line_number-100>    }\n<line_number-101>\n<line_number-102>    public MongoConnection(\n<line_number-103>            MongoClient mongoClient,\n<line_number-104>            MongoConnectionProperties connectionProperties,\n<line_number-105>            char[] x509Passphrase) {\n<line_number-106>        this.connectionId = connectionCounter.incrementAndGet();\n<line_number-107>        initConnectionLogger(\n<line_number-108>                connectionId,\n<line_number-109>                hashCode(),\n<line_number-110>                connectionProperties.getLogLevel(),\n<line_number-111>                connectionProperties.getLogDir());\n<line_number-112>\n<line_number-113>        Preconditions.checkNotNull(connectionProperties.getConnectionString());\n<line_number-114>        initializeConnection(connectionProperties);\n<line_number-115>\n<line_number-116>        this.x509Passphrase = x509Passphrase;\n<line_number-117>        this.mongoClientSettings = createMongoClientSettings(connectionProperties);\n<line_number-118>\n<line_number-119>        if (mongoClient == null) {\n<line_number-120>            this.mongoClient =\n<line_number-121>                    MongoClients.create(\n<line_number-122>                            this.mongoClientSettings,\n<line_number-123>                            MongoDriverInformation.builder()\n<line_number-124>                                    .driverName(MongoDriver.NAME)\n<line_number-125>                                    .driverVersion(MongoDriver.getVersion())\n<line_number-126>                                    .build());\n<line_number-127>        } else {\n<line_number-128>            this.mongoClient = mongoClient;\n<line_number-129>        }\n<line_number-130>    }\n<line_number-131>\n<line_number-132>    public MongoConnection(\n<line_number-133>            MongoClient mongoClient, MongoConnectionProperties connectionProperties) {\n<line_number-134>        this(mongoClient, connectionProperties, null);\n<line_number-135>    }\n<line_number-136>\n<line_number-137>    public MongoConnection(MongoConnectionProperties connectionProperties, char[] x509Passphrase) {\n<line_number-138>        this(null, connectionProperties, x509Passphrase);\n<line_number-139>    }\n<line_number-140>\n<line_number-141>    public MongoConnection(MongoConnectionProperties connectionProperties) {\n<line_number-142>        this(null, connectionProperties);\n<line_number-143>    }\n<line_number-144>\n<line_number-145>    private void initializeConnection(MongoConnectionProperties connectionProperties) {\n<line_number-146>        this.url = connectionProperties.getConnectionString().getConnectionString();\n<line_number-147>        this.user = connectionProperties.getConnectionString().getUsername();\n<line_number-148>        this.currentDB = connectionProperties.getDatabase();\n<line_number-149>        this.extJsonMode = connectionProperties.getExtJsonMode();\n<line_number-150>        this.uuidRepresentation =\n<line_number-151>                connectionProperties.getConnectionString().getUuidRepresentation();\n<line_number-152>        this.appName = buildAppName(connectionProperties);\n<line_number-153>        this.mongosqlTranslate = new MongoSQLTranslate(this.logger);\n<line_number-154>\n<line_number-155>        this.isClosed = false;\n<line_number-156>    }\n<line_number-157>\n<line_number-158>    private String buildAppName(MongoConnectionProperties connectionProperties) {\n<line_number-159>        StringBuilder appNameBuilder =\n<line_number-160>                new StringBuilder(MongoDriver.NAME).append(\"+\").append(MongoDriver.getVersion());\n<line_number-161>\n<line_number-162>        String clientInfo = connectionProperties.getClientInfo();\n<line_number-163>        if (clientInfo != null) {\n<line_number-164>            String[] clientInfoSplit = clientInfo.split(\"\\\\+\");\n<line_number-165>            if (clientInfoSplit.length == 2) {\n<line_number-166>                appNameBuilder.append('|').append(clientInfo);\n<line_number-167>            }\n<line_number-168>        }\n<line_number-169>\n<line_number-170>        return appNameBuilder.toString();\n<line_number-171>    }\n<line_number-172>\n<line_number-173>    private MongoClientSettings createMongoClientSettings(\n<line_number-174>            MongoConnectionProperties connectionProperties) {\n<line_number-175>        MongoClientSettings.Builder settingsBuilder =\n<line_number-176>                MongoClientSettings.builder()\n<line_number-177>                        .applicationName(this.appName)\n<line_number-178>                        .applyConnectionString(connectionProperties.getConnectionString());\n<line_number-179>\n<line_number-180>        MongoCredential credential = connectionProperties.getConnectionString().getCredential();\n<line_number-181>\n<line_number-182>        if (credential != null) {\n<line_number-183>            AuthenticationMechanism authMechanism = credential.getAuthenticationMechanism();\n<line_number-184>\n<line_number-185>            if (authMechanism != null && authMechanism.equals(MONGODB_OIDC)) {\n<line_number-186>                // Handle OIDC authentication\n<line_number-187>                OidcCallback oidcCallback = new JdbcOidcCallback(this.logger);\n<line_number-188>                credential =\n<line_number-189>                        MongoCredential.createOidcCredential(\n<line_number-190>                                        connectionProperties.getConnectionString().getUsername())\n<line_number-191>                                .withMechanismProperty(\n<line_number-192>                                        MongoCredential.OIDC_HUMAN_CALLBACK_KEY, oidcCallback);\n<line_number-193>                settingsBuilder.credential(credential);\n<line_number-194>            } else if (authMechanism != null && authMechanism.equals(MONGODB_X509)) {\n<line_number-195>                String pemPath = connectionProperties.getX509PemPath();\n<line_number-196>                if (pemPath == null || pemPath.isEmpty()) {\n<line_number-197>                    pemPath = System.getenv(MONGODB_JDBC_X509_CLIENT_CERT_PATH);\n<line_number-198>                }\n<line_number-199>                if (pemPath == null || pemPath.isEmpty()) {\n<line_number-200>                    throw new IllegalStateException(\n<line_number-201>                            \"PEM file path is required for X.509 authentication but was not provided.\");\n<line_number-202>                }\n<line_number-203>\n<line_number-204>                X509Authentication x509Authentication = new X509Authentication(logger);\n<line_number-205>                x509Authentication.configureX509Authentication(\n<line_number-206>                        settingsBuilder, pemPath, this.x509Passphrase);\n<line_number-207>            }\n<line_number-208>        }\n<line_number-209>\n<line_number-210>        return settingsBuilder.build();\n<line_number-211>    }\n<line_number-212>\n<line_number-213>    protected MongoSQLTranslate getMongosqlTranslate() {\n<line_number-214>        return mongosqlTranslate;\n<line_number-215>    }\n<line_number-216>\n<line_number-217>    protected MongoClusterType getClusterType() {\n<line_number-218>        return clusterType;\n<line_number-219>    }\n<line_number-220>\n<line_number-221>    protected MongoClient getMongoClient() {\n<line_number-222>        return mongoClient;\n<line_number-223>    }\n<line_number-224>\n<line_number-225>    @DisableAutoLogging\n<line_number-226>    public MongoLogger getLogger() {\n<line_number-227>        return logger;\n<line_number-228>    }\n<line_number-229>\n<line_number-230>    protected int getNextStatementId() {\n<line_number-231>        return stmtCounter.incrementAndGet();\n<line_number-232>    }\n<line_number-233>\n<line_number-234>    protected void checkConnection() throws SQLException {\n<line_number-235>        if (isClosed) {\n<line_number-236>            throw new SQLException(\"Connection is closed.\");\n<line_number-237>        }\n<line_number-238>    }\n<line_number-239>\n<line_number-240>    private MongoClusterType determineClusterType() {\n<line_number-241>        BsonDocument buildInfoCmd = new BsonDocument();\n<line_number-242>        buildInfoCmd.put(\"buildInfo\", new BsonInt32(1));\n<line_number-243>\n<line_number-244>        // The { buildInfo: 1 } command returns information that indicates\n<line_number-245>        // the type of the cluster.\n<line_number-246>        BuildInfo buildInfoRes =\n<line_number-247>                mongoClient\n<line_number-248>                        .getDatabase(currentDB)\n<line_number-249>                        .withCodecRegistry(MongoDriver.REGISTRY)\n<line_number-250>                        .runCommand(buildInfoCmd, BuildInfo.class);\n<line_number-251>\n<line_number-252>        // if \"ok\" is not 1, then the target type could not be determined.\n<line_number-253>        if (buildInfoRes.ok != 1) {\n<line_number-254>            return MongoClusterType.UnknownTarget;\n<line_number-255>        }\n<line_number-256>\n<line_number-257>        logger.log(Level.FINE, buildInfoRes.toString());\n<line_number-258>\n<line_number-259>        this.serverVersion = buildInfoRes.getFullVersion();\n<line_number-260>\n<line_number-261>        try {\n<line_number-262>            this.serverMajorVersion = buildInfoRes.getMajorVersion();\n<line_number-263>            this.serverMinorVersion = buildInfoRes.getMinorVersion();\n<line_number-264>            // Only log issues happening while trying to compute the server version as this is not a blocker.\n<line_number-265>        } catch (Exception e) {\n<line_number-266>            logger.log(Level.SEVERE, e.toString());\n<line_number-267>        }\n<line_number-268>\n<line_number-269>        // If the \"dataLake\" field is present, it must be an ADF cluster.\n<line_number-270>        if (buildInfoRes.dataLake != null) {\n<line_number-271>            // append datalake and mongosql version to server version\n<line_number-272>            return MongoClusterType.AtlasDataFederation;\n<line_number-273>        } else if (buildInfoRes.modules != null) {\n<line_number-274>            // Otherwise, if \"modules\" is present and contains \"enterprise\",\n<line_number-275>            // this must be an Enterprise cluster.\n<line_number-276>            if (buildInfoRes.modules.contains(\"enterprise\")) {\n<line_number-277>                return MongoClusterType.Enterprise;\n<line_number-278>            }\n<line_number-279>        }\n<line_number-280>\n<line_number-281>        // Otherwise, this is a Community cluster.\n<line_number-282>        return MongoClusterType.Community;\n<line_number-283>    }\n<line_number-284>\n<line_number-285>    @Override\n<line_number-286>    public Statement createStatement() throws SQLException {\n<line_number-287>        checkConnection();\n<line_number-288>        try {\n<line_number-289>            return new MongoStatement(this, currentDB);\n<line_number-290>        } catch (IllegalArgumentException e) {\n<line_number-291>            throw new SQLException(e);\n<line_number-292>        }\n<line_number-293>    }\n<line_number-294>\n<line_number-295>    protected int getDefaultConnectionValidationTimeoutSeconds() {\n<line_number-296>        return this.mongoClientSettings.getSocketSettings().getConnectTimeout(TimeUnit.SECONDS);\n<line_number-297>    }\n<line_number-298>\n<line_number-299>    boolean getExtJsonMode() {\n<line_number-300>        return extJsonMode;\n<line_number-301>    }\n<line_number-302>\n<line_number-303>    UuidRepresentation getUuidRepresentation() {\n<line_number-304>        return uuidRepresentation;\n<line_number-305>    }\n<line_number-306>\n<line_number-307>    String getURL() {\n<line_number-308>        return url;\n<line_number-309>    }\n<line_number-310>\n<line_number-311>    String getUser() {\n<line_number-312>        return user;\n<line_number-313>    }\n<line_number-314>\n<line_number-315>    protected MongoDatabase getDatabase(String DBName) {\n<line_number-316>        return mongoClient.getDatabase(DBName);\n<line_number-317>    }\n<line_number-318>\n<line_number-319>    @Override\n<line_number-320>    public DatabaseMetaData getMetaData() throws SQLException {\n<line_number-321>        return new MongoDatabaseMetaData(this);\n<line_number-322>    }\n<line_number-323>\n<line_number-324>    @Override\n<line_number-325>    public String nativeSQL(String sql) throws SQLException {\n<line_number-326>        throw new SQLFeatureNotSupportedException(\n<line_number-327>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-328>    }\n<line_number-329>\n<line_number-330>    @Override\n<line_number-331>    public CallableStatement prepareCall(String sql) throws SQLException {\n<line_number-332>        throw new SQLFeatureNotSupportedException(\n<line_number-333>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-334>    }\n<line_number-335>\n<line_number-336>    @Override\n<line_number-337>    public PreparedStatement prepareStatement(String sql) throws SQLException {\n<line_number-338>        try {\n<line_number-339>            return new MongoPreparedStatement(sql, new MongoStatement(this, currentDB));\n<line_number-340>        } catch (IllegalArgumentException e) {\n<line_number-341>            throw new SQLException(e);\n<line_number-342>        }\n<line_number-343>    }\n<line_number-344>\n<line_number-345>    @Override\n<line_number-346>    public void setAutoCommit(boolean autoCommit) throws SQLException {\n<line_number-347>        // no-op, we only check that the connection is open\n<line_number-348>        checkConnection();\n<line_number-349>        logger.log(\n<line_number-350>                Level.WARNING,\n<line_number-351>                \"Changing the auto-commit mode has no effect. The driver doesn't support transactions and is read-only. \"\n<line_number-352>                        + \"It will always report auto-commit true. Calling Commit() or Rollback() also has no effect\");\n<line_number-353>    }\n<line_number-354>\n<line_number-355>    @Override\n<line_number-356>    public boolean getAutoCommit() throws SQLException {\n<line_number-357>        checkConnection();\n<line_number-358>        // By default, new connections are in auto-commit mode\n<line_number-359>        // and since we don't support transactions, changing the auto-commit mode is a no-op\n<line_number-360>        return true;\n<line_number-361>    }\n<line_number-362>\n<line_number-363>    @Override\n<line_number-364>    public void commit() throws SQLException {\n<line_number-365>        // no-op, we only check that the connection is open\n<line_number-366>        checkConnection();\n<line_number-367>    }\n<line_number-368>\n<line_number-369>    @Override\n<line_number-370>    public void rollback() throws SQLException {\n<line_number-371>        // no-op, we only check that the connection is open\n<line_number-372>        checkConnection();\n<line_number-373>    }\n<line_number-374>\n<line_number-375>    @Override\n<line_number-376>    public void close() {\n<line_number-377>        if (isClosed()) {\n<line_number-378>            return;\n<line_number-379>        }\n<line_number-380>\n<line_number-381>        // Decrement fileHandlerCount and delete entry\n<line_number-382>        // if no more connections are using it.\n<line_number-383>        synchronized (this) {\n<line_number-384>            if ((null != handlerCount) && handlerCount.containsKey(logDirPath)) {\n<line_number-385>                handlerCount.put(logDirPath, handlerCount.get(logDirPath) - 1);\n<line_number-386>                if (handlerCount.get(logDirPath) == 0) {\n<line_number-387>                    // Remove the FileHandler and remove this entry too\n<line_number-388>                    if (null != fileHandlers) {\n<line_number-389>                        fileHandlers.remove(logDirPath);\n<line_number-390>                    }\n<line_number-391>                    handlerCount.remove(logDirPath);\n<line_number-392>                }\n<line_number-393>            }\n<line_number-394>        }\n<line_number-395>\n<line_number-396>        isClosed = true;\n<line_number-397>    }\n<line_number-398>\n<line_number-399>    @Override\n<line_number-400>    public boolean isClosed() {\n<line_number-401>        return isClosed;\n<line_number-402>    }\n<line_number-403>\n<line_number-404>    @Override\n<line_number-405>    public void setReadOnly(boolean readOnly) throws SQLException {\n<line_number-406>        checkConnection();\n<line_number-407>    }\n<line_number-408>\n<line_number-409>    @Override\n<line_number-410>    public boolean isReadOnly() throws SQLException {\n<line_number-411>        checkConnection();\n<line_number-412>        return true;\n<line_number-413>    }\n<line_number-414>\n<line_number-415>    @Override\n<line_number-416>    public void setCatalog(String catalog) throws SQLException {\n<line_number-417>        checkConnection();\n<line_number-418>        currentDB = catalog;\n<line_number-419>    }\n<line_number-420>\n<line_number-421>    @Override\n<line_number-422>    public String getCatalog() throws SQLException {\n<line_number-423>        checkConnection();\n<line_number-424>        return currentDB;\n<line_number-425>    }\n<line_number-426>\n<line_number-427>    @Override\n<line_number-428>    public void setTransactionIsolation(int level) throws SQLException {\n<line_number-429>        checkConnection();\n<line_number-430>    }\n<line_number-431>\n<line_number-432>    @Override\n<line_number-433>    public int getTransactionIsolation() throws SQLException {\n<line_number-434>        checkConnection();\n<line_number-435>        return Connection.TRANSACTION_NONE;\n<line_number-436>    }\n<line_number-437>\n<line_number-438>    @Override\n<line_number-439>    public SQLWarning getWarnings() throws SQLException {\n<line_number-440>        checkConnection();\n<line_number-441>        return null;\n<line_number-442>    }\n<line_number-443>\n<line_number-444>    @Override\n<line_number-445>    public void clearWarnings() throws SQLException {\n<line_number-446>        checkConnection();\n<line_number-447>    }\n<line_number-448>\n<line_number-449>    // --------------------------JDBC 2.0-----------------------------\n<line_number-450>    @Override\n<line_number-451>    public Statement createStatement(int resultSetType, int resultSetConcurrency)\n<line_number-452>            throws SQLException {\n<line_number-453>        if (resultSetType == ResultSet.TYPE_FORWARD_ONLY\n<line_number-454>                && resultSetConcurrency == ResultSet.CONCUR_READ_ONLY) {\n<line_number-455>            return createStatement();\n<line_number-456>        } else {\n<line_number-457>            throw new SQLFeatureNotSupportedException(\n<line_number-458>                    Thread.currentThread().getStackTrace()[1].toString());\n<line_number-459>        }\n<line_number-460>    }\n<line_number-461>\n<line_number-462>    @Override\n<line_number-463>    public PreparedStatement prepareStatement(\n<line_number-464>            String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\n<line_number-465>        if (resultSetType == ResultSet.TYPE_FORWARD_ONLY\n<line_number-466>                && resultSetConcurrency == ResultSet.CONCUR_READ_ONLY) {\n<line_number-467>            return prepareStatement(sql);\n<line_number-468>        } else {\n<line_number-469>            throw new SQLFeatureNotSupportedException(\n<line_number-470>                    Thread.currentThread().getStackTrace()[1].toString());\n<line_number-471>        }\n<line_number-472>    }\n<line_number-473>\n<line_number-474>    @Override\n<line_number-475>    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency)\n<line_number-476>            throws SQLException {\n<line_number-477>        throw new SQLFeatureNotSupportedException(\n<line_number-478>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-479>    }\n<line_number-480>\n<line_number-481>    @Override\n<line_number-482>    public java.util.Map<String, Class<?>> getTypeMap() throws SQLException {\n<line_number-483>        throw new SQLFeatureNotSupportedException(\n<line_number-484>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-485>    }\n<line_number-486>\n<line_number-487>    @Override\n<line_number-488>    public void setTypeMap(java.util.Map<String, Class<?>> map) throws SQLException {\n<line_number-489>        throw new SQLFeatureNotSupportedException(\n<line_number-490>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-491>    }\n<line_number-492>\n<line_number-493>    // --------------------------JDBC 3.0-----------------------------\n<line_number-494>\n<line_number-495>    @Override\n<line_number-496>    public Statement createStatement(\n<line_number-497>            int resultSetType, int resultSetConcurrency, int resultSetHoldability)\n<line_number-498>            throws SQLException {\n<line_number-499>        if (resultSetType == ResultSet.TYPE_FORWARD_ONLY\n<line_number-500>                && resultSetConcurrency == ResultSet.CONCUR_READ_ONLY) {\n<line_number-501>            return createStatement();\n<line_number-502>        } else {\n<line_number-503>            throw new SQLFeatureNotSupportedException(\n<line_number-504>                    Thread.currentThread().getStackTrace()[1].toString());\n<line_number-505>        }\n<line_number-506>    }\n<line_number-507>\n<line_number-508>    @Override\n<line_number-509>    public PreparedStatement prepareStatement(\n<line_number-510>            String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)\n<line_number-511>            throws SQLException {\n<line_number-512>        throw new SQLFeatureNotSupportedException(\n<line_number-513>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-514>    }\n<line_number-515>\n<line_number-516>    @Override\n<line_number-517>    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)\n<line_number-518>            throws SQLException {\n<line_number-519>        throw new SQLFeatureNotSupportedException(\n<line_number-520>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-521>    }\n<line_number-522>\n<line_number-523>    @Override\n<line_number-524>    public PreparedStatement prepareStatement(String sql, int columnIndexes[]) throws SQLException {\n<line_number-525>        throw new SQLFeatureNotSupportedException(\n<line_number-526>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-527>    }\n<line_number-528>\n<line_number-529>    @Override\n<line_number-530>    public PreparedStatement prepareStatement(String sql, String columnNames[])\n<line_number-531>            throws SQLException {\n<line_number-532>        throw new SQLFeatureNotSupportedException(\n<line_number-533>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-534>    }\n<line_number-535>\n<line_number-536>    @Override\n<line_number-537>    public void setHoldability(int holdability) throws SQLException {\n<line_number-538>        throw new SQLFeatureNotSupportedException(\n<line_number-539>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-540>    }\n<line_number-541>\n<line_number-542>    @Override\n<line_number-543>    public int getHoldability() throws SQLException {\n<line_number-544>        throw new SQLFeatureNotSupportedException(\n<line_number-545>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-546>    }\n<line_number-547>\n<line_number-548>    @Override\n<line_number-549>    public Savepoint setSavepoint() throws SQLException {\n<line_number-550>        throw new SQLFeatureNotSupportedException(\n<line_number-551>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-552>    }\n<line_number-553>\n<line_number-554>    @Override\n<line_number-555>    public Savepoint setSavepoint(String name) throws SQLException {\n<line_number-556>        throw new SQLFeatureNotSupportedException(\n<line_number-557>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-558>    }\n<line_number-559>\n<line_number-560>    @Override\n<line_number-561>    public void rollback(Savepoint savepoint) throws SQLException {\n<line_number-562>        checkConnection();\n<line_number-563>    }\n<line_number-564>\n<line_number-565>    @Override\n<line_number-566>    public void releaseSavepoint(Savepoint savepoint) throws SQLException {\n<line_number-567>        throw new SQLFeatureNotSupportedException(\n<line_number-568>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-569>    }\n<line_number-570>\n<line_number-571>    @Override\n<line_number-572>    public CallableStatement prepareCall(\n<line_number-573>            String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)\n<line_number-574>            throws SQLException {\n<line_number-575>        throw new SQLFeatureNotSupportedException(\n<line_number-576>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-577>    }\n<line_number-578>\n<line_number-579>    @Override\n<line_number-580>    public Clob createClob() throws SQLException {\n<line_number-581>        throw new SQLFeatureNotSupportedException(\n<line_number-582>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-583>    }\n<line_number-584>\n<line_number-585>    @Override\n<line_number-586>    public Blob createBlob() throws SQLException {\n<line_number-587>        throw new SQLFeatureNotSupportedException(\n<line_number-588>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-589>    }\n<line_number-590>\n<line_number-591>    @Override\n<line_number-592>    public NClob createNClob() throws SQLException {\n<line_number-593>        throw new SQLFeatureNotSupportedException(\n<line_number-594>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-595>    }\n<line_number-596>\n<line_number-597>    @Override\n<line_number-598>    public SQLXML createSQLXML() throws SQLException {\n<line_number-599>        throw new SQLFeatureNotSupportedException(\n<line_number-600>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-601>    }\n<line_number-602>\n<line_number-603>    class ConnValidation implements Callable<Void> {\n<line_number-604>        @Override\n<line_number-605>        public Void call() throws SQLException, MongoSQLException, MongoSerializationException {\n<line_number-606>            MongoClusterType actualClusterType = determineClusterType();\n<line_number-607>            String serverInfo =\n<line_number-608>                    \"Connecting to cluster type \"\n<line_number-609>                            + actualClusterType.toString()\n<line_number-610>                            + \" with server version \"\n<line_number-611>                            + serverVersion;\n<line_number-612>            logger.log(Level.INFO, serverInfo);\n<line_number-613>\n<line_number-614>            switch (actualClusterType) {\n<line_number-615>                case AtlasDataFederation:\n<line_number-616>                    logger.log(Level.FINE, \"Connecting to Atlas Data Federation.\");\n<line_number-617>                    break;\n<line_number-618>                case Community:\n<line_number-619>                    // Community edition is disallowed.\n<line_number-620>                    throw new SQLException(\n<line_number-621>                            \"Community edition detected. The JDBC driver is intended for use with MongoDB Enterprise edition or Atlas Data Federation.\");\n<line_number-622>                case Enterprise:\n<line_number-623>                    String version = MongoDriver.getVersion();\n<line_number-624>                    if (MongoDriver.isEapBuild()) {\n<line_number-625>                        // Ensure the library is loaded if Enterprise edition detected.\n<line_number-626>                        if (!MongoDriver.isMongoSqlTranslateLibraryLoaded()) {\n<line_number-627>                            throw new SQLException(\n<line_number-628>                                    \"Enterprise edition detected, but mongosqltranslate library not found\",\n<line_number-629>                                    MongoDriver.getMongoSqlTranslateLibraryLoadError());\n<line_number-630>                        } else if (MongoDriver.getMongoSqlTranslateLibraryLoadError() != null) {\n<line_number-631>                            logger.log(\n<line_number-632>                                    Level.INFO,\n<line_number-633>                                    \"Error while loading the library using the environment variable. Library bundled with the driver used instead.\\n\"\n<line_number-634>                                            + Arrays.stream(\n<line_number-635>                                                            MongoDriver\n<line_number-636>                                                                    .getMongoSqlTranslateLibraryLoadError()\n<line_number-637>                                                                    .getStackTrace())\n<line_number-638>                                                    .map(StackTraceElement::toString));\n<line_number-639>                        }\n<line_number-640>                        String mongosqlTranslateVersion =\n<line_number-641>                                mongosqlTranslate.getMongosqlTranslateVersion().version;\n<line_number-642>                        if (!mongosqlTranslate.checkDriverVersion().compatible) {\n<line_number-643>                            throw new SQLException(\n<line_number-644>                                    \"Incompatible driver version. The JDBC driver version, \"\n<line_number-645>                                            + version\n<line_number-646>                                            + \", is not compatible with mongosqltranslate library version, \"\n<line_number-647>                                            + mongosqlTranslateVersion);\n<line_number-648>                        }\n<line_number-649>                        appName = appName + \"|libmongosqltranslate+\" + mongosqlTranslateVersion;\n<line_number-650>                    } else {\n<line_number-651>                        throw new SQLException(\n<line_number-652>                                \"Direct Cluster connection is only supported in EAP driver builds. \"\n<line_number-653>                                        + \"Your driver version ('\"\n<line_number-654>                                        + version\n<line_number-655>                                        + \"') is not an EAP build.\");\n<line_number-656>                    }\n<line_number-657>                    break;\n<line_number-658>                case UnknownTarget:\n<line_number-659>                    // Target could not be determined.\n<line_number-660>                    throw new SQLException(\n<line_number-661>                            \"Unknown cluster/target type detected. The JDBC driver is intended for use with MongoDB Enterprise edition or Atlas Data Federation.\");\n<line_number-662>            }\n<line_number-663>\n<line_number-664>            // Set the cluster type.\n<line_number-665>            clusterType = actualClusterType;\n<line_number-666>            boolean resultExists;\n<line_number-667>            try (Statement statement = createStatement()) {\n<line_number-668>                resultExists = statement.execute(\"SELECT 1\");\n<line_number-669>            }\n<line_number-670>            if (!resultExists) {\n<line_number-671>                // no resultSet returned\n<line_number-672>                throw new SQLException(\"Connection error\");\n<line_number-673>            }\n<line_number-674>            return null;\n<line_number-675>        }\n<line_number-676>    }\n<line_number-677>\n<line_number-678>    /**\n<line_number-679>     * Executes a dummy query to test the connection.\n<line_number-680>     *\n<line_number-681>     * @param timeout The query timeout.\n<line_number-682>     */\n<line_number-683>    protected void testConnection(int timeout)\n<line_number-684>            throws SQLException, InterruptedException, ExecutionException, TimeoutException {\n<line_number-685>        if (timeout < 0) {\n<line_number-686>            throw new SQLException(\"Input is invalid.\");\n<line_number-687>        }\n<line_number-688>\n<line_number-689>        if (isClosed) {\n<line_number-690>            throw new SQLException(\"Connection is closed.\");\n<line_number-691>        }\n<line_number-692>\n<line_number-693>        // We use createStatement to test the connection. Since we are not allowed\n<line_number-694>        // to set the timeout adhoc on the calls, we use Executor to run a blocked call with timeout.\n<line_number-695>        ExecutorService executor = Executors.newCachedThreadPool();\n<line_number-696>        Future<Void> future = executor.submit(new ConnValidation());\n<line_number-697>\n<line_number-698>        try {\n<line_number-699>            if (timeout > 0) {\n<line_number-700>                future.get(timeout, TimeUnit.SECONDS);\n<line_number-701>            } else {\n<line_number-702>                future.get();\n<line_number-703>            }\n<line_number-704>        } finally {\n<line_number-705>            future.cancel(true);\n<line_number-706>            executor.shutdown();\n<line_number-707>        }\n<line_number-708>    }\n<line_number-709>\n<line_number-710>    @Override\n<line_number-711>    public boolean isValid(int timeout) throws SQLException {\n<line_number-712>        try {\n<line_number-713>            testConnection(timeout);\n<line_number-714>        } catch (InterruptedException | ExecutionException | TimeoutException ex) {\n<line_number-715>            // Only propagate the SQLException\n<line_number-716>            return false;\n<line_number-717>        }\n<line_number-718>        return true;\n<line_number-719>    }\n<line_number-720>\n<line_number-721>    @Override\n<line_number-722>    public void setClientInfo(String name, String value) throws SQLClientInfoException {\n<line_number-723>        throw new SQLClientInfoException(null);\n<line_number-724>    }\n<line_number-725>\n<line_number-726>    @Override\n<line_number-727>    public void setClientInfo(Properties properties) throws SQLClientInfoException {\n<line_number-728>        throw new SQLClientInfoException(null);\n<line_number-729>    }\n<line_number-730>\n<line_number-731>    @Override\n<line_number-732>    public String getClientInfo(String name) throws SQLException {\n<line_number-733>        throw new SQLFeatureNotSupportedException(\n<line_number-734>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-735>    }\n<line_number-736>\n<line_number-737>    @Override\n<line_number-738>    public Properties getClientInfo() throws SQLException {\n<line_number-739>        throw new SQLFeatureNotSupportedException(\n<line_number-740>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-741>    }\n<line_number-742>\n<line_number-743>    @Override\n<line_number-744>    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\n<line_number-745>        throw new SQLFeatureNotSupportedException(\n<line_number-746>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-747>    }\n<line_number-748>\n<line_number-749>    @Override\n<line_number-750>    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {\n<line_number-751>        throw new SQLFeatureNotSupportedException(\n<line_number-752>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-753>    }\n<line_number-754>\n<line_number-755>    // --------------------------JDBC 4.1 -----------------------------\n<line_number-756>\n<line_number-757>    @Override\n<line_number-758>    public void setSchema(String schema) throws SQLException {\n<line_number-759>        // JDBC standard says this function is ignored if schemas are not supported.\n<line_number-760>        // So we do not want to check the connection.\n<line_number-761>    }\n<line_number-762>\n<line_number-763>    @Override\n<line_number-764>    public String getSchema() throws SQLException {\n<line_number-765>        // JDBC standard says this function is ignored if schemas are not supported.\n<line_number-766>        // So we do not want to check the connection.\n<line_number-767>        return null;\n<line_number-768>    }\n<line_number-769>\n<line_number-770>    @Override\n<line_number-771>    public void abort(Executor executor) throws SQLException {\n<line_number-772>        throw new SQLFeatureNotSupportedException(\n<line_number-773>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-774>    }\n<line_number-775>\n<line_number-776>    @Override\n<line_number-777>    public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {\n<line_number-778>        throw new SQLFeatureNotSupportedException(\n<line_number-779>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-780>    }\n<line_number-781>\n<line_number-782>    @Override\n<line_number-783>    public int getNetworkTimeout() throws SQLException {\n<line_number-784>        throw new SQLFeatureNotSupportedException(\n<line_number-785>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-786>    }\n<line_number-787>\n<line_number-788>    // JDBC 4.3\n<line_number-789>\n<line_number-790>    public void beginRequest() throws SQLException {\n<line_number-791>        throw new SQLFeatureNotSupportedException(\n<line_number-792>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-793>    }\n<line_number-794>\n<line_number-795>    public void endRequest() throws SQLException {\n<line_number-796>        throw new SQLFeatureNotSupportedException(\n<line_number-797>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-798>    }\n<line_number-799>\n<line_number-800>    // java.sql.Wrapper impl\n<line_number-801>    @Override\n<line_number-802>    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n<line_number-803>        return iface.isInstance(this);\n<line_number-804>    }\n<line_number-805>\n<line_number-806>    @SuppressWarnings(\"unchecked\")\n<line_number-807>    public <T> T unwrap(Class<T> iface) throws SQLException {\n<line_number-808>        return (T) this;\n<line_number-809>    }\n<line_number-810>\n<line_number-811>    private void initConnectionLogger(\n<line_number-812>            Integer connection_id, Integer connectionHashCode, Level logLevel, File logDir) {\n<line_number-813>        // Adding the connection hashcode as part of the logger name to differentiate the connections when the driver\n<line_number-814>        // is loaded multiple times from different classloader (there will then be multiple connections #1, #2, etc..).\n<line_number-815>        // Otherwise, a new handler will be added to the existing connection with the same id and info will be logged in\n<line_number-816>        // 2 files, potentially at different levels.\n<line_number-817>        Logger logger =\n<line_number-818>                Logger.getLogger(\n<line_number-819>                        connectionHashCode\n<line_number-820>                                + \"_\"\n<line_number-821>                                + connection_id\n<line_number-822>                                + \"_\"\n<line_number-823>                                + MongoConnection.class.getCanonicalName());\n<line_number-824>        try {\n<line_number-825>            if (logLevel != null) {\n<line_number-826>                // If log level is not OFF, create a new handler.\n<line_number-827>                // Otherwise, don't bother.\n<line_number-828>                if (logLevel != Level.OFF) {\n<line_number-829>                    // If a log directory is provided, get the file handler to log messages\n<line_number-830>                    // in that directory or create a new one if none exist yet.\n<line_number-831>                    if (logDir != null) {\n<line_number-832>                        logDirPath = logDir.getAbsolutePath();\n<line_number-833>                        synchronized (this) {\n<line_number-834>                            if (!fileHandlers.containsKey(logDirPath)) {\n<line_number-835>                                String logPath = logDirPath + File.separator + \"connection.log\";\n<line_number-836>                                // Create a new file handler with the configuration provided instead of relying on\n<line_number-837>                                // properties. This way, our handler configuration is not affected by other application\n<line_number-838>                                // using JUL\n<line_number-839>                                FileHandler fileHandler =\n<line_number-840>                                        new FileHandler(logPath, 10000000, 1, true);\n<line_number-841>                                fileHandler.setLevel(logLevel);\n<line_number-842>                                fileHandler.setFormatter(new MongoSimpleFormatter());\n<line_number-843>                                fileHandlers.put(logDirPath, fileHandler);\n<line_number-844>                                if (handlerCount.containsKey(logDirPath)) {\n<line_number-845>                                    handlerCount.put(logDirPath, handlerCount.get(logDirPath) + 1);\n<line_number-846>                                } else {\n<line_number-847>                                    handlerCount.put(logDirPath, Integer.valueOf(1));\n<line_number-848>                                }\n<line_number-849>                            }\n<line_number-850>                            logger.addHandler(fileHandlers.get(logDirPath));\n<line_number-851>                        }\n<line_number-852>                    }\n<line_number-853>                    // If no directory is provided, send the message to the console\n<line_number-854>                    else {\n<line_number-855>                        if (consoleHandler == null) {\n<line_number-856>                            consoleHandler = new ConsoleHandler();\n<line_number-857>                            consoleHandler.setFormatter(new SimpleFormatter());\n<line_number-858>                            consoleHandler.setLevel(logLevel);\n<line_number-859>                        }\n<line_number-860>                        logger.addHandler(consoleHandler);\n<line_number-861>                    }\n<line_number-862>                }\n<line_number-863>\n<line_number-864>                // Set the overall logger level too\n<line_number-865>                logger.setLevel(logLevel);\n<line_number-866>            }\n<line_number-867>        } catch (IOException e) {\n<line_number-868>            // Can't log the error since it can't open the log file\n<line_number-869>            e.printStackTrace();\n<line_number-870>        }\n<line_number-871>\n<line_number-872>        this.logger = new MongoLogger(logger, connectionId);\n<line_number-873>        // Log the driver name and version\n<line_number-874>        this.logger.log(\n<line_number-875>                Level.INFO,\n<line_number-876>                \"Connecting using \"\n<line_number-877>                        + MongoDriver.MONGO_DRIVER_NAME\n<line_number-878>                        + \" \"\n<line_number-879>                        + MongoDriver.getVersion());\n<line_number-880>    }\n<line_number-881>}\n",
        "comments": [
          {
            "comment_code_range": "53-54",
            "comment_linenumber": "54",
            "comment": "This class represents a MongoDB connection implementing the JDBC Connection interface, managing connection settings, authentication, and logging.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "102-130",
            "comment_linenumber": "102",
            "comment": "Constructor initializing the MongoConnection with a MongoClient, connection properties, and an optional X.509 passphrase.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "132-138",
            "comment_linenumber": "132",
            "comment": "Constructor initializing the MongoConnection with a MongoClient and connection properties.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "137-143",
            "comment_linenumber": "137",
            "comment": "Constructor initializing the MongoConnection with connection properties and an optional X.509 passphrase.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "145-156",
            "comment_linenumber": "145",
            "comment": "Initializes connection properties such as URL, user, database, and logging settings.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "158-170",
            "comment_linenumber": "158",
            "comment": "Builds the application name for logging based on connection properties.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "173-210",
            "comment_linenumber": "173",
            "comment": "Creates MongoClientSettings based on connection properties, handling authentication mechanisms.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "213-215",
            "comment_linenumber": "213",
            "comment": "Returns the MongoSQLTranslate instance used for SQL translation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "217-219",
            "comment_linenumber": "217",
            "comment": "Returns the current cluster type of the MongoDB connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "221-223",
            "comment_linenumber": "221",
            "comment": "Returns the MongoClient instance associated with this connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "225-227",
            "comment_linenumber": "225",
            "comment": "Returns the logger instance for this connection, with auto-logging disabled.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "230-238",
            "comment_linenumber": "230",
            "comment": "Checks if the connection is closed and throws an SQLException if it is.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "240-282",
            "comment_linenumber": "240",
            "comment": "Determines the cluster type by executing a buildInfo command and analyzing the response.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "285-290",
            "comment_linenumber": "285",
            "comment": "Creates a Statement for executing SQL commands, checking if the connection is open.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "295-296",
            "comment_linenumber": "295",
            "comment": "Returns the default connection validation timeout in seconds.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "299-300",
            "comment_linenumber": "299",
            "comment": "Returns whether the connection is in extended JSON mode.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "303-304",
            "comment_linenumber": "303",
            "comment": "Returns the UUID representation setting for this connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "307-308",
            "comment_linenumber": "307",
            "comment": "Returns the URL of the MongoDB connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "311-312",
            "comment_linenumber": "311",
            "comment": "Returns the username used for the MongoDB connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "315-317",
            "comment_linenumber": "315",
            "comment": "Returns the MongoDatabase instance for the specified database name.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "319-321",
            "comment_linenumber": "319",
            "comment": "Returns metadata about the database.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "324-334",
            "comment_linenumber": "324",
            "comment": "Throws an exception indicating that native SQL is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "336-342",
            "comment_linenumber": "336",
            "comment": "Prepares a CallableStatement, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "346-352",
            "comment_linenumber": "346",
            "comment": "Sets the auto-commit mode, which is a no-op for this driver.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "355-360",
            "comment_linenumber": "355",
            "comment": "Returns true indicating that auto-commit is always enabled.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "363-367",
            "comment_linenumber": "363",
            "comment": "Commits the transaction, which is a no-op for this driver.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "370-373",
            "comment_linenumber": "370",
            "comment": "Rolls back the transaction, which is a no-op for this driver.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "375-396",
            "comment_linenumber": "375",
            "comment": "Closes the connection and cleans up resources, including logging handlers.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "399-401",
            "comment_linenumber": "399",
            "comment": "Checks if the connection is closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "404-406",
            "comment_linenumber": "404",
            "comment": "Sets the connection to read-only mode, which is a no-op.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "409-413",
            "comment_linenumber": "409",
            "comment": "Returns true indicating that the connection is read-only.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "416-418",
            "comment_linenumber": "416",
            "comment": "Sets the current database for the connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "421-423",
            "comment_linenumber": "421",
            "comment": "Returns the current database name.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "427-430",
            "comment_linenumber": "427",
            "comment": "Sets the transaction isolation level, which is a no-op.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "433-435",
            "comment_linenumber": "433",
            "comment": "Returns the transaction isolation level, which is always TRANSACTION_NONE.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "438-441",
            "comment_linenumber": "438",
            "comment": "Returns any warnings, which are not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "444-446",
            "comment_linenumber": "444",
            "comment": "Clears any warnings, which is a no-op.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "449-455",
            "comment_linenumber": "449",
            "comment": "Creates a Statement with specified result set type and concurrency, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "462-470",
            "comment_linenumber": "462",
            "comment": "Prepares a statement with specified result set type and concurrency, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "474-478",
            "comment_linenumber": "474",
            "comment": "Prepares a CallableStatement with specified parameters, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "481-486",
            "comment_linenumber": "481",
            "comment": "Creates an array of a specified type, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "489-494",
            "comment_linenumber": "489",
            "comment": "Creates a struct of a specified type, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "755-760",
            "comment_linenumber": "755",
            "comment": "Sets the schema for the connection, which is ignored if schemas are not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "763-766",
            "comment_linenumber": "763",
            "comment": "Returns the schema for the connection, which is ignored if schemas are not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "770-773",
            "comment_linenumber": "770",
            "comment": "Aborts the connection, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "776-779",
            "comment_linenumber": "776",
            "comment": "Sets the network timeout for the connection, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "782-785",
            "comment_linenumber": "782",
            "comment": "Returns the network timeout for the connection, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "790-792",
            "comment_linenumber": "790",
            "comment": "Begins a request, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "795-797",
            "comment_linenumber": "795",
            "comment": "Ends a request, throwing an exception if not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "800-804",
            "comment_linenumber": "800",
            "comment": "Checks if this connection is a wrapper for a specified interface.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "806-809",
            "comment_linenumber": "806",
            "comment": "Unwraps this connection to the specified interface type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "811-870",
            "comment_linenumber": "811",
            "comment": "Initializes the connection logger with specified parameters, handling multiple connections and logging settings.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "603-675",
            "comment_linenumber": "603",
            "comment": "Validates the connection by determining the cluster type and executing a test query.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "678-680",
            "comment_linenumber": "678",
            "comment": "Executes a dummy query to test the connection with a specified timeout.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "710-718",
            "comment_linenumber": "710",
            "comment": "Checks if the connection is valid by testing it with a timeout.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoConnection.java' defines a class that implements the JDBC Connection interface for MongoDB. It manages connection settings, authentication, and logging. The class contains multiple constructors to initialize the connection with various parameters, including MongoClient and connection properties. It has methods for creating statements, preparing SQL commands, and managing connection states (open/close, read-only). The class also includes internal mechanisms for logging connection activities and validating the connection by executing test queries. The MongoClusterType enum defines the types of MongoDB clusters supported. The class utilizes external libraries for MongoDB operations and logging, ensuring compatibility with different authentication mechanisms such as OIDC and X.509. Overall, the class encapsulates the complexities of connecting to a MongoDB database while adhering to JDBC standards.",
        "file_summary": "The 'MongoConnection.java' file provides an implementation of the JDBC Connection interface for MongoDB, facilitating database connectivity, authentication, and logging. It supports various authentication mechanisms and manages connection states, ensuring compliance with JDBC standards."
      }
    ]
  },
  "MongoConnectionProperties.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoConnectionProperties.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoConnectionProperties.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoConnectionProperties.java",
        "chunk_id": "MongoConnectionProperties_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import com.mongodb.ConnectionString;\n<line_number-20>import java.io.File;\n<line_number-21>import java.util.logging.Level;\n<line_number-22>\n<line_number-23>public class MongoConnectionProperties {\n<line_number-24>    private ConnectionString connectionString;\n<line_number-25>    private String database;\n<line_number-26>    private Level logLevel;\n<line_number-27>    private File logDir;\n<line_number-28>    private String clientInfo;\n<line_number-29>    private boolean extJsonMode;\n<line_number-30>    private String x509PemPath;\n<line_number-31>\n<line_number-32>    public MongoConnectionProperties(\n<line_number-33>            ConnectionString connectionString,\n<line_number-34>            String database,\n<line_number-35>            Level logLevel,\n<line_number-36>            File logDir,\n<line_number-37>            String clientInfo,\n<line_number-38>            boolean extJsonMode,\n<line_number-39>            String x509PemPath) {\n<line_number-40>        this.connectionString = connectionString;\n<line_number-41>        this.database = database;\n<line_number-42>        this.logLevel = logLevel;\n<line_number-43>        this.logDir = logDir;\n<line_number-44>        this.clientInfo = clientInfo;\n<line_number-45>        this.extJsonMode = extJsonMode;\n<line_number-46>        this.x509PemPath = x509PemPath;\n<line_number-47>    }\n<line_number-48>\n<line_number-49>    public ConnectionString getConnectionString() {\n<line_number-50>        return connectionString;\n<line_number-51>    }\n<line_number-52>\n<line_number-53>    public String getDatabase() {\n<line_number-54>        return database;\n<line_number-55>    }\n<line_number-56>\n<line_number-57>    public Level getLogLevel() {\n<line_number-58>        return logLevel;\n<line_number-59>    }\n<line_number-60>\n<line_number-61>    public File getLogDir() {\n<line_number-62>        return logDir;\n<line_number-63>    }\n<line_number-64>\n<line_number-65>    public String getClientInfo() {\n<line_number-66>        return clientInfo;\n<line_number-67>    }\n<line_number-68>\n<line_number-69>    public boolean getExtJsonMode() {\n<line_number-70>        return extJsonMode;\n<line_number-71>    }\n<line_number-72>\n<line_number-73>    public String getX509PemPath() {\n<line_number-74>        return x509PemPath;\n<line_number-75>    }\n<line_number-76>\n<line_number-77>    /*\n<line_number-78>     * Generate a unique key for the connection properties. This key is used to identify the connection properties in the\n<line_number-79>     * connection cache. Properties that do not differentiate a specific client such as the log level are not included in the key.\n<line_number-80>     */\n<line_number-81>    public Integer generateKey() {\n<line_number-82>        StringBuilder keyBuilder = new StringBuilder();\n<line_number-83>        keyBuilder.append(connectionString.toString());\n<line_number-84>        if (clientInfo != null) {\n<line_number-85>            keyBuilder.append(\":clientInfo=\").append(clientInfo);\n<line_number-86>        }\n<line_number-87>        return keyBuilder.toString().hashCode();\n<line_number-88>    }\n<line_number-89>}\n",
        "comments": [
          {
            "comment_code_range": "23-47",
            "comment_linenumber": "22",
            "comment": "Represents the connection properties for MongoDB, encapsulating details such as connection string, database name, logging configuration, and client information.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "32-47",
            "comment_linenumber": "31",
            "comment": "Constructor that initializes MongoConnectionProperties with the specified connection string, database name, logging level, log directory, client information, JSON mode, and X.509 PEM path.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "49-51",
            "comment_linenumber": "48",
            "comment": "Returns the connection string used for MongoDB connections.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "53-55",
            "comment_linenumber": "52",
            "comment": "Returns the name of the database to connect to.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "57-59",
            "comment_linenumber": "56",
            "comment": "Returns the logging level for the connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "61-63",
            "comment_linenumber": "60",
            "comment": "Returns the directory where logs are stored.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "65-67",
            "comment_linenumber": "64",
            "comment": "Returns client information associated with the connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "69-71",
            "comment_linenumber": "68",
            "comment": "Indicates whether extended JSON mode is enabled for the connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "73-75",
            "comment_linenumber": "72",
            "comment": "Returns the path to the X.509 PEM file used for authentication.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "81-87",
            "comment_linenumber": "80",
            "comment": "Generates a unique key for the connection properties, excluding non-distinguishing properties like log level, to identify the connection in the cache.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoConnectionProperties.java' defines a class responsible for encapsulating the connection properties required to connect to a MongoDB database. It follows a standard Java class structure with private fields representing various connection attributes such as connection string, database name, logging level, log directory, client information, extended JSON mode, and X.509 PEM path. The class provides a constructor to initialize these properties and getter methods for each property, allowing external access to the connection details. Additionally, it includes a method to generate a unique key for the connection properties, which is useful for caching purposes. The class does not implement any interfaces or extend any other classes, indicating it is a standalone utility class. The use of private fields ensures encapsulation, and the public methods provide controlled access to the internal state of the object.",
        "file_summary": "The 'MongoConnectionProperties.java' file defines a class that encapsulates the properties required for establishing a connection to a MongoDB database, including connection string, database name, logging configurations, and client-specific information. It provides methods to retrieve these properties and generate a unique key for connection caching."
      }
    ]
  },
  "MongoDatabaseMetaData.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoDatabaseMetaData.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoDatabaseMetaData.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoDatabaseMetaData.java",
        "chunk_id": "MongoDatabaseMetaData_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.BsonTypeInfo.*;\n<line_number-20>\n<line_number-21>import com.mongodb.client.ListIndexesIterable;\n<line_number-22>import com.mongodb.client.MongoDatabase;\n<line_number-23>import com.mongodb.jdbc.logging.AutoLoggable;\n<line_number-24>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-25>import com.mongodb.jdbc.mongosql.MongoSQLException;\n<line_number-26>import java.sql.*;\n<line_number-27>import java.util.ArrayList;\n<line_number-28>import java.util.Arrays;\n<line_number-29>import java.util.Collections;\n<line_number-30>import java.util.LinkedHashMap;\n<line_number-31>import java.util.List;\n<line_number-32>import java.util.Map;\n<line_number-33>import java.util.concurrent.atomic.AtomicInteger;\n<line_number-34>import java.util.function.BiFunction;\n<line_number-35>import java.util.function.Function;\n<line_number-36>import java.util.function.Supplier;\n<line_number-37>import java.util.regex.Pattern;\n<line_number-38>import java.util.stream.Collectors;\n<line_number-39>import java.util.stream.Stream;\n<line_number-40>import org.bson.BsonBoolean;\n<line_number-41>import org.bson.BsonDocument;\n<line_number-42>import org.bson.BsonElement;\n<line_number-43>import org.bson.BsonInt32;\n<line_number-44>import org.bson.BsonNull;\n<line_number-45>import org.bson.BsonString;\n<line_number-46>import org.bson.BsonValue;\n<line_number-47>import org.bson.Document;\n<line_number-48>\n<line_number-49>@AutoLoggable\n<line_number-50>public class MongoDatabaseMetaData implements DatabaseMetaData {\n<line_number-51>    private static final BsonInt32 BSON_ZERO_INT_VALUE = new BsonInt32(0);\n<line_number-52>    private static final BsonInt32 BSON_TYPE_SEARCHABLE_INT_VALUE = new BsonInt32(typeSearchable);\n<line_number-53>    private static final BsonInt32 BSON_OTHER_INT_VALUE = new BsonInt32(Types.OTHER);\n<line_number-54>    private static final BsonInt32 BSON_COLUMN_NULLABLE_INT_VALUE =\n<line_number-55>            new BsonInt32(ResultSetMetaData.columnNullable);\n<line_number-56>    private static final BsonString BSON_EMPTY_STR_VALUE = new BsonString(\"\");\n<line_number-57>    private static final BsonString BSON_YES_STR_VALUE = new BsonString(\"YES\");\n<line_number-58>    private static final BsonString BSON_NO_STR_VALUE = new BsonString(\"NO\");\n<line_number-59>\n<line_number-60>    private static final String BOT_NAME = \"\";\n<line_number-61>    private static final String INDEX_KEY_KEY = \"key\";\n<line_number-62>    private static final String INDEX_NAME_KEY = \"name\";\n<line_number-63>\n<line_number-64>    private static final List<String> UNIQUE_KEY_PATH = Collections.singletonList(\"unique\");\n<line_number-65>\n<line_number-66>    private static final String PROCEDURE_CAT = \"PROCEDURE_CAT\";\n<line_number-67>    private static final String PROCEDURE_SCHEM = \"PROCEDURE_SCHEM\";\n<line_number-68>    private static final String PROCEDURE_NAME = \"PROCEDURE_NAME\";\n<line_number-69>    private static final String PROCEDURE_TYPE = \"PROCEDURE_TYPE\";\n<line_number-70>    private static final String REMARKS = \"REMARKS\";\n<line_number-71>    private static final String SPECIFIC_NAME = \"SPECIFIC_NAME\";\n<line_number-72>    private static final String FUNCTION_CAT = \"FUNCTION_CAT\";\n<line_number-73>    private static final String FUNCTION_SCHEM = \"FUNCTION_SCHEM\";\n<line_number-74>    private static final String FUNCTION_NAME = \"FUNCTION_NAME\";\n<line_number-75>    private static final String FUNCTION_TYPE = \"FUNCTION_TYPE\";\n<line_number-76>\n<line_number-77>    private static final String AUTO_INCREMENT = \"AUTO_INCREMENT\";\n<line_number-78>    private static final String CASE_SENSITIVE = \"CASE_SENSITIVE\";\n<line_number-79>    private static final String CHAR_OCTET_LENGTH = \"CHAR_OCTET_LENGTH\";\n<line_number-80>    private static final String COLUMN_DEF = \"COLUMN_DEF\";\n<line_number-81>    private static final String COLUMN_NAME = \"COLUMN_NAME\";\n<line_number-82>    private static final String COLUMN_TYPE = \"COLUMN_TYPE\";\n<line_number-83>    private static final String CREATE_PARAMS = \"CREATE_PARAMS\";\n<line_number-84>    private static final String DATA_TYPE = \"DATA_TYPE\";\n<line_number-85>    private static final String DEFAULT_VALUE = \"DEFAULT_VALUE\";\n<line_number-86>    private static final String DESCRIPTION = \"DESCRIPTION\";\n<line_number-87>    private static final String FIXED_PREC_SCALE = \"FIXED_PREC_SCALE\";\n<line_number-88>    private static final String FIX_PREC_SCALE = \"FIX_PREC_SCALE\";\n<line_number-89>    private static final String IS_NULLABLE = \"IS_NULLABLE\";\n<line_number-90>    private static final String LENGTH = \"LENGTH\";\n<line_number-91>    private static final String LITERAL_PREFIX = \"LITERAL_PREFIX\";\n<line_number-92>    private static final String LITERAL_SUFFIX = \"LITERAL_SUFFIX\";\n<line_number-93>    private static final String LOCAL_TYPE_NAME = \"LOCAL_TYPE_NAME\";\n<line_number-94>    private static final String MAXIMUM_SCALE = \"MAXIMUM_SCALE\";\n<line_number-95>    private static final String MAX_LEN = \"MAX_LEN\";\n<line_number-96>    private static final String MINIMUM_SCALE = \"MINIMUM_SCALE\";\n<line_number-97>    private static final String NAME = \"NAME\";\n<line_number-98>    private static final String NULLABLE = \"NULLABLE\";\n<line_number-99>    private static final String ORDINAL_POSITION = \"ORDINAL_POSITION\";\n<line_number-100>    private static final String PRECISION = \"PRECISION\";\n<line_number-101>    private static final String RADIX = \"RADIX\";\n<line_number-102>    private static final String SCALE = \"SCALE\";\n<line_number-103>    private static final String SEARCHABLE = \"SEARCHABLE\";\n<line_number-104>    private static final String SQL_DATA_TYPE = \"SQL_DATA_TYPE\";\n<line_number-105>    private static final String SQL_DATETIME_SUB = \"SQL_DATETIME_SUB\";\n<line_number-106>    private static final String TABLE_TYPE = \"TABLE_TYPE\";\n<line_number-107>    private static final String TYPE_NAME = \"TYPE_NAME\";\n<line_number-108>    private static final String UNSIGNED_ATTRIBUTE = \"UNSIGNED_ATTRIBUTE\";\n<line_number-109>\n<line_number-110>    private static final String TABLE_SCHEM = \"TABLE_SCHEM\";\n<line_number-111>    private static final String TABLE_CATALOG = \"TABLE_CATALOG\";\n<line_number-112>\n<line_number-113>    private static final String SCOPE = \"SCOPE\";\n<line_number-114>    private static final String COLUMN_SIZE = \"COLUMN_SIZE\";\n<line_number-115>    private static final String BUFFER_LENGTH = \"BUFFER_LENGTH\";\n<line_number-116>    private static final String DECIMAL_DIGITS = \"DECIMAL_DIGITS\";\n<line_number-117>    private static final String PSEUDO_COLUMN = \"PSEUDO_COLUMN\";\n<line_number-118>\n<line_number-119>    private static final String PKTABLE_CAT = \"PKTABLE_CAT\";\n<line_number-120>    private static final String PKTABLE_SCHEM = \"PKTABLE_SCHEM\";\n<line_number-121>    private static final String PKTABLE_NAME = \"PKTABLE_NAME\";\n<line_number-122>    private static final String PKCOLUMN_NAME = \"PKCOLUMN_NAME\";\n<line_number-123>    private static final String FKTABLE_CAT = \"FKTABLE_CAT\";\n<line_number-124>    private static final String FKTABLE_SCHEM = \"FKTABLE_SCHEM\";\n<line_number-125>    private static final String FKTABLE_NAME = \"FKTABLE_NAME\";\n<line_number-126>    private static final String FKCOLUMN_NAME = \"FKCOLUMN_NAME\";\n<line_number-127>    private static final String KEY_SEQ = \"KEY_SEQ\";\n<line_number-128>    private static final String UPDATE_RULE = \"UPDATE_RULE\";\n<line_number-129>    private static final String DELETE_RULE = \"DELETE_RULE\";\n<line_number-130>    private static final String FK_NAME = \"FK_NAME\";\n<line_number-131>    private static final String PK_NAME = \"PK_NAME\";\n<line_number-132>    private static final String DEFERRABILITY = \"DEFERRABILITY\";\n<line_number-133>\n<line_number-134>    private static final String TYPE_CAT = \"TYPE_CAT\";\n<line_number-135>    private static final String TYPE_SCHEM = \"TYPE_SCHEM\";\n<line_number-136>    private static final String CLASS_NAME = \"CLASS_NAME\";\n<line_number-137>    private static final String BASE_TYPE = \"BASE_TYPE\";\n<line_number-138>\n<line_number-139>    private static final String SUPERTYPE_CAT = \"SUPERTYPE_CAT\";\n<line_number-140>    private static final String SUPERTYPE_SCHEM = \"SUPERTYPE_SCHEM\";\n<line_number-141>    private static final String SUPERTYPE_NAME = \"SUPERTYPE_NAME\";\n<line_number-142>\n<line_number-143>    private static final String TABLE_CAT = \"TABLE_CAT\";\n<line_number-144>    private static final String TABLE_NAME = \"TABLE_NAME\";\n<line_number-145>    private static final String SUPERTABLE_NAME = \"SUPERTABLE_NAME\";\n<line_number-146>\n<line_number-147>    private static final String ATTR_NAME = \"ATTR_NAME\";\n<line_number-148>    private static final String ATTR_TYPE_NAME = \"ATTR_TYPE_NAME\";\n<line_number-149>    private static final String ATTR_SIZE = \"ATTR_SIZE\";\n<line_number-150>    private static final String NUM_PREC_RADIX = \"NUM_PREC_RADIX\";\n<line_number-151>    private static final String ATTR_DEF = \"ATTR_DEF\";\n<line_number-152>    private static final String SCOPE_CATALOG = \"SCOPE_CATALOG\";\n<line_number-153>    private static final String SCOPE_SCHEMA = \"SCOPE_SCHEMA\";\n<line_number-154>    private static final String SCOPE_TABLE = \"SCOPE_TABLE\";\n<line_number-155>    private static final String SOURCE_DATA_TYPE = \"SOURCE_DATA_TYPE\";\n<line_number-156>    private static final String COLUMN_USAGE = \"COLUMN_USAGE\";\n<line_number-157>\n<line_number-158>    private static final String IS_AUTOINCREMENT = \"IS_AUTOINCREMENT\";\n<line_number-159>    private static final String IS_GENERATEDCOLUMN = \"IS_GENERATEDCOLUMN\";\n<line_number-160>\n<line_number-161>    private static final String SELF_REFERENCING_COL_NAME = \"SELF_REFERENCING_COL_NAME\";\n<line_number-162>    private static final String REF_GENERATION = \"REF_GENERATION\";\n<line_number-163>\n<line_number-164>    private static final String GRANTOR = \"GRANTOR\";\n<line_number-165>    private static final String GRANTEE = \"GRANTEE\";\n<line_number-166>    private static final String PRIVILEGE = \"PRIVILEGE\";\n<line_number-167>    private static final String IS_GRANTABLE = \"IS_GRANTABLE\";\n<line_number-168>\n<line_number-169>    private static final String NON_UNIQUE = \"NON_UNIQUE\";\n<line_number-170>    private static final String INDEX_QUALIFIER = \"INDEX_QUALIFIER\";\n<line_number-171>    private static final String INDEX_NAME = \"INDEX_NAME\";\n<line_number-172>    private static final String TYPE = \"TYPE\";\n<line_number-173>    private static final String ASC_OR_DESC = \"ASC_OR_DESC\";\n<line_number-174>    private static final String CARDINALITY = \"CARDINALITY\";\n<line_number-175>    private static final String PAGES = \"PAGES\";\n<line_number-176>    private static final String FILTER_CONDITION = \"FILTER_CONDITION\";\n<line_number-177>\n<line_number-178>    // Actual max size is 16777216, we reserve 216 for other bits of encoding,\n<line_number-179>    // since this value is used to set limits on literals and field names.\n<line_number-180>    // This is arbitrary and conservative.\n<line_number-181>    private static final int APPROXIMATE_DOC_SIZE = 16777000;\n<line_number-182>    private static final String FUNC_DEFAULT_CATALOG = \"def\";\n<line_number-183>    private static final String YES = \"YES\";\n<line_number-184>\n<line_number-185>    private static final List<SortableBsonDocument.SortSpec> GET_TABLES_SORT_SPECS =\n<line_number-186>            Arrays.asList(\n<line_number-187>                    new SortableBsonDocument.SortSpec(\n<line_number-188>                            TABLE_TYPE, SortableBsonDocument.ValueType.String),\n<line_number-189>                    new SortableBsonDocument.SortSpec(\n<line_number-190>                            TABLE_CAT, SortableBsonDocument.ValueType.String),\n<line_number-191>                    new SortableBsonDocument.SortSpec(\n<line_number-192>                            TABLE_NAME, SortableBsonDocument.ValueType.String));\n<line_number-193>\n<line_number-194>    private static final List<SortableBsonDocument.SortSpec> GET_TABLE_PRIVILEGES_SORT_SPECS =\n<line_number-195>            Arrays.asList(\n<line_number-196>                    new SortableBsonDocument.SortSpec(\n<line_number-197>                            TABLE_CAT, SortableBsonDocument.ValueType.String),\n<line_number-198>                    new SortableBsonDocument.SortSpec(\n<line_number-199>                            TABLE_NAME, SortableBsonDocument.ValueType.String));\n<line_number-200>\n<line_number-201>    private static final List<SortableBsonDocument.SortSpec> GET_COLUMNS_SORT_SPECS =\n<line_number-202>            Arrays.asList(\n<line_number-203>                    new SortableBsonDocument.SortSpec(\n<line_number-204>                            TABLE_CAT, SortableBsonDocument.ValueType.String),\n<line_number-205>                    new SortableBsonDocument.SortSpec(\n<line_number-206>                            TABLE_NAME, SortableBsonDocument.ValueType.String),\n<line_number-207>                    new SortableBsonDocument.SortSpec(\n<line_number-208>                            ORDINAL_POSITION, SortableBsonDocument.ValueType.Int));\n<line_number-209>\n<line_number-210>    private static final List<SortableBsonDocument.SortSpec> GET_COLUMN_PRIVILEGES_SORT_SPECS =\n<line_number-211>            Collections.singletonList(\n<line_number-212>                    new SortableBsonDocument.SortSpec(\n<line_number-213>                            COLUMN_NAME, SortableBsonDocument.ValueType.String));\n<line_number-214>\n<line_number-215>    private static final List<SortableBsonDocument.SortSpec> GET_PRIMARY_KEYS_SORT_SPECS =\n<line_number-216>            Collections.singletonList(\n<line_number-217>                    new SortableBsonDocument.SortSpec(\n<line_number-218>                            COLUMN_NAME, SortableBsonDocument.ValueType.String));\n<line_number-219>\n<line_number-220>    private static final List<SortableBsonDocument.SortSpec> GET_INDEX_INFO_SORT_SPECS =\n<line_number-221>            Arrays.asList(\n<line_number-222>                    new SortableBsonDocument.SortSpec(\n<line_number-223>                            NON_UNIQUE, SortableBsonDocument.ValueType.Boolean),\n<line_number-224>                    new SortableBsonDocument.SortSpec(\n<line_number-225>                            INDEX_NAME, SortableBsonDocument.ValueType.String),\n<line_number-226>                    new SortableBsonDocument.SortSpec(\n<line_number-227>                            ORDINAL_POSITION, SortableBsonDocument.ValueType.Int));\n<line_number-228>\n<line_number-229>    private static final com.mongodb.jdbc.MongoFunctions MongoFunctions =\n<line_number-230>            com.mongodb.jdbc.MongoFunctions.getInstance();\n<line_number-231>\n<line_number-232>    public static final Pattern DISALLOWED_COLLECTION_NAMES =\n<line_number-233>            Pattern.compile(\"(system\\\\.(namespace|indexes|profiles|js|views))|__sql_schemas\");\n<line_number-234>\n<line_number-235>    public static final Pattern DISALLOWED_DB_NAMES = Pattern.compile(\"admin|config|local|system\");\n<line_number-236>\n<line_number-237>    private final MongoConnection conn;\n<line_number-238>    private String serverVersion;\n<line_number-239>    private MongoLogger logger;\n<line_number-240>\n<line_number-241>    public MongoDatabaseMetaData(MongoConnection conn) {\n<line_number-242>        this.conn = conn;\n<line_number-243>        logger = new MongoLogger(this.getClass().getCanonicalName(), conn.getLogger());\n<line_number-244>    }\n<line_number-245>\n<line_number-246>    // For all methods in this class, the fields in the result set are nested\n<line_number-247>    // under the bottom namespace. This helper method takes result set fields\n<line_number-248>    // and nests them appropriately.\n<line_number-249>    private BsonDocument createBottomBson(BsonElement... elements) {\n<line_number-250>        BsonDocument bot = new BsonDocument(Arrays.asList(elements));\n<line_number-251>        return new BsonDocument(BOT_NAME, bot);\n<line_number-252>    }\n<line_number-253>\n<line_number-254>    // This helper method nests result fields under the bottom namespace, and also\n<line_number-255>    // ensures the BsonDocument returned is sortable based on argued criteria.\n<line_number-256>    private SortableBsonDocument createSortableBottomBson(\n<line_number-257>            List<SortableBsonDocument.SortSpec> sortSpecs, BsonElement... elements) {\n<line_number-258>        BsonDocument bot = new BsonDocument(Arrays.asList(elements));\n<line_number-259>        return new SortableBsonDocument(sortSpecs, BOT_NAME, bot);\n<line_number-260>    }\n<line_number-261>\n<line_number-262>    // For all methods in this class, the fields in the result set are nested\n<line_number-263>    // under the bottom namespace. This helper method takes result schema fields\n<line_number-264>    // and nests them appropriately.\n<line_number-265>    private final MongoJsonSchema createBottomSchema(\n<line_number-266>            MongoJsonSchema.ScalarProperties... resultSchemaFields) {\n<line_number-267>        MongoJsonSchema resultSchema = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-268>        resultSchema.addScalarKeys(resultSchemaFields);\n<line_number-269>\n<line_number-270>        MongoJsonSchema bot = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-271>        bot.required.add(BOT_NAME);\n<line_number-272>        bot.properties.put(BOT_NAME, resultSchema);\n<line_number-273>        return bot;\n<line_number-274>    }\n<line_number-275>\n<line_number-276>    private BsonValue asBsonIntOrNull(Integer i) {\n<line_number-277>        return asBsonIntOrDefault(i, null);\n<line_number-278>    }\n<line_number-279>\n<line_number-280>    private BsonValue asBsonIntOrDefault(Integer i, Integer defaultVal) {\n<line_number-281>        if (i == null) {\n<line_number-282>            return defaultVal == null ? new BsonNull() : new BsonInt32(defaultVal);\n<line_number-283>        }\n<line_number-284>        return new BsonInt32(i);\n<line_number-285>    }\n<line_number-286>\n<line_number-287>    @Override\n<line_number-288>    public String getSQLKeywords() throws SQLException {\n<line_number-289>        // These come from keywords from the mongosql-rs parser, minus the Standard SQL-2003 Reserved keywords\n<line_number-290>        return \"AGGREGATE,\"\n<line_number-291>                + \"ASC,\"\n<line_number-292>                + \"BINDATA,\"\n<line_number-293>                + \"BIT,\"\n<line_number-294>                + \"BOOL,\"\n<line_number-295>                + \"BSON_DATE,\"\n<line_number-296>                + \"BSON_TIMESTAMP,\"\n<line_number-297>                + \"DBPOINTER,\"\n<line_number-298>                + \"DESC,\"\n<line_number-299>                + \"DOCUMENT,\"\n<line_number-300>                + \"ERROR,\"\n<line_number-301>                + \"EXTRACT,\"\n<line_number-302>                + \"FIRST,\"\n<line_number-303>                + \"JAVASCRIPT,\"\n<line_number-304>                + \"JAVASCRIPTWITHSCOPE,\"\n<line_number-305>                + \"LIMIT,\"\n<line_number-306>                + \"LONG,\"\n<line_number-307>                + \"MAXKEY,\"\n<line_number-308>                + \"MINKEY,\"\n<line_number-309>                + \"MISSING,\"\n<line_number-310>                + \"NEXT,\"\n<line_number-311>                + \"NUMBER,\"\n<line_number-312>                + \"OBJECTID,\"\n<line_number-313>                + \"OFFSET,\"\n<line_number-314>                + \"POSITION,\"\n<line_number-315>                + \"REGEX,\"\n<line_number-316>                + \"SUBSTRING,\"\n<line_number-317>                + \"SYMBOL,\"\n<line_number-318>                + \"TRIM,\"\n<line_number-319>                + \"UNDEFINED\";\n<line_number-320>    }\n<line_number-321>\n<line_number-322>    @Override\n<line_number-323>    public String getNumericFunctions() throws SQLException {\n<line_number-324>        return MongoFunctions.numericFunctionsString;\n<line_number-325>    }\n<line_number-326>\n<line_number-327>    @Override\n<line_number-328>    public String getStringFunctions() throws SQLException {\n<line_number-329>        return MongoFunctions.stringFunctionsString;\n<line_number-330>    }\n<line_number-331>\n<line_number-332>    @Override\n<line_number-333>    public String getSystemFunctions() throws SQLException {\n<line_number-334>        return MongoFunctions.systemFunctionsString;\n<line_number-335>    }\n<line_number-336>\n<line_number-337>    @Override\n<line_number-338>    public String getTimeDateFunctions() throws SQLException {\n<line_number-339>        return MongoFunctions.dateFunctionsString;\n<line_number-340>    }\n<line_number-341>\n<line_number-342>    @Override\n<line_number-343>    public ResultSet getProcedures(\n<line_number-344>            String catalog, String schemaPattern, String procedureNamePattern) throws SQLException {\n<line_number-345>        MongoJsonSchema botSchema =\n<line_number-346>                createBottomSchema(\n<line_number-347>                        new MongoJsonSchema.ScalarProperties(PROCEDURE_CAT, BSON_STRING, false),\n<line_number-348>                        new MongoJsonSchema.ScalarProperties(PROCEDURE_SCHEM, BSON_STRING, false),\n<line_number-349>                        new MongoJsonSchema.ScalarProperties(PROCEDURE_NAME, BSON_STRING),\n<line_number-350>                        new MongoJsonSchema.ScalarProperties(REMARKS, BSON_STRING),\n<line_number-351>                        new MongoJsonSchema.ScalarProperties(PROCEDURE_TYPE, BSON_INT),\n<line_number-352>                        new MongoJsonSchema.ScalarProperties(SPECIFIC_NAME, BSON_STRING));\n<line_number-353>\n<line_number-354>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-355>    }\n<line_number-356>\n<line_number-357>    @Override\n<line_number-358>    public ResultSet getProcedureColumns(\n<line_number-359>            String catalog,\n<line_number-360>            String schemaPattern,\n<line_number-361>            String procedureNamePattern,\n<line_number-362>            String columnNamePattern)\n<line_number-363>            throws SQLException {\n<line_number-364>        MongoJsonSchema botSchema =\n<line_number-365>                createBottomSchema(\n<line_number-366>                        new MongoJsonSchema.ScalarProperties(PROCEDURE_CAT, BSON_STRING, false),\n<line_number-367>                        new MongoJsonSchema.ScalarProperties(PROCEDURE_SCHEM, BSON_STRING, false),\n<line_number-368>                        new MongoJsonSchema.ScalarProperties(PROCEDURE_NAME, BSON_STRING),\n<line_number-369>                        new MongoJsonSchema.ScalarProperties(COLUMN_NAME, BSON_STRING),\n<line_number-370>                        new MongoJsonSchema.ScalarProperties(COLUMN_TYPE, BSON_INT),\n<line_number-371>                        new MongoJsonSchema.ScalarProperties(DATA_TYPE, BSON_INT),\n<line_number-372>                        new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING),\n<line_number-373>                        new MongoJsonSchema.ScalarProperties(PRECISION, BSON_INT),\n<line_number-374>                        new MongoJsonSchema.ScalarProperties(LENGTH, BSON_INT),\n<line_number-375>                        new MongoJsonSchema.ScalarProperties(SCALE, BSON_INT, false),\n<line_number-376>                        new MongoJsonSchema.ScalarProperties(RADIX, BSON_INT),\n<line_number-377>                        new MongoJsonSchema.ScalarProperties(NULLABLE, BSON_INT),\n<line_number-378>                        new MongoJsonSchema.ScalarProperties(REMARKS, BSON_STRING),\n<line_number-379>                        new MongoJsonSchema.ScalarProperties(COLUMN_DEF, BSON_STRING, false),\n<line_number-380>                        new MongoJsonSchema.ScalarProperties(SQL_DATA_TYPE, BSON_INT),\n<line_number-381>                        new MongoJsonSchema.ScalarProperties(SQL_DATETIME_SUB, BSON_INT),\n<line_number-382>                        new MongoJsonSchema.ScalarProperties(CHAR_OCTET_LENGTH, BSON_INT, false),\n<line_number-383>                        new MongoJsonSchema.ScalarProperties(ORDINAL_POSITION, BSON_INT),\n<line_number-384>                        new MongoJsonSchema.ScalarProperties(IS_NULLABLE, BSON_STRING),\n<line_number-385>                        new MongoJsonSchema.ScalarProperties(SPECIFIC_NAME, BSON_STRING));\n<line_number-386>\n<line_number-387>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-388>    }\n<line_number-389>\n<line_number-390>    @Override\n<line_number-391>    public ResultSet getTableTypes() throws SQLException {\n<line_number-392>        ArrayList<BsonDocument> docs = new ArrayList<>();\n<line_number-393>\n<line_number-394>        MongoJsonSchema schema = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-395>        schema.addScalarKeys(new MongoJsonSchema.ScalarProperties(TABLE_TYPE, BSON_STRING));\n<line_number-396>\n<line_number-397>        docs.add(createBottomBson(new BsonElement(TABLE_TYPE, new BsonString(\"TABLE\"))));\n<line_number-398>        docs.add(createBottomBson(new BsonElement(TABLE_TYPE, new BsonString(\"VIEW\"))));\n<line_number-399>\n<line_number-400>        // All fields in this result set are nested under the bottom namespace.\n<line_number-401>        MongoJsonSchema botSchema = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-402>        botSchema.properties.put(BOT_NAME, schema);\n<line_number-403>\n<line_number-404>        return new MongoResultSet(conn.getLogger(), new BsonExplicitCursor(docs), botSchema);\n<line_number-405>    }\n<line_number-406>\n<line_number-407>    // MHOUSE-7119: ADF quickstarts return empty strings and the admin database, so we filter them out\n<line_number-408>    static boolean filterEmptiesAndInternalDBs(String dbName) {\n<line_number-409>        return !dbName.isEmpty() && !DISALLOWED_DB_NAMES.matcher(dbName).matches();\n<line_number-410>    }\n<line_number-411>\n<line_number-412>    // Helper for getting a stream of all database names.\n<line_number-413>    private Stream<String> getDatabaseNames() {\n<line_number-414>        return this.conn\n<line_number-415>                .mongoClient\n<line_number-416>                .listDatabaseNames()\n<line_number-417>                .into(new ArrayList<>())\n<line_number-418>                .stream()\n<line_number-419>                .filter(dbName -> filterEmptiesAndInternalDBs(dbName));\n<line_number-420>    }\n<line_number-421>\n<line_number-422>    // Helper for getting a list of collection names from the db\n<line_number-423>    // Using runCommand instead of listCollections as listCollections does not support authorizedCollections option\n<line_number-424>    private ArrayList<MongoListTablesResult> getCollectionsFromRunCommand(MongoDatabase db) {\n<line_number-425>        MongoRunCmdListTablesResult mongoRunCmdListTablesResult =\n<line_number-426>                db.runCommand(\n<line_number-427>                        new Document(\"listCollections\", 1)\n<line_number-428>                                .append(\"authorizedCollections\", true)\n<line_number-429>                                .append(\"nameOnly\", true),\n<line_number-430>                        MongoRunCmdListTablesResult.class);\n<line_number-431>        return mongoRunCmdListTablesResult.getCursor().getFirstBatch();\n<line_number-432>    }\n<line_number-433>\n<line_number-434>    // Helper for getting a stream of MongoListCollectionsResults from the argued db that match\n<line_number-435>    // the argued filter.\n<line_number-436>    private Stream<MongoListTablesResult> getTableDataFromDB(\n<line_number-437>            String dbName, Function<MongoListTablesResult, Boolean> filter) {\n<line_number-438>        MongoDatabase db = this.conn.getDatabase(dbName).withCodecRegistry(MongoDriver.REGISTRY);\n<line_number-439>        return getCollectionsFromRunCommand(db).stream().filter(filter::apply);\n<line_number-440>    }\n<line_number-441>\n<line_number-442>    // Helper for creating BSON documents for the getTables method. Intended for use\n<line_number-443>    // with the getTableDataFromDB helper method which is shared between getTables and\n<line_number-444>    // getTablePrivileges.\n<line_number-445>    private BsonDocument toGetTablesDoc(String dbName, MongoListTablesResult res) {\n<line_number-446>        return createSortableBottomBson(\n<line_number-447>                // Per JDBC spec, sort by  TABLE_TYPE, TABLE_CAT, TABLE_SCHEM (omitted), and\n<line_number-448>                // TABLE_NAME.\n<line_number-449>                GET_TABLES_SORT_SPECS,\n<line_number-450>                new BsonElement(TABLE_CAT, new BsonString(dbName)),\n<line_number-451>                new BsonElement(TABLE_SCHEM, BsonNull.VALUE),\n<line_number-452>                new BsonElement(TABLE_NAME, new BsonString(res.name)),\n<line_number-453>                new BsonElement(TABLE_TYPE, new BsonString(res.type)),\n<line_number-454>                new BsonElement(REMARKS, BsonNull.VALUE),\n<line_number-455>                new BsonElement(TYPE_CAT, BsonNull.VALUE),\n<line_number-456>                new BsonElement(TYPE_SCHEM, BsonNull.VALUE),\n<line_number-457>                new BsonElement(TYPE_NAME, BsonNull.VALUE),\n<line_number-458>                new BsonElement(SELF_REFERENCING_COL_NAME, BsonNull.VALUE),\n<line_number-459>                new BsonElement(REF_GENERATION, BsonNull.VALUE));\n<line_number-460>    }\n<line_number-461>\n<line_number-462>    // Helper for creating BSON documents for the getTablePrivileges method. Intended\n<line_number-463>    // for use with the getTableDataFromDB helper method which is shared between getTables\n<line_number-464>    // and getTablePrivileges.\n<line_number-465>    private BsonDocument toGetTablePrivilegesDoc(String dbName, MongoListTablesResult res) {\n<line_number-466>        return createSortableBottomBson(\n<line_number-467>                // Per JDBC spec, sort by  TABLE_CAT, TABLE_SCHEM (omitted), TABLE_NAME, and\n<line_number-468>                // PRIVILEGE. Since all PRIVILEGEs are the same, we also omit that.\n<line_number-469>                GET_TABLE_PRIVILEGES_SORT_SPECS,\n<line_number-470>                new BsonElement(TABLE_CAT, new BsonString(dbName)),\n<line_number-471>                new BsonElement(TABLE_SCHEM, BsonNull.VALUE),\n<line_number-472>                new BsonElement(TABLE_NAME, new BsonString(res.name)),\n<line_number-473>                new BsonElement(GRANTOR, BsonNull.VALUE),\n<line_number-474>                new BsonElement(GRANTEE, BSON_EMPTY_STR_VALUE),\n<line_number-475>                new BsonElement(PRIVILEGE, new BsonString(\"SELECT\")),\n<line_number-476>                new BsonElement(IS_GRANTABLE, BsonNull.VALUE));\n<line_number-477>    }\n<line_number-478>\n<line_number-479>    // Helper for getting table data for all tables from a specific database. Used by\n<line_number-480>    // getTables and getTablePrivileges. The caller specifies how to serialize the table\n<line_number-481>    // info into BSON documents for the result set.\n<line_number-482>    private Stream<BsonDocument> getTableDataFromDB(\n<line_number-483>            String dbName,\n<line_number-484>            Pattern tableNamePatternRE,\n<line_number-485>            List<String> types,\n<line_number-486>            BiFunction<String, MongoListTablesResult, BsonDocument> bsonSerializer) {\n<line_number-487>\n<line_number-488>        // Filter out __sql_schemas, system.namespaces, system.indexes,system.profile,system.js,system.views\n<line_number-489>        return this.getTableDataFromDB(\n<line_number-490>                        dbName,\n<line_number-491>                        res ->\n<line_number-492>                                // Don't list system collections\n<line_number-493>                                (!DISALLOWED_COLLECTION_NAMES.matcher(res.name).matches())\n<line_number-494>                                        && (tableNamePatternRE == null\n<line_number-495>                                                || tableNamePatternRE.matcher(res.name).matches())\n<line_number-496>                                        && (types == null\n<line_number-497>                                                || types.contains(res.type.toLowerCase())))\n<line_number-498>                .map(res -> bsonSerializer.apply(dbName, res));\n<line_number-499>    }\n<line_number-500>\n<line_number-501>    private List<String> toTableTypeList(String[] types) {\n<line_number-502>        List<String> l = null;\n<line_number-503>        if (types != null) {\n<line_number-504>            l = Arrays.asList(types);\n<line_number-505>            l.replaceAll(String::toLowerCase);\n<line_number-506>        }\n<line_number-507>        return l;\n<line_number-508>    }\n<line_number-509>\n<line_number-510>    public static Pattern toJavaPattern(String sqlPattern) {\n<line_number-511>        return sqlPattern == null\n<line_number-512>                ? null\n<line_number-513>                : Pattern.compile(\n<line_number-514>                        sqlPattern\n<line_number-515>                                .replaceAll(\"([.^$*+?(){}|\\\\[\\\\]\\\\\\\\])\", \"\\\\\\\\$1\")\n<line_number-516>                                .replaceAll(\"(?<!\\\\\\\\)%\", \".*\")\n<line_number-517>                                .replaceAll(\"(?<!\\\\\\\\)_\", \".\"));\n<line_number-518>    }\n<line_number-519>\n<line_number-520>    //----------------------------------------------------------------------\n<line_number-521>    // First, a variety of minor information about the target database.\n<line_number-522>    @Override\n<line_number-523>    public boolean allProceduresAreCallable() throws SQLException {\n<line_number-524>        return true;\n<line_number-525>    }\n<line_number-526>\n<line_number-527>    @Override\n<line_number-528>    public boolean allTablesAreSelectable() throws SQLException {\n<line_number-529>        return true;\n<line_number-530>    }\n<line_number-531>\n<line_number-532>    @Override\n<line_number-533>    public String getURL() throws SQLException {\n<line_number-534>        return conn.getURL();\n<line_number-535>    }\n<line_number-536>\n<line_number-537>    @Override\n<line_number-538>    public String getUserName() throws SQLException {\n<line_number-539>        return conn.getUser();\n<line_number-540>    }\n<line_number-541>\n<line_number-542>    @Override\n<line_number-543>    public boolean isReadOnly() throws SQLException {\n<line_number-544>        return true; // we are only read-only for now.\n<line_number-545>    }\n<line_number-546>\n<line_number-547>    @Override\n<line_number-548>    public boolean nullsAreSortedHigh() throws SQLException {\n<line_number-549>        return false; // missing and NULL < all other values\n<line_number-550>    }\n<line_number-551>\n<line_number-552>    @Override\n<line_number-553>    public boolean nullsAreSortedLow() throws SQLException {\n<line_number-554>        return true; // missing and NULL < all other values\n<line_number-555>    }\n<line_number-556>\n<line_number-557>    @Override\n<line_number-558>    public boolean nullsAreSortedAtStart() throws SQLException {\n<line_number-559>        return false; // missing and NULL < all other values\n<line_number-560>    }\n<line_number-561>\n<line_number-562>    @Override\n<line_number-563>    public boolean nullsAreSortedAtEnd() throws SQLException {\n<line_number-564>        return false; // missing and NULL < all other values\n<line_number-565>    }\n<line_number-566>\n<line_number-567>    @Override\n<line_number-568>    public String getDatabaseProductName() throws SQLException {\n<line_number-569>        return MongoDriver.MONGODB_PRODUCT_NAME;\n<line_number-570>    }\n<line_number-571>\n<line_number-572>    @Override\n<line_number-573>    public String getDatabaseProductVersion() throws SQLException {\n<line_number-574>        return conn.getServerVersion();\n<line_number-575>    }\n<line_number-576>\n<line_number-577>    @Override\n<line_number-578>    public String getDriverName() throws SQLException {\n<line_number-579>        return MongoDriver.MONGO_DRIVER_NAME;\n<line_number-580>    }\n<line_number-581>\n<line_number-582>    @Override\n<line_number-583>    public String getDriverVersion() throws SQLException {\n<line_number-584>        return MongoDriver.VERSION;\n<line_number-585>    }\n<line_number-586>\n<line_number-587>    @Override\n<line_number-588>    public int getDriverMajorVersion() {\n<line_number-589>        return MongoDriver.MAJOR_VERSION;\n<line_number-590>    }\n<line_number-591>\n<line_number-592>    @Override\n<line_number-593>    public int getDriverMinorVersion() {\n<line_number-594>        return MongoDriver.MINOR_VERSION;\n<line_number-595>    }\n<line_number-596>\n<line_number-597>    @Override\n<line_number-598>    public boolean usesLocalFiles() throws SQLException {\n<line_number-599>        // No files are local on Atlas Data Lake\n<line_number-600>        return false;\n<line_number-601>    }\n<line_number-602>\n<line_number-603>    @Override\n<line_number-604>    public boolean usesLocalFilePerTable() throws SQLException {\n<line_number-605>        // No files are local on Atlas Data Lake\n<line_number-606>        return false;\n<line_number-607>    }\n<line_number-608>\n<line_number-609>    @Override\n<line_number-610>    public boolean supportsMixedCaseIdentifiers() throws SQLException {\n<line_number-611>        return true;\n<line_number-612>    }\n<line_number-613>\n<line_number-614>    @Override\n<line_number-615>    public boolean storesUpperCaseIdentifiers() throws SQLException {\n<line_number-616>        return false;\n<line_number-617>    }\n<line_number-618>\n<line_number-619>    @Override\n<line_number-620>    public boolean storesLowerCaseIdentifiers() throws SQLException {\n<line_number-621>        return false;\n<line_number-622>    }\n<line_number-623>\n<line_number-624>    @Override\n<line_number-625>    public boolean storesMixedCaseIdentifiers() throws SQLException {\n<line_number-626>        return supportsMixedCaseIdentifiers();\n<line_number-627>    }\n<line_number-628>\n<line_number-629>    @Override\n<line_number-630>    public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\n<line_number-631>        return true;\n<line_number-632>    }\n<line_number-633>\n<line_number-634>    @Override\n<line_number-635>    public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {\n<line_number-636>        return false;\n<line_number-637>    }\n<line_number-638>\n<line_number-639>    @Override\n<line_number-640>    public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {\n<line_number-641>        return false;\n<line_number-642>    }\n<line_number-643>\n<line_number-644>    @Override\n<line_number-645>    public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {\n<line_number-646>        return true;\n<line_number-647>    }\n<line_number-648>\n<line_number-649>    @Override\n<line_number-650>    public String getIdentifierQuoteString() throws SQLException {\n<line_number-651>        return \"`\";\n<line_number-652>    }\n<line_number-653>\n<line_number-654>    @Override\n<line_number-655>    public String getSearchStringEscape() throws SQLException {\n<line_number-656>        return \"\\\\\";\n<line_number-657>    }\n<line_number-658>\n<line_number-659>    @Override\n<line_number-660>    public String getExtraNameCharacters() throws SQLException {\n<line_number-661>        // Retrieves all the \"extra\" characters that can be used in unquoted identifier names (those beyond a-z, A-Z, 0-9 and _).\n<line_number-662>        return \"\";\n<line_number-663>    }\n<line_number-664>\n<line_number-665>    //--------------------------------------------------------------------\n<line_number-666>    // Functions describing which features are supported.\n<line_number-667>\n<line_number-668>    @Override\n<line_number-669>    public boolean supportsAlterTableWithAddColumn() throws SQLException {\n<line_number-670>        return false;\n<line_number-671>    }\n<line_number-672>\n<line_number-673>    @Override\n<line_number-674>    public boolean supportsAlterTableWithDropColumn() throws SQLException {\n<line_number-675>        return false;\n<line_number-676>    }\n<line_number-677>\n<line_number-678>    @Override\n<line_number-679>    public boolean supportsColumnAliasing() throws SQLException {\n<line_number-680>        return true;\n<line_number-681>    }\n<line_number-682>\n<line_number-683>    @Override\n<line_number-684>    public boolean nullPlusNonNullIsNull() throws SQLException {\n<line_number-685>        return true;\n<line_number-686>    }\n<line_number-687>\n<line_number-688>    @Override\n<line_number-689>    public boolean supportsConvert() throws SQLException {\n<line_number-690>        return true;\n<line_number-691>    }\n<line_number-692>\n<line_number-693>    @Override\n<line_number-694>    public boolean supportsConvert(int fromType, int toType) throws SQLException {\n<line_number-695>        switch (toType) {\n<line_number-696>            case Types.ARRAY:\n<line_number-697>                return false;\n<line_number-698>            case Types.BLOB:\n<line_number-699>            case Types.BINARY:\n<line_number-700>            case Types.BIT:\n<line_number-701>            case Types.TIMESTAMP:\n<line_number-702>            case Types.DECIMAL:\n<line_number-703>            case Types.DOUBLE:\n<line_number-704>            case Types.INTEGER:\n<line_number-705>            case Types.LONGVARCHAR:\n<line_number-706>            case Types.NULL:\n<line_number-707>                return true;\n<line_number-708>        }\n<line_number-709>        return false;\n<line_number-710>    }\n<line_number-711>\n<line_number-712>    @Override\n<line_number-713>    public boolean supportsTableCorrelationNames() throws SQLException {\n<line_number-714>        return true;\n<line_number-715>    }\n<line_number-716>\n<line_number-717>    @Override\n<line_number-718>    public boolean supportsDifferentTableCorrelationNames() throws SQLException {\n<line_number-719>        return false;\n<line_number-720>    }\n<line_number-721>\n<line_number-722>    @Override\n<line_number-723>    public boolean supportsExpressionsInOrderBy() throws SQLException {\n<line_number-724>        return true;\n<line_number-725>    }\n<line_number-726>\n<line_number-727>    @Override\n<line_number-728>    public boolean supportsOrderByUnrelated() throws SQLException {\n<line_number-729>        return true;\n<line_number-730>    }\n<line_number-731>\n<line_number-732>    @Override\n<line_number-733>    public boolean supportsGroupBy() throws SQLException {\n<line_number-734>        return true;\n<line_number-735>    }\n<line_number-736>\n<line_number-737>    @Override\n<line_number-738>    public boolean supportsGroupByUnrelated() throws SQLException {\n<line_number-739>        return true;\n<line_number-740>    }\n<line_number-741>\n<line_number-742>    @Override\n<line_number-743>    public boolean supportsGroupByBeyondSelect() throws SQLException {\n<line_number-744>        return true;\n<line_number-745>    }\n<line_number-746>\n<line_number-747>    @Override\n<line_number-748>    public boolean supportsLikeEscapeClause() throws SQLException {\n<line_number-749>        return true;\n<line_number-750>    }\n<line_number-751>\n<line_number-752>    @Override\n<line_number-753>    public boolean supportsMultipleResultSets() throws SQLException {\n<line_number-754>        return false;\n<line_number-755>    }\n<line_number-756>\n<line_number-757>    @Override\n<line_number-758>    public boolean supportsMultipleTransactions() throws SQLException {\n<line_number-759>        // We don't support transactions for now.\n<line_number-760>        return false;\n<line_number-761>    }\n<line_number-762>\n<line_number-763>    @Override\n<line_number-764>    public boolean supportsNonNullableColumns() throws SQLException {\n<line_number-765>        return false;\n<line_number-766>    }\n<line_number-767>\n<line_number-768>    @Override\n<line_number-769>    public boolean supportsMinimumSQLGrammar() throws SQLException {\n<line_number-770>        // If this isn't true, it's a bug.\n<line_number-771>        return true;\n<line_number-772>    }\n<line_number-773>\n<line_number-774>    @Override\n<line_number-775>    public boolean supportsCoreSQLGrammar() throws SQLException {\n<line_number-776>        // If this isn't true, it's a bug.\n<line_number-777>        return true;\n<line_number-778>    }\n<line_number-779>\n<line_number-780>    @Override\n<line_number-781>    public boolean supportsExtendedSQLGrammar() throws SQLException {\n<line_number-782>        return false;\n<line_number-783>    }\n<line_number-784>\n<line_number-785>    @Override\n<line_number-786>    public boolean supportsANSI92EntryLevelSQL() throws SQLException {\n<line_number-787>        // If it does not, this is a bug.\n<line_number-788>        return true;\n<line_number-789>    }\n<line_number-790>\n<line_number-791>    @Override\n<line_number-792>    public boolean supportsANSI92IntermediateSQL() throws SQLException {\n<line_number-793>        // If it does not, this is a bug.\n<line_number-794>        return true;\n<line_number-795>    }\n<line_number-796>\n<line_number-797>    @Override\n<line_number-798>    public boolean supportsANSI92FullSQL() throws SQLException {\n<line_number-799>        return true;\n<line_number-800>    }\n<line_number-801>\n<line_number-802>    @Override\n<line_number-803>    public boolean supportsIntegrityEnhancementFacility() throws SQLException {\n<line_number-804>        return false;\n<line_number-805>    }\n<line_number-806>\n<line_number-807>    @Override\n<line_number-808>    public boolean supportsOuterJoins() throws SQLException {\n<line_number-809>        return true;\n<line_number-810>    }\n<line_number-811>\n<line_number-812>    @Override\n<line_number-813>    public boolean supportsFullOuterJoins() throws SQLException {\n<line_number-814>        return false;\n<line_number-815>    }\n<line_number-816>\n<line_number-817>    @Override\n<line_number-818>    public boolean supportsLimitedOuterJoins() throws SQLException {\n<line_number-819>        return false;\n<line_number-820>    }\n<line_number-821>\n<line_number-822>    @Override\n<line_number-823>    public String getSchemaTerm() throws SQLException {\n<line_number-824>        // We do not support schemata.\n<line_number-825>        return \"schema\";\n<line_number-826>    }\n<line_number-827>\n<line_number-828>    @Override\n<line_number-829>    public String getProcedureTerm() throws SQLException {\n<line_number-830>        // We do not support procedures.\n<line_number-831>        return \"procedure\";\n<line_number-832>    }\n<line_number-833>\n<line_number-834>    @Override\n<line_number-835>    public String getCatalogTerm() throws SQLException {\n<line_number-836>        return \"database\";\n<line_number-837>    }\n<line_number-838>\n<line_number-839>    @Override\n<line_number-840>    public boolean isCatalogAtStart() throws SQLException {\n<line_number-841>        return true;\n<line_number-842>    }\n<line_number-843>\n<line_number-844>    @Override\n<line_number-845>    public String getCatalogSeparator() throws SQLException {\n<line_number-846>        return \".\";\n<line_number-847>    }\n<line_number-848>\n<line_number-849>    @Override\n<line_number-850>    public boolean supportsSchemasInDataManipulation() throws SQLException {\n<line_number-851>        return false;\n<line_number-852>    }\n<line_number-853>\n<line_number-854>    @Override\n<line_number-855>    public boolean supportsSchemasInProcedureCalls() throws SQLException {\n<line_number-856>        return false;\n<line_number-857>    }\n<line_number-858>\n<line_number-859>    @Override\n<line_number-860>    public boolean supportsSchemasInTableDefinitions() throws SQLException {\n<line_number-861>        return false;\n<line_number-862>    }\n<line_number-863>\n<line_number-864>    @Override\n<line_number-865>    public boolean supportsSchemasInIndexDefinitions() throws SQLException {\n<line_number-866>        return false;\n<line_number-867>    }\n<line_number-868>\n<line_number-869>    @Override\n<line_number-870>    public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {\n<line_number-871>        return false;\n<line_number-872>    }\n<line_number-873>\n<line_number-874>    @Override\n<line_number-875>    public boolean supportsCatalogsInDataManipulation() throws SQLException {\n<line_number-876>        // at least when we support data manipulation calls. Also A => B and !A ==> true.\n<line_number-877>        return true;\n<line_number-878>    }\n<line_number-879>\n<line_number-880>    @Override\n<line_number-881>    public boolean supportsCatalogsInProcedureCalls() throws SQLException {\n<line_number-882>        // at least when we support data manipulation calls. Also A => B and !A ==> true.\n<line_number-883>        return true;\n<line_number-884>    }\n<line_number-885>\n<line_number-886>    @Override\n<line_number-887>    public boolean supportsCatalogsInTableDefinitions() throws SQLException {\n<line_number-888>        // at least when we support data manipulation calls. Also A => B and !A ==> true.\n<line_number-889>        return true;\n<line_number-890>    }\n<line_number-891>\n<line_number-892>    @Override\n<line_number-893>    public boolean supportsCatalogsInIndexDefinitions() throws SQLException {\n<line_number-894>        // at least when we support data manipulation calls. Also A => B and !A ==> true.\n<line_number-895>        return true;\n<line_number-896>    }\n<line_number-897>\n<line_number-898>    @Override\n<line_number-899>    public boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException {\n<line_number-900>        // at least when we support data manipulation calls. Also A => B and !A ==> true.\n<line_number-901>        return true;\n<line_number-902>    }\n<line_number-903>\n<line_number-904>    @Override\n<line_number-905>    public boolean supportsPositionedDelete() throws SQLException {\n<line_number-906>        return false;\n<line_number-907>    }\n<line_number-908>\n<line_number-909>    @Override\n<line_number-910>    public boolean supportsPositionedUpdate() throws SQLException {\n<line_number-911>        return false;\n<line_number-912>    }\n<line_number-913>\n<line_number-914>    @Override\n<line_number-915>    public boolean supportsSelectForUpdate() throws SQLException {\n<line_number-916>        return false;\n<line_number-917>    }\n<line_number-918>\n<line_number-919>    @Override\n<line_number-920>    public boolean supportsStoredProcedures() throws SQLException {\n<line_number-921>        return false;\n<line_number-922>    }\n<line_number-923>\n<line_number-924>    @Override\n<line_number-925>    public boolean supportsSubqueriesInComparisons() throws SQLException {\n<line_number-926>        return true;\n<line_number-927>    }\n<line_number-928>\n<line_number-929>    @Override\n<line_number-930>    public boolean supportsSubqueriesInExists() throws SQLException {\n<line_number-931>        return true;\n<line_number-932>    }\n<line_number-933>\n<line_number-934>    @Override\n<line_number-935>    public boolean supportsSubqueriesInIns() throws SQLException {\n<line_number-936>        return true;\n<line_number-937>    }\n<line_number-938>\n<line_number-939>    @Override\n<line_number-940>    public boolean supportsSubqueriesInQuantifieds() throws SQLException {\n<line_number-941>        return true;\n<line_number-942>    }\n<line_number-943>\n<line_number-944>    @Override\n<line_number-945>    public boolean supportsCorrelatedSubqueries() throws SQLException {\n<line_number-946>        return true;\n<line_number-947>    }\n<line_number-948>\n<line_number-949>    @Override\n<line_number-950>    public boolean supportsUnion() throws SQLException {\n<line_number-951>        return true;\n<line_number-952>    }\n<line_number-953>\n<line_number-954>    @Override\n<line_number-955>    public boolean supportsUnionAll() throws SQLException {\n<line_number-956>        return true;\n<line_number-957>    }\n<line_number-958>\n<line_number-959>    @Override\n<line_number-960>    public boolean supportsOpenCursorsAcrossCommit() throws SQLException {\n<line_number-961>        // Though we don't support commit.\n<line_number-962>        return true;\n<line_number-963>    }\n<line_number-964>\n<line_number-965>    @Override\n<line_number-966>    public boolean supportsOpenCursorsAcrossRollback() throws SQLException {\n<line_number-967>        // Though we don't support rollback.\n<line_number-968>        return true;\n<line_number-969>    }\n<line_number-970>\n<line_number-971>    @Override\n<line_number-972>    public boolean supportsOpenStatementsAcrossCommit() throws SQLException {\n<line_number-973>        // Though we don't support commit.\n<line_number-974>        return true;\n<line_number-975>    }\n<line_number-976>\n<line_number-977>    @Override\n<line_number-978>    public boolean supportsOpenStatementsAcrossRollback() throws SQLException {\n<line_number-979>        // Though we don't support rollback.\n<line_number-980>        return true;\n<line_number-981>    }\n<line_number-982>\n<line_number-983>    //----------------------------------------------------------------------\n<line_number-984>    // The following group of methods exposes various limitations\n<line_number-985>    // based on the target database with the current driver.\n<line_number-986>    // Unless otherwise specified, a result of zero means there is no\n<line_number-987>    // limit, or the limit is not known.\n<line_number-988>    @Override\n<line_number-989>    public int getMaxBinaryLiteralLength() throws SQLException {\n<line_number-990>        return APPROXIMATE_DOC_SIZE;\n<line_number-991>    }\n<line_number-992>\n<line_number-993>    @Override\n<line_number-994>    public int getMaxCharLiteralLength() throws SQLException {\n<line_number-995>        return APPROXIMATE_DOC_SIZE;\n<line_number-996>    }\n<line_number-997>\n<line_number-998>    @Override\n<line_number-999>    public int getMaxColumnNameLength() throws SQLException {\n<line_number-1000>        return APPROXIMATE_DOC_SIZE;\n<line_number-1001>    }\n<line_number-1002>\n<line_number-1003>    @Override\n<line_number-1004>    public int getMaxColumnsInGroupBy() throws SQLException {\n<line_number-1005>        // No specific max size, though it would be limited by max document size.\n<line_number-1006>        return 0;\n<line_number-1007>    }\n<line_number-1008>\n<line_number-1009>    @Override\n<line_number-1010>    public int getMaxColumnsInIndex() throws SQLException {\n<line_number-1011>        // MongoDB has no limit in 4.2+. Datalake doesn't support indexes, yet,\n<line_number-1012>        // but returning 0 is fine.\n<line_number-1013>        return 0;\n<line_number-1014>    }\n<line_number-1015>\n<line_number-1016>    @Override\n<line_number-1017>    public int getMaxColumnsInOrderBy() throws SQLException {\n<line_number-1018>        // The only limit would be based on document size.\n<line_number-1019>        return 0;\n<line_number-1020>    }\n<line_number-1021>\n<line_number-1022>    @Override\n<line_number-1023>    public int getMaxColumnsInSelect() throws SQLException {\n<line_number-1024>        // The only limit would be based on document size.\n<line_number-1025>        return 0;\n<line_number-1026>    }\n<line_number-1027>\n<line_number-1028>    @Override\n<line_number-1029>    public int getMaxColumnsInTable() throws SQLException {\n<line_number-1030>        return 0;\n<line_number-1031>    }\n<line_number-1032>\n<line_number-1033>    @Override\n<line_number-1034>    public int getMaxConnections() throws SQLException {\n<line_number-1035>        return 0;\n<line_number-1036>    }\n<line_number-1037>\n<line_number-1038>    @Override\n<line_number-1039>    public int getMaxCursorNameLength() throws SQLException {\n<line_number-1040>        return 0;\n<line_number-1041>    }\n<line_number-1042>\n<line_number-1043>    @Override\n<line_number-1044>    public int getMaxIndexLength() throws SQLException {\n<line_number-1045>        return 0;\n<line_number-1046>    }\n<line_number-1047>\n<line_number-1048>    @Override\n<line_number-1049>    public int getMaxSchemaNameLength() throws SQLException {\n<line_number-1050>        return 0;\n<line_number-1051>    }\n<line_number-1052>\n<line_number-1053>    @Override\n<line_number-1054>    public int getMaxProcedureNameLength() throws SQLException {\n<line_number-1055>        return 0;\n<line_number-1056>    }\n<line_number-1057>\n<line_number-1058>    @Override\n<line_number-1059>    public int getMaxCatalogNameLength() throws SQLException {\n<line_number-1060>        return 255;\n<line_number-1061>    }\n<line_number-1062>\n<line_number-1063>    @Override\n<line_number-1064>    public int getMaxRowSize() throws SQLException {\n<line_number-1065>        return APPROXIMATE_DOC_SIZE;\n<line_number-1066>    }\n<line_number-1067>\n<line_number-1068>    @Override\n<line_number-1069>    public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {\n<line_number-1070>        return true;\n<line_number-1071>    }\n<line_number-1072>\n<line_number-1073>    @Override\n<line_number-1074>    public int getMaxStatementLength() throws SQLException {\n<line_number-1075>        return APPROXIMATE_DOC_SIZE;\n<line_number-1076>    }\n<line_number-1077>\n<line_number-1078>    @Override\n<line_number-1079>    public int getMaxStatements() throws SQLException {\n<line_number-1080>        return 0;\n<line_number-1081>    }\n<line_number-1082>\n<line_number-1083>    @Override\n<line_number-1084>    public int getMaxTableNameLength() throws SQLException {\n<line_number-1085>        return APPROXIMATE_DOC_SIZE;\n<line_number-1086>    }\n<line_number-1087>\n<line_number-1088>    @Override\n<line_number-1089>    public int getMaxTablesInSelect() throws SQLException {\n<line_number-1090>        return 0;\n<line_number-1091>    }\n<line_number-1092>\n<line_number-1093>    @Override\n<line_number-1094>    public int getMaxUserNameLength() throws SQLException {\n<line_number-1095>        return APPROXIMATE_DOC_SIZE;\n<line_number-1096>    }\n<line_number-1097>\n<line_number-1098>    //----------------------------------------------------------------------\n<line_number-1099>\n<line_number-1100>    @Override\n<line_number-1101>    public int getDefaultTransactionIsolation() throws SQLException {\n<line_number-1102>        return java.sql.Connection.TRANSACTION_NONE;\n<line_number-1103>    }\n<line_number-1104>\n<line_number-1105>    @Override\n<line_number-1106>    public boolean supportsTransactions() throws SQLException {\n<line_number-1107>        return false;\n<line_number-1108>    }\n<line_number-1109>\n<line_number-1110>    @Override\n<line_number-1111>    public boolean supportsTransactionIsolationLevel(int level) throws SQLException {\n<line_number-1112>        return level == java.sql.Connection.TRANSACTION_NONE;\n<line_number-1113>    }\n<line_number-1114>\n<line_number-1115>    @Override\n<line_number-1116>    public boolean supportsDataDefinitionAndDataManipulationTransactions() throws SQLException {\n<line_number-1117>        // at least when we support data manipulation calls. Also A => B and !A ==> true.\n<line_number-1118>        return true;\n<line_number-1119>    }\n<line_number-1120>\n<line_number-1121>    @Override\n<line_number-1122>    public boolean supportsDataManipulationTransactionsOnly() throws SQLException {\n<line_number-1123>        return false;\n<line_number-1124>    }\n<line_number-1125>\n<line_number-1126>    @Override\n<line_number-1127>    public boolean dataDefinitionCausesTransactionCommit() throws SQLException {\n<line_number-1128>        return false;\n<line_number-1129>    }\n<line_number-1130>\n<line_number-1131>    @Override\n<line_number-1132>    public boolean dataDefinitionIgnoredInTransactions() throws SQLException {\n<line_number-1133>        return false;\n<line_number-1134>    }\n<line_number-1135>\n<line_number-1136>    //--------------------------JDBC 2.0-----------------------------\n<line_number-1137>    @Override\n<line_number-1138>    public boolean supportsResultSetType(int type) throws SQLException {\n<line_number-1139>        return type == ResultSet.TYPE_FORWARD_ONLY;\n<line_number-1140>    }\n<line_number-1141>\n<line_number-1142>    @Override\n<line_number-1143>    public boolean supportsResultSetConcurrency(int type, int concurrency) throws SQLException {\n<line_number-1144>        return type == ResultSet.TYPE_FORWARD_ONLY && concurrency == ResultSet.CONCUR_READ_ONLY;\n<line_number-1145>    }\n<line_number-1146>\n<line_number-1147>    @Override\n<line_number-1148>    public boolean ownUpdatesAreVisible(int type) throws SQLException {\n<line_number-1149>        // We do not have updates.\n<line_number-1150>        return false;\n<line_number-1151>    }\n<line_number-1152>\n<line_number-1153>    @Override\n<line_number-1154>    public boolean ownDeletesAreVisible(int type) throws SQLException {\n<line_number-1155>        // We do not have deletes.\n<line_number-1156>        return false;\n<line_number-1157>    }\n<line_number-1158>\n<line_number-1159>    @Override\n<line_number-1160>    public boolean ownInsertsAreVisible(int type) throws SQLException {\n<line_number-1161>        // We do not have inserts.\n<line_number-1162>        return false;\n<line_number-1163>    }\n<line_number-1164>\n<line_number-1165>    @Override\n<line_number-1166>    public boolean othersUpdatesAreVisible(int type) throws SQLException {\n<line_number-1167>        // We do not have updates.\n<line_number-1168>        return false;\n<line_number-1169>    }\n<line_number-1170>\n<line_number-1171>    @Override\n<line_number-1172>    public boolean othersDeletesAreVisible(int type) throws SQLException {\n<line_number-1173>        // We do not have deletes.\n<line_number-1174>        return false;\n<line_number-1175>    }\n<line_number-1176>\n<line_number-1177>    @Override\n<line_number-1178>    public boolean othersInsertsAreVisible(int type) throws SQLException {\n<line_number-1179>        // We do not have inserts.\n<line_number-1180>        return false;\n<line_number-1181>    }\n<line_number-1182>\n<line_number-1183>    @Override\n<line_number-1184>    public boolean updatesAreDetected(int type) throws SQLException {\n<line_number-1185>        // We do not have updates.\n<line_number-1186>        return false;\n<line_number-1187>    }\n<line_number-1188>\n<line_number-1189>    @Override\n<line_number-1190>    public boolean deletesAreDetected(int type) throws SQLException {\n<line_number-1191>        // We do not have deletes.\n<line_number-1192>        return false;\n<line_number-1193>    }\n<line_number-1194>\n<line_number-1195>    @Override\n<line_number-1196>    public boolean insertsAreDetected(int type) throws SQLException {\n<line_number-1197>        // We do not have inserts.\n<line_number-1198>        return false;\n<line_number-1199>    }\n<line_number-1200>\n<line_number-1201>    @Override\n<line_number-1202>    public boolean supportsBatchUpdates() throws SQLException {\n<line_number-1203>        // We do not have updates.\n<line_number-1204>        return false;\n<line_number-1205>    }\n<line_number-1206>\n<line_number-1207>    @Override\n<line_number-1208>    public Connection getConnection() throws SQLException {\n<line_number-1209>        return conn;\n<line_number-1210>    }\n<line_number-1211>\n<line_number-1212>    // ------------------- JDBC 3.0 -------------------------\n<line_number-1213>\n<line_number-1214>    @Override\n<line_number-1215>    public boolean supportsSavepoints() throws SQLException {\n<line_number-1216>        return false;\n<line_number-1217>    }\n<line_number-1218>\n<line_number-1219>    @Override\n<line_number-1220>    public boolean supportsNamedParameters() throws SQLException {\n<line_number-1221>        return false;\n<line_number-1222>    }\n<line_number-1223>\n<line_number-1224>    @Override\n<line_number-1225>    public boolean supportsMultipleOpenResults() throws SQLException {\n<line_number-1226>        return false;\n<line_number-1227>    }\n<line_number-1228>\n<line_number-1229>    @Override\n<line_number-1230>    public boolean supportsGetGeneratedKeys() throws SQLException {\n<line_number-1231>        // This is related to keys generated automatically on inserts,\n<line_number-1232>        // and we do not support inserts.\n<line_number-1233>        return false;\n<line_number-1234>    }\n<line_number-1235>\n<line_number-1236>    @Override\n<line_number-1237>    public boolean supportsResultSetHoldability(int holdability) throws SQLException {\n<line_number-1238>        return false;\n<line_number-1239>    }\n<line_number-1240>\n<line_number-1241>    @Override\n<line_number-1242>    public int getResultSetHoldability() throws SQLException {\n<line_number-1243>        return ResultSet.HOLD_CURSORS_OVER_COMMIT;\n<line_number-1244>    }\n<line_number-1245>\n<line_number-1246>    @Override\n<line_number-1247>    public int getDatabaseMajorVersion() throws SQLException {\n<line_number-1248>        return conn.getServerMajorVersion();\n<line_number-1249>    }\n<line_number-1250>\n<line_number-1251>    @Override\n<line_number-1252>    public int getDatabaseMinorVersion() throws SQLException {\n<line_number-1253>        return conn.getServerMinorVersion();\n<line_number-1254>    }\n<line_number-1255>\n<line_number-1256>    @Override\n<line_number-1257>    public int getJDBCMajorVersion() throws SQLException {\n<line_number-1258>        return 4;\n<line_number-1259>    }\n<line_number-1260>\n<line_number-1261>    @Override\n<line_number-1262>    public int getJDBCMinorVersion() throws SQLException {\n<line_number-1263>        return 2;\n<line_number-1264>    }\n<line_number-1265>\n<line_number-1266>    @Override\n<line_number-1267>    public int getSQLStateType() throws SQLException {\n<line_number-1268>        // This is what postgres returns.\n<line_number-1269>        return sqlStateSQL;\n<line_number-1270>    }\n<line_number-1271>\n<line_number-1272>    @Override\n<line_number-1273>    public boolean locatorsUpdateCopy() throws SQLException {\n<line_number-1274>        // It does not matter what return here. But we don't have locators\n<line_number-1275>        // or allow them to be updated.\n<line_number-1276>        return false;\n<line_number-1277>    }\n<line_number-1278>\n<line_number-1279>    @Override\n<line_number-1280>    public boolean supportsStatementPooling() throws SQLException {\n<line_number-1281>        return false;\n<line_number-1282>    }\n<line_number-1283>\n<line_number-1284>    //------------------------- JDBC 4.0 -----------------------------------\n<line_number-1285>\n<line_number-1286>    @Override\n<line_number-1287>    public RowIdLifetime getRowIdLifetime() throws SQLException {\n<line_number-1288>        return RowIdLifetime.ROWID_UNSUPPORTED;\n<line_number-1289>    }\n<line_number-1290>\n<line_number-1291>    @Override\n<line_number-1292>    public boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException {\n<line_number-1293>        // This is related to using stored procedure escape syntax, which we do not support.\n<line_number-1294>        return false;\n<line_number-1295>    }\n<line_number-1296>\n<line_number-1297>    @Override\n<line_number-1298>    public boolean autoCommitFailureClosesAllResultSets() throws SQLException {\n<line_number-1299>        // No writes.\n<line_number-1300>        return false;\n<line_number-1301>    }\n<line_number-1302>\n<line_number-1303>    //--------------------------JDBC 4.1 -----------------------------\n<line_number-1304>\n<line_number-1305>    @Override\n<line_number-1306>    public boolean generatedKeyAlwaysReturned() throws SQLException {\n<line_number-1307>        // We do not have generated keys.\n<line_number-1308>        return false;\n<line_number-1309>    }\n<line_number-1310>\n<line_number-1311>    // java.sql.Wrapper impl\n<line_number-1312>    @Override\n<line_number-1313>    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n<line_number-1314>        return iface.isInstance(this);\n<line_number-1315>    }\n<line_number-1316>\n<line_number-1317>    @SuppressWarnings(\"unchecked\")\n<line_number-1318>    @Override\n<line_number-1319>    public <T> T unwrap(Class<T> iface) throws SQLException {\n<line_number-1320>        return (T) this;\n<line_number-1321>    }\n<line_number-1322>    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n<line_number-1323>\n<line_number-1324>    @Override\n<line_number-1325>    public ResultSet getTables(\n<line_number-1326>            String catalog, String schemaPattern, String tableNamePattern, String[] types)\n<line_number-1327>            throws SQLException {\n<line_number-1328>        MongoJsonSchema botSchema =\n<line_number-1329>                createBottomSchema(\n<line_number-1330>                        new MongoJsonSchema.ScalarProperties(TABLE_CAT, BSON_STRING, false),\n<line_number-1331>                        new MongoJsonSchema.ScalarProperties(TABLE_SCHEM, BSON_STRING, false),\n<line_number-1332>                        new MongoJsonSchema.ScalarProperties(TABLE_NAME, BSON_STRING),\n<line_number-1333>                        new MongoJsonSchema.ScalarProperties(TABLE_TYPE, BSON_STRING),\n<line_number-1334>                        new MongoJsonSchema.ScalarProperties(REMARKS, BSON_STRING),\n<line_number-1335>                        new MongoJsonSchema.ScalarProperties(TYPE_CAT, BSON_STRING, false),\n<line_number-1336>                        new MongoJsonSchema.ScalarProperties(TYPE_SCHEM, BSON_STRING, false),\n<line_number-1337>                        new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING, false),\n<line_number-1338>                        new MongoJsonSchema.ScalarProperties(\n<line_number-1339>                                SELF_REFERENCING_COL_NAME, BSON_STRING, false),\n<line_number-1340>                        new MongoJsonSchema.ScalarProperties(REF_GENERATION, BSON_STRING, false));\n<line_number-1341>\n<line_number-1342>        // Note: JDBC has Catalogs, Schemas, and Tables: they are three levels of organization.\n<line_number-1343>        // MongoDB only has Databases (Catalogs) and Collections (Tables), so we ignore the\n<line_number-1344>        // schemaPattern argument.\n<line_number-1345>        Pattern tableNamePatternRE = toJavaPattern(tableNamePattern);\n<line_number-1346>        List<String> typesList = toTableTypeList(types);\n<line_number-1347>\n<line_number-1348>        Stream<BsonDocument> docs;\n<line_number-1349>        if (catalog == null) {\n<line_number-1350>            // If no catalog (database) is specified, get tables for all databases.\n<line_number-1351>            docs =\n<line_number-1352>                    this.getDatabaseNames()\n<line_number-1353>                            .flatMap(\n<line_number-1354>                                    dbName ->\n<line_number-1355>                                            getTableDataFromDB(\n<line_number-1356>                                                    dbName,\n<line_number-1357>                                                    tableNamePatternRE,\n<line_number-1358>                                                    typesList,\n<line_number-1359>                                                    this::toGetTablesDoc));\n<line_number-1360>        } else if (catalog.isEmpty()) {\n<line_number-1361>            // If catalog (database) is empty, we will return an empty result set because\n<line_number-1362>            // MongoDB does not support tables (collections) without databases.\n<line_number-1363>            docs = Stream.empty();\n<line_number-1364>        } else {\n<line_number-1365>            docs = getTableDataFromDB(catalog, tableNamePatternRE, typesList, this::toGetTablesDoc);\n<line_number-1366>        }\n<line_number-1367>\n<line_number-1368>        // Collect to sorted list.\n<line_number-1369>        List<BsonDocument> docsList = docs.sorted().collect(Collectors.toList());\n<line_number-1370>        BsonExplicitCursor c = new BsonExplicitCursor(docsList);\n<line_number-1371>\n<line_number-1372>        return new MongoResultSet(conn.getLogger(), c, botSchema);\n<line_number-1373>    }\n<line_number-1374>\n<line_number-1375>    @Override\n<line_number-1376>    public ResultSet getSchemas() throws SQLException {\n<line_number-1377>        MongoJsonSchema botSchema =\n<line_number-1378>                createBottomSchema(\n<line_number-1379>                        new MongoJsonSchema.ScalarProperties(TABLE_SCHEM, BSON_STRING),\n<line_number-1380>                        new MongoJsonSchema.ScalarProperties(TABLE_CATALOG, BSON_STRING, false));\n<line_number-1381>\n<line_number-1382>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-1383>    }\n<line_number-1384>\n<line_number-1385>    @Override\n<line_number-1386>    public ResultSet getCatalogs() throws SQLException {\n<line_number-1387>        MongoJsonSchema botSchema =\n<line_number-1388>                createBottomSchema(new MongoJsonSchema.ScalarProperties(TABLE_CAT, BSON_STRING));\n<line_number-1389>\n<line_number-1390>        BsonExplicitCursor c =\n<line_number-1391>                new BsonExplicitCursor(\n<line_number-1392>                        this.getDatabaseNames()\n<line_number-1393>                                .sorted()\n<line_number-1394>                                .map(\n<line_number-1395>                                        dbName ->\n<line_number-1396>                                                createBottomBson(\n<line_number-1397>                                                        new BsonElement(\n<line_number-1398>                                                                TABLE_CAT, new BsonString(dbName))))\n<line_number-1399>                                .collect(Collectors.toList()));\n<line_number-1400>\n<line_number-1401>        return new MongoResultSet(conn.getLogger(), c, botSchema);\n<line_number-1402>    }\n<line_number-1403>\n<line_number-1404>    /**\n<line_number-1405>     * liftSQLException tries to execute a Supplier that may throw a RuntimeException that wraps a\n<line_number-1406>     * SQLException as the cause. If such an exception is encountered, the inner SQLException is\n<line_number-1407>     * thrown. Otherwise, the Supplier executes as expected.\n<line_number-1408>     *\n<line_number-1409>     * <p>This method is intended for use with higher order functions that wrap SQLExceptions in\n<line_number-1410>     * RuntimeExceptions to appease the compiler. We want to propagate those SQLExceptions all the\n<line_number-1411>     * way out to the caller so this method is a way of recovering them.\n<line_number-1412>     *\n<line_number-1413>     * @param f The Supplier function to execute. This function may throw a RuntimeException that\n<line_number-1414>     *     wraps a SQLException.\n<line_number-1415>     * @param <T> The return type of the Supplier.\n<line_number-1416>     * @return The return value of the Supplier.\n<line_number-1417>     * @throws SQLException If a RuntimeException that wraps a SQLException is caught.\n<line_number-1418>     */\n<line_number-1419>    private static <T> T liftSQLException(Supplier<T> f) throws SQLException {\n<line_number-1420>        try {\n<line_number-1421>            return f.get();\n<line_number-1422>        } catch (RuntimeException e) {\n<line_number-1423>            if (e.getCause() instanceof SQLException) {\n<line_number-1424>                throw (SQLException) e.getCause();\n<line_number-1425>            }\n<line_number-1426>            throw e;\n<line_number-1427>        }\n<line_number-1428>    }\n<line_number-1429>\n<line_number-1430>    // Helper class for representing all info needed to serialize column data for the\n<line_number-1431>    // getColumns and getColumnPrivileges methods. Intended for use with toGetColumnsDoc\n<line_number-1432>    // and toGetColumnPrivilegesDoc helpers.\n<line_number-1433>    private static class GetColumnsDocInfo {\n<line_number-1434>        String dbName;\n<line_number-1435>        String tableName;\n<line_number-1436>        String columnName;\n<line_number-1437>        BsonTypeInfo columnBsonTypeInfo;\n<line_number-1438>        int nullability;\n<line_number-1439>        int idx;\n<line_number-1440>\n<line_number-1441>        GetColumnsDocInfo(\n<line_number-1442>                String dbName,\n<line_number-1443>                String tableName,\n<line_number-1444>                String columnName,\n<line_number-1445>                MongoJsonSchema parentSchema,\n<line_number-1446>                MongoJsonSchema columnSchema,\n<line_number-1447>                int idx) {\n<line_number-1448>            this.dbName = dbName;\n<line_number-1449>            this.tableName = tableName;\n<line_number-1450>            this.columnName = columnName;\n<line_number-1451>            this.idx = idx;\n<line_number-1452>\n<line_number-1453>            try {\n<line_number-1454>                this.columnBsonTypeInfo = columnSchema.getBsonTypeInfo();\n<line_number-1455>                this.nullability = parentSchema.getColumnNullability(columnName);\n<line_number-1456>            } catch (SQLException e) {\n<line_number-1457>                throw new RuntimeException(e);\n<line_number-1458>            }\n<line_number-1459>        }\n<line_number-1460>    }\n<line_number-1461>\n<line_number-1462>    // Helper for creating BSON documents for the getColumns method. Intended for use\n<line_number-1463>    // with the getColumnsFromDB helper method which is shared between getColumns and\n<line_number-1464>    // getColumnPrivileges.\n<line_number-1465>    private BsonDocument toGetColumnsDoc(GetColumnsDocInfo i) {\n<line_number-1466>        BsonValue isNullable =\n<line_number-1467>                i.nullability == columnNoNulls\n<line_number-1468>                        ? BSON_NO_STR_VALUE\n<line_number-1469>                        : i.nullability == columnNullable\n<line_number-1470>                                ? BSON_YES_STR_VALUE\n<line_number-1471>                                : BSON_EMPTY_STR_VALUE;\n<line_number-1472>\n<line_number-1473>        return createSortableBottomBson(\n<line_number-1474>                // Per JDBC spec, sort by  TABLE_CAT, TABLE_SCHEM (omitted), TABLE_NAME and\n<line_number-1475>                // ORDINAL_POSITION.\n<line_number-1476>                GET_COLUMNS_SORT_SPECS,\n<line_number-1477>                new BsonElement(TABLE_CAT, new BsonString(i.dbName)),\n<line_number-1478>                new BsonElement(TABLE_SCHEM, BsonNull.VALUE),\n<line_number-1479>                new BsonElement(TABLE_NAME, new BsonString(i.tableName)),\n<line_number-1480>                new BsonElement(COLUMN_NAME, new BsonString(i.columnName)),\n<line_number-1481>                new BsonElement(DATA_TYPE, new BsonInt32(i.columnBsonTypeInfo.getJdbcType())),\n<line_number-1482>                new BsonElement(TYPE_NAME, new BsonString(i.columnBsonTypeInfo.getBsonName())),\n<line_number-1483>                new BsonElement(COLUMN_SIZE, BsonNull.VALUE),\n<line_number-1484>                new BsonElement(BUFFER_LENGTH, BSON_ZERO_INT_VALUE),\n<line_number-1485>                new BsonElement(\n<line_number-1486>                        DECIMAL_DIGITS, asBsonIntOrNull(i.columnBsonTypeInfo.getDecimalDigits())),\n<line_number-1487>                new BsonElement(\n<line_number-1488>                        NUM_PREC_RADIX, new BsonInt32(i.columnBsonTypeInfo.getNumPrecRadix())),\n<line_number-1489>                new BsonElement(NULLABLE, new BsonInt32(i.nullability)),\n<line_number-1490>                new BsonElement(REMARKS, BSON_EMPTY_STR_VALUE),\n<line_number-1491>                new BsonElement(COLUMN_DEF, BsonNull.VALUE),\n<line_number-1492>                new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-1493>                new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-1494>                new BsonElement(\n<line_number-1495>                        CHAR_OCTET_LENGTH,\n<line_number-1496>                        asBsonIntOrNull(i.columnBsonTypeInfo.getCharOctetLength())),\n<line_number-1497>                new BsonElement(ORDINAL_POSITION, new BsonInt32(i.idx)),\n<line_number-1498>                new BsonElement(IS_NULLABLE, isNullable),\n<line_number-1499>                new BsonElement(SCOPE_CATALOG, BsonNull.VALUE),\n<line_number-1500>                new BsonElement(SCOPE_SCHEMA, BsonNull.VALUE),\n<line_number-1501>                new BsonElement(SCOPE_TABLE, BsonNull.VALUE),\n<line_number-1502>                new BsonElement(SOURCE_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-1503>                new BsonElement(IS_AUTOINCREMENT, BSON_NO_STR_VALUE),\n<line_number-1504>                new BsonElement(IS_GENERATEDCOLUMN, BSON_EMPTY_STR_VALUE));\n<line_number-1505>    }\n<line_number-1506>\n<line_number-1507>    // Helper for creating BSON documents for the getColumnPrivileges methods. Intended\n<line_number-1508>    // for use with the getColumnsFromDB helper method which is shared between getColumns\n<line_number-1509>    // and getColumnPrivileges.\n<line_number-1510>    private BsonDocument toGetColumnPrivilegesDoc(GetColumnsDocInfo i) {\n<line_number-1511>        return createSortableBottomBson(\n<line_number-1512>                // Per JDBC spec, sort by  COLUMN_NAME and PRIVILEGE. Since all PRIVILEGEs are the same,\n<line_number-1513>                // we just sort by COLUMN_NAME here.\n<line_number-1514>                GET_COLUMN_PRIVILEGES_SORT_SPECS,\n<line_number-1515>                new BsonElement(TABLE_CAT, new BsonString(i.dbName)),\n<line_number-1516>                new BsonElement(TABLE_SCHEM, BsonNull.VALUE),\n<line_number-1517>                new BsonElement(TABLE_NAME, new BsonString(i.tableName)),\n<line_number-1518>                new BsonElement(COLUMN_NAME, new BsonString(i.columnName)),\n<line_number-1519>                new BsonElement(GRANTOR, BsonNull.VALUE),\n<line_number-1520>                new BsonElement(GRANTEE, BSON_EMPTY_STR_VALUE),\n<line_number-1521>                new BsonElement(PRIVILEGE, new BsonString(\"SELECT\")),\n<line_number-1522>                new BsonElement(IS_GRANTABLE, BsonNull.VALUE));\n<line_number-1523>    }\n<line_number-1524>\n<line_number-1525>    // Helper for ensuring a sqlGetSchema result is a valid collection schema. As in,\n<line_number-1526>    // it has ok: 1, has a jsonSchema, and the jsonSchema is an object schema.\n<line_number-1527>    private boolean isValidSchema(MongoJsonSchemaResult res) {\n<line_number-1528>        return res.ok == 1\n<line_number-1529>                && res.schema.mongoJsonSchema != null\n<line_number-1530>                && res.schema.mongoJsonSchema.isObject();\n<line_number-1531>    }\n<line_number-1532>\n<line_number-1533>    // Helper for getting column data for all columns from all tables from a specific\n<line_number-1534>    // database. Used by getColumns and getColumnPrivileges. The caller specifies how\n<line_number-1535>    // to serialize the column info into BSON documents for the result set.\n<line_number-1536>    private Stream<BsonDocument> getColumnsFromDB(\n<line_number-1537>            String dbName,\n<line_number-1538>            Pattern tableNamePatternRE,\n<line_number-1539>            Pattern columnNamePatternRE,\n<line_number-1540>            Function<GetColumnsDocInfo, BsonDocument> bsonSerializer) {\n<line_number-1541>        MongoDatabase db = this.conn.getDatabase(dbName).withCodecRegistry(MongoDriver.REGISTRY);\n<line_number-1542>        return getCollectionsFromRunCommand(db)\n<line_number-1543>                .stream()\n<line_number-1544>                .map(collection -> collection.name)\n<line_number-1545>                .collect(Collectors.toList())\n<line_number-1546>                .stream()\n<line_number-1547>\n<line_number-1548>                // filter only for collections matching the pattern, and exclude the `__sql_schemas` collection\n<line_number-1549>                .filter(\n<line_number-1550>                        tableName ->\n<line_number-1551>                                // Don't list system collections\n<line_number-1552>                                (!DISALLOWED_COLLECTION_NAMES.matcher(tableName).matches())\n<line_number-1553>                                        && (tableNamePatternRE == null\n<line_number-1554>                                                || tableNamePatternRE.matcher(tableName).matches()))\n<line_number-1555>\n<line_number-1556>                // map the collection names into triples of (dbName, tableName, tableSchema)\n<line_number-1557>                .map(\n<line_number-1558>                        tableName -> {\n<line_number-1559>                            try {\n<line_number-1560>                                return new Pair<>(\n<line_number-1561>                                        new Pair<>(dbName, tableName),\n<line_number-1562>                                        getSchemaByClusterType(db, tableName));\n<line_number-1563>                            } catch (MongoSQLException | MongoSerializationException e) {\n<line_number-1564>                                throw new RuntimeException(\n<line_number-1565>                                        \"Error retrieving schema for: \" + dbName + \".\" + tableName,\n<line_number-1566>                                        e);\n<line_number-1567>                            }\n<line_number-1568>                        })\n<line_number-1569>\n<line_number-1570>                // filter only for collections that have schemas\n<line_number-1571>                .filter(p -> isValidSchema(p.right()))\n<line_number-1572>\n<line_number-1573>                // flatMap the column data into a single stream of BSON docs\n<line_number-1574>                .flatMap(\n<line_number-1575>                        p -> {\n<line_number-1576>                            Pair<String, String> ns = p.left();\n<line_number-1577>                            MongoJsonSchemaResult res = p.right();\n<line_number-1578>                            AtomicInteger idx = new AtomicInteger();\n<line_number-1579>                            return res.schema\n<line_number-1580>                                    .mongoJsonSchema\n<line_number-1581>                                    .properties\n<line_number-1582>                                    .entrySet()\n<line_number-1583>                                    .stream()\n<line_number-1584>\n<line_number-1585>                                    // filter only for columns matching the pattern\n<line_number-1586>                                    .filter(\n<line_number-1587>                                            entry ->\n<line_number-1588>                                                    columnNamePatternRE == null\n<line_number-1589>                                                            || columnNamePatternRE\n<line_number-1590>                                                                    .matcher(entry.getKey())\n<line_number-1591>                                                                    .matches())\n<line_number-1592>\n<line_number-1593>                                    // sort by column name since ordinal position is\n<line_number-1594>                                    // based on column sort order\n<line_number-1595>                                    .sorted(Map.Entry.comparingByKey())\n<line_number-1596>\n<line_number-1597>                                    // map the (columnName, columnSchema) pairs into BSON docs\n<line_number-1598>                                    .map(\n<line_number-1599>                                            entry ->\n<line_number-1600>                                                    bsonSerializer.apply(\n<line_number-1601>                                                            new GetColumnsDocInfo(\n<line_number-1602>                                                                    ns.left(),\n<line_number-1603>                                                                    ns.right(),\n<line_number-1604>                                                                    entry.getKey(),\n<line_number-1605>                                                                    res.schema.mongoJsonSchema,\n<line_number-1606>                                                                    entry.getValue(),\n<line_number-1607>                                                                    idx.getAndIncrement())));\n<line_number-1608>                        });\n<line_number-1609>    }\n<line_number-1610>\n<line_number-1611>    private MongoJsonSchemaResult getSchemaByClusterType(MongoDatabase db, String tableName)\n<line_number-1612>            throws MongoSQLException, MongoSerializationException {\n<line_number-1613>        if (conn.getClusterType() == MongoConnection.MongoClusterType.AtlasDataFederation) {\n<line_number-1614>            return db.runCommand(\n<line_number-1615>                    new BsonDocument(\"sqlGetSchema\", new BsonString(tableName)),\n<line_number-1616>                    MongoJsonSchemaResult.class);\n<line_number-1617>        } else if (conn.getClusterType() == MongoConnection.MongoClusterType.Enterprise) {\n<line_number-1618>            return conn.getMongosqlTranslate().getSchema(db, tableName);\n<line_number-1619>        } else {\n<line_number-1620>            throw new UnsupportedOperationException(\n<line_number-1621>                    \"Unsupported cluster type: \" + conn.getClusterType());\n<line_number-1622>        }\n<line_number-1623>    }\n<line_number-1624>\n<line_number-1625>    @Override\n<line_number-1626>    public ResultSet getColumns(\n<line_number-1627>            String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)\n<line_number-1628>            throws SQLException {\n<line_number-1629>        MongoJsonSchema botSchema =\n<line_number-1630>                createBottomSchema(\n<line_number-1631>                        new MongoJsonSchema.ScalarProperties(TABLE_CAT, BSON_STRING, false),\n<line_number-1632>                        new MongoJsonSchema.ScalarProperties(TABLE_SCHEM, BSON_STRING, false),\n<line_number-1633>                        new MongoJsonSchema.ScalarProperties(TABLE_NAME, BSON_STRING),\n<line_number-1634>                        new MongoJsonSchema.ScalarProperties(COLUMN_NAME, BSON_STRING),\n<line_number-1635>                        new MongoJsonSchema.ScalarProperties(DATA_TYPE, BSON_INT),\n<line_number-1636>                        new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING),\n<line_number-1637>                        new MongoJsonSchema.ScalarProperties(COLUMN_SIZE, BSON_INT),\n<line_number-1638>                        new MongoJsonSchema.ScalarProperties(BUFFER_LENGTH, BSON_INT, false),\n<line_number-1639>                        new MongoJsonSchema.ScalarProperties(DECIMAL_DIGITS, BSON_INT, false),\n<line_number-1640>                        new MongoJsonSchema.ScalarProperties(NUM_PREC_RADIX, BSON_INT),\n<line_number-1641>                        new MongoJsonSchema.ScalarProperties(NULLABLE, BSON_INT),\n<line_number-1642>                        new MongoJsonSchema.ScalarProperties(REMARKS, BSON_STRING, false),\n<line_number-1643>                        new MongoJsonSchema.ScalarProperties(COLUMN_DEF, BSON_STRING, false),\n<line_number-1644>                        new MongoJsonSchema.ScalarProperties(SQL_DATA_TYPE, BSON_INT),\n<line_number-1645>                        new MongoJsonSchema.ScalarProperties(SQL_DATETIME_SUB, BSON_INT),\n<line_number-1646>                        new MongoJsonSchema.ScalarProperties(CHAR_OCTET_LENGTH, BSON_INT),\n<line_number-1647>                        new MongoJsonSchema.ScalarProperties(ORDINAL_POSITION, BSON_INT),\n<line_number-1648>                        new MongoJsonSchema.ScalarProperties(IS_NULLABLE, BSON_STRING),\n<line_number-1649>                        new MongoJsonSchema.ScalarProperties(SCOPE_CATALOG, BSON_STRING, false),\n<line_number-1650>                        new MongoJsonSchema.ScalarProperties(SCOPE_SCHEMA, BSON_STRING, false),\n<line_number-1651>                        new MongoJsonSchema.ScalarProperties(SCOPE_TABLE, BSON_STRING, false),\n<line_number-1652>                        new MongoJsonSchema.ScalarProperties(SOURCE_DATA_TYPE, BSON_INT, false),\n<line_number-1653>                        new MongoJsonSchema.ScalarProperties(IS_AUTOINCREMENT, BSON_STRING),\n<line_number-1654>                        new MongoJsonSchema.ScalarProperties(IS_GENERATEDCOLUMN, BSON_STRING));\n<line_number-1655>\n<line_number-1656>        // Note: JDBC has Catalogs, Schemas, and Tables: they are three levels of organization.\n<line_number-1657>        // MongoDB only has Databases (Catalogs) and Collections (Tables), so we ignore the\n<line_number-1658>        // schemaPattern argument.\n<line_number-1659>        Pattern tableNamePatternRE = toJavaPattern(tableNamePattern);\n<line_number-1660>        Pattern columnNamePatternRE = toJavaPattern(columnNamePattern);\n<line_number-1661>\n<line_number-1662>        Stream<BsonDocument> docs;\n<line_number-1663>        if (catalog == null) {\n<line_number-1664>            // If no catalog (database) is specified, get columns for all databases.\n<line_number-1665>            docs =\n<line_number-1666>                    liftSQLException(\n<line_number-1667>                            () ->\n<line_number-1668>                                    this.getDatabaseNames()\n<line_number-1669>                                            .flatMap(\n<line_number-1670>                                                    dbName ->\n<line_number-1671>                                                            getColumnsFromDB(\n<line_number-1672>                                                                    dbName,\n<line_number-1673>                                                                    tableNamePatternRE,\n<line_number-1674>                                                                    columnNamePatternRE,\n<line_number-1675>                                                                    this::toGetColumnsDoc)));\n<line_number-1676>\n<line_number-1677>        } else if (catalog.isEmpty()) {\n<line_number-1678>            // If catalog (database) is empty, we will return an empty result set because\n<line_number-1679>            // MongoDB does not support tables (collections) without databases.\n<line_number-1680>            docs = Stream.empty();\n<line_number-1681>        } else {\n<line_number-1682>            docs =\n<line_number-1683>                    liftSQLException(\n<line_number-1684>                            () ->\n<line_number-1685>                                    getColumnsFromDB(\n<line_number-1686>                                            catalog,\n<line_number-1687>                                            tableNamePatternRE,\n<line_number-1688>                                            columnNamePatternRE,\n<line_number-1689>                                            this::toGetColumnsDoc));\n<line_number-1690>        }\n<line_number-1691>\n<line_number-1692>        // Collect to sorted list.\n<line_number-1693>        List<BsonDocument> docsList = docs.sorted().collect(Collectors.toList());\n<line_number-1694>        BsonExplicitCursor c = new BsonExplicitCursor(docsList);\n<line_number-1695>\n<line_number-1696>        return new MongoResultSet(conn.getLogger(), c, botSchema);\n<line_number-1697>    }\n<line_number-1698>\n<line_number-1699>    @Override\n<line_number-1700>    public ResultSet getColumnPrivileges(\n<line_number-1701>            String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)\n<line_number-1702>            throws SQLException {\n<line_number-1703>        MongoJsonSchema botSchema =\n<line_number-1704>                createBottomSchema(\n<line_number-1705>                        new MongoJsonSchema.ScalarProperties(TABLE_CAT, BSON_STRING, false),\n<line_number-1706>                        new MongoJsonSchema.ScalarProperties(TABLE_SCHEM, BSON_STRING, false),\n<line_number-1707>                        new MongoJsonSchema.ScalarProperties(TABLE_NAME, BSON_STRING),\n<line_number-1708>                        new MongoJsonSchema.ScalarProperties(COLUMN_NAME, BSON_STRING),\n<line_number-1709>                        new MongoJsonSchema.ScalarProperties(GRANTOR, BSON_STRING, false),\n<line_number-1710>                        new MongoJsonSchema.ScalarProperties(GRANTEE, BSON_STRING),\n<line_number-1711>                        new MongoJsonSchema.ScalarProperties(PRIVILEGE, BSON_STRING),\n<line_number-1712>                        new MongoJsonSchema.ScalarProperties(IS_GRANTABLE, BSON_STRING, false));\n<line_number-1713>\n<line_number-1714>        // Note: JDBC has Catalogs, Schemas, and Tables: they are three levels of organization.\n<line_number-1715>        // MongoDB only has Databases (Catalogs) and Collections (Tables), so we ignore the\n<line_number-1716>        // schemaPattern argument.\n<line_number-1717>        Pattern tableNamePatternRE = toJavaPattern(tableNamePattern);\n<line_number-1718>        Pattern columnNamePatternRE = toJavaPattern(columnNamePattern);\n<line_number-1719>\n<line_number-1720>        Stream<BsonDocument> docs;\n<line_number-1721>        if (catalog == null) {\n<line_number-1722>            // If no catalog (database) is specified, get column privileges for all databases.\n<line_number-1723>            docs =\n<line_number-1724>                    liftSQLException(\n<line_number-1725>                            () ->\n<line_number-1726>                                    this.getDatabaseNames()\n<line_number-1727>                                            .flatMap(\n<line_number-1728>                                                    dbName ->\n<line_number-1729>                                                            getColumnsFromDB(\n<line_number-1730>                                                                    dbName,\n<line_number-1731>                                                                    tableNamePatternRE,\n<line_number-1732>                                                                    columnNamePatternRE,\n<line_number-1733>                                                                    this\n<line_number-1734>                                                                            ::toGetColumnPrivilegesDoc)));\n<line_number-1735>        } else if (catalog.isEmpty()) {\n<line_number-1736>            // If catalog (database) is empty, we will return an empty result set because\n<line_number-1737>            // MongoDB does not support tables (collections) without databases.\n<line_number-1738>            docs = Stream.empty();\n<line_number-1739>        } else {\n<line_number-1740>            docs =\n<line_number-1741>                    liftSQLException(\n<line_number-1742>                            () ->\n<line_number-1743>                                    getColumnsFromDB(\n<line_number-1744>                                            catalog,\n<line_number-1745>                                            tableNamePatternRE,\n<line_number-1746>                                            columnNamePatternRE,\n<line_number-1747>                                            this::toGetColumnPrivilegesDoc));\n<line_number-1748>        }\n<line_number-1749>\n<line_number-1750>        // Collect to sorted list.\n<line_number-1751>        List<BsonDocument> docsList = docs.sorted().collect(Collectors.toList());\n<line_number-1752>        BsonExplicitCursor c = new BsonExplicitCursor(docsList);\n<line_number-1753>\n<line_number-1754>        return new MongoResultSet(conn.getLogger(), c, botSchema);\n<line_number-1755>    }\n<line_number-1756>\n<line_number-1757>    @Override\n<line_number-1758>    public ResultSet getTablePrivileges(\n<line_number-1759>            String catalog, String schemaPattern, String tableNamePattern) throws SQLException {\n<line_number-1760>        MongoJsonSchema botSchema =\n<line_number-1761>                createBottomSchema(\n<line_number-1762>                        new MongoJsonSchema.ScalarProperties(TABLE_CAT, BSON_STRING, false),\n<line_number-1763>                        new MongoJsonSchema.ScalarProperties(TABLE_SCHEM, BSON_STRING, false),\n<line_number-1764>                        new MongoJsonSchema.ScalarProperties(TABLE_NAME, BSON_STRING),\n<line_number-1765>                        new MongoJsonSchema.ScalarProperties(GRANTOR, BSON_STRING, false),\n<line_number-1766>                        new MongoJsonSchema.ScalarProperties(GRANTEE, BSON_STRING),\n<line_number-1767>                        new MongoJsonSchema.ScalarProperties(PRIVILEGE, BSON_STRING),\n<line_number-1768>                        new MongoJsonSchema.ScalarProperties(IS_GRANTABLE, BSON_STRING, false));\n<line_number-1769>\n<line_number-1770>        // Note: JDBC has Catalogs, Schemas, and Tables: they are three levels of organization.\n<line_number-1771>        // MongoDB only has Databases (Catalogs) and Collections (Tables), so we ignore the\n<line_number-1772>        // schemaPattern argument.\n<line_number-1773>        Pattern tableNamePatternRE = toJavaPattern(tableNamePattern);\n<line_number-1774>\n<line_number-1775>        Stream<BsonDocument> docs;\n<line_number-1776>        if (catalog == null) {\n<line_number-1777>            // If no catalog (database) is specified, get table privileges for all databases.\n<line_number-1778>            docs =\n<line_number-1779>                    this.getDatabaseNames()\n<line_number-1780>                            .flatMap(\n<line_number-1781>                                    dbName ->\n<line_number-1782>                                            getTableDataFromDB(\n<line_number-1783>                                                    dbName,\n<line_number-1784>                                                    tableNamePatternRE,\n<line_number-1785>                                                    null,\n<line_number-1786>                                                    this::toGetTablePrivilegesDoc));\n<line_number-1787>        } else if (catalog.isEmpty()) {\n<line_number-1788>            // If catalog (database) is empty, we will return an empty result set because\n<line_number-1789>            // MongoDB does not support tables (collections) without databases.\n<line_number-1790>            docs = Stream.empty();\n<line_number-1791>        } else {\n<line_number-1792>            docs =\n<line_number-1793>                    getTableDataFromDB(\n<line_number-1794>                            catalog, tableNamePatternRE, null, this::toGetTablePrivilegesDoc);\n<line_number-1795>        }\n<line_number-1796>\n<line_number-1797>        // Collect to sorted list.\n<line_number-1798>        List<BsonDocument> docsList = docs.sorted().collect(Collectors.toList());\n<line_number-1799>        BsonExplicitCursor c = new BsonExplicitCursor(docsList);\n<line_number-1800>\n<line_number-1801>        return new MongoResultSet(conn.getLogger(), c, botSchema);\n<line_number-1802>    }\n<line_number-1803>\n<line_number-1804>    private Stream<BsonDocument> getFirstUniqueIndexDocsForTable(\n<line_number-1805>            String dbName,\n<line_number-1806>            String tableName,\n<line_number-1807>            BiFunction<Pair<String, String>, Document, List<BsonDocument>> serializer) {\n<line_number-1808>        MongoDatabase db = this.conn.getDatabase(dbName).withCodecRegistry(MongoDriver.REGISTRY);\n<line_number-1809>        ListIndexesIterable<Document> i = db.getCollection(tableName).listIndexes();\n<line_number-1810>        List<BsonDocument> docs = new ArrayList<>();\n<line_number-1811>\n<line_number-1812>        for (Document d : i) {\n<line_number-1813>            Boolean isUnique = d.getEmbedded(UNIQUE_KEY_PATH, Boolean.class);\n<line_number-1814>            if (isUnique == null || !isUnique) {\n<line_number-1815>                continue;\n<line_number-1816>            }\n<line_number-1817>\n<line_number-1818>            // Get result set rows from first unique index\n<line_number-1819>            docs.addAll(serializer.apply(new Pair<>(dbName, tableName), d));\n<line_number-1820>\n<line_number-1821>            // Break after we find the first unique index\n<line_number-1822>            break;\n<line_number-1823>        }\n<line_number-1824>\n<line_number-1825>        return docs.stream();\n<line_number-1826>    }\n<line_number-1827>\n<line_number-1828>    // Helper for getting a ResultSet based on the first unique index for the argued table. The\n<line_number-1829>    // result set documents are produced by the serializer function. Given a (dbName, tableName)\n<line_number-1830>    // pair and a Document representing the first unique index, the serializer function creates\n<line_number-1831>    // a list of BsonDocuments corresponding to the rows of the result set. This method is shared\n<line_number-1832>    // between getBestRowIdentifier and getPrimaryKeys, which both return data based on the first\n<line_number-1833>    // unique index.\n<line_number-1834>    private ResultSet getFirstUniqueIndexResultSet(\n<line_number-1835>            String catalog,\n<line_number-1836>            String table,\n<line_number-1837>            MongoJsonSchema botSchema,\n<line_number-1838>            BiFunction<Pair<String, String>, Document, List<BsonDocument>> serializer) {\n<line_number-1839>        try {\n<line_number-1840>            Stream<BsonDocument> docs;\n<line_number-1841>            if (catalog == null) {\n<line_number-1842>                // If no catalog (database) is specified, get first unique index for all databases that have a\n<line_number-1843>                // collection with the argued table name.\n<line_number-1844>                docs =\n<line_number-1845>                        this.getDatabaseNames()\n<line_number-1846>                                .flatMap(\n<line_number-1847>                                        dbName ->\n<line_number-1848>                                                getTableDataFromDB(\n<line_number-1849>                                                                dbName,\n<line_number-1850>                                                                res -> res.name.equals(table))\n<line_number-1851>                                                        .flatMap(\n<line_number-1852>                                                                r ->\n<line_number-1853>                                                                        getFirstUniqueIndexDocsForTable(\n<line_number-1854>                                                                                dbName,\n<line_number-1855>                                                                                r.name,\n<line_number-1856>                                                                                serializer)));\n<line_number-1857>            } else if (catalog.isEmpty()) {\n<line_number-1858>                // If catalog (database) is empty, we will return an empty result set because\n<line_number-1859>                // MongoDB does not support tables (collections) without databases.\n<line_number-1860>                docs = Stream.empty();\n<line_number-1861>            } else {\n<line_number-1862>                docs = getFirstUniqueIndexDocsForTable(catalog, table, serializer);\n<line_number-1863>            }\n<line_number-1864>\n<line_number-1865>            // Collect to list.\n<line_number-1866>            List<BsonDocument> docsList = docs.collect(Collectors.toList());\n<line_number-1867>            BsonExplicitCursor c = new BsonExplicitCursor(docsList);\n<line_number-1868>\n<line_number-1869>            return new MongoResultSet(conn.getLogger(), c, botSchema);\n<line_number-1870>        } catch (SQLException e) {\n<line_number-1871>            throw new RuntimeException(e);\n<line_number-1872>        }\n<line_number-1873>    }\n<line_number-1874>\n<line_number-1875>    // Helper for getting the rows for the getBestRowIdentifier result set. Given a\n<line_number-1876>    // (dbName, tableName) and an index doc, it produces a list of BsonDocuments where\n<line_number-1877>    // each document corresponds to a row in the result set representing a column in\n<line_number-1878>    // the index. This method is intended for use with the getFirstUniqueIndexResultSet\n<line_number-1879>    // method.\n<line_number-1880>    private List<BsonDocument> toGetBestRowIdentifierDocs(\n<line_number-1881>            Pair<String, String> namespace, Document indexInfo) {\n<line_number-1882>        List<BsonDocument> docs = new ArrayList<>();\n<line_number-1883>\n<line_number-1884>        // We've found the first unique index. At this point, we get the schema for this\n<line_number-1885>        // collection and create a result set based on this index's keys.\n<line_number-1886>        MongoJsonSchemaResult r;\n<line_number-1887>        try {\n<line_number-1888>            r = getSchemaByClusterType(conn.getDatabase(namespace.left()), namespace.right());\n<line_number-1889>        } catch (MongoSQLException | MongoSerializationException e) {\n<line_number-1890>            throw new RuntimeException(\n<line_number-1891>                    \"Error retrieving schema for collection: \" + namespace.right(), e);\n<line_number-1892>        }\n<line_number-1893>\n<line_number-1894>        Document keys = indexInfo.get(INDEX_KEY_KEY, Document.class);\n<line_number-1895>        try {\n<line_number-1896>            for (String key : keys.keySet()) {\n<line_number-1897>                docs.add(\n<line_number-1898>                        toGetBestRowIdentifierDoc(\n<line_number-1899>                                key,\n<line_number-1900>                                r.schema.mongoJsonSchema.properties.get(key).getBsonTypeInfo()));\n<line_number-1901>            }\n<line_number-1902>        } catch (SQLException e) {\n<line_number-1903>            throw new RuntimeException(e);\n<line_number-1904>        }\n<line_number-1905>\n<line_number-1906>        return docs;\n<line_number-1907>    }\n<line_number-1908>\n<line_number-1909>    // Helper for creating a result set BsonDocument for an index column for the\n<line_number-1910>    // getBestRowIdentifier method.\n<line_number-1911>    private BsonDocument toGetBestRowIdentifierDoc(\n<line_number-1912>            String columnName, BsonTypeInfo columnBsonTypeInfo) {\n<line_number-1913>        return createBottomBson(\n<line_number-1914>                new BsonElement(SCOPE, BsonNull.VALUE),\n<line_number-1915>                new BsonElement(COLUMN_NAME, new BsonString(columnName)),\n<line_number-1916>                new BsonElement(DATA_TYPE, new BsonInt32(columnBsonTypeInfo.getJdbcType())),\n<line_number-1917>                new BsonElement(TYPE_NAME, new BsonString(columnBsonTypeInfo.getBsonName())),\n<line_number-1918>                new BsonElement(COLUMN_SIZE, asBsonIntOrNull(columnBsonTypeInfo.getPrecision())),\n<line_number-1919>                new BsonElement(BUFFER_LENGTH, BsonNull.VALUE),\n<line_number-1920>                new BsonElement(\n<line_number-1921>                        DECIMAL_DIGITS, asBsonIntOrNull(columnBsonTypeInfo.getDecimalDigits())),\n<line_number-1922>                new BsonElement(PSEUDO_COLUMN, new BsonInt32(bestRowNotPseudo)));\n<line_number-1923>    }\n<line_number-1924>\n<line_number-1925>    @Override\n<line_number-1926>    public ResultSet getBestRowIdentifier(\n<line_number-1927>            String catalog, String schema, String table, int scope, boolean nullable)\n<line_number-1928>            throws SQLException {\n<line_number-1929>        MongoJsonSchema botSchema =\n<line_number-1930>                createBottomSchema(\n<line_number-1931>                        new MongoJsonSchema.ScalarProperties(SCOPE, BSON_INT),\n<line_number-1932>                        new MongoJsonSchema.ScalarProperties(COLUMN_NAME, BSON_STRING),\n<line_number-1933>                        new MongoJsonSchema.ScalarProperties(DATA_TYPE, BSON_INT),\n<line_number-1934>                        new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING),\n<line_number-1935>                        new MongoJsonSchema.ScalarProperties(COLUMN_SIZE, BSON_INT),\n<line_number-1936>                        new MongoJsonSchema.ScalarProperties(BUFFER_LENGTH, BSON_INT),\n<line_number-1937>                        new MongoJsonSchema.ScalarProperties(DECIMAL_DIGITS, BSON_INT, false),\n<line_number-1938>                        new MongoJsonSchema.ScalarProperties(PSEUDO_COLUMN, BSON_INT));\n<line_number-1939>\n<line_number-1940>        // As in other methods, we ignore the schema argument. Here, we also ignore the\n<line_number-1941>        // scope and nullable arguments.\n<line_number-1942>        return liftSQLException(\n<line_number-1943>                () ->\n<line_number-1944>                        getFirstUniqueIndexResultSet(\n<line_number-1945>                                catalog, table, botSchema, this::toGetBestRowIdentifierDocs));\n<line_number-1946>    }\n<line_number-1947>\n<line_number-1948>    @Override\n<line_number-1949>    public ResultSet getVersionColumns(String catalog, String schema, String table)\n<line_number-1950>            throws SQLException {\n<line_number-1951>        MongoJsonSchema botSchema =\n<line_number-1952>                createBottomSchema(\n<line_number-1953>                        new MongoJsonSchema.ScalarProperties(SCOPE, BSON_STRING, false),\n<line_number-1954>                        new MongoJsonSchema.ScalarProperties(COLUMN_NAME, BSON_STRING),\n<line_number-1955>                        new MongoJsonSchema.ScalarProperties(DATA_TYPE, BSON_INT),\n<line_number-1956>                        new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING),\n<line_number-1957>                        new MongoJsonSchema.ScalarProperties(COLUMN_SIZE, BSON_INT),\n<line_number-1958>                        new MongoJsonSchema.ScalarProperties(BUFFER_LENGTH, BSON_INT),\n<line_number-1959>                        new MongoJsonSchema.ScalarProperties(DECIMAL_DIGITS, BSON_INT, false),\n<line_number-1960>                        new MongoJsonSchema.ScalarProperties(PSEUDO_COLUMN, BSON_INT));\n<line_number-1961>\n<line_number-1962>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-1963>    }\n<line_number-1964>\n<line_number-1965>    @Override\n<line_number-1966>    public ResultSet getImportedKeys(String catalog, String schema, String table)\n<line_number-1967>            throws SQLException {\n<line_number-1968>        MongoJsonSchema botSchema =\n<line_number-1969>                createBottomSchema(\n<line_number-1970>                        new MongoJsonSchema.ScalarProperties(PKTABLE_CAT, BSON_STRING, false),\n<line_number-1971>                        new MongoJsonSchema.ScalarProperties(PKTABLE_SCHEM, BSON_STRING, false),\n<line_number-1972>                        new MongoJsonSchema.ScalarProperties(PKTABLE_NAME, BSON_STRING),\n<line_number-1973>                        new MongoJsonSchema.ScalarProperties(PKCOLUMN_NAME, BSON_STRING),\n<line_number-1974>                        new MongoJsonSchema.ScalarProperties(FKTABLE_CAT, BSON_STRING, false),\n<line_number-1975>                        new MongoJsonSchema.ScalarProperties(FKTABLE_SCHEM, BSON_STRING, false),\n<line_number-1976>                        new MongoJsonSchema.ScalarProperties(FKTABLE_NAME, BSON_STRING),\n<line_number-1977>                        new MongoJsonSchema.ScalarProperties(FKCOLUMN_NAME, BSON_STRING),\n<line_number-1978>                        new MongoJsonSchema.ScalarProperties(KEY_SEQ, BSON_INT),\n<line_number-1979>                        new MongoJsonSchema.ScalarProperties(UPDATE_RULE, BSON_INT),\n<line_number-1980>                        new MongoJsonSchema.ScalarProperties(DELETE_RULE, BSON_INT),\n<line_number-1981>                        new MongoJsonSchema.ScalarProperties(FK_NAME, BSON_STRING, false),\n<line_number-1982>                        new MongoJsonSchema.ScalarProperties(PK_NAME, BSON_STRING, false),\n<line_number-1983>                        new MongoJsonSchema.ScalarProperties(DEFERRABILITY, BSON_INT));\n<line_number-1984>\n<line_number-1985>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-1986>    }\n<line_number-1987>\n<line_number-1988>    @Override\n<line_number-1989>    public ResultSet getExportedKeys(String catalog, String schema, String table)\n<line_number-1990>            throws SQLException {\n<line_number-1991>        MongoJsonSchema botSchema =\n<line_number-1992>                createBottomSchema(\n<line_number-1993>                        new MongoJsonSchema.ScalarProperties(PKTABLE_CAT, BSON_STRING, false),\n<line_number-1994>                        new MongoJsonSchema.ScalarProperties(PKTABLE_SCHEM, BSON_STRING, false),\n<line_number-1995>                        new MongoJsonSchema.ScalarProperties(PKTABLE_NAME, BSON_STRING),\n<line_number-1996>                        new MongoJsonSchema.ScalarProperties(PKCOLUMN_NAME, BSON_STRING),\n<line_number-1997>                        new MongoJsonSchema.ScalarProperties(FKTABLE_CAT, BSON_STRING, false),\n<line_number-1998>                        new MongoJsonSchema.ScalarProperties(FKTABLE_SCHEM, BSON_STRING, false),\n<line_number-1999>                        new MongoJsonSchema.ScalarProperties(FKTABLE_NAME, BSON_STRING),\n<line_number-2000>                        new MongoJsonSchema.ScalarProperties(FKCOLUMN_NAME, BSON_STRING),\n<line_number-2001>                        new MongoJsonSchema.ScalarProperties(KEY_SEQ, BSON_INT),\n<line_number-2002>                        new MongoJsonSchema.ScalarProperties(UPDATE_RULE, BSON_INT),\n<line_number-2003>                        new MongoJsonSchema.ScalarProperties(DELETE_RULE, BSON_INT),\n<line_number-2004>                        new MongoJsonSchema.ScalarProperties(FK_NAME, BSON_STRING, false),\n<line_number-2005>                        new MongoJsonSchema.ScalarProperties(PK_NAME, BSON_STRING, false),\n<line_number-2006>                        new MongoJsonSchema.ScalarProperties(DEFERRABILITY, BSON_INT));\n<line_number-2007>\n<line_number-2008>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-2009>    }\n<line_number-2010>\n<line_number-2011>    @Override\n<line_number-2012>    public ResultSet getCrossReference(\n<line_number-2013>            String parentCatalog,\n<line_number-2014>            String parentSchema,\n<line_number-2015>            String parentTable,\n<line_number-2016>            String foreignCatalog,\n<line_number-2017>            String foreignSchema,\n<line_number-2018>            String foreignTable)\n<line_number-2019>            throws SQLException {\n<line_number-2020>        MongoJsonSchema botSchema =\n<line_number-2021>                createBottomSchema(\n<line_number-2022>                        new MongoJsonSchema.ScalarProperties(PKTABLE_CAT, BSON_STRING, false),\n<line_number-2023>                        new MongoJsonSchema.ScalarProperties(PKTABLE_SCHEM, BSON_STRING, false),\n<line_number-2024>                        new MongoJsonSchema.ScalarProperties(PKTABLE_NAME, BSON_STRING),\n<line_number-2025>                        new MongoJsonSchema.ScalarProperties(PKCOLUMN_NAME, BSON_STRING),\n<line_number-2026>                        new MongoJsonSchema.ScalarProperties(FKTABLE_CAT, BSON_STRING, false),\n<line_number-2027>                        new MongoJsonSchema.ScalarProperties(FKTABLE_SCHEM, BSON_STRING, false),\n<line_number-2028>                        new MongoJsonSchema.ScalarProperties(FKTABLE_NAME, BSON_STRING),\n<line_number-2029>                        new MongoJsonSchema.ScalarProperties(FKCOLUMN_NAME, BSON_STRING),\n<line_number-2030>                        new MongoJsonSchema.ScalarProperties(KEY_SEQ, BSON_INT),\n<line_number-2031>                        new MongoJsonSchema.ScalarProperties(UPDATE_RULE, BSON_INT),\n<line_number-2032>                        new MongoJsonSchema.ScalarProperties(DELETE_RULE, BSON_INT),\n<line_number-2033>                        new MongoJsonSchema.ScalarProperties(FK_NAME, BSON_STRING, false),\n<line_number-2034>                        new MongoJsonSchema.ScalarProperties(PK_NAME, BSON_STRING, false),\n<line_number-2035>                        new MongoJsonSchema.ScalarProperties(DEFERRABILITY, BSON_INT));\n<line_number-2036>\n<line_number-2037>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-2038>    }\n<line_number-2039>\n<line_number-2040>    // Helper for getting the rows for the getPrimaryKeys result set. Given a (dbName, tableName)\n<line_number-2041>    // and an index doc, it produces a list of BsonDocuments where each document corresponds to a\n<line_number-2042>    // row in the result set representing a column in the index. This method is intended for use\n<line_number-2043>    // with the getFirstUniqueIndexResultSet method.\n<line_number-2044>    private List<BsonDocument> toGetPrimaryKeysDocs(\n<line_number-2045>            Pair<String, String> namespace, Document indexInfo) {\n<line_number-2046>        Document keys = indexInfo.get(INDEX_KEY_KEY, Document.class);\n<line_number-2047>        String indexName = indexInfo.getString(INDEX_NAME_KEY);\n<line_number-2048>        AtomicInteger pos = new AtomicInteger();\n<line_number-2049>\n<line_number-2050>        return keys.keySet()\n<line_number-2051>                .stream()\n<line_number-2052>                .map(\n<line_number-2053>                        key ->\n<line_number-2054>                                createSortableBottomBson(\n<line_number-2055>                                        // Per JDBC spec, sort by COLUMN_NAME.\n<line_number-2056>                                        GET_PRIMARY_KEYS_SORT_SPECS,\n<line_number-2057>                                        new BsonElement(\n<line_number-2058>                                                TABLE_CAT, new BsonString(namespace.left())),\n<line_number-2059>                                        new BsonElement(TABLE_SCHEM, BsonNull.VALUE),\n<line_number-2060>                                        new BsonElement(\n<line_number-2061>                                                TABLE_NAME, new BsonString(namespace.right())),\n<line_number-2062>                                        new BsonElement(COLUMN_NAME, new BsonString(key)),\n<line_number-2063>                                        new BsonElement(\n<line_number-2064>                                                KEY_SEQ, new BsonInt32(pos.incrementAndGet())),\n<line_number-2065>                                        new BsonElement(PK_NAME, new BsonString(indexName))))\n<line_number-2066>                .sorted()\n<line_number-2067>                .collect(Collectors.toList());\n<line_number-2068>    }\n<line_number-2069>\n<line_number-2070>    @Override\n<line_number-2071>    public ResultSet getPrimaryKeys(String catalog, String schema, String table)\n<line_number-2072>            throws SQLException {\n<line_number-2073>        MongoJsonSchema botSchema =\n<line_number-2074>                createBottomSchema(\n<line_number-2075>                        new MongoJsonSchema.ScalarProperties(TABLE_CAT, BSON_STRING, false),\n<line_number-2076>                        new MongoJsonSchema.ScalarProperties(TABLE_SCHEM, BSON_STRING, false),\n<line_number-2077>                        new MongoJsonSchema.ScalarProperties(TABLE_NAME, BSON_STRING),\n<line_number-2078>                        new MongoJsonSchema.ScalarProperties(COLUMN_NAME, BSON_STRING),\n<line_number-2079>                        new MongoJsonSchema.ScalarProperties(KEY_SEQ, BSON_INT),\n<line_number-2080>                        new MongoJsonSchema.ScalarProperties(PK_NAME, BSON_STRING, false));\n<line_number-2081>        // As in other methods, we ignore the schema argument.\n<line_number-2082>        return liftSQLException(\n<line_number-2083>                () ->\n<line_number-2084>                        getFirstUniqueIndexResultSet(\n<line_number-2085>                                catalog, table, botSchema, this::toGetPrimaryKeysDocs));\n<line_number-2086>    }\n<line_number-2087>\n<line_number-2088>    private MongoJsonSchema getTypeInfoJsonSchema() {\n<line_number-2089>\n<line_number-2090>        MongoJsonSchema schema = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-2091>        schema.addScalarKeys(\n<line_number-2092>                new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING),\n<line_number-2093>                new MongoJsonSchema.ScalarProperties(DATA_TYPE, BSON_INT),\n<line_number-2094>                new MongoJsonSchema.ScalarProperties(PRECISION, BSON_INT),\n<line_number-2095>                new MongoJsonSchema.ScalarProperties(LITERAL_PREFIX, BSON_STRING, false),\n<line_number-2096>                new MongoJsonSchema.ScalarProperties(LITERAL_SUFFIX, BSON_STRING, false),\n<line_number-2097>                new MongoJsonSchema.ScalarProperties(CREATE_PARAMS, BSON_STRING, false),\n<line_number-2098>                new MongoJsonSchema.ScalarProperties(NULLABLE, BSON_INT),\n<line_number-2099>                new MongoJsonSchema.ScalarProperties(CASE_SENSITIVE, BSON_BOOL),\n<line_number-2100>                new MongoJsonSchema.ScalarProperties(SEARCHABLE, BSON_INT),\n<line_number-2101>                new MongoJsonSchema.ScalarProperties(UNSIGNED_ATTRIBUTE, BSON_BOOL),\n<line_number-2102>                new MongoJsonSchema.ScalarProperties(FIX_PREC_SCALE, BSON_BOOL),\n<line_number-2103>                new MongoJsonSchema.ScalarProperties(AUTO_INCREMENT, BSON_BOOL),\n<line_number-2104>                new MongoJsonSchema.ScalarProperties(LOCAL_TYPE_NAME, BSON_STRING, false),\n<line_number-2105>                new MongoJsonSchema.ScalarProperties(MINIMUM_SCALE, BSON_INT),\n<line_number-2106>                new MongoJsonSchema.ScalarProperties(MAXIMUM_SCALE, BSON_INT),\n<line_number-2107>                new MongoJsonSchema.ScalarProperties(SQL_DATA_TYPE, BSON_INT),\n<line_number-2108>                new MongoJsonSchema.ScalarProperties(SQL_DATETIME_SUB, BSON_INT),\n<line_number-2109>                new MongoJsonSchema.ScalarProperties(NUM_PREC_RADIX, BSON_INT));\n<line_number-2110>        return schema;\n<line_number-2111>    }\n<line_number-2112>\n<line_number-2113>    @Override\n<line_number-2114>    public ResultSet getTypeInfo() throws SQLException {\n<line_number-2115>        ArrayList<BsonDocument> docs = new ArrayList<>();\n<line_number-2116>        MongoJsonSchema schema = getTypeInfoJsonSchema();\n<line_number-2117>\n<line_number-2118>        // The following BSON Types are mostly ordered to follow the javadoc (i.e., they are ordered by DATA_TYPE).\n<line_number-2119>        // However, instead of ordering all the BSON Types with DATA_TYPE == 1111 by how closely they map to the\n<line_number-2120>        // corresponding JDBC SQL type (as the javadocs say), we order them alphabetically since \"closest to JDBC\n<line_number-2121>        // SQL type\" is meaningless in this case (as all 1111 types are inaccurate).\n<line_number-2122>        docs.add(\n<line_number-2123>                createBottomBson(\n<line_number-2124>                        new BsonElement(TYPE_NAME, new BsonString(BSON_LONG.getBsonName())),\n<line_number-2125>                        new BsonElement(DATA_TYPE, new BsonInt32(Types.BIGINT)),\n<line_number-2126>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_LONG.getPrecision())),\n<line_number-2127>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2128>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2129>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2130>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2131>                        new BsonElement(\n<line_number-2132>                                CASE_SENSITIVE, new BsonBoolean(BSON_LONG.getCaseSensitivity())),\n<line_number-2133>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2134>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2135>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2136>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2137>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2138>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_LONG.getMinScale())),\n<line_number-2139>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_LONG.getMaxScale())),\n<line_number-2140>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2141>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2142>                        new BsonElement(\n<line_number-2143>                                NUM_PREC_RADIX, new BsonInt32(BSON_LONG.getNumPrecRadix()))));\n<line_number-2144>\n<line_number-2145>        docs.add(\n<line_number-2146>                createBottomBson(\n<line_number-2147>                        new BsonElement(TYPE_NAME, new BsonString(BSON_BINDATA.getBsonName())),\n<line_number-2148>                        new BsonElement(DATA_TYPE, new BsonInt32(Types.BINARY)),\n<line_number-2149>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_BINDATA.getPrecision())),\n<line_number-2150>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2151>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2152>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2153>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2154>                        new BsonElement(\n<line_number-2155>                                CASE_SENSITIVE, new BsonBoolean(BSON_BINDATA.getCaseSensitivity())),\n<line_number-2156>                        new BsonElement(SEARCHABLE, new BsonInt32(typePredNone)),\n<line_number-2157>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2158>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2159>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2160>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2161>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_BINDATA.getMinScale())),\n<line_number-2162>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_BINDATA.getMaxScale())),\n<line_number-2163>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2164>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2165>                        new BsonElement(\n<line_number-2166>                                NUM_PREC_RADIX, new BsonInt32(BSON_BINDATA.getNumPrecRadix()))));\n<line_number-2167>\n<line_number-2168>        docs.add(\n<line_number-2169>                createBottomBson(\n<line_number-2170>                        new BsonElement(TYPE_NAME, new BsonString(BSON_STRING.getBsonName())),\n<line_number-2171>                        new BsonElement(DATA_TYPE, new BsonInt32(Types.LONGVARCHAR)),\n<line_number-2172>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_STRING.getPrecision())),\n<line_number-2173>                        new BsonElement(LITERAL_PREFIX, new BsonString(\"'\")),\n<line_number-2174>                        new BsonElement(LITERAL_SUFFIX, new BsonString(\"'\")),\n<line_number-2175>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2176>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2177>                        new BsonElement(\n<line_number-2178>                                CASE_SENSITIVE, new BsonBoolean(BSON_STRING.getCaseSensitivity())),\n<line_number-2179>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2180>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2181>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2182>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2183>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2184>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_STRING.getMinScale())),\n<line_number-2185>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_STRING.getMaxScale())),\n<line_number-2186>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2187>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2188>                        new BsonElement(\n<line_number-2189>                                NUM_PREC_RADIX, new BsonInt32(BSON_STRING.getNumPrecRadix()))));\n<line_number-2190>\n<line_number-2191>        docs.add(\n<line_number-2192>                createBottomBson(\n<line_number-2193>                        new BsonElement(TYPE_NAME, new BsonString(BSON_NULL.getBsonName())),\n<line_number-2194>                        new BsonElement(DATA_TYPE, new BsonInt32(BSON_NULL.getJdbcType())),\n<line_number-2195>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_NULL.getPrecision())),\n<line_number-2196>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2197>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2198>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2199>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2200>                        new BsonElement(\n<line_number-2201>                                CASE_SENSITIVE, new BsonBoolean(BSON_NULL.getCaseSensitivity())),\n<line_number-2202>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2203>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2204>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2205>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2206>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2207>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_NULL.getMinScale())),\n<line_number-2208>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_NULL.getMaxScale())),\n<line_number-2209>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2210>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2211>                        new BsonElement(\n<line_number-2212>                                NUM_PREC_RADIX, new BsonInt32(BSON_NULL.getNumPrecRadix()))));\n<line_number-2213>\n<line_number-2214>        docs.add(\n<line_number-2215>                createBottomBson(\n<line_number-2216>                        new BsonElement(TYPE_NAME, new BsonString(BSON_DECIMAL.getBsonName())),\n<line_number-2217>                        new BsonElement(DATA_TYPE, new BsonInt32(Types.DECIMAL)),\n<line_number-2218>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_DECIMAL.getPrecision())),\n<line_number-2219>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2220>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2221>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2222>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2223>                        new BsonElement(\n<line_number-2224>                                CASE_SENSITIVE, new BsonBoolean(BSON_DECIMAL.getCaseSensitivity())),\n<line_number-2225>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2226>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2227>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2228>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2229>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2230>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_DECIMAL.getMinScale())),\n<line_number-2231>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_DECIMAL.getMaxScale())),\n<line_number-2232>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2233>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2234>                        new BsonElement(\n<line_number-2235>                                NUM_PREC_RADIX, new BsonInt32(BSON_DECIMAL.getNumPrecRadix()))));\n<line_number-2236>\n<line_number-2237>        docs.add(\n<line_number-2238>                createBottomBson(\n<line_number-2239>                        new BsonElement(TYPE_NAME, new BsonString(BSON_INT.getBsonName())),\n<line_number-2240>                        new BsonElement(DATA_TYPE, new BsonInt32(Types.INTEGER)),\n<line_number-2241>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_INT.getPrecision())),\n<line_number-2242>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2243>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2244>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2245>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2246>                        new BsonElement(\n<line_number-2247>                                CASE_SENSITIVE, new BsonBoolean(BSON_INT.getCaseSensitivity())),\n<line_number-2248>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2249>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2250>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2251>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2252>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2253>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_INT.getMinScale())),\n<line_number-2254>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_INT.getMaxScale())),\n<line_number-2255>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2256>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2257>                        new BsonElement(\n<line_number-2258>                                NUM_PREC_RADIX, new BsonInt32(BSON_INT.getNumPrecRadix()))));\n<line_number-2259>\n<line_number-2260>        docs.add(\n<line_number-2261>                createBottomBson(\n<line_number-2262>                        new BsonElement(TYPE_NAME, new BsonString(BSON_DOUBLE.getBsonName())),\n<line_number-2263>                        new BsonElement(DATA_TYPE, new BsonInt32(Types.DOUBLE)),\n<line_number-2264>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_DOUBLE.getPrecision())),\n<line_number-2265>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2266>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2267>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2268>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2269>                        new BsonElement(\n<line_number-2270>                                CASE_SENSITIVE, new BsonBoolean(BSON_DOUBLE.getCaseSensitivity())),\n<line_number-2271>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2272>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2273>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2274>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2275>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2276>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_DOUBLE.getMinScale())),\n<line_number-2277>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_DOUBLE.getMaxScale())),\n<line_number-2278>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2279>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2280>                        new BsonElement(\n<line_number-2281>                                NUM_PREC_RADIX, new BsonInt32(BSON_DOUBLE.getNumPrecRadix()))));\n<line_number-2282>\n<line_number-2283>        docs.add(\n<line_number-2284>                createBottomBson(\n<line_number-2285>                        new BsonElement(TYPE_NAME, new BsonString(BSON_BOOL.getBsonName())),\n<line_number-2286>                        new BsonElement(DATA_TYPE, new BsonInt32(BSON_BOOL.getJdbcType())),\n<line_number-2287>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_BOOL.getPrecision())),\n<line_number-2288>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2289>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2290>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2291>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2292>                        new BsonElement(\n<line_number-2293>                                CASE_SENSITIVE, new BsonBoolean(BSON_BOOL.getCaseSensitivity())),\n<line_number-2294>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2295>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2296>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2297>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2298>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2299>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_BOOL.getMinScale())),\n<line_number-2300>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_BOOL.getMaxScale())),\n<line_number-2301>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2302>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2303>                        new BsonElement(\n<line_number-2304>                                NUM_PREC_RADIX, new BsonInt32(BSON_BOOL.getNumPrecRadix()))));\n<line_number-2305>\n<line_number-2306>        docs.add(\n<line_number-2307>                createBottomBson(\n<line_number-2308>                        new BsonElement(TYPE_NAME, new BsonString(BSON_DATE.getBsonName())),\n<line_number-2309>                        new BsonElement(DATA_TYPE, new BsonInt32(Types.TIMESTAMP)),\n<line_number-2310>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_DATE.getPrecision())),\n<line_number-2311>                        new BsonElement(LITERAL_PREFIX, new BsonString(\"'\")),\n<line_number-2312>                        new BsonElement(LITERAL_SUFFIX, new BsonString(\"'\")),\n<line_number-2313>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2314>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2315>                        new BsonElement(\n<line_number-2316>                                CASE_SENSITIVE, new BsonBoolean(BSON_DATE.getCaseSensitivity())),\n<line_number-2317>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2318>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2319>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2320>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2321>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2322>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_DATE.getMinScale())),\n<line_number-2323>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_DATE.getMaxScale())),\n<line_number-2324>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2325>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2326>                        new BsonElement(\n<line_number-2327>                                NUM_PREC_RADIX, new BsonInt32(BSON_DATE.getNumPrecRadix()))));\n<line_number-2328>\n<line_number-2329>        docs.add(\n<line_number-2330>                createBottomBson(\n<line_number-2331>                        new BsonElement(TYPE_NAME, new BsonString(BSON_ARRAY.getBsonName())),\n<line_number-2332>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2333>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_ARRAY.getPrecision())),\n<line_number-2334>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2335>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2336>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2337>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2338>                        new BsonElement(\n<line_number-2339>                                CASE_SENSITIVE, new BsonBoolean(BSON_ARRAY.getCaseSensitivity())),\n<line_number-2340>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2341>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2342>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2343>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2344>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2345>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_ARRAY.getMinScale())),\n<line_number-2346>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_ARRAY.getMaxScale())),\n<line_number-2347>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2348>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2349>                        new BsonElement(\n<line_number-2350>                                NUM_PREC_RADIX, new BsonInt32(BSON_ARRAY.getNumPrecRadix()))));\n<line_number-2351>\n<line_number-2352>        docs.add(\n<line_number-2353>                createBottomBson(\n<line_number-2354>                        new BsonElement(TYPE_NAME, new BsonString(BSON_BSON.getBsonName())),\n<line_number-2355>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2356>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_BSON.getPrecision())),\n<line_number-2357>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2358>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2359>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2360>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2361>                        new BsonElement(\n<line_number-2362>                                CASE_SENSITIVE, new BsonBoolean(BSON_BSON.getCaseSensitivity())),\n<line_number-2363>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2364>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2365>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2366>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2367>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2368>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_BSON.getMinScale())),\n<line_number-2369>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_BSON.getMaxScale())),\n<line_number-2370>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2371>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2372>                        new BsonElement(\n<line_number-2373>                                NUM_PREC_RADIX, new BsonInt32(BSON_BSON.getNumPrecRadix()))));\n<line_number-2374>\n<line_number-2375>        docs.add(\n<line_number-2376>                createBottomBson(\n<line_number-2377>                        new BsonElement(TYPE_NAME, new BsonString(BSON_DBPOINTER.getBsonName())),\n<line_number-2378>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2379>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_DBPOINTER.getPrecision())),\n<line_number-2380>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2381>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2382>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2383>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2384>                        new BsonElement(\n<line_number-2385>                                CASE_SENSITIVE,\n<line_number-2386>                                new BsonBoolean(BSON_DBPOINTER.getCaseSensitivity())),\n<line_number-2387>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2388>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2389>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2390>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2391>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2392>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_DBPOINTER.getMinScale())),\n<line_number-2393>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_DBPOINTER.getMaxScale())),\n<line_number-2394>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2395>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2396>                        new BsonElement(\n<line_number-2397>                                NUM_PREC_RADIX, new BsonInt32(BSON_DBPOINTER.getNumPrecRadix()))));\n<line_number-2398>\n<line_number-2399>        docs.add(\n<line_number-2400>                createBottomBson(\n<line_number-2401>                        new BsonElement(TYPE_NAME, new BsonString(BSON_JAVASCRIPT.getBsonName())),\n<line_number-2402>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2403>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_JAVASCRIPT.getPrecision())),\n<line_number-2404>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2405>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2406>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2407>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2408>                        new BsonElement(\n<line_number-2409>                                CASE_SENSITIVE,\n<line_number-2410>                                new BsonBoolean(BSON_JAVASCRIPT.getCaseSensitivity())),\n<line_number-2411>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2412>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2413>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2414>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2415>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2416>                        new BsonElement(\n<line_number-2417>                                MINIMUM_SCALE, new BsonInt32(BSON_JAVASCRIPT.getMinScale())),\n<line_number-2418>                        new BsonElement(\n<line_number-2419>                                MAXIMUM_SCALE, new BsonInt32(BSON_JAVASCRIPT.getMaxScale())),\n<line_number-2420>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2421>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2422>                        new BsonElement(\n<line_number-2423>                                NUM_PREC_RADIX, new BsonInt32(BSON_JAVASCRIPT.getNumPrecRadix()))));\n<line_number-2424>\n<line_number-2425>        docs.add(\n<line_number-2426>                createBottomBson(\n<line_number-2427>                        new BsonElement(\n<line_number-2428>                                TYPE_NAME, new BsonString(BSON_JAVASCRIPTWITHSCOPE.getBsonName())),\n<line_number-2429>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2430>                        new BsonElement(\n<line_number-2431>                                PRECISION,\n<line_number-2432>                                asBsonIntOrNull(BSON_JAVASCRIPTWITHSCOPE.getPrecision())),\n<line_number-2433>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2434>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2435>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2436>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2437>                        new BsonElement(\n<line_number-2438>                                CASE_SENSITIVE,\n<line_number-2439>                                new BsonBoolean(BSON_JAVASCRIPTWITHSCOPE.getCaseSensitivity())),\n<line_number-2440>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2441>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2442>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2443>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2444>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2445>                        new BsonElement(\n<line_number-2446>                                MINIMUM_SCALE,\n<line_number-2447>                                new BsonInt32(BSON_JAVASCRIPTWITHSCOPE.getMinScale())),\n<line_number-2448>                        new BsonElement(\n<line_number-2449>                                MAXIMUM_SCALE,\n<line_number-2450>                                new BsonInt32(BSON_JAVASCRIPTWITHSCOPE.getMaxScale())),\n<line_number-2451>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2452>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2453>                        new BsonElement(\n<line_number-2454>                                NUM_PREC_RADIX,\n<line_number-2455>                                new BsonInt32(BSON_JAVASCRIPTWITHSCOPE.getNumPrecRadix()))));\n<line_number-2456>\n<line_number-2457>        docs.add(\n<line_number-2458>                createBottomBson(\n<line_number-2459>                        new BsonElement(TYPE_NAME, new BsonString(BSON_MAXKEY.getBsonName())),\n<line_number-2460>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2461>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_MAXKEY.getPrecision())),\n<line_number-2462>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2463>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2464>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2465>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2466>                        new BsonElement(\n<line_number-2467>                                CASE_SENSITIVE, new BsonBoolean(BSON_MAXKEY.getCaseSensitivity())),\n<line_number-2468>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2469>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2470>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2471>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2472>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2473>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_MAXKEY.getMinScale())),\n<line_number-2474>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_MAXKEY.getMaxScale())),\n<line_number-2475>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2476>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2477>                        new BsonElement(\n<line_number-2478>                                NUM_PREC_RADIX, new BsonInt32(BSON_MAXKEY.getNumPrecRadix()))));\n<line_number-2479>\n<line_number-2480>        docs.add(\n<line_number-2481>                createBottomBson(\n<line_number-2482>                        new BsonElement(TYPE_NAME, new BsonString(BSON_MINKEY.getBsonName())),\n<line_number-2483>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2484>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_MINKEY.getPrecision())),\n<line_number-2485>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2486>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2487>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2488>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2489>                        new BsonElement(\n<line_number-2490>                                CASE_SENSITIVE, new BsonBoolean(BSON_MINKEY.getCaseSensitivity())),\n<line_number-2491>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2492>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2493>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2494>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2495>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2496>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_MINKEY.getMinScale())),\n<line_number-2497>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_MINKEY.getMaxScale())),\n<line_number-2498>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2499>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2500>                        new BsonElement(\n<line_number-2501>                                NUM_PREC_RADIX, new BsonInt32(BSON_MINKEY.getNumPrecRadix()))));\n<line_number-2502>\n<line_number-2503>        docs.add(\n<line_number-2504>                createBottomBson(\n<line_number-2505>                        new BsonElement(TYPE_NAME, new BsonString(BSON_OBJECT.getBsonName())),\n<line_number-2506>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2507>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_OBJECT.getPrecision())),\n<line_number-2508>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2509>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2510>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2511>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2512>                        new BsonElement(\n<line_number-2513>                                CASE_SENSITIVE, new BsonBoolean(BSON_OBJECT.getCaseSensitivity())),\n<line_number-2514>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2515>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2516>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2517>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2518>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2519>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_OBJECT.getMinScale())),\n<line_number-2520>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_OBJECT.getMaxScale())),\n<line_number-2521>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2522>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2523>                        new BsonElement(\n<line_number-2524>                                NUM_PREC_RADIX, new BsonInt32(BSON_OBJECT.getNumPrecRadix()))));\n<line_number-2525>\n<line_number-2526>        docs.add(\n<line_number-2527>                createBottomBson(\n<line_number-2528>                        new BsonElement(TYPE_NAME, new BsonString(BSON_OBJECTID.getBsonName())),\n<line_number-2529>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2530>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_OBJECTID.getPrecision())),\n<line_number-2531>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2532>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2533>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2534>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2535>                        new BsonElement(\n<line_number-2536>                                CASE_SENSITIVE,\n<line_number-2537>                                new BsonBoolean(BSON_OBJECTID.getCaseSensitivity())),\n<line_number-2538>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2539>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2540>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2541>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2542>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2543>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_OBJECTID.getMinScale())),\n<line_number-2544>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_OBJECTID.getMaxScale())),\n<line_number-2545>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2546>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2547>                        new BsonElement(\n<line_number-2548>                                NUM_PREC_RADIX, new BsonInt32(BSON_OBJECTID.getNumPrecRadix()))));\n<line_number-2549>\n<line_number-2550>        docs.add(\n<line_number-2551>                createBottomBson(\n<line_number-2552>                        new BsonElement(TYPE_NAME, new BsonString(BSON_REGEX.getBsonName())),\n<line_number-2553>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2554>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_REGEX.getPrecision())),\n<line_number-2555>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2556>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2557>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2558>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2559>                        new BsonElement(\n<line_number-2560>                                CASE_SENSITIVE, new BsonBoolean(BSON_REGEX.getCaseSensitivity())),\n<line_number-2561>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2562>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2563>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2564>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2565>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2566>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_REGEX.getMinScale())),\n<line_number-2567>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_REGEX.getMaxScale())),\n<line_number-2568>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2569>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2570>                        new BsonElement(\n<line_number-2571>                                NUM_PREC_RADIX, new BsonInt32(BSON_REGEX.getNumPrecRadix()))));\n<line_number-2572>\n<line_number-2573>        docs.add(\n<line_number-2574>                createBottomBson(\n<line_number-2575>                        new BsonElement(TYPE_NAME, new BsonString(BSON_SYMBOL.getBsonName())),\n<line_number-2576>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2577>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_SYMBOL.getPrecision())),\n<line_number-2578>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2579>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2580>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2581>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2582>                        new BsonElement(\n<line_number-2583>                                CASE_SENSITIVE, new BsonBoolean(BSON_SYMBOL.getCaseSensitivity())),\n<line_number-2584>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2585>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2586>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2587>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2588>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2589>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_SYMBOL.getMinScale())),\n<line_number-2590>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_SYMBOL.getMaxScale())),\n<line_number-2591>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2592>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2593>                        new BsonElement(\n<line_number-2594>                                NUM_PREC_RADIX, new BsonInt32(BSON_SYMBOL.getNumPrecRadix()))));\n<line_number-2595>\n<line_number-2596>        docs.add(\n<line_number-2597>                createBottomBson(\n<line_number-2598>                        new BsonElement(TYPE_NAME, new BsonString(BSON_TIMESTAMP.getBsonName())),\n<line_number-2599>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2600>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_TIMESTAMP.getPrecision())),\n<line_number-2601>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2602>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2603>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2604>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2605>                        new BsonElement(\n<line_number-2606>                                CASE_SENSITIVE,\n<line_number-2607>                                new BsonBoolean(BSON_TIMESTAMP.getCaseSensitivity())),\n<line_number-2608>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2609>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2610>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2611>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2612>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2613>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_TIMESTAMP.getMinScale())),\n<line_number-2614>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_TIMESTAMP.getMaxScale())),\n<line_number-2615>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2616>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2617>                        new BsonElement(\n<line_number-2618>                                NUM_PREC_RADIX, new BsonInt32(BSON_TIMESTAMP.getNumPrecRadix()))));\n<line_number-2619>\n<line_number-2620>        docs.add(\n<line_number-2621>                createBottomBson(\n<line_number-2622>                        new BsonElement(TYPE_NAME, new BsonString(BSON_UNDEFINED.getBsonName())),\n<line_number-2623>                        new BsonElement(DATA_TYPE, BSON_OTHER_INT_VALUE),\n<line_number-2624>                        new BsonElement(PRECISION, asBsonIntOrNull(BSON_UNDEFINED.getPrecision())),\n<line_number-2625>                        new BsonElement(LITERAL_PREFIX, BsonNull.VALUE),\n<line_number-2626>                        new BsonElement(LITERAL_SUFFIX, BsonNull.VALUE),\n<line_number-2627>                        new BsonElement(CREATE_PARAMS, BsonNull.VALUE),\n<line_number-2628>                        new BsonElement(NULLABLE, BSON_COLUMN_NULLABLE_INT_VALUE),\n<line_number-2629>                        new BsonElement(\n<line_number-2630>                                CASE_SENSITIVE,\n<line_number-2631>                                new BsonBoolean(BSON_UNDEFINED.getCaseSensitivity())),\n<line_number-2632>                        new BsonElement(SEARCHABLE, BSON_TYPE_SEARCHABLE_INT_VALUE),\n<line_number-2633>                        new BsonElement(UNSIGNED_ATTRIBUTE, BsonBoolean.FALSE),\n<line_number-2634>                        new BsonElement(FIXED_PREC_SCALE, BsonBoolean.FALSE),\n<line_number-2635>                        new BsonElement(AUTO_INCREMENT, BsonBoolean.FALSE),\n<line_number-2636>                        new BsonElement(LOCAL_TYPE_NAME, BsonNull.VALUE),\n<line_number-2637>                        new BsonElement(MINIMUM_SCALE, new BsonInt32(BSON_UNDEFINED.getMinScale())),\n<line_number-2638>                        new BsonElement(MAXIMUM_SCALE, new BsonInt32(BSON_UNDEFINED.getMaxScale())),\n<line_number-2639>                        new BsonElement(SQL_DATA_TYPE, BSON_ZERO_INT_VALUE),\n<line_number-2640>                        new BsonElement(SQL_DATETIME_SUB, BSON_ZERO_INT_VALUE),\n<line_number-2641>                        new BsonElement(\n<line_number-2642>                                NUM_PREC_RADIX, new BsonInt32(BSON_UNDEFINED.getNumPrecRadix()))));\n<line_number-2643>\n<line_number-2644>        // All fields in this result set are nested under the bottom namespace.\n<line_number-2645>        MongoJsonSchema botSchema = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-2646>        botSchema.properties.put(BOT_NAME, schema);\n<line_number-2647>        return new MongoResultSet(conn.getLogger(), new BsonExplicitCursor(docs), botSchema);\n<line_number-2648>    }\n<line_number-2649>\n<line_number-2650>    // Helper for creating stream of bson documents from the columns in the indexInfo doc.\n<line_number-2651>    private Stream<BsonDocument> toGetIndexInfoDocs(\n<line_number-2652>            String dbName, String tableName, Document indexInfo) {\n<line_number-2653>        Boolean isUnique = indexInfo.getEmbedded(UNIQUE_KEY_PATH, Boolean.class);\n<line_number-2654>        BsonValue nonUnique = new BsonBoolean(isUnique == null || !isUnique);\n<line_number-2655>        BsonValue indexName = new BsonString(indexInfo.getString(INDEX_NAME_KEY));\n<line_number-2656>\n<line_number-2657>        Document keys = indexInfo.get(INDEX_KEY_KEY, Document.class);\n<line_number-2658>        AtomicInteger pos = new AtomicInteger();\n<line_number-2659>\n<line_number-2660>        return keys.keySet()\n<line_number-2661>                .stream()\n<line_number-2662>                .filter(\n<line_number-2663>                        key -> {\n<line_number-2664>                            // If the index is not an integer (e.g., a geospatial index), `keys.getInteger(key)`\n<line_number-2665>                            // will throw a ClassCastException. In this case, we skip the index because the\n<line_number-2666>                            // sort sequence is not supported by JDBC.\n<line_number-2667>                            try {\n<line_number-2668>                                keys.getInteger(key);\n<line_number-2669>                            } catch (ClassCastException e) {\n<line_number-2670>                                return false;\n<line_number-2671>                            }\n<line_number-2672>                            return true;\n<line_number-2673>                        })\n<line_number-2674>                .map(\n<line_number-2675>                        key -> {\n<line_number-2676>                            BsonValue ascOrDesc =\n<line_number-2677>                                    new BsonString(keys.getInteger(key) > 0 ? \"A\" : \"D\");\n<line_number-2678>\n<line_number-2679>                            return createSortableBottomBson(\n<line_number-2680>                                    // Per JDBC spec, sort by  NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.\n<line_number-2681>                                    // Since TYPE is the same for every index, we omit it here.\n<line_number-2682>                                    GET_INDEX_INFO_SORT_SPECS,\n<line_number-2683>                                    new BsonElement(TABLE_CAT, new BsonString(dbName)),\n<line_number-2684>                                    new BsonElement(TABLE_SCHEM, BsonNull.VALUE),\n<line_number-2685>                                    new BsonElement(TABLE_NAME, new BsonString(tableName)),\n<line_number-2686>                                    new BsonElement(NON_UNIQUE, nonUnique),\n<line_number-2687>                                    new BsonElement(INDEX_QUALIFIER, BsonNull.VALUE),\n<line_number-2688>                                    new BsonElement(INDEX_NAME, indexName),\n<line_number-2689>                                    new BsonElement(TYPE, new BsonInt32(tableIndexOther)),\n<line_number-2690>                                    new BsonElement(\n<line_number-2691>                                            ORDINAL_POSITION, new BsonInt32(pos.incrementAndGet())),\n<line_number-2692>                                    new BsonElement(COLUMN_NAME, new BsonString(key)),\n<line_number-2693>                                    new BsonElement(ASC_OR_DESC, ascOrDesc),\n<line_number-2694>                                    new BsonElement(CARDINALITY, BsonNull.VALUE),\n<line_number-2695>                                    new BsonElement(PAGES, BsonNull.VALUE),\n<line_number-2696>                                    new BsonElement(FILTER_CONDITION, BsonNull.VALUE));\n<line_number-2697>                        });\n<line_number-2698>    }\n<line_number-2699>\n<line_number-2700>    // Helper for getting stream of bson documents for indexes in the argued table. This is\n<line_number-2701>    // used for creating the result set for getIndexInfo method.\n<line_number-2702>    private Stream<BsonDocument> getIndexesFromTable(\n<line_number-2703>            String dbName, String tableName, boolean unique) {\n<line_number-2704>        return this.conn\n<line_number-2705>                .getDatabase(dbName)\n<line_number-2706>                .getCollection(tableName)\n<line_number-2707>                .listIndexes()\n<line_number-2708>                .into(new ArrayList<>())\n<line_number-2709>                .stream()\n<line_number-2710>                .filter(\n<line_number-2711>                        d -> {\n<line_number-2712>                            Boolean isUnique = d.getEmbedded(UNIQUE_KEY_PATH, Boolean.class);\n<line_number-2713>\n<line_number-2714>                            // If unique is false, include all indexes. If it is true, include\n<line_number-2715>                            // only indexes that are marked as unique.\n<line_number-2716>                            return !unique || (isUnique != null && isUnique);\n<line_number-2717>                        })\n<line_number-2718>                .flatMap(d -> toGetIndexInfoDocs(dbName, tableName, d));\n<line_number-2719>    }\n<line_number-2720>\n<line_number-2721>    @Override\n<line_number-2722>    public ResultSet getIndexInfo(\n<line_number-2723>            String catalog, String schema, String table, boolean unique, boolean approximate)\n<line_number-2724>            throws SQLException {\n<line_number-2725>        MongoJsonSchema botSchema =\n<line_number-2726>                createBottomSchema(\n<line_number-2727>                        new MongoJsonSchema.ScalarProperties(TABLE_CAT, BSON_STRING, false),\n<line_number-2728>                        new MongoJsonSchema.ScalarProperties(TABLE_SCHEM, BSON_STRING, false),\n<line_number-2729>                        new MongoJsonSchema.ScalarProperties(TABLE_NAME, BSON_STRING),\n<line_number-2730>                        new MongoJsonSchema.ScalarProperties(NON_UNIQUE, BSON_BOOL),\n<line_number-2731>                        new MongoJsonSchema.ScalarProperties(INDEX_QUALIFIER, BSON_STRING, false),\n<line_number-2732>                        new MongoJsonSchema.ScalarProperties(INDEX_NAME, BSON_STRING, false),\n<line_number-2733>                        new MongoJsonSchema.ScalarProperties(TYPE, BSON_INT),\n<line_number-2734>                        new MongoJsonSchema.ScalarProperties(ORDINAL_POSITION, BSON_INT),\n<line_number-2735>                        new MongoJsonSchema.ScalarProperties(COLUMN_NAME, BSON_STRING, false),\n<line_number-2736>                        new MongoJsonSchema.ScalarProperties(ASC_OR_DESC, BSON_STRING, false),\n<line_number-2737>                        new MongoJsonSchema.ScalarProperties(CARDINALITY, BSON_LONG),\n<line_number-2738>                        new MongoJsonSchema.ScalarProperties(PAGES, BSON_LONG),\n<line_number-2739>                        new MongoJsonSchema.ScalarProperties(FILTER_CONDITION, BSON_LONG, false));\n<line_number-2740>\n<line_number-2741>        Stream<BsonDocument> docs;\n<line_number-2742>        if (catalog == null) {\n<line_number-2743>            // If no catalog (database) is specified, get indexes for all databases that have a\n<line_number-2744>            // collection with the argued table name.\n<line_number-2745>            docs =\n<line_number-2746>                    this.getDatabaseNames()\n<line_number-2747>                            .flatMap(\n<line_number-2748>                                    dbName ->\n<line_number-2749>                                            this.getTableDataFromDB(\n<line_number-2750>                                                            dbName, res -> res.name.equals(table))\n<line_number-2751>                                                    .flatMap(\n<line_number-2752>                                                            r ->\n<line_number-2753>                                                                    getIndexesFromTable(\n<line_number-2754>                                                                            dbName, r.name,\n<line_number-2755>                                                                            unique)));\n<line_number-2756>        } else if (catalog.isEmpty()) {\n<line_number-2757>            // If catalog (database) is empty, we will return an empty result set because\n<line_number-2758>            // MongoDB does not support tables (collections) without databases.\n<line_number-2759>            docs = Stream.empty();\n<line_number-2760>        } else {\n<line_number-2761>            docs = getIndexesFromTable(catalog, table, unique);\n<line_number-2762>        }\n<line_number-2763>\n<line_number-2764>        // Collect to sorted list.\n<line_number-2765>        List<BsonDocument> docsList = docs.sorted().collect(Collectors.toList());\n<line_number-2766>        BsonExplicitCursor c = new BsonExplicitCursor(docsList);\n<line_number-2767>\n<line_number-2768>        return new MongoResultSet(conn.getLogger(), c, botSchema);\n<line_number-2769>    }\n<line_number-2770>\n<line_number-2771>    @Override\n<line_number-2772>    public ResultSet getUDTs(\n<line_number-2773>            String catalog, String schemaPattern, String typeNamePattern, int[] types)\n<line_number-2774>            throws SQLException {\n<line_number-2775>        MongoJsonSchema botSchema =\n<line_number-2776>                createBottomSchema(\n<line_number-2777>                        new MongoJsonSchema.ScalarProperties(TYPE_CAT, BSON_STRING, false),\n<line_number-2778>                        new MongoJsonSchema.ScalarProperties(TYPE_SCHEM, BSON_STRING, false),\n<line_number-2779>                        new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING),\n<line_number-2780>                        new MongoJsonSchema.ScalarProperties(CLASS_NAME, BSON_STRING),\n<line_number-2781>                        new MongoJsonSchema.ScalarProperties(DATA_TYPE, BSON_INT),\n<line_number-2782>                        new MongoJsonSchema.ScalarProperties(REMARKS, BSON_STRING),\n<line_number-2783>                        new MongoJsonSchema.ScalarProperties(BASE_TYPE, BSON_INT, false));\n<line_number-2784>\n<line_number-2785>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-2786>    }\n<line_number-2787>\n<line_number-2788>    @Override\n<line_number-2789>    public ResultSet getSuperTypes(String catalog, String schemaPattern, String typeNamePattern)\n<line_number-2790>            throws SQLException {\n<line_number-2791>        MongoJsonSchema botSchema =\n<line_number-2792>                createBottomSchema(\n<line_number-2793>                        new MongoJsonSchema.ScalarProperties(TYPE_CAT, BSON_STRING, false),\n<line_number-2794>                        new MongoJsonSchema.ScalarProperties(TYPE_SCHEM, BSON_STRING, false),\n<line_number-2795>                        new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING),\n<line_number-2796>                        new MongoJsonSchema.ScalarProperties(SUPERTYPE_CAT, BSON_STRING, false),\n<line_number-2797>                        new MongoJsonSchema.ScalarProperties(SUPERTYPE_SCHEM, BSON_STRING, false),\n<line_number-2798>                        new MongoJsonSchema.ScalarProperties(SUPERTYPE_NAME, BSON_STRING));\n<line_number-2799>\n<line_number-2800>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-2801>    }\n<line_number-2802>\n<line_number-2803>    @Override\n<line_number-2804>    public ResultSet getSuperTables(String catalog, String schemaPattern, String tableNamePattern)\n<line_number-2805>            throws SQLException {\n<line_number-2806>        MongoJsonSchema botSchema =\n<line_number-2807>                createBottomSchema(\n<line_number-2808>                        new MongoJsonSchema.ScalarProperties(TABLE_CAT, BSON_STRING, false),\n<line_number-2809>                        new MongoJsonSchema.ScalarProperties(TABLE_SCHEM, BSON_STRING, false),\n<line_number-2810>                        new MongoJsonSchema.ScalarProperties(TABLE_NAME, BSON_STRING),\n<line_number-2811>                        new MongoJsonSchema.ScalarProperties(SUPERTABLE_NAME, BSON_STRING));\n<line_number-2812>\n<line_number-2813>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-2814>    }\n<line_number-2815>\n<line_number-2816>    @Override\n<line_number-2817>    public ResultSet getAttributes(\n<line_number-2818>            String catalog,\n<line_number-2819>            String schemaPattern,\n<line_number-2820>            String typeNamePattern,\n<line_number-2821>            String attributeNamePattern)\n<line_number-2822>            throws SQLException {\n<line_number-2823>        MongoJsonSchema botSchema =\n<line_number-2824>                createBottomSchema(\n<line_number-2825>                        new MongoJsonSchema.ScalarProperties(TYPE_CAT, BSON_STRING, false),\n<line_number-2826>                        new MongoJsonSchema.ScalarProperties(TYPE_SCHEM, BSON_STRING, false),\n<line_number-2827>                        new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING),\n<line_number-2828>                        new MongoJsonSchema.ScalarProperties(ATTR_NAME, BSON_STRING),\n<line_number-2829>                        new MongoJsonSchema.ScalarProperties(DATA_TYPE, BSON_INT),\n<line_number-2830>                        new MongoJsonSchema.ScalarProperties(ATTR_TYPE_NAME, BSON_STRING),\n<line_number-2831>                        new MongoJsonSchema.ScalarProperties(ATTR_SIZE, BSON_INT),\n<line_number-2832>                        new MongoJsonSchema.ScalarProperties(DECIMAL_DIGITS, BSON_INT, false),\n<line_number-2833>                        new MongoJsonSchema.ScalarProperties(NUM_PREC_RADIX, BSON_INT),\n<line_number-2834>                        new MongoJsonSchema.ScalarProperties(NULLABLE, BSON_INT),\n<line_number-2835>                        new MongoJsonSchema.ScalarProperties(REMARKS, BSON_STRING, false),\n<line_number-2836>                        new MongoJsonSchema.ScalarProperties(ATTR_DEF, BSON_STRING, false),\n<line_number-2837>                        new MongoJsonSchema.ScalarProperties(SQL_DATA_TYPE, BSON_INT),\n<line_number-2838>                        new MongoJsonSchema.ScalarProperties(SQL_DATETIME_SUB, BSON_INT),\n<line_number-2839>                        new MongoJsonSchema.ScalarProperties(CHAR_OCTET_LENGTH, BSON_INT),\n<line_number-2840>                        new MongoJsonSchema.ScalarProperties(ORDINAL_POSITION, BSON_INT),\n<line_number-2841>                        new MongoJsonSchema.ScalarProperties(IS_NULLABLE, BSON_STRING),\n<line_number-2842>                        new MongoJsonSchema.ScalarProperties(SCOPE_CATALOG, BSON_STRING, false),\n<line_number-2843>                        new MongoJsonSchema.ScalarProperties(SCOPE_SCHEMA, BSON_STRING, false),\n<line_number-2844>                        new MongoJsonSchema.ScalarProperties(SCOPE_TABLE, BSON_STRING, false),\n<line_number-2845>                        new MongoJsonSchema.ScalarProperties(SOURCE_DATA_TYPE, BSON_INT, false));\n<line_number-2846>\n<line_number-2847>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-2848>    }\n<line_number-2849>\n<line_number-2850>    //------------------------- JDBC 4.0 -----------------------------------\n<line_number-2851>\n<line_number-2852>    @Override\n<line_number-2853>    public ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException {\n<line_number-2854>        return getSchemas();\n<line_number-2855>    }\n<line_number-2856>\n<line_number-2857>    @Override\n<line_number-2858>    public ResultSet getClientInfoProperties() throws SQLException {\n<line_number-2859>        ArrayList<BsonDocument> docs = new ArrayList<>();\n<line_number-2860>\n<line_number-2861>        MongoJsonSchema schema = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-2862>        schema.addScalarKeys(\n<line_number-2863>                new MongoJsonSchema.ScalarProperties(NAME, BSON_STRING),\n<line_number-2864>                new MongoJsonSchema.ScalarProperties(MAX_LEN, BSON_STRING),\n<line_number-2865>                new MongoJsonSchema.ScalarProperties(DEFAULT_VALUE, BSON_STRING),\n<line_number-2866>                new MongoJsonSchema.ScalarProperties(DESCRIPTION, BSON_STRING));\n<line_number-2867>\n<line_number-2868>        // All fields in this result set are nested under the bottom namespace.\n<line_number-2869>        MongoJsonSchema botSchema = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-2870>        botSchema.properties.put(BOT_NAME, schema);\n<line_number-2871>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-2872>    }\n<line_number-2873>\n<line_number-2874>    private MongoJsonSchema getFunctionJsonSchema() {\n<line_number-2875>        MongoJsonSchema botSchema =\n<line_number-2876>                createBottomSchema(\n<line_number-2877>                        new MongoJsonSchema.ScalarProperties(FUNCTION_CAT, BSON_STRING, false),\n<line_number-2878>                        new MongoJsonSchema.ScalarProperties(FUNCTION_SCHEM, BSON_STRING, false),\n<line_number-2879>                        new MongoJsonSchema.ScalarProperties(FUNCTION_NAME, BSON_STRING),\n<line_number-2880>                        new MongoJsonSchema.ScalarProperties(REMARKS, BSON_STRING),\n<line_number-2881>                        new MongoJsonSchema.ScalarProperties(FUNCTION_TYPE, BSON_INT),\n<line_number-2882>                        new MongoJsonSchema.ScalarProperties(SPECIFIC_NAME, BSON_STRING));\n<line_number-2883>\n<line_number-2884>        return botSchema;\n<line_number-2885>    }\n<line_number-2886>\n<line_number-2887>    private BsonDocument getFunctionValuesDoc(String functionName, String remarks) {\n<line_number-2888>        BsonDocument root = new BsonDocument();\n<line_number-2889>        BsonDocument bot = new BsonDocument();\n<line_number-2890>        root.put(BOT_NAME, bot);\n<line_number-2891>        bot.put(FUNCTION_CAT, new BsonString(FUNC_DEFAULT_CATALOG));\n<line_number-2892>        bot.put(FUNCTION_SCHEM, BsonNull.VALUE);\n<line_number-2893>        bot.put(FUNCTION_NAME, new BsonString(functionName));\n<line_number-2894>        bot.put(REMARKS, new BsonString(remarks));\n<line_number-2895>        bot.put(FUNCTION_TYPE, new BsonInt32(functionNoTable));\n<line_number-2896>        bot.put(SPECIFIC_NAME, new BsonString(functionName));\n<line_number-2897>        return root;\n<line_number-2898>    }\n<line_number-2899>\n<line_number-2900>    @Override\n<line_number-2901>    public ResultSet getFunctions(String catalog, String schemaPattern, String functionNamePattern)\n<line_number-2902>            throws SQLException {\n<line_number-2903>        ArrayList<BsonDocument> docs = new ArrayList<>(MongoFunctions.functions.length);\n<line_number-2904>        MongoJsonSchema schema = getFunctionJsonSchema();\n<line_number-2905>\n<line_number-2906>        Pattern functionPatternRE = null;\n<line_number-2907>        if (functionNamePattern != null) {\n<line_number-2908>            functionPatternRE = toJavaPattern(functionNamePattern);\n<line_number-2909>        }\n<line_number-2910>\n<line_number-2911>        for (MongoFunctions.MongoFunction func : MongoFunctions.functions) {\n<line_number-2912>            if (functionPatternRE != null && !functionPatternRE.matcher(func.name).matches()) {\n<line_number-2913>                continue;\n<line_number-2914>            }\n<line_number-2915>            BsonDocument doc = getFunctionValuesDoc(func.name, func.comment);\n<line_number-2916>            docs.add(doc);\n<line_number-2917>        }\n<line_number-2918>\n<line_number-2919>        return new MongoResultSet(conn.getLogger(), new BsonExplicitCursor(docs), schema);\n<line_number-2920>    }\n<line_number-2921>\n<line_number-2922>    private MongoJsonSchema getFunctionColumnJsonSchema() {\n<line_number-2923>        MongoJsonSchema botSchema =\n<line_number-2924>                createBottomSchema(\n<line_number-2925>                        new MongoJsonSchema.ScalarProperties(FUNCTION_CAT, BSON_STRING, false),\n<line_number-2926>                        new MongoJsonSchema.ScalarProperties(FUNCTION_SCHEM, BSON_STRING, false),\n<line_number-2927>                        new MongoJsonSchema.ScalarProperties(FUNCTION_NAME, BSON_STRING),\n<line_number-2928>                        new MongoJsonSchema.ScalarProperties(COLUMN_NAME, BSON_STRING),\n<line_number-2929>                        new MongoJsonSchema.ScalarProperties(COLUMN_TYPE, BSON_INT),\n<line_number-2930>                        new MongoJsonSchema.ScalarProperties(DATA_TYPE, BSON_INT),\n<line_number-2931>                        new MongoJsonSchema.ScalarProperties(TYPE_NAME, BSON_STRING),\n<line_number-2932>                        new MongoJsonSchema.ScalarProperties(PRECISION, BSON_INT, false),\n<line_number-2933>                        new MongoJsonSchema.ScalarProperties(LENGTH, BSON_INT),\n<line_number-2934>                        new MongoJsonSchema.ScalarProperties(SCALE, BSON_INT, false),\n<line_number-2935>                        new MongoJsonSchema.ScalarProperties(RADIX, BSON_INT),\n<line_number-2936>                        new MongoJsonSchema.ScalarProperties(NULLABLE, BSON_INT),\n<line_number-2937>                        new MongoJsonSchema.ScalarProperties(REMARKS, BSON_STRING),\n<line_number-2938>                        new MongoJsonSchema.ScalarProperties(CHAR_OCTET_LENGTH, BSON_INT, false),\n<line_number-2939>                        new MongoJsonSchema.ScalarProperties(ORDINAL_POSITION, BSON_INT),\n<line_number-2940>                        new MongoJsonSchema.ScalarProperties(IS_NULLABLE, BSON_STRING),\n<line_number-2941>                        new MongoJsonSchema.ScalarProperties(SPECIFIC_NAME, BSON_STRING));\n<line_number-2942>        return botSchema;\n<line_number-2943>    }\n<line_number-2944>\n<line_number-2945>    /**\n<line_number-2946>     * Returns information for a given function argument.\n<line_number-2947>     *\n<line_number-2948>     * @param func The function name.\n<line_number-2949>     * @param i The parameter index.\n<line_number-2950>     * @param argName The parameter name.\n<line_number-2951>     * @param argType The parameter type.\n<line_number-2952>     * @param isReturnColumn Is the parameter a return parameter.\n<line_number-2953>     * @return the information for the given parameter.\n<line_number-2954>     */\n<line_number-2955>    private Map<String, BsonValue> getFunctionParameterValues(\n<line_number-2956>            MongoFunctions.MongoFunction func,\n<line_number-2957>            int i,\n<line_number-2958>            String argName,\n<line_number-2959>            String argType,\n<line_number-2960>            boolean isReturnColumn)\n<line_number-2961>            throws SQLException {\n<line_number-2962>        Map<String, BsonValue> info =\n<line_number-2963>                new LinkedHashMap<\n<line_number-2964>                        String,\n<line_number-2965>                        BsonValue>(); // Using a LinkedHashMap to conserve the insertion order\n<line_number-2966>        BsonTypeInfo bsonTypeInfo =\n<line_number-2967>                argType == null ? BSON_UNDEFINED : BsonTypeInfo.getBsonTypeInfoByName(argType);\n<line_number-2968>        info.put(FUNCTION_CAT, new BsonString(FUNC_DEFAULT_CATALOG));\n<line_number-2969>        info.put(FUNCTION_SCHEM, BsonNull.VALUE);\n<line_number-2970>        info.put(FUNCTION_NAME, new BsonString(func.name));\n<line_number-2971>\n<line_number-2972>        info.put(COLUMN_NAME, new BsonString(argName));\n<line_number-2973>        info.put(COLUMN_TYPE, asBsonIntOrNull(isReturnColumn ? functionReturn : functionColumnIn));\n<line_number-2974>        info.put(DATA_TYPE, asBsonIntOrNull(bsonTypeInfo.getJdbcType()));\n<line_number-2975>        info.put(\n<line_number-2976>                TYPE_NAME,\n<line_number-2977>                new BsonString(bsonTypeInfo == BSON_UNDEFINED ? \"\" : bsonTypeInfo.getBsonName()));\n<line_number-2978>\n<line_number-2979>        info.put(PRECISION, asBsonIntOrNull(bsonTypeInfo.getPrecision()));\n<line_number-2980>        // Note : LENGTH is only reported in getFunctionColumns and getProcedureColumns and is not flagged as 'may be null'\n<line_number-2981>        // so for unknown length we are defaulting to 0.\n<line_number-2982>        info.put(LENGTH, asBsonIntOrDefault(bsonTypeInfo.getFixedBytesLength(), 0));\n<line_number-2983>        info.put(SCALE, asBsonIntOrNull(bsonTypeInfo.getDecimalDigits()));\n<line_number-2984>        info.put(RADIX, new BsonInt32(bsonTypeInfo.getNumPrecRadix()));\n<line_number-2985>\n<line_number-2986>        info.put(NULLABLE, new BsonInt32(functionNullable));\n<line_number-2987>        info.put(REMARKS, new BsonString(func.comment));\n<line_number-2988>        info.put(CHAR_OCTET_LENGTH, asBsonIntOrNull(bsonTypeInfo.getCharOctetLength()));\n<line_number-2989>\n<line_number-2990>        info.put(ORDINAL_POSITION, new BsonInt32(i));\n<line_number-2991>        info.put(IS_NULLABLE, new BsonString(YES));\n<line_number-2992>\n<line_number-2993>        info.put(SPECIFIC_NAME, new BsonString(func.name));\n<line_number-2994>\n<line_number-2995>        return info;\n<line_number-2996>    }\n<line_number-2997>\n<line_number-2998>    private BsonDocument getFunctionColumnValuesDoc(\n<line_number-2999>            MongoFunctions.MongoFunction func,\n<line_number-3000>            int i,\n<line_number-3001>            String argName,\n<line_number-3002>            String argType,\n<line_number-3003>            boolean isReturnColumn)\n<line_number-3004>            throws SQLException {\n<line_number-3005>\n<line_number-3006>        Map<String, BsonValue> info =\n<line_number-3007>                getFunctionParameterValues(func, i, argName, argType, isReturnColumn);\n<line_number-3008>        BsonDocument root = new BsonDocument();\n<line_number-3009>        BsonDocument bot = new BsonDocument();\n<line_number-3010>        root.put(BOT_NAME, bot);\n<line_number-3011>        String functionName = func.name;\n<line_number-3012>        bot.putAll(info);\n<line_number-3013>        return root;\n<line_number-3014>    }\n<line_number-3015>\n<line_number-3016>    @Override\n<line_number-3017>    public ResultSet getFunctionColumns(\n<line_number-3018>            String catalog,\n<line_number-3019>            String schemaPattern,\n<line_number-3020>            String functionNamePattern,\n<line_number-3021>            String columnNamePattern)\n<line_number-3022>            throws SQLException {\n<line_number-3023>\n<line_number-3024>        ArrayList<BsonDocument> docs = new ArrayList<>(MongoFunctions.functions.length);\n<line_number-3025>        MongoJsonSchema schema = getFunctionColumnJsonSchema();\n<line_number-3026>\n<line_number-3027>        Pattern functionNamePatternRE = null;\n<line_number-3028>        Pattern columnNamePatternRE = null;\n<line_number-3029>        if (functionNamePattern != null) {\n<line_number-3030>            functionNamePatternRE = toJavaPattern(functionNamePattern);\n<line_number-3031>        }\n<line_number-3032>        if (columnNamePattern != null) {\n<line_number-3033>            columnNamePatternRE = toJavaPattern(columnNamePattern);\n<line_number-3034>        }\n<line_number-3035>\n<line_number-3036>        for (MongoFunctions.MongoFunction func : MongoFunctions.functions) {\n<line_number-3037>            if (functionNamePatternRE != null\n<line_number-3038>                    && !functionNamePatternRE.matcher(func.name).matches()) {\n<line_number-3039>                continue;\n<line_number-3040>            }\n<line_number-3041>            int i = 0;\n<line_number-3042>            for (String argType : func.argTypes) {\n<line_number-3043>                // We don't have better names for our arguments, for the most part.\n<line_number-3044>                ++i;\n<line_number-3045>                String columnName = \"arg\" + i;\n<line_number-3046>                if (columnNamePatternRE != null\n<line_number-3047>                        && !columnNamePatternRE.matcher(columnName).matches()) {\n<line_number-3048>                    continue;\n<line_number-3049>                }\n<line_number-3050>                BsonDocument doc = getFunctionColumnValuesDoc(func, i, columnName, argType, false);\n<line_number-3051>                docs.add(doc);\n<line_number-3052>            }\n<line_number-3053>            String columnName = \"argReturn\";\n<line_number-3054>            if (columnNamePatternRE == null || columnNamePatternRE.matcher(columnName).matches()) {\n<line_number-3055>                BsonDocument doc =\n<line_number-3056>                        getFunctionColumnValuesDoc(func, i, \"argReturn\", func.returnType, true);\n<line_number-3057>                docs.add(doc);\n<line_number-3058>            }\n<line_number-3059>        }\n<line_number-3060>\n<line_number-3061>        return new MongoResultSet(conn.getLogger(), new BsonExplicitCursor(docs), schema);\n<line_number-3062>    }\n<line_number-3063>\n<line_number-3064>    //--------------------------JDBC 4.1 -----------------------------\n<line_number-3065>    @Override\n<line_number-3066>    public ResultSet getPseudoColumns(\n<line_number-3067>            String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)\n<line_number-3068>            throws SQLException {\n<line_number-3069>        MongoJsonSchema botSchema =\n<line_number-3070>                createBottomSchema(\n<line_number-3071>                        new MongoJsonSchema.ScalarProperties(TABLE_CAT, BSON_STRING, false),\n<line_number-3072>                        new MongoJsonSchema.ScalarProperties(TABLE_SCHEM, BSON_STRING, false),\n<line_number-3073>                        new MongoJsonSchema.ScalarProperties(TABLE_NAME, BSON_STRING),\n<line_number-3074>                        new MongoJsonSchema.ScalarProperties(COLUMN_NAME, BSON_STRING),\n<line_number-3075>                        new MongoJsonSchema.ScalarProperties(DATA_TYPE, BSON_INT),\n<line_number-3076>                        new MongoJsonSchema.ScalarProperties(COLUMN_SIZE, BSON_INT),\n<line_number-3077>                        new MongoJsonSchema.ScalarProperties(DECIMAL_DIGITS, BSON_INT, false),\n<line_number-3078>                        new MongoJsonSchema.ScalarProperties(NUM_PREC_RADIX, BSON_STRING),\n<line_number-3079>                        new MongoJsonSchema.ScalarProperties(COLUMN_USAGE, BSON_STRING),\n<line_number-3080>                        new MongoJsonSchema.ScalarProperties(REMARKS, BSON_STRING, false),\n<line_number-3081>                        new MongoJsonSchema.ScalarProperties(CHAR_OCTET_LENGTH, BSON_INT),\n<line_number-3082>                        new MongoJsonSchema.ScalarProperties(IS_NULLABLE, BSON_STRING));\n<line_number-3083>\n<line_number-3084>        return new MongoResultSet(conn.getLogger(), BsonExplicitCursor.EMPTY_CURSOR, botSchema);\n<line_number-3085>    }\n<line_number-3086>}\n",
        "comments": [
          {
            "comment_code_range": "49-50",
            "comment_linenumber": "48",
            "comment": "This class implements DatabaseMetaData for MongoDB, providing metadata about the database, tables, and columns.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "241-244",
            "comment_linenumber": "240",
            "comment": "Constructor initializes the MongoDatabaseMetaData with a MongoConnection and sets up logging.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "246-248",
            "comment_linenumber": "245",
            "comment": "Creates a BSON document with fields nested under a bottom namespace for result sets.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "254-256",
            "comment_linenumber": "253",
            "comment": "Creates a sortable BSON document with fields nested under a bottom namespace for result sets.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "262-264",
            "comment_linenumber": "261",
            "comment": "Creates a BSON schema with fields nested under a bottom namespace for result sets.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "276-278",
            "comment_linenumber": "275",
            "comment": "Converts an Integer to a BSON value, returning null if the input is null.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "287-289",
            "comment_linenumber": "286",
            "comment": "Returns a comma-separated string of SQL keywords supported by MongoDB.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "342-354",
            "comment_linenumber": "341",
            "comment": "Retrieves procedures from the database, returning a result set with their metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "390-404",
            "comment_linenumber": "389",
            "comment": "Retrieves table types from the database, returning a result set with their metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "408-420",
            "comment_linenumber": "407",
            "comment": "Filters out empty and internal database names.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "422-424",
            "comment_linenumber": "421",
            "comment": "Retrieves collection names from the database using a run command.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "462-464",
            "comment_linenumber": "461",
            "comment": "Creates BSON documents for the getTables method, used for result set serialization.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "479-481",
            "comment_linenumber": "478",
            "comment": "Retrieves table data for all tables from a specific database, used by getTables and getTablePrivileges.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "483-485",
            "comment_linenumber": "482",
            "comment": "Creates BSON documents for the getTablePrivileges method, used for result set serialization.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "490-492",
            "comment_linenumber": "489",
            "comment": "Retrieves the first unique index documents for a specified table.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "495-497",
            "comment_linenumber": "494",
            "comment": "Creates BSON documents for the getBestRowIdentifier method, used for result set serialization.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "500-502",
            "comment_linenumber": "499",
            "comment": "Retrieves primary keys for a specified table, returning a result set with their metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "508-510",
            "comment_linenumber": "507",
            "comment": "Retrieves type information for the database, returning a result set with metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "515-517",
            "comment_linenumber": "514",
            "comment": "Retrieves schemas from the database, returning a result set with their metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "520-522",
            "comment_linenumber": "519",
            "comment": "Retrieves user-defined types from the database, returning a result set with their metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "525-527",
            "comment_linenumber": "524",
            "comment": "Retrieves super types from the database, returning a result set with their metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "530-532",
            "comment_linenumber": "529",
            "comment": "Retrieves super tables from the database, returning a result set with their metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "535-537",
            "comment_linenumber": "534",
            "comment": "Retrieves attributes from the database, returning a result set with their metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "540-542",
            "comment_linenumber": "539",
            "comment": "Retrieves schemas from the database, returning a result set with their metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "550-552",
            "comment_linenumber": "549",
            "comment": "Retrieves the connection associated with this metadata object.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoDatabaseMetaData.java' implements the DatabaseMetaData interface for MongoDB, providing methods to retrieve metadata about the database, tables, columns, and functions. It contains a single public class, MongoDatabaseMetaData, which has a constructor that initializes the MongoConnection and sets up logging. The class includes various methods that return information about SQL keywords, procedures, table types, and more, all tailored to the MongoDB context. The methods utilize BSON documents for data representation and employ helper methods for creating structured results. The class also handles exceptions related to SQL operations, ensuring that SQLExceptions are propagated correctly. Overall, the class serves as a bridge between JDBC and MongoDB, allowing for SQL-like interactions with MongoDB databases.",
        "file_summary": "This file defines the MongoDatabaseMetaData class, which implements the DatabaseMetaData interface for MongoDB, providing metadata about databases, tables, columns, and functions. It facilitates SQL-like interactions with MongoDB, allowing users to retrieve information about the database structure and properties."
      }
    ]
  },
  "MongoDriver.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoDriver.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoDriver.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoDriver.java",
        "chunk_id": "MongoDriver_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2020-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static com.mongodb.AuthenticationMechanism.*;\n<line_number-20>import static com.mongodb.jdbc.MongoDriver.MongoJDBCProperty.*;\n<line_number-21>import static org.bson.codecs.configuration.CodecRegistries.fromProviders;\n<line_number-22>\n<line_number-23>import com.mongodb.AuthenticationMechanism;\n<line_number-24>import com.mongodb.ConnectionString;\n<line_number-25>import com.mongodb.MongoClientSettings;\n<line_number-26>import com.mongodb.MongoConfigurationException;\n<line_number-27>import com.mongodb.client.MongoClient;\n<line_number-28>import com.mongodb.jdbc.utils.NativeLoader;\n<line_number-29>import java.io.*;\n<line_number-30>import java.lang.ref.WeakReference;\n<line_number-31>import java.net.URLEncoder;\n<line_number-32>import java.nio.file.Paths;\n<line_number-33>import java.sql.Connection;\n<line_number-34>import java.sql.Driver;\n<line_number-35>import java.sql.DriverManager;\n<line_number-36>import java.sql.DriverPropertyInfo;\n<line_number-37>import java.sql.SQLException;\n<line_number-38>import java.sql.SQLFeatureNotSupportedException;\n<line_number-39>import java.sql.SQLTimeoutException;\n<line_number-40>import java.util.ArrayList;\n<line_number-41>import java.util.Arrays;\n<line_number-42>import java.util.Enumeration;\n<line_number-43>import java.util.List;\n<line_number-44>import java.util.Properties;\n<line_number-45>import java.util.concurrent.ConcurrentHashMap;\n<line_number-46>import java.util.concurrent.TimeoutException;\n<line_number-47>import java.util.concurrent.locks.ReadWriteLock;\n<line_number-48>import java.util.concurrent.locks.ReentrantReadWriteLock;\n<line_number-49>import java.util.logging.Level;\n<line_number-50>import java.util.regex.Matcher;\n<line_number-51>import java.util.regex.Pattern;\n<line_number-52>import java.util.stream.Stream;\n<line_number-53>import org.bson.codecs.BsonValueCodecProvider;\n<line_number-54>import org.bson.codecs.ValueCodecProvider;\n<line_number-55>import org.bson.codecs.configuration.CodecRegistry;\n<line_number-56>import org.bson.codecs.pojo.PojoCodecProvider;\n<line_number-57>\n<line_number-58>/**\n<line_number-59> * The MongoDriver implements the java.sql.Driver interface, which allows for opening Connections to\n<line_number-60> * MonogDB databases that have SQL support.\n<line_number-61> *\n<line_number-62> * @see DriverManager\n<line_number-63> * @see Connection\n<line_number-64> * @since 1.0.0\n<line_number-65> */\n<line_number-66>public class MongoDriver implements Driver {\n<line_number-67>\n<line_number-68>    // The regular expression to validate and manipulate the mongoDB uri.\n<line_number-69>    protected static final Pattern MONGODB_URI_PATTERN =\n<line_number-70>            Pattern.compile(\n<line_number-71>                    \"(mongodb(?:\\\\+srv)?://)(?<uidpwd>(?:\\\\S+:)?\\\\S+@)?([^\\\\r\\\\n\\\\t\\\\f\\\\v ?]+(\\\\?(?<options>.*))?)\");\n<line_number-72>    // The regular expression to extract the authentication mechanism.\n<line_number-73>    protected static final Pattern AUTH_MECH_TO_AUGMENT_PATTERN =\n<line_number-74>            Pattern.compile(\n<line_number-75>                    \"authMechanism=(?<authMech>(\"\n<line_number-76>                            + PLAIN.getMechanismName()\n<line_number-77>                            + \"|\"\n<line_number-78>                            + SCRAM_SHA_1.getMechanismName()\n<line_number-79>                            + \"|\"\n<line_number-80>                            + SCRAM_SHA_256.getMechanismName()\n<line_number-81>                            + \"|\"\n<line_number-82>                            + GSSAPI.getMechanismName()\n<line_number-83>                            + \"))\");\n<line_number-84>    //The list of mechanism for which a username and/or password must be present for the first uri parsing pass.\n<line_number-85>    protected static final List<String> MECHANISMS_TO_AUGMENT =\n<line_number-86>            Arrays.asList(\n<line_number-87>                    PLAIN.getMechanismName(),\n<line_number-88>                    SCRAM_SHA_1.getMechanismName(),\n<line_number-89>                    SCRAM_SHA_256.getMechanismName(),\n<line_number-90>                    GSSAPI.getMechanismName());\n<line_number-91>\n<line_number-92>    /**\n<line_number-93>     * The list of connection options specific to the JDBC driver which can only be provided through\n<line_number-94>     * a Properties Object.\n<line_number-95>     */\n<line_number-96>    public enum MongoJDBCProperty {\n<line_number-97>        DATABASE(\"database\"),\n<line_number-98>        CLIENT_INFO(\"clientinfo\"),\n<line_number-99>        LOG_LEVEL(\"loglevel\"),\n<line_number-100>        LOG_DIR(\"logdir\"),\n<line_number-101>        EXT_JSON_MODE(\"extjsonmode\"),\n<line_number-102>        X509_PEM_PATH(\"x509pempath\"),\n<line_number-103>        DISABLE_CLIENT_CACHE(\"disableclientcache\");\n<line_number-104>\n<line_number-105>        private final String propertyName;\n<line_number-106>\n<line_number-107>        MongoJDBCProperty(String propertyName) {\n<line_number-108>            this.propertyName = propertyName;\n<line_number-109>        }\n<line_number-110>\n<line_number-111>        public String getPropertyName() {\n<line_number-112>            return propertyName;\n<line_number-113>        }\n<line_number-114>    }\n<line_number-115>\n<line_number-116>    /** All MongoDB SQL URLs must begin with jdbc:mongodb: */\n<line_number-117>    static final String JDBC = \"jdbc:\";\n<line_number-118>\n<line_number-119>    static final String MONGODB_URL_PREFIX = JDBC + \"mongodb:\";\n<line_number-120>    static final String MONGODB_SRV_URL_PREFIX = JDBC + \"mongodb+srv:\";\n<line_number-121>    public static final String USER = \"user\";\n<line_number-122>    public static final String PASSWORD = \"password\";\n<line_number-123>    static final String MONGODB_PRODUCT_NAME = \"MongoDB Atlas\";\n<line_number-124>    static final String MONGO_DRIVER_NAME = MONGODB_PRODUCT_NAME + \" SQL interface JDBC Driver\";\n<line_number-125>\n<line_number-126>    static final String NAME;\n<line_number-127>    static final String VERSION;\n<line_number-128>    static final int MAJOR_VERSION;\n<line_number-129>    static final int MINOR_VERSION;\n<line_number-130>    static final String LEVELS =\n<line_number-131>            Arrays.toString(\n<line_number-132>                    new String[] {\n<line_number-133>                        Level.OFF.getName(),\n<line_number-134>                        Level.SEVERE.getName(),\n<line_number-135>                        Level.FINER.getName(),\n<line_number-136>                        Level.INFO.getName(),\n<line_number-137>                        Level.FINE.getName(),\n<line_number-138>                        Level.WARNING.getName()\n<line_number-139>                    });\n<line_number-140>    static final String RELAXED = \"RELAXED\";\n<line_number-141>    static final String EXTENDED = \"EXTENDED\";\n<line_number-142>\n<line_number-143>    public static final String LOG_TO_CONSOLE = \"console\";\n<line_number-144>    protected static final String CONNECTION_ERROR_SQLSTATE = \"08000\";\n<line_number-145>    public static final String AUTHENTICATION_ERROR_SQLSTATE = \"28000\";\n<line_number-146>\n<line_number-147>    private static ConcurrentHashMap<Integer, WeakReference<MongoClient>> mongoClientCache =\n<line_number-148>            new ConcurrentHashMap<>();\n<line_number-149>    private static final ReadWriteLock mongoClientCacheLock = new ReentrantReadWriteLock();\n<line_number-150>\n<line_number-151>    public static String getVersion() {\n<line_number-152>        return VERSION != null ? VERSION : MAJOR_VERSION + \".\" + MINOR_VERSION;\n<line_number-153>    }\n<line_number-154>\n<line_number-155>    private static boolean mongoSqlTranslateLibraryLoaded = false;\n<line_number-156>    private static Exception mongoSqlTranslateLibraryLoadingError = null;\n<line_number-157>    private static String mongoSqlTranslateLibraryPath = null;\n<line_number-158>    private static final String MONGOSQL_TRANSLATE_NAME = \"mongosqltranslate\";\n<line_number-159>    public static final String MONGOSQL_TRANSLATE_PATH = \"MONGOSQL_TRANSLATE_PATH\";\n<line_number-160>\n<line_number-161>    protected static final CodecRegistry REGISTRY =\n<line_number-162>            fromProviders(\n<line_number-163>                    new BsonValueCodecProvider(),\n<line_number-164>                    new ValueCodecProvider(),\n<line_number-165>                    MongoClientSettings.getDefaultCodecRegistry(),\n<line_number-166>                    PojoCodecProvider.builder().automatic(true).build());\n<line_number-167>\n<line_number-168>    static String getAbbreviatedGitVersion() {\n<line_number-169>        Process p = null;\n<line_number-170>        try {\n<line_number-171>            // Unit and integration tests can't rely on the manifest from the jar\n<line_number-172>            // Get the git tag and use it as the version\n<line_number-173>            String command = \"git describe --abbrev=0\";\n<line_number-174>            p = Runtime.getRuntime().exec(command);\n<line_number-175>            try (BufferedReader input =\n<line_number-176>                    new BufferedReader(new InputStreamReader(p.getInputStream())); ) {\n<line_number-177>                StringBuilder version_sb = new StringBuilder();\n<line_number-178>                String line;\n<line_number-179>                while ((line = input.readLine()) != null) {\n<line_number-180>                    version_sb.append(line);\n<line_number-181>                }\n<line_number-182>                return version_sb.append(\"-SNAPSHOT\").substring(1).trim();\n<line_number-183>            }\n<line_number-184>        } catch (IOException e) {\n<line_number-185>            throw new RuntimeException(\n<line_number-186>                    new SQLException(\"Internal error retrieving driver version\"));\n<line_number-187>        } finally {\n<line_number-188>            if (p != null) {\n<line_number-189>                p.destroy();\n<line_number-190>            }\n<line_number-191>        }\n<line_number-192>    }\n<line_number-193>\n<line_number-194>    static int getClientCacheSizeForTest() {\n<line_number-195>        mongoClientCacheLock.readLock().lock();\n<line_number-196>        try {\n<line_number-197>            return mongoClientCache.size();\n<line_number-198>        } finally {\n<line_number-199>            mongoClientCacheLock.readLock().unlock();\n<line_number-200>        }\n<line_number-201>    }\n<line_number-202>\n<line_number-203>    static void clearClientCacheForTest() {\n<line_number-204>        mongoClientCacheLock.readLock().lock();\n<line_number-205>        try {\n<line_number-206>            mongoClientCache.clear();\n<line_number-207>        } finally {\n<line_number-208>            mongoClientCacheLock.readLock().unlock();\n<line_number-209>        }\n<line_number-210>    }\n<line_number-211>\n<line_number-212>    static {\n<line_number-213>        MongoDriver unit = new MongoDriver();\n<line_number-214>        try {\n<line_number-215>            DriverManager.registerDriver(unit);\n<line_number-216>        } catch (SQLException e) {\n<line_number-217>            throw new RuntimeException(e);\n<line_number-218>        }\n<line_number-219>\n<line_number-220>        String version = unit.getClass().getPackage().getImplementationVersion();\n<line_number-221>        if (version == null) {\n<line_number-222>            VERSION = getAbbreviatedGitVersion();\n<line_number-223>        } else {\n<line_number-224>            VERSION = version;\n<line_number-225>        }\n<line_number-226>        String[] verSp = VERSION.split(\"[.]\");\n<line_number-227>        if (verSp.length < 2) {\n<line_number-228>            throw new RuntimeException(\n<line_number-229>                    new SQLException(\n<line_number-230>                            \"version was not specified correctly, must contain at least major and minor parts\"));\n<line_number-231>        }\n<line_number-232>        MAJOR_VERSION = Integer.parseInt(verSp[0]);\n<line_number-233>        MINOR_VERSION = Integer.parseInt(verSp[1]);\n<line_number-234>\n<line_number-235>        String name = unit.getClass().getPackage().getImplementationTitle();\n<line_number-236>        NAME = (name != null) ? name : \"mongodb-jdbc\";\n<line_number-237>        Runtime.getRuntime().addShutdownHook(new Thread(MongoDriver::closeAllClients));\n<line_number-238>\n<line_number-239>        try {\n<line_number-240>            loadMongoSqlTranslateLibrary();\n<line_number-241>        }\n<line_number-242>        // Store the error so that we can log it later.\n<line_number-243>        catch (Exception e) {\n<line_number-244>            mongoSqlTranslateLibraryLoadingError = e;\n<line_number-245>        } catch (Error e) {\n<line_number-246>            // Note, linkage issues are reported as linkage error and not as Exception. We need to track both.\n<line_number-247>            mongoSqlTranslateLibraryLoadingError = new Exception(e);\n<line_number-248>        }\n<line_number-249>    }\n<line_number-250>\n<line_number-251>    /**\n<line_number-252>     * Attempts to initialize the MongoSQL Translate library from various paths and sets\n<line_number-253>     * mongoSqlTranslateLibraryLoaded to indicate success or failure.\n<line_number-254>     */\n<line_number-255>    private static void loadMongoSqlTranslateLibrary() throws IOException {\n<line_number-256>        // The `MONGOSQL_TRANSLATE_PATH` environment variable allows specifying an alternative library path.\n<line_number-257>        // This provides a backdoor mechanism to override the default library path of being colocated with the\n<line_number-258>        // driver library and load the MongoSQL Translate library from a different location.\n<line_number-259>        // Intended primarily for development and testing purposes.\n<line_number-260>        String envPath = System.getenv(MONGOSQL_TRANSLATE_PATH);\n<line_number-261>        if (envPath != null && !envPath.isEmpty()) {\n<line_number-262>            String absolutePath = Paths.get(envPath).toAbsolutePath().normalize().toString();\n<line_number-263>            try {\n<line_number-264>                System.load(absolutePath);\n<line_number-265>                mongoSqlTranslateLibraryPath = absolutePath;\n<line_number-266>                mongoSqlTranslateLibraryLoaded = true;\n<line_number-267>                return;\n<line_number-268>            } catch (Error e) {\n<line_number-269>                // Store the error and then try loading the library from inside the jar next.\n<line_number-270>                mongoSqlTranslateLibraryLoadingError = new Exception(e);\n<line_number-271>            }\n<line_number-272>        }\n<line_number-273>        mongoSqlTranslateLibraryPath = NativeLoader.loadLibraryFromJar(MONGOSQL_TRANSLATE_NAME);\n<line_number-274>        mongoSqlTranslateLibraryLoaded = true;\n<line_number-275>    }\n<line_number-276>\n<line_number-277>    public static CodecRegistry getCodecRegistry() {\n<line_number-278>        return REGISTRY;\n<line_number-279>    }\n<line_number-280>\n<line_number-281>    public static boolean isEapBuild() {\n<line_number-282>        String version = getVersion();\n<line_number-283>        // Return false if the version string is null or empty\n<line_number-284>        if (version == null || version.isEmpty()) {\n<line_number-285>            return false;\n<line_number-286>        }\n<line_number-287>\n<line_number-288>        // Our EAP builds contain `libv` in the tag\n<line_number-289>        return version.contains(\"libv\");\n<line_number-290>    }\n<line_number-291>\n<line_number-292>    private Properties canonicalizeProperties(Properties info) throws SQLException {\n<line_number-293>        Properties lowerCaseprops = new Properties();\n<line_number-294>        // Normalize all properties key to lower case to make all connection settings case-insensitive\n<line_number-295>        if (info != null) {\n<line_number-296>            try {\n<line_number-297>                Enumeration<?> keys = info.propertyNames();\n<line_number-298>                while (keys.hasMoreElements()) {\n<line_number-299>                    String key = (String) keys.nextElement();\n<line_number-300>                    String value = info.getProperty(key);\n<line_number-301>                    // The value here can only be null if the value is not a String because\n<line_number-302>                    // the keys are all obtained by enumerating all the propertyNames.\n<line_number-303>                    if (value == null) {\n<line_number-304>                        throw new SQLException(\n<line_number-305>                                \"Properties Object must contain String values only.\");\n<line_number-306>                    }\n<line_number-307>                    key = key.toLowerCase(); // Normalize key to lower case\n<line_number-308>                    value = value.trim(); // Trim whitespace from the value\n<line_number-309>                    lowerCaseprops.setProperty(key, value);\n<line_number-310>                }\n<line_number-311>            } catch (ClassCastException e) {\n<line_number-312>                throw new SQLException(\"Properties Object must contain String keys only.\");\n<line_number-313>            }\n<line_number-314>        }\n<line_number-315>        return lowerCaseprops;\n<line_number-316>    }\n<line_number-317>\n<line_number-318>    @Override\n<line_number-319>    public Connection connect(String url, Properties info) throws SQLException {\n<line_number-320>        if (!acceptsURL(url)) {\n<line_number-321>            return null;\n<line_number-322>        }\n<line_number-323>        Properties lowerCaseprops = canonicalizeProperties(info);\n<line_number-324>        MongoConnection conn = getUnvalidatedConnection(url, lowerCaseprops);\n<line_number-325>        // the jdbc spec requires that null be returned if a Driver cannot handle the specified URL\n<line_number-326>        // (cases where multiple jdbc drivers are present and the program is checking which driver\n<line_number-327>        // to use), so it is possible for conn to be null at this point.\n<line_number-328>        if (conn != null) {\n<line_number-329>            try {\n<line_number-330>                conn.testConnection(conn.getDefaultConnectionValidationTimeoutSeconds());\n<line_number-331>            } catch (TimeoutException te) {\n<line_number-332>                throw new SQLTimeoutException(\n<line_number-333>                        \"Couldn't connect due to a timeout. Please check your hostname and port. If necessary, set a \"\n<line_number-334>                                + \"longer connection timeout in the MongoDB URI.\");\n<line_number-335>            } catch (Exception e) {\n<line_number-336>                // Unwrap the cause to detect authentication failures\n<line_number-337>                Throwable cause = e;\n<line_number-338>                while (cause != null) {\n<line_number-339>                    if (cause instanceof com.mongodb.MongoSecurityException) {\n<line_number-340>                        throw new SQLException(\n<line_number-341>                                \"Authentication failed. Verify that the credentials are correct.\",\n<line_number-342>                                AUTHENTICATION_ERROR_SQLSTATE,\n<line_number-343>                                e);\n<line_number-344>                    }\n<line_number-345>                    cause = cause.getCause();\n<line_number-346>                }\n<line_number-347>\n<line_number-348>                throw new SQLException(\"Connection failed.\", e);\n<line_number-349>            }\n<line_number-350>        }\n<line_number-351>        return conn;\n<line_number-352>    }\n<line_number-353>\n<line_number-354>    public static class MongoConnectionConfig {\n<line_number-355>        public final ConnectionString connectionString;\n<line_number-356>        public final DriverPropertyInfo[] driverInfo;\n<line_number-357>        public final char[] x509Passphrase;\n<line_number-358>\n<line_number-359>        MongoConnectionConfig(ConnectionString cs, DriverPropertyInfo[] di, char[] x509pass) {\n<line_number-360>            connectionString = cs;\n<line_number-361>            driverInfo = di;\n<line_number-362>            x509Passphrase = x509pass;\n<line_number-363>        }\n<line_number-364>    }\n<line_number-365>\n<line_number-366>    protected MongoConnection getUnvalidatedConnection(String url, Properties info)\n<line_number-367>            throws SQLException {\n<line_number-368>        if (!acceptsURL(url)) {\n<line_number-369>            return null;\n<line_number-370>        }\n<line_number-371>        if (info == null) {\n<line_number-372>            info = new Properties();\n<line_number-373>        }\n<line_number-374>\n<line_number-375>        // Ensure that the ConnectionString and Properties are consistent.\n<line_number-376>        // Reuse the code getPropertyInfo to make sure the URI is properly set wrt the passed\n<line_number-377>        // Properties info value.\n<line_number-378>        MongoConnectionConfig connectionConfig = getConnectionSettings(url, info);\n<line_number-379>        // Since the user is calling connect, we should throw a SQLException if we get a prompt back.\n<line_number-380>        if (connectionConfig.driverInfo.length != 0) {\n<line_number-381>            // Inspect the return value to format the SQLException and throw the connection error\n<line_number-382>            throw new SQLException(\n<line_number-383>                    reportMissingProperties(connectionConfig.driverInfo),\n<line_number-384>                    CONNECTION_ERROR_SQLSTATE);\n<line_number-385>        }\n<line_number-386>\n<line_number-387>        return createConnection(\n<line_number-388>                connectionConfig.connectionString, info, connectionConfig.x509Passphrase);\n<line_number-389>    }\n<line_number-390>\n<line_number-391>    /**\n<line_number-392>     * Provides feedback regarding the missing properties.\n<line_number-393>     *\n<line_number-394>     * @param missingRequiredProperties The list of required properties a connection needs to be\n<line_number-395>     *     successful.\n<line_number-396>     * @return the format error message to return to the user.\n<line_number-397>     */\n<line_number-398>    private String reportMissingProperties(DriverPropertyInfo[] missingRequiredProperties) {\n<line_number-399>        List<String> propertyNames = new ArrayList<>();\n<line_number-400>        StringBuilder sb = new StringBuilder();\n<line_number-401>        sb.append(\"There are issues with your connection settings : \");\n<line_number-402>        for (DriverPropertyInfo info : missingRequiredProperties) {\n<line_number-403>            if (info.name.equals(USER)) {\n<line_number-404>                sb.append(\"Password specified without user. Please provide '\");\n<line_number-405>                sb.append(USER);\n<line_number-406>                sb.append(\"' property value.\\n\");\n<line_number-407>            } else if (info.name.equals(PASSWORD)) {\n<line_number-408>                sb.append(\"User specified without password. Please provide '\");\n<line_number-409>                sb.append(PASSWORD);\n<line_number-410>                sb.append(\"' property value.\\n\");\n<line_number-411>            } else if (info.name.equals(DATABASE.getPropertyName())) {\n<line_number-412>                sb.append(\"Mandatory property '\");\n<line_number-413>                sb.append(DATABASE.getPropertyName());\n<line_number-414>                sb.append(\"' is missing.\\n\");\n<line_number-415>            } else {\n<line_number-416>                propertyNames.add(info.name);\n<line_number-417>            }\n<line_number-418>        }\n<line_number-419>        if (!propertyNames.isEmpty()) {\n<line_number-420>            sb.append(\"Unexpected driver property info : \");\n<line_number-421>            sb.append(String.join(\", \", propertyNames));\n<line_number-422>            sb.append(\"\\n\");\n<line_number-423>        }\n<line_number-424>\n<line_number-425>        return sb.toString();\n<line_number-426>    }\n<line_number-427>\n<line_number-428>    private MongoConnection createConnection(\n<line_number-429>            ConnectionString cs, Properties info, char[] x509Passphrase) throws SQLException {\n<line_number-430>        // Database from the properties must be present\n<line_number-431>        String database = info.getProperty(DATABASE.getPropertyName());\n<line_number-432>\n<line_number-433>        // Default log level is OFF\n<line_number-434>        String logLevelVal = info.getProperty(LOG_LEVEL.getPropertyName(), Level.OFF.getName());\n<line_number-435>        Level logLevel;\n<line_number-436>        try {\n<line_number-437>            logLevel = Level.parse(logLevelVal.toUpperCase());\n<line_number-438>        } catch (IllegalArgumentException e) {\n<line_number-439>            throw new SQLException(\n<line_number-440>                    \"Invalid \"\n<line_number-441>                            + LOG_LEVEL.getPropertyName()\n<line_number-442>                            + \" property value : \"\n<line_number-443>                            + logLevelVal\n<line_number-444>                            + \". Valid values are : \"\n<line_number-445>                            + LEVELS\n<line_number-446>                            + \".\");\n<line_number-447>        }\n<line_number-448>        String logDirVal = info.getProperty(LOG_DIR.getPropertyName());\n<line_number-449>        if ((logDirVal != null) && LOG_TO_CONSOLE.equalsIgnoreCase(logDirVal.trim())) {\n<line_number-450>            // If logDir is \"console\" then remove the value since the logger\n<line_number-451>            // will default to a console handler if no logDir is specified\n<line_number-452>            logDirVal = null;\n<line_number-453>        }\n<line_number-454>        File logDir = (logDirVal == null) ? null : new File(logDirVal);\n<line_number-455>        if (logDir != null && !logDir.isDirectory()) {\n<line_number-456>            throw new SQLException(\n<line_number-457>                    \"Invalid \"\n<line_number-458>                            + LOG_DIR.getPropertyName()\n<line_number-459>                            + \" property value : \"\n<line_number-460>                            + logDirVal\n<line_number-461>                            + \". It must be a directory.\");\n<line_number-462>        }\n<line_number-463>        String clientInfo = info.getProperty(CLIENT_INFO.getPropertyName());\n<line_number-464>        if (clientInfo != null && clientInfo.split(\"\\\\+\").length != 2) {\n<line_number-465>            throw new SQLException(\n<line_number-466>                    \"Invalid \"\n<line_number-467>                            + CLIENT_INFO.getPropertyName()\n<line_number-468>                            + \" property value : \"\n<line_number-469>                            + clientInfo\n<line_number-470>                            + \". Expected format <name>+<version>.\");\n<line_number-471>        }\n<line_number-472>\n<line_number-473>        String extJsonModeVal = info.getProperty(EXT_JSON_MODE.getPropertyName());\n<line_number-474>        boolean extJsonMode = false;\n<line_number-475>        if (extJsonModeVal != null) {\n<line_number-476>            extJsonModeVal = extJsonModeVal.toUpperCase().trim();\n<line_number-477>            if (extJsonModeVal == EXTENDED) {\n<line_number-478>                extJsonMode = true;\n<line_number-479>            } else if (extJsonModeVal != RELAXED) {\n<line_number-480>                throw new SQLException(\"Invalid JSON mode: \" + extJsonModeVal);\n<line_number-481>            }\n<line_number-482>        }\n<line_number-483>\n<line_number-484>        MongoConnectionProperties mongoConnectionProperties =\n<line_number-485>                new MongoConnectionProperties(\n<line_number-486>                        cs,\n<line_number-487>                        database,\n<line_number-488>                        logLevel,\n<line_number-489>                        logDir,\n<line_number-490>                        clientInfo,\n<line_number-491>                        extJsonMode,\n<line_number-492>                        info.getProperty(X509_PEM_PATH.getPropertyName()));\n<line_number-493>\n<line_number-494>        String disableCacheVal =\n<line_number-495>                info.getProperty(DISABLE_CLIENT_CACHE.getPropertyName(), \"false\").toLowerCase();\n<line_number-496>        if (disableCacheVal.equals(\"true\")\n<line_number-497>                || disableCacheVal.equals(\"yes\")\n<line_number-498>                || disableCacheVal.equals(\"1\")) {\n<line_number-499>            // If the user has set the disable cache property, we will not use the cache.\n<line_number-500>            return new MongoConnection(mongoConnectionProperties, x509Passphrase);\n<line_number-501>        }\n<line_number-502>\n<line_number-503>        Integer key = mongoConnectionProperties.generateKey();\n<line_number-504>\n<line_number-505>        mongoClientCacheLock.readLock().lock();\n<line_number-506>        try {\n<line_number-507>            WeakReference<MongoClient> clientRef = mongoClientCache.get(key);\n<line_number-508>            MongoClient client = (clientRef != null) ? clientRef.get() : null;\n<line_number-509>\n<line_number-510>            if (client != null) {\n<line_number-511>                return new MongoConnection(client, mongoConnectionProperties, x509Passphrase);\n<line_number-512>            }\n<line_number-513>        } finally {\n<line_number-514>            mongoClientCacheLock.readLock().unlock();\n<line_number-515>        }\n<line_number-516>\n<line_number-517>        // Acquire write lock to create and cache a new MongoClient if it wasn't found\n<line_number-518>        mongoClientCacheLock.writeLock().lock();\n<line_number-519>        try {\n<line_number-520>            WeakReference<MongoClient> clientRef = mongoClientCache.get(key);\n<line_number-521>            MongoClient client = (clientRef != null) ? clientRef.get() : null;\n<line_number-522>            // Check for client again to handle race conditions\n<line_number-523>            if (client != null) {\n<line_number-524>                return new MongoConnection(client, mongoConnectionProperties, x509Passphrase);\n<line_number-525>            }\n<line_number-526>            MongoConnection newConnection =\n<line_number-527>                    new MongoConnection(mongoConnectionProperties, x509Passphrase);\n<line_number-528>            mongoClientCache.put(key, new WeakReference<>(newConnection.getMongoClient()));\n<line_number-529>            return newConnection;\n<line_number-530>        } finally {\n<line_number-531>            mongoClientCacheLock.writeLock().unlock();\n<line_number-532>        }\n<line_number-533>    }\n<line_number-534>\n<line_number-535>    public static void closeAllClients() {\n<line_number-536>        mongoClientCacheLock.writeLock().lock();\n<line_number-537>        try {\n<line_number-538>            for (WeakReference<MongoClient> clientRef : mongoClientCache.values()) {\n<line_number-539>                MongoClient client = clientRef.get();\n<line_number-540>                if (client != null) {\n<line_number-541>                    client.close();\n<line_number-542>                }\n<line_number-543>            }\n<line_number-544>            mongoClientCache.clear();\n<line_number-545>        } finally {\n<line_number-546>            mongoClientCacheLock.writeLock().unlock();\n<line_number-547>        }\n<line_number-548>    }\n<line_number-549>\n<line_number-550>    @Override\n<line_number-551>    public boolean acceptsURL(String url) throws SQLException {\n<line_number-552>        return url.startsWith(MONGODB_URL_PREFIX) || url.startsWith(MONGODB_SRV_URL_PREFIX);\n<line_number-553>    }\n<line_number-554>\n<line_number-555>    @Override\n<line_number-556>    public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException {\n<line_number-557>        MongoConnectionConfig connectionConfig = getConnectionSettings(url, info);\n<line_number-558>        return connectionConfig.driverInfo;\n<line_number-559>    }\n<line_number-560>\n<line_number-561>    @Override\n<line_number-562>    public int getMajorVersion() {\n<line_number-563>        return 1;\n<line_number-564>    }\n<line_number-565>\n<line_number-566>    @Override\n<line_number-567>    public int getMinorVersion() {\n<line_number-568>        return 0;\n<line_number-569>    }\n<line_number-570>\n<line_number-571>    @Override\n<line_number-572>    public boolean jdbcCompliant() {\n<line_number-573>        return false;\n<line_number-574>    }\n<line_number-575>\n<line_number-576>    // ------------------------- JDBC 4.1 -----------------------------------\n<line_number-577>\n<line_number-578>    @Override\n<line_number-579>    public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException {\n<line_number-580>        throw new SQLFeatureNotSupportedException();\n<line_number-581>    }\n<line_number-582>\n<line_number-583>    public static boolean isMongoSqlTranslateLibraryLoaded() {\n<line_number-584>        return mongoSqlTranslateLibraryLoaded;\n<line_number-585>    }\n<line_number-586>\n<line_number-587>    public static String getMongoSqlTranslateLibraryPath() {\n<line_number-588>        return mongoSqlTranslateLibraryPath;\n<line_number-589>    }\n<line_number-590>\n<line_number-591>    public static Exception getMongoSqlTranslateLibraryLoadError() {\n<line_number-592>        return mongoSqlTranslateLibraryLoadingError;\n<line_number-593>    }\n<line_number-594>\n<line_number-595>    // removePrefix removes a prefix from a String.\n<line_number-596>    private static String removePrefix(String prefix, String s) {\n<line_number-597>        if (s != null && prefix != null && s.startsWith(prefix)) {\n<line_number-598>            return s.substring(prefix.length());\n<line_number-599>        }\n<line_number-600>        return s;\n<line_number-601>    }\n<line_number-602>\n<line_number-603>    private static class ParseResult {\n<line_number-604>        String user;\n<line_number-605>        char[] password;\n<line_number-606>        AuthenticationMechanism authMechanism;\n<line_number-607>        Properties normalizedOptions;\n<line_number-608>\n<line_number-609>        ParseResult(String u, char[] p, AuthenticationMechanism a, Properties options) {\n<line_number-610>            user = u;\n<line_number-611>            password = p;\n<line_number-612>            authMechanism = a;\n<line_number-613>            normalizedOptions = options;\n<line_number-614>        }\n<line_number-615>    }\n<line_number-616>\n<line_number-617>    // getConnectionSettings constructs a valid MongoDB connection string which will be used as an input to the mongoClient.\n<line_number-618>    // If there are required fields missing, those fields will be returned in DriverPropertyInfo[] with a null connectionString\n<line_number-619>    public static MongoConnectionConfig getConnectionSettings(String url, Properties info)\n<line_number-620>            throws SQLException {\n<line_number-621>        if (info == null) {\n<line_number-622>            info = new Properties();\n<line_number-623>        }\n<line_number-624>\n<line_number-625>        try {\n<line_number-626>            String actualURL = removePrefix(JDBC, url);\n<line_number-627>            ConnectionString originalConnectionString;\n<line_number-628>            try {\n<line_number-629>                originalConnectionString = new ConnectionString(actualURL);\n<line_number-630>            } catch (Exception e) {\n<line_number-631>                throw new SQLException(e);\n<line_number-632>            }\n<line_number-633>\n<line_number-634>            ParseResult result = normalizeConnectionOptions(originalConnectionString, info);\n<line_number-635>            String user = null;\n<line_number-636>            char[] password = null;\n<line_number-637>            char[] x509Passphrase = null;\n<line_number-638>\n<line_number-639>            if (result.authMechanism != null && result.authMechanism.equals(MONGODB_X509)) {\n<line_number-640>                // X509 authentication does not require a password to authenticate.  It is used by the driver in case\n<line_number-641>                // the PEM file has been encrypted with a passphrase.\n<line_number-642>                x509Passphrase = result.password;\n<line_number-643>            } else {\n<line_number-644>                user = result.user;\n<line_number-645>                password = result.password;\n<line_number-646>            }\n<line_number-647>\n<line_number-648>            List<DriverPropertyInfo> mandatoryConnectionProperties = new ArrayList<>();\n<line_number-649>\n<line_number-650>            // A database to connect to is required. If they have not specified one, look in the connection string for a\n<line_number-651>            // database. The specified database in the connect window will always override the uri database.\n<line_number-652>            if ((!info.containsKey(DATABASE.getPropertyName())\n<line_number-653>                            || info.getProperty(DATABASE.getPropertyName()).isEmpty())\n<line_number-654>                    && originalConnectionString.getDatabase() != null) {\n<line_number-655>                info.setProperty(\n<line_number-656>                        DATABASE.getPropertyName(), originalConnectionString.getDatabase());\n<line_number-657>            }\n<line_number-658>            if (!info.containsKey(DATABASE.getPropertyName())\n<line_number-659>                    || info.getProperty(DATABASE.getPropertyName()).isEmpty()) {\n<line_number-660>                mandatoryConnectionProperties.add(\n<line_number-661>                        new DriverPropertyInfo(DATABASE.getPropertyName(), null));\n<line_number-662>            }\n<line_number-663>            String authDatabase = info.getProperty(DATABASE.getPropertyName());\n<line_number-664>\n<line_number-665>            if (user == null && password != null) {\n<line_number-666>                // user is null, but password is not, we must prompt for the user.\n<line_number-667>                // Note: The convention is actually to return DriverPropertyInfo objects\n<line_number-668>                // with null values, this is not a bug.\n<line_number-669>                mandatoryConnectionProperties.add(new DriverPropertyInfo(USER, null));\n<line_number-670>            }\n<line_number-671>            if (password == null && user != null) {\n<line_number-672>                if (result.authMechanism == null\n<line_number-673>                        || (!result.authMechanism.equals(MONGODB_X509)\n<line_number-674>                                && !result.authMechanism.equals(MONGODB_OIDC))) {\n<line_number-675>                    // password is null, but user is not, we must prompt for the password.\n<line_number-676>                    mandatoryConnectionProperties.add(new DriverPropertyInfo(PASSWORD, null));\n<line_number-677>                }\n<line_number-678>            }\n<line_number-679>\n<line_number-680>            // If mandatoryConnectionProperties is not empty, we stop here because we are missing connection information\n<line_number-681>            if (mandatoryConnectionProperties.size() > 0) {\n<line_number-682>                return new MongoConnectionConfig(\n<line_number-683>                        null,\n<line_number-684>                        mandatoryConnectionProperties.toArray(\n<line_number-685>                                new DriverPropertyInfo[mandatoryConnectionProperties.size()]),\n<line_number-686>                        null);\n<line_number-687>            }\n<line_number-688>\n<line_number-689>            // If we are here, we must have all the required connection information. So we have a valid URI state,\n<line_number-690>            // go ahead and construct it and prompt for nothing.\n<line_number-691>            ConnectionString c =\n<line_number-692>                    new ConnectionString(\n<line_number-693>                            buildNewURI(\n<line_number-694>                                    originalConnectionString.isSrvProtocol(),\n<line_number-695>                                    originalConnectionString.getHosts(),\n<line_number-696>                                    user,\n<line_number-697>                                    password,\n<line_number-698>                                    authDatabase,\n<line_number-699>                                    result.normalizedOptions));\n<line_number-700>            return new MongoConnectionConfig(c, new DriverPropertyInfo[] {}, x509Passphrase);\n<line_number-701>        } catch (Exception e) {\n<line_number-702>            if ((e instanceof SQLException)) {\n<line_number-703>                throw e;\n<line_number-704>            } else {\n<line_number-705>                throw new SQLException(e);\n<line_number-706>            }\n<line_number-707>        }\n<line_number-708>    }\n<line_number-709>\n<line_number-710>    /**\n<line_number-711>     * Parse the original uri provided by the user. If the parsing failed, we try to augment the URI\n<line_number-712>     * with the username and password provided in the properties. The reason behind it is that new\n<line_number-713>     * ConnectionString(xx) validates the uri as is parses it and for some authentication mechanisms\n<line_number-714>     * these info are mandatory, but the user can provide them separately to the driver.\n<line_number-715>     *\n<line_number-716>     * @param url The original uri as provided by the user.\n<line_number-717>     * @param info The extra properties.\n<line_number-718>     * @return the uri unchanged or augmented with uid and pwd from info.\n<line_number-719>     * @throws IllegalArgumentException\n<line_number-720>     * @throws MongoConfigurationException\n<line_number-721>     */\n<line_number-722>    protected static ConnectionString buildConnectionString(String url, Properties info)\n<line_number-723>            throws IllegalArgumentException, MongoConfigurationException {\n<line_number-724>        String actualURL = removePrefix(JDBC, url);\n<line_number-725>        try {\n<line_number-726>            return new ConnectionString(actualURL);\n<line_number-727>        } catch (IllegalArgumentException ea) {\n<line_number-728>            Matcher uri_matcher = MONGODB_URI_PATTERN.matcher(actualURL);\n<line_number-729>            if (uri_matcher.find()) {\n<line_number-730>                String username =\n<line_number-731>                        info.getProperty(USER) != null\n<line_number-732>                                ? URLEncoder.encode(info.getProperty(USER))\n<line_number-733>                                : null;\n<line_number-734>                String password =\n<line_number-735>                        info.getProperty(PASSWORD) != null\n<line_number-736>                                ? URLEncoder.encode(info.getProperty(PASSWORD))\n<line_number-737>                                : null;\n<line_number-738>                String options = uri_matcher.group(\"options\");\n<line_number-739>                if (uri_matcher.group(\"uidpwd\") == null && username != null && options != null) {\n<line_number-740>                    Matcher authMec_matcher = AUTH_MECH_TO_AUGMENT_PATTERN.matcher(options);\n<line_number-741>                    if (authMec_matcher.find()) {\n<line_number-742>                        String authMech = authMec_matcher.group(\"authMech\");\n<line_number-743>                        if (MECHANISMS_TO_AUGMENT.contains(authMech.toUpperCase())) {\n<line_number-744>                            StringBuilder sb = new StringBuilder();\n<line_number-745>                            sb.append(uri_matcher.group(1)); // protocol\n<line_number-746>                            sb.append(username);\n<line_number-747>                            if (password != null) {\n<line_number-748>                                sb.append(\":\");\n<line_number-749>                                sb.append(password);\n<line_number-750>                            }\n<line_number-751>                            sb.append(\"@\");\n<line_number-752>                            sb.append(uri_matcher.group(3)); // host and options\n<line_number-753>\n<line_number-754>                            return new ConnectionString(sb.toString());\n<line_number-755>                        }\n<line_number-756>                    }\n<line_number-757>                }\n<line_number-758>                // The error is not related to a missing uid/pwd for the mechanisms which need them\n<line_number-759>                throw ea;\n<line_number-760>            } else {\n<line_number-761>                // Credential information were present in the URI, this issue is not related to missing username and/or password\n<line_number-762>                throw ea;\n<line_number-763>            }\n<line_number-764>        }\n<line_number-765>    }\n<line_number-766>\n<line_number-767>    private static interface NullCoalesce<T> {\n<line_number-768>        T coalesce(T left, T right);\n<line_number-769>    }\n<line_number-770>\n<line_number-771>    // private helper function to abstract checking consistency between properties and the URI, and\n<line_number-772>    // grabbing the username, password and the consolidated connection arguments\n<line_number-773>    //\n<line_number-774>    // throws SQLException if url and options properties disagree on the value\n<line_number-775>    private static ParseResult normalizeConnectionOptions(\n<line_number-776>            ConnectionString clientURI, Properties info) throws SQLException {\n<line_number-777>        String user = null;\n<line_number-778>        char[] password = null;\n<line_number-779>\n<line_number-780>        if (info == null) {\n<line_number-781>            info = new Properties();\n<line_number-782>        }\n<line_number-783>        // The coalesce function takes the first non-null argument, returning null only\n<line_number-784>        // if both arguments are null. The java type system requires us to write this twice,\n<line_number-785>        // once for each type we care about, unless we prefer to use Objects and cast, but I avoid\n<line_number-786>        // that.\n<line_number-787>        NullCoalesce<String> s =\n<line_number-788>                (left, right) -> {\n<line_number-789>                    if (left == null) {\n<line_number-790>                        return right;\n<line_number-791>                    }\n<line_number-792>                    return left;\n<line_number-793>                };\n<line_number-794>\n<line_number-795>        NullCoalesce<char[]> c =\n<line_number-796>                (left, right) -> {\n<line_number-797>                    if (left == null) {\n<line_number-798>                        return right;\n<line_number-799>                    }\n<line_number-800>                    return left;\n<line_number-801>                };\n<line_number-802>\n<line_number-803>        AuthenticationMechanism authMechanism =\n<line_number-804>                clientURI.getCredential() != null\n<line_number-805>                        ? clientURI.getCredential().getAuthenticationMechanism()\n<line_number-806>                        : null;\n<line_number-807>\n<line_number-808>        // grab the user and password from the URI.\n<line_number-809>        String uriUser = clientURI.getUsername();\n<line_number-810>        char[] uriPWD = clientURI.getPassword();\n<line_number-811>        String propertyUser = info.getProperty(USER);\n<line_number-812>        String propertyPWDStr = info.getProperty(PASSWORD);\n<line_number-813>        char[] propertyPWD = propertyPWDStr != null ? propertyPWDStr.toCharArray() : null;\n<line_number-814>\n<line_number-815>        // handle disagreements on user.\n<line_number-816>        if (authMechanism != null && authMechanism.equals(MONGODB_OIDC)) {\n<line_number-817>            if (uriPWD != null || propertyPWD != null) {\n<line_number-818>                throw new SQLException(\n<line_number-819>                        \"Password should not be specified when using MONGODB-OIDC authentication\");\n<line_number-820>            }\n<line_number-821>            user = s.coalesce(uriUser, propertyUser);\n<line_number-822>        } else {\n<line_number-823>            if (uriUser != null && propertyUser != null && !uriUser.equals(propertyUser)) {\n<line_number-824>                throw new SQLException(\n<line_number-825>                        \"uri and properties disagree on user: '\"\n<line_number-826>                                + uriUser\n<line_number-827>                                + \", and \"\n<line_number-828>                                + propertyUser\n<line_number-829>                                + \" respectively\");\n<line_number-830>            }\n<line_number-831>            // set the user\n<line_number-832>            user = s.coalesce(uriUser, propertyUser);\n<line_number-833>            if (user != null) {\n<line_number-834>                // Make sure the `info` reflects the URL for USER because MongoDatabaseMetaData needs to\n<line_number-835>                // know this.\n<line_number-836>                info.setProperty(USER, user);\n<line_number-837>            }\n<line_number-838>            // handle disagreements on password.\n<line_number-839>            if (uriPWD != null && propertyPWD != null && !Arrays.equals(uriPWD, propertyPWD)) {\n<line_number-840>                throw new SQLException(\"uri and properties disagree on password\");\n<line_number-841>            }\n<line_number-842>            // set the password\n<line_number-843>            password = c.coalesce(uriPWD, propertyPWD);\n<line_number-844>        }\n<line_number-845>\n<line_number-846>        String optionString = null;\n<line_number-847>        String[] optionSplit =\n<line_number-848>                clientURI\n<line_number-849>                        .getConnectionString()\n<line_number-850>                        .split(\"[?]\"); // split takes a regexp and '?' is a metachar.\n<line_number-851>        if (optionSplit.length > 1) {\n<line_number-852>            optionString = optionSplit[1];\n<line_number-853>        }\n<line_number-854>\n<line_number-855>        Properties options = new Properties();\n<line_number-856>        if (optionString != null) {\n<line_number-857>            String[] optionStrs = optionString.split(\"&\");\n<line_number-858>            for (String optionStr : optionStrs) {\n<line_number-859>                String[] kv = optionStr.split(\"=\");\n<line_number-860>                if (kv.length != 2) {\n<line_number-861>                    throw new SQLException(\"Option String is not valid\");\n<line_number-862>                }\n<line_number-863>                String normalizedKey = kv[0].toLowerCase();\n<line_number-864>                if (normalizedKey.equals(USER) || normalizedKey.equals(PASSWORD)) {\n<line_number-865>                    continue;\n<line_number-866>                }\n<line_number-867>                options.put(normalizedKey, kv[1]);\n<line_number-868>            }\n<line_number-869>        }\n<line_number-870>\n<line_number-871>        for (String key : info.stringPropertyNames()) {\n<line_number-872>            String normalizedKey = key.toLowerCase();\n<line_number-873>            if (normalizedKey.equals(USER) || normalizedKey.equals(PASSWORD)) {\n<line_number-874>                continue;\n<line_number-875>            }\n<line_number-876>            String val = info.getProperty(key);\n<line_number-877>            if (options.containsKey(normalizedKey)) {\n<line_number-878>                if (!options.getProperty(normalizedKey).equals(val)) {\n<line_number-879>                    throw new SQLException(\"uri and properties disagree on \" + key);\n<line_number-880>                }\n<line_number-881>            } else {\n<line_number-882>                options.setProperty(normalizedKey, val);\n<line_number-883>            }\n<line_number-884>        }\n<line_number-885>\n<line_number-886>        return new ParseResult(user, password, authMechanism, options);\n<line_number-887>    }\n<line_number-888>\n<line_number-889>    // This is just a clean abstraction around URLEncode.\n<line_number-890>    private static String sqlURLEncode(String item) throws SQLException {\n<line_number-891>        try {\n<line_number-892>            return URLEncoder.encode(item, \"utf-8\");\n<line_number-893>        } catch (Exception e) {\n<line_number-894>            throw new SQLException(e);\n<line_number-895>        }\n<line_number-896>    }\n<line_number-897>\n<line_number-898>    /**\n<line_number-899>     * Return true if the given key is a JDBC specific property, false otherwise.\n<line_number-900>     *\n<line_number-901>     * @param key The key to check.\n<line_number-902>     * @return true if the given key is a JDBC specific property, false otherwise.\n<line_number-903>     */\n<line_number-904>    private static boolean isMongoJDBCProperty(String key) {\n<line_number-905>        return Stream.of(MongoJDBCProperty.values())\n<line_number-906>                .anyMatch(v -> v.getPropertyName().equalsIgnoreCase(key));\n<line_number-907>    }\n<line_number-908>\n<line_number-909>    /**\n<line_number-910>     * This function builds a new uri from the original clientURI, adding user, password, options,\n<line_number-911>     * and database, if necessary.\n<line_number-912>     *\n<line_number-913>     * @param hosts the list of MongoDB host names\n<line_number-914>     * @param user the auth username\n<line_number-915>     * @param password the auth password\n<line_number-916>     * @param authDatabase the authentication database to use if authSource option is not specified\n<line_number-917>     * @param options the consolidated tag/value pairs from the url query string and connection\n<line_number-918>     *     arguments user provided,\n<line_number-919>     */\n<line_number-920>    private static String buildNewURI(\n<line_number-921>            boolean isSrvProtocol,\n<line_number-922>            List<String> hosts,\n<line_number-923>            String user,\n<line_number-924>            char[] password,\n<line_number-925>            String authDatabase,\n<line_number-926>            Properties options)\n<line_number-927>            throws SQLException {\n<line_number-928>        // The returned URI should be of the following format:\n<line_number-929>        //\"mongodb(+srv)?://[user:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[authDatabase][?options]]\")\n<line_number-930>        String ret = isSrvProtocol ? \"mongodb+srv://\" : \"mongodb://\";\n<line_number-931>        if (user != null) {\n<line_number-932>            ret += sqlURLEncode(user);\n<line_number-933>            if (password != null) {\n<line_number-934>                ret += \":\" + sqlURLEncode(String.valueOf(password));\n<line_number-935>            }\n<line_number-936>            ret += \"@\";\n<line_number-937>        }\n<line_number-938>\n<line_number-939>        // Now add hosts.\n<line_number-940>        ret += String.join(\",\", hosts);\n<line_number-941>        // Now add authDatabase, if necessary.\n<line_number-942>        if (authDatabase != null) {\n<line_number-943>            ret += \"/\" + sqlURLEncode(authDatabase);\n<line_number-944>        } else {\n<line_number-945>            ret += \"/\";\n<line_number-946>        }\n<line_number-947>\n<line_number-948>        StringBuilder buff = new StringBuilder();\n<line_number-949>        if (options != null) {\n<line_number-950>            for (String key : options.stringPropertyNames()) {\n<line_number-951>\n<line_number-952>                // Only add keys which are part of the standard MongoDB URI (except user and password) and skip JDBC\n<line_number-953>                // //specific properties which can't be specified via the connection string\n<line_number-954>                if (!key.equals(USER) && !key.equals(PASSWORD) && !isMongoJDBCProperty(key)) {\n<line_number-955>                    if (buff.length() > 0) {\n<line_number-956>                        buff.append(\"&\");\n<line_number-957>                    }\n<line_number-958>                    try {\n<line_number-959>                        buff.append(key)\n<line_number-960>                                .append(\"=\")\n<line_number-961>                                .append(URLEncoder.encode(options.getProperty(key), \"utf-8\"));\n<line_number-962>                    } catch (UnsupportedEncodingException e) {\n<line_number-963>                        throw new SQLException(e);\n<line_number-964>                    }\n<line_number-965>                }\n<line_number-966>            }\n<line_number-967>        }\n<line_number-968>\n<line_number-969>        if (buff.length() > 0) {\n<line_number-970>            ret += \"?\" + buff;\n<line_number-971>        }\n<line_number-972>        return ret;\n<line_number-973>    }\n<line_number-974>}\n",
        "comments": [
          {
            "comment_code_range": "58-64",
            "comment_linenumber": "65",
            "comment": "The MongoDriver implements the java.sql.Driver interface, which allows for opening Connections to MongoDB databases that have SQL support.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "151-152",
            "comment_linenumber": "151",
            "comment": "Returns the version of the MongoDriver, either from the implementation or generated from the git tag.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "194-199",
            "comment_linenumber": "194",
            "comment": "Locks the read lock to retrieve the size of the mongoClientCache for testing purposes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "203-208",
            "comment_linenumber": "203",
            "comment": "Locks the read lock to clear the mongoClientCache for testing purposes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "212-249",
            "comment_linenumber": "212",
            "comment": "Static initializer that registers the MongoDriver with DriverManager and initializes versioning and library loading.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "251-255",
            "comment_linenumber": "251",
            "comment": "Attempts to initialize the MongoSQL Translate library from various paths and sets mongoSqlTranslateLibraryLoaded to indicate success or failure.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "292-315",
            "comment_linenumber": "292",
            "comment": "Normalizes all properties keys to lower case to ensure case-insensitivity in connection settings.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "318-351",
            "comment_linenumber": "318",
            "comment": "Connects to the MongoDB database using the provided URL and properties, returning a MongoConnection object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "354-364",
            "comment_linenumber": "354",
            "comment": "Configuration class for MongoConnection, holding connection string, driver info, and x509 passphrase.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "366-389",
            "comment_linenumber": "366",
            "comment": "Retrieves an unvalidated MongoConnection based on the provided URL and properties, ensuring consistency.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "391-426",
            "comment_linenumber": "391",
            "comment": "Reports missing properties required for a successful connection, returning a formatted error message.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "428-530",
            "comment_linenumber": "428",
            "comment": "Creates a MongoConnection based on the provided connection string, properties, and x509 passphrase, utilizing caching.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "535-546",
            "comment_linenumber": "535",
            "comment": "Closes all MongoClient instances in the cache and clears the cache.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "550-573",
            "comment_linenumber": "550",
            "comment": "Checks if the provided URL is accepted by the MongoDriver based on its prefix.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "579-581",
            "comment_linenumber": "579",
            "comment": "Throws SQLFeatureNotSupportedException as the parent logger is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "583-593",
            "comment_linenumber": "583",
            "comment": "Returns the status of whether the MongoSQL Translate library has been loaded.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "595-600",
            "comment_linenumber": "595",
            "comment": "Removes a specified prefix from a given string if it starts with that prefix.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "603-615",
            "comment_linenumber": "603",
            "comment": "Holds the results of parsing a connection string, including user, password, authentication mechanism, and options.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "617-619",
            "comment_linenumber": "617",
            "comment": "Constructs a valid MongoDB connection string based on the provided URL and properties.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "722-763",
            "comment_linenumber": "722",
            "comment": "Builds a connection string from the provided URL and properties, augmenting with user credentials if necessary.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "767-775",
            "comment_linenumber": "767",
            "comment": "Normalizes connection options by checking for consistency between the URI and properties.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "889-895",
            "comment_linenumber": "889",
            "comment": "Encodes a string for use in a SQL URL, throwing an SQLException on failure.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "899-906",
            "comment_linenumber": "899",
            "comment": "Checks if a given key is a MongoDB JDBC specific property.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "909-919",
            "comment_linenumber": "909",
            "comment": "Builds a new URI from the original client URI, adding necessary authentication and options.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoDriver.java' serves as the JDBC driver for MongoDB, implementing the java.sql.Driver interface to facilitate connections to MongoDB databases with SQL support. The primary class, MongoDriver, contains various static fields and methods for managing connection properties, handling authentication mechanisms, and caching MongoClient instances. The MongoJDBCProperty enum defines specific properties for the JDBC driver, while the MongoConnectionConfig class encapsulates connection settings. The file employs a combination of static initializers and methods to register the driver, manage library loading, and ensure thread-safe access to the client cache. Key methods include connect, which establishes a connection based on a provided URL and properties, and getConnectionSettings, which constructs a valid connection string. The file also includes error handling for authentication failures and connection issues, ensuring robust interaction with MongoDB databases.",
        "file_summary": "The MongoDriver.java file implements a JDBC driver for MongoDB, enabling SQL-based interactions with MongoDB databases. It manages connection properties, authentication mechanisms, and client caching, providing a seamless interface for Java applications to connect to MongoDB."
      }
    ]
  },
  "MongoFunctions.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoFunctions.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoFunctions.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoFunctions.java",
        "chunk_id": "MongoFunctions_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.util.HashSet;\n<line_number-20>import java.util.Set;\n<line_number-21>\n<line_number-22>public class MongoFunctions {\n<line_number-23>    public enum FunctionCategory {\n<line_number-24>        STRING_FUNC,\n<line_number-25>        NUM_FUNC,\n<line_number-26>        TIME_DATE_FUNC,\n<line_number-27>        SYSTEM_FUNC,\n<line_number-28>        CONV_FUNC,\n<line_number-29>        UNCATEGORIZED_FUNC\n<line_number-30>    }\n<line_number-31>\n<line_number-32>    public static class MongoFunction {\n<line_number-33>        public String name;\n<line_number-34>        public String returnType;\n<line_number-35>        public String comment;\n<line_number-36>        public String[] argTypes;\n<line_number-37>        public FunctionCategory functionCategory;\n<line_number-38>\n<line_number-39>        protected MongoFunction(\n<line_number-40>                String name,\n<line_number-41>                String returnType,\n<line_number-42>                String comment,\n<line_number-43>                String[] argTypes,\n<line_number-44>                FunctionCategory category) {\n<line_number-45>            this.name = name;\n<line_number-46>            this.returnType = returnType;\n<line_number-47>            this.comment = comment;\n<line_number-48>            this.argTypes = argTypes;\n<line_number-49>            this.functionCategory = category;\n<line_number-50>        }\n<line_number-51>\n<line_number-52>        protected MongoFunction(String name, String returnType, String comment, String[] argTypes) {\n<line_number-53>            this.name = name;\n<line_number-54>            this.returnType = returnType;\n<line_number-55>            this.comment = comment;\n<line_number-56>            this.argTypes = argTypes;\n<line_number-57>            this.functionCategory = FunctionCategory.UNCATEGORIZED_FUNC;\n<line_number-58>        }\n<line_number-59>    }\n<line_number-60>\n<line_number-61>    private static MongoFunctions instance;\n<line_number-62>    public MongoFunction[] functions;\n<line_number-63>    public String numericFunctionsString;\n<line_number-64>    public String stringFunctionsString;\n<line_number-65>    public String dateFunctionsString;\n<line_number-66>    public String systemFunctionsString;\n<line_number-67>\n<line_number-68>    // Common and repeated function names.\n<line_number-69>    protected static final String ABS = \"ABS\";\n<line_number-70>    protected static final String CEIL = \"CEIL\";\n<line_number-71>    protected static final String COS = \"COS\";\n<line_number-72>    protected static final String DEGREES = \"DEGREES\";\n<line_number-73>    protected static final String FLOOR = \"FLOOR\";\n<line_number-74>    protected static final String LOG = \"LOG\";\n<line_number-75>    protected static final String MOD = \"MOD\";\n<line_number-76>    protected static final String POW = \"POW\";\n<line_number-77>    protected static final String RADIANS = \"RADIANS\";\n<line_number-78>    protected static final String ROUND = \"ROUND\";\n<line_number-79>    protected static final String SIN = \"SIN\";\n<line_number-80>    protected static final String SQRT = \"SQRT\";\n<line_number-81>    protected static final String TAN = \"TAN\";\n<line_number-82>    protected static final String CURRENT_TIMESTAMP = \"CURRENT_TIMESTAMP\";\n<line_number-83>    protected static final String DATEADD = \"DATEADD\";\n<line_number-84>    protected static final String DATEDIFF = \"DATEDIFF\";\n<line_number-85>    protected static final String DATETRUNC = \"DATETRUNC\";\n<line_number-86>    protected static final String EXTRACT = \"EXTRACT\";\n<line_number-87>    protected static final String SUBSTRING = \"SUBSTRING\";\n<line_number-88>\n<line_number-89>    private MongoFunctions(MongoFunction[] functions) {\n<line_number-90>        this.functions = functions;\n<line_number-91>        initCategorizedFunctionsList();\n<line_number-92>    }\n<line_number-93>\n<line_number-94>    public static MongoFunctions getInstance() {\n<line_number-95>        if (null == instance) {\n<line_number-96>            instance =\n<line_number-97>                    new MongoFunctions(\n<line_number-98>                            new MongoFunction[] {\n<line_number-99>                                new MongoFunction(\n<line_number-100>                                        ABS,\n<line_number-101>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-102>                                        \"returns the absolute value of the given number.\",\n<line_number-103>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()},\n<line_number-104>                                        FunctionCategory.NUM_FUNC),\n<line_number-105>                                new MongoFunction(\n<line_number-106>                                        ABS,\n<line_number-107>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-108>                                        \"returns the absolute value of the given number.\",\n<line_number-109>                                        new String[] {BsonTypeInfo.BSON_LONG.getBsonName()},\n<line_number-110>                                        FunctionCategory.NUM_FUNC),\n<line_number-111>                                new MongoFunction(\n<line_number-112>                                        ABS,\n<line_number-113>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-114>                                        \"returns the absolute value of the given number.\",\n<line_number-115>                                        new String[] {BsonTypeInfo.BSON_DOUBLE.getBsonName()},\n<line_number-116>                                        FunctionCategory.NUM_FUNC),\n<line_number-117>                                new MongoFunction(\n<line_number-118>                                        ABS,\n<line_number-119>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-120>                                        \"returns the absolute value of the given number.\",\n<line_number-121>                                        new String[] {BsonTypeInfo.BSON_DECIMAL.getBsonName()},\n<line_number-122>                                        FunctionCategory.NUM_FUNC),\n<line_number-123>                                new MongoFunction(\n<line_number-124>                                        \"BIT_LENGTH\",\n<line_number-125>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-126>                                        \"returns length of string in bits\",\n<line_number-127>                                        new String[] {BsonTypeInfo.BSON_STRING.getBsonName()}),\n<line_number-128>                                new MongoFunction(\n<line_number-129>                                        CEIL,\n<line_number-130>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-131>                                        \"returns a number to the nearest whole number of equal or greater value.\",\n<line_number-132>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()}),\n<line_number-133>                                new MongoFunction(\n<line_number-134>                                        CEIL,\n<line_number-135>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-136>                                        \"returns a number to the nearest whole number of equal or greater value.\",\n<line_number-137>                                        new String[] {BsonTypeInfo.BSON_LONG.getBsonName()}),\n<line_number-138>                                new MongoFunction(\n<line_number-139>                                        CEIL,\n<line_number-140>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-141>                                        \"returns a number to the nearest whole number of equal or greater value.\",\n<line_number-142>                                        new String[] {BsonTypeInfo.BSON_DOUBLE.getBsonName()}),\n<line_number-143>                                new MongoFunction(\n<line_number-144>                                        CEIL,\n<line_number-145>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-146>                                        \"returns a number to the nearest whole number of equal or greater value.\",\n<line_number-147>                                        new String[] {BsonTypeInfo.BSON_DECIMAL.getBsonName()}),\n<line_number-148>                                new MongoFunction(\n<line_number-149>                                        \"CHAR_LENGTH\",\n<line_number-150>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-151>                                        \"returns length of string\",\n<line_number-152>                                        new String[] {BsonTypeInfo.BSON_STRING.getBsonName()},\n<line_number-153>                                        FunctionCategory.STRING_FUNC),\n<line_number-154>                                new MongoFunction(\n<line_number-155>                                        COS,\n<line_number-156>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-157>                                        \"returns the cosine of an angle specified in radians.\",\n<line_number-158>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()},\n<line_number-159>                                        FunctionCategory.NUM_FUNC),\n<line_number-160>                                new MongoFunction(\n<line_number-161>                                        COS,\n<line_number-162>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-163>                                        \"returns the cosine of an angle specified in radians.\",\n<line_number-164>                                        new String[] {BsonTypeInfo.BSON_LONG.getBsonName()},\n<line_number-165>                                        FunctionCategory.NUM_FUNC),\n<line_number-166>                                new MongoFunction(\n<line_number-167>                                        COS,\n<line_number-168>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-169>                                        \"returns the cosine of an angle specified in radians.\",\n<line_number-170>                                        new String[] {BsonTypeInfo.BSON_DOUBLE.getBsonName()},\n<line_number-171>                                        FunctionCategory.NUM_FUNC),\n<line_number-172>                                new MongoFunction(\n<line_number-173>                                        COS,\n<line_number-174>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-175>                                        \"returns the cosine of an angle specified in radians.\",\n<line_number-176>                                        new String[] {BsonTypeInfo.BSON_DECIMAL.getBsonName()},\n<line_number-177>                                        FunctionCategory.NUM_FUNC),\n<line_number-178>                                new MongoFunction(\n<line_number-179>                                        CURRENT_TIMESTAMP,\n<line_number-180>                                        BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-181>                                        \"returns the current date and time.\",\n<line_number-182>                                        new String[] {},\n<line_number-183>                                        FunctionCategory.TIME_DATE_FUNC),\n<line_number-184>                                new MongoFunction(\n<line_number-185>                                        CURRENT_TIMESTAMP,\n<line_number-186>                                        BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-187>                                        \"returns the current date and time.\",\n<line_number-188>                                        // Timestamp precision\n<line_number-189>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()}),\n<line_number-190>                                new MongoFunction(\n<line_number-191>                                        DATEADD,\n<line_number-192>                                        BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-193>                                        \"returns the specified date with the specified number interval added to the specified date_part of that date.\",\n<line_number-194>                                        new String[] {\n<line_number-195>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-196>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-197>                                            BsonTypeInfo.BSON_DATE.getBsonName()\n<line_number-198>                                        }),\n<line_number-199>                                new MongoFunction(\n<line_number-200>                                        DATEADD,\n<line_number-201>                                        BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-202>                                        \"returns the specified date with the specified number interval added to the specified date_part of that date.\",\n<line_number-203>                                        new String[] {\n<line_number-204>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-205>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-206>                                            BsonTypeInfo.BSON_DATE.getBsonName()\n<line_number-207>                                        }),\n<line_number-208>                                new MongoFunction(\n<line_number-209>                                        DATEDIFF,\n<line_number-210>                                        BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-211>                                        \"returns the difference between date1 and date2 expressed in units of date_part.\",\n<line_number-212>                                        new String[] {\n<line_number-213>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-214>                                            BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-215>                                            BsonTypeInfo.BSON_DATE.getBsonName()\n<line_number-216>                                        }),\n<line_number-217>                                new MongoFunction(\n<line_number-218>                                        DATEDIFF,\n<line_number-219>                                        BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-220>                                        \"returns the difference between date1 and date2 expressed in units of date_part.\",\n<line_number-221>                                        new String[] {\n<line_number-222>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-223>                                            BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-224>                                            BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-225>                                            BsonTypeInfo.BSON_STRING.getBsonName()\n<line_number-226>                                        }),\n<line_number-227>                                new MongoFunction(\n<line_number-228>                                        DATETRUNC,\n<line_number-229>                                        BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-230>                                        \"truncates the specified date to the accuracy specified by date_part.\",\n<line_number-231>                                        new String[] {\n<line_number-232>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-233>                                            BsonTypeInfo.BSON_DATE.getBsonName()\n<line_number-234>                                        }),\n<line_number-235>                                new MongoFunction(\n<line_number-236>                                        DATETRUNC,\n<line_number-237>                                        BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-238>                                        \"truncates the specified date to the accuracy specified by date_part.\",\n<line_number-239>                                        new String[] {\n<line_number-240>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-241>                                            BsonTypeInfo.BSON_DATE.getBsonName(),\n<line_number-242>                                            BsonTypeInfo.BSON_STRING.getBsonName()\n<line_number-243>                                        }),\n<line_number-244>                                new MongoFunction(\n<line_number-245>                                        DEGREES,\n<line_number-246>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-247>                                        \"returns the given number converted from radians to degrees.\",\n<line_number-248>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()},\n<line_number-249>                                        FunctionCategory.NUM_FUNC),\n<line_number-250>                                new MongoFunction(\n<line_number-251>                                        DEGREES,\n<line_number-252>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-253>                                        \"returns the given number converted from radians to degrees.\",\n<line_number-254>                                        new String[] {BsonTypeInfo.BSON_LONG.getBsonName()},\n<line_number-255>                                        FunctionCategory.NUM_FUNC),\n<line_number-256>                                new MongoFunction(\n<line_number-257>                                        DEGREES,\n<line_number-258>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-259>                                        \"returns the given number converted from radians to degrees.\",\n<line_number-260>                                        new String[] {BsonTypeInfo.BSON_DOUBLE.getBsonName()},\n<line_number-261>                                        FunctionCategory.NUM_FUNC),\n<line_number-262>                                new MongoFunction(\n<line_number-263>                                        DEGREES,\n<line_number-264>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-265>                                        \"returns the given number converted from radians to degrees.\",\n<line_number-266>                                        new String[] {BsonTypeInfo.BSON_DECIMAL.getBsonName()},\n<line_number-267>                                        FunctionCategory.NUM_FUNC),\n<line_number-268>                                /**\n<line_number-269>                                 * Note EXTRACT supports more than YEAR, MONTH, DAY, HOUR, MINUTE,\n<line_number-270>                                 * SECOND for the unit. It also supports TIMEZONE_HOUR |\n<line_number-271>                                 * TIMEZONE_MINUTE.\n<line_number-272>                                 */\n<line_number-273>                                new MongoFunction(\n<line_number-274>                                        EXTRACT,\n<line_number-275>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-276>                                        \"returns the value of the specified unit from the provided date.\",\n<line_number-277>                                        new String[] {\n<line_number-278>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-279>                                            BsonTypeInfo.BSON_DATE.getBsonName()\n<line_number-280>                                        },\n<line_number-281>                                        FunctionCategory.TIME_DATE_FUNC),\n<line_number-282>                                new MongoFunction(\n<line_number-283>                                        FLOOR,\n<line_number-284>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-285>                                        \"returns a number to the nearest whole number of equal or lesser value.\",\n<line_number-286>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()},\n<line_number-287>                                        FunctionCategory.NUM_FUNC),\n<line_number-288>                                new MongoFunction(\n<line_number-289>                                        FLOOR,\n<line_number-290>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-291>                                        \"returns a number to the nearest whole number of equal or lesser value.\",\n<line_number-292>                                        new String[] {BsonTypeInfo.BSON_LONG.getBsonName()},\n<line_number-293>                                        FunctionCategory.NUM_FUNC),\n<line_number-294>                                new MongoFunction(\n<line_number-295>                                        FLOOR,\n<line_number-296>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-297>                                        \"returns a number to the nearest whole number of equal or lesser value.\",\n<line_number-298>                                        new String[] {BsonTypeInfo.BSON_DOUBLE.getBsonName()},\n<line_number-299>                                        FunctionCategory.NUM_FUNC),\n<line_number-300>                                new MongoFunction(\n<line_number-301>                                        FLOOR,\n<line_number-302>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-303>                                        \"returns a number to the nearest whole number of equal or lesser value.\",\n<line_number-304>                                        new String[] {BsonTypeInfo.BSON_DECIMAL.getBsonName()},\n<line_number-305>                                        FunctionCategory.NUM_FUNC),\n<line_number-306>                                new MongoFunction(\n<line_number-307>                                        LOG,\n<line_number-308>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-309>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-310>                                        new String[] {\n<line_number-311>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-312>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-313>                                        }),\n<line_number-314>                                new MongoFunction(\n<line_number-315>                                        LOG,\n<line_number-316>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-317>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-318>                                        new String[] {\n<line_number-319>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-320>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-321>                                        }),\n<line_number-322>                                new MongoFunction(\n<line_number-323>                                        LOG,\n<line_number-324>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-325>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-326>                                        new String[] {\n<line_number-327>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-328>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-329>                                        }),\n<line_number-330>                                new MongoFunction(\n<line_number-331>                                        LOG,\n<line_number-332>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-333>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-334>                                        new String[] {\n<line_number-335>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-336>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-337>                                        }),\n<line_number-338>                                new MongoFunction(\n<line_number-339>                                        LOG,\n<line_number-340>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-341>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-342>                                        new String[] {\n<line_number-343>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-344>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-345>                                        }),\n<line_number-346>                                new MongoFunction(\n<line_number-347>                                        LOG,\n<line_number-348>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-349>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-350>                                        new String[] {\n<line_number-351>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-352>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-353>                                        }),\n<line_number-354>                                new MongoFunction(\n<line_number-355>                                        LOG,\n<line_number-356>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-357>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-358>                                        new String[] {\n<line_number-359>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-360>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-361>                                        }),\n<line_number-362>                                new MongoFunction(\n<line_number-363>                                        LOG,\n<line_number-364>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-365>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-366>                                        new String[] {\n<line_number-367>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-368>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-369>                                        }),\n<line_number-370>                                new MongoFunction(\n<line_number-371>                                        LOG,\n<line_number-372>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-373>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-374>                                        new String[] {\n<line_number-375>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-376>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-377>                                        }),\n<line_number-378>                                new MongoFunction(\n<line_number-379>                                        LOG,\n<line_number-380>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-381>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-382>                                        new String[] {\n<line_number-383>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-384>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-385>                                        }),\n<line_number-386>                                new MongoFunction(\n<line_number-387>                                        LOG,\n<line_number-388>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-389>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-390>                                        new String[] {\n<line_number-391>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-392>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-393>                                        }),\n<line_number-394>                                new MongoFunction(\n<line_number-395>                                        LOG,\n<line_number-396>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-397>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-398>                                        new String[] {\n<line_number-399>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-400>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-401>                                        }),\n<line_number-402>                                new MongoFunction(\n<line_number-403>                                        LOG,\n<line_number-404>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-405>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-406>                                        new String[] {\n<line_number-407>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-408>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-409>                                        }),\n<line_number-410>                                new MongoFunction(\n<line_number-411>                                        LOG,\n<line_number-412>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-413>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-414>                                        new String[] {\n<line_number-415>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-416>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-417>                                        }),\n<line_number-418>                                new MongoFunction(\n<line_number-419>                                        LOG,\n<line_number-420>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-421>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-422>                                        new String[] {\n<line_number-423>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-424>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-425>                                        }),\n<line_number-426>                                new MongoFunction(\n<line_number-427>                                        LOG,\n<line_number-428>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-429>                                        \"returns the logarithm of a number for the given base.\",\n<line_number-430>                                        new String[] {\n<line_number-431>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-432>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-433>                                        }),\n<line_number-434>                                new MongoFunction(\n<line_number-435>                                        \"LOWER\",\n<line_number-436>                                        BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-437>                                        \"returns the provided string with all characters changed to lowercase.\",\n<line_number-438>                                        new String[] {BsonTypeInfo.BSON_STRING.getBsonName()}),\n<line_number-439>                                new MongoFunction(\n<line_number-440>                                        MOD,\n<line_number-441>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-442>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-443>                                        new String[] {\n<line_number-444>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-445>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-446>                                        },\n<line_number-447>                                        FunctionCategory.NUM_FUNC),\n<line_number-448>                                new MongoFunction(\n<line_number-449>                                        MOD,\n<line_number-450>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-451>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-452>                                        new String[] {\n<line_number-453>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-454>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-455>                                        },\n<line_number-456>                                        FunctionCategory.NUM_FUNC),\n<line_number-457>                                new MongoFunction(\n<line_number-458>                                        MOD,\n<line_number-459>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-460>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-461>                                        new String[] {\n<line_number-462>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-463>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-464>                                        },\n<line_number-465>                                        FunctionCategory.NUM_FUNC),\n<line_number-466>                                new MongoFunction(\n<line_number-467>                                        MOD,\n<line_number-468>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-469>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-470>                                        new String[] {\n<line_number-471>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-472>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-473>                                        },\n<line_number-474>                                        FunctionCategory.NUM_FUNC),\n<line_number-475>                                new MongoFunction(\n<line_number-476>                                        MOD,\n<line_number-477>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-478>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-479>                                        new String[] {\n<line_number-480>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-481>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-482>                                        },\n<line_number-483>                                        FunctionCategory.NUM_FUNC),\n<line_number-484>                                new MongoFunction(\n<line_number-485>                                        MOD,\n<line_number-486>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-487>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-488>                                        new String[] {\n<line_number-489>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-490>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-491>                                        },\n<line_number-492>                                        FunctionCategory.NUM_FUNC),\n<line_number-493>                                new MongoFunction(\n<line_number-494>                                        MOD,\n<line_number-495>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-496>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-497>                                        new String[] {\n<line_number-498>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-499>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-500>                                        },\n<line_number-501>                                        FunctionCategory.NUM_FUNC),\n<line_number-502>                                new MongoFunction(\n<line_number-503>                                        MOD,\n<line_number-504>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-505>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-506>                                        new String[] {\n<line_number-507>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-508>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-509>                                        },\n<line_number-510>                                        FunctionCategory.NUM_FUNC),\n<line_number-511>                                new MongoFunction(\n<line_number-512>                                        MOD,\n<line_number-513>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-514>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-515>                                        new String[] {\n<line_number-516>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-517>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-518>                                        },\n<line_number-519>                                        FunctionCategory.NUM_FUNC),\n<line_number-520>                                new MongoFunction(\n<line_number-521>                                        MOD,\n<line_number-522>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-523>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-524>                                        new String[] {\n<line_number-525>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-526>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-527>                                        },\n<line_number-528>                                        FunctionCategory.NUM_FUNC),\n<line_number-529>                                new MongoFunction(\n<line_number-530>                                        MOD,\n<line_number-531>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-532>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-533>                                        new String[] {\n<line_number-534>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-535>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-536>                                        },\n<line_number-537>                                        FunctionCategory.NUM_FUNC),\n<line_number-538>                                new MongoFunction(\n<line_number-539>                                        MOD,\n<line_number-540>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-541>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-542>                                        new String[] {\n<line_number-543>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-544>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-545>                                        },\n<line_number-546>                                        FunctionCategory.NUM_FUNC),\n<line_number-547>                                new MongoFunction(\n<line_number-548>                                        MOD,\n<line_number-549>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-550>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-551>                                        new String[] {\n<line_number-552>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-553>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-554>                                        },\n<line_number-555>                                        FunctionCategory.NUM_FUNC),\n<line_number-556>                                new MongoFunction(\n<line_number-557>                                        MOD,\n<line_number-558>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-559>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-560>                                        new String[] {\n<line_number-561>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-562>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-563>                                        },\n<line_number-564>                                        FunctionCategory.NUM_FUNC),\n<line_number-565>                                new MongoFunction(\n<line_number-566>                                        MOD,\n<line_number-567>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-568>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-569>                                        new String[] {\n<line_number-570>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-571>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-572>                                        },\n<line_number-573>                                        FunctionCategory.NUM_FUNC),\n<line_number-574>                                new MongoFunction(\n<line_number-575>                                        MOD,\n<line_number-576>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-577>                                        \"divides number by divisor and returns the remainder.\",\n<line_number-578>                                        new String[] {\n<line_number-579>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-580>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-581>                                        },\n<line_number-582>                                        FunctionCategory.NUM_FUNC),\n<line_number-583>                                new MongoFunction(\n<line_number-584>                                        \"OCTET_LENGTH\",\n<line_number-585>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-586>                                        \"returns length of string in bytes\",\n<line_number-587>                                        new String[] {BsonTypeInfo.BSON_STRING.getBsonName()},\n<line_number-588>                                        FunctionCategory.STRING_FUNC),\n<line_number-589>                                new MongoFunction(\n<line_number-590>                                        \"POSITION\",\n<line_number-591>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-592>                                        \"returns the position of the first occurrence of substring substr in string str.\",\n<line_number-593>                                        new String[] {\n<line_number-594>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-595>                                            BsonTypeInfo.BSON_STRING.getBsonName()\n<line_number-596>                                        },\n<line_number-597>                                        FunctionCategory.STRING_FUNC),\n<line_number-598>                                new MongoFunction(\n<line_number-599>                                        POW,\n<line_number-600>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-601>                                        \"returns the number raised to the specified exponent.\",\n<line_number-602>                                        new String[] {\n<line_number-603>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-604>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-605>                                        }),\n<line_number-606>                                new MongoFunction(\n<line_number-607>                                        POW,\n<line_number-608>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-609>                                        \"returns the number raised to the specified exponent.\",\n<line_number-610>                                        new String[] {\n<line_number-611>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-612>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-613>                                        }),\n<line_number-614>                                new MongoFunction(\n<line_number-615>                                        POW,\n<line_number-616>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-617>                                        \"returns the number raised to the specified exponent.\",\n<line_number-618>                                        new String[] {\n<line_number-619>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-620>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-621>                                        }),\n<line_number-622>                                new MongoFunction(\n<line_number-623>                                        POW,\n<line_number-624>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-625>                                        \"returns the number raised to the specified exponent.\",\n<line_number-626>                                        new String[] {\n<line_number-627>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-628>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-629>                                        }),\n<line_number-630>                                new MongoFunction(\n<line_number-631>                                        POW,\n<line_number-632>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-633>                                        \"returns the number raised to the specified exponent.\",\n<line_number-634>                                        new String[] {\n<line_number-635>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-636>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-637>                                        }),\n<line_number-638>                                new MongoFunction(\n<line_number-639>                                        POW,\n<line_number-640>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-641>                                        \"returns the number raised to the specified exponent.\",\n<line_number-642>                                        new String[] {\n<line_number-643>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-644>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-645>                                        }),\n<line_number-646>                                new MongoFunction(\n<line_number-647>                                        POW,\n<line_number-648>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-649>                                        \"returns the number raised to the specified exponent.\",\n<line_number-650>                                        new String[] {\n<line_number-651>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-652>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-653>                                        }),\n<line_number-654>                                new MongoFunction(\n<line_number-655>                                        POW,\n<line_number-656>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-657>                                        \"returns the number raised to the specified exponent.\",\n<line_number-658>                                        new String[] {\n<line_number-659>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-660>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-661>                                        }),\n<line_number-662>                                new MongoFunction(\n<line_number-663>                                        POW,\n<line_number-664>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-665>                                        \"returns the number raised to the specified exponent.\",\n<line_number-666>                                        new String[] {\n<line_number-667>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-668>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-669>                                        }),\n<line_number-670>                                new MongoFunction(\n<line_number-671>                                        POW,\n<line_number-672>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-673>                                        \"returns the number raised to the specified exponent.\",\n<line_number-674>                                        new String[] {\n<line_number-675>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-676>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-677>                                        }),\n<line_number-678>                                new MongoFunction(\n<line_number-679>                                        POW,\n<line_number-680>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-681>                                        \"returns the number raised to the specified exponent.\",\n<line_number-682>                                        new String[] {\n<line_number-683>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-684>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-685>                                        }),\n<line_number-686>                                new MongoFunction(\n<line_number-687>                                        POW,\n<line_number-688>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-689>                                        \"returns the number raised to the specified exponent.\",\n<line_number-690>                                        new String[] {\n<line_number-691>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-692>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-693>                                        }),\n<line_number-694>                                new MongoFunction(\n<line_number-695>                                        POW,\n<line_number-696>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-697>                                        \"returns the number raised to the specified exponent.\",\n<line_number-698>                                        new String[] {\n<line_number-699>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-700>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-701>                                        }),\n<line_number-702>                                new MongoFunction(\n<line_number-703>                                        POW,\n<line_number-704>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-705>                                        \"returns the number raised to the specified exponent.\",\n<line_number-706>                                        new String[] {\n<line_number-707>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-708>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-709>                                        }),\n<line_number-710>                                new MongoFunction(\n<line_number-711>                                        POW,\n<line_number-712>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-713>                                        \"returns the number raised to the specified exponent.\",\n<line_number-714>                                        new String[] {\n<line_number-715>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-716>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName()\n<line_number-717>                                        }),\n<line_number-718>                                new MongoFunction(\n<line_number-719>                                        POW,\n<line_number-720>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-721>                                        \"returns the number raised to the specified exponent.\",\n<line_number-722>                                        new String[] {\n<line_number-723>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-724>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName()\n<line_number-725>                                        }),\n<line_number-726>                                new MongoFunction(\n<line_number-727>                                        RADIANS,\n<line_number-728>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-729>                                        \"returns the given number converted from degrees to radians.\",\n<line_number-730>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()},\n<line_number-731>                                        FunctionCategory.NUM_FUNC),\n<line_number-732>                                new MongoFunction(\n<line_number-733>                                        RADIANS,\n<line_number-734>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-735>                                        \"returns the given number converted from degrees to radians.\",\n<line_number-736>                                        new String[] {BsonTypeInfo.BSON_LONG.getBsonName()},\n<line_number-737>                                        FunctionCategory.NUM_FUNC),\n<line_number-738>                                new MongoFunction(\n<line_number-739>                                        RADIANS,\n<line_number-740>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-741>                                        \"returns the given number converted from degrees to radians.\",\n<line_number-742>                                        new String[] {BsonTypeInfo.BSON_DOUBLE.getBsonName()},\n<line_number-743>                                        FunctionCategory.NUM_FUNC),\n<line_number-744>                                new MongoFunction(\n<line_number-745>                                        RADIANS,\n<line_number-746>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-747>                                        \"returns the given number converted from degrees to radians.\",\n<line_number-748>                                        new String[] {BsonTypeInfo.BSON_DECIMAL.getBsonName()},\n<line_number-749>                                        FunctionCategory.NUM_FUNC),\n<line_number-750>                                new MongoFunction(\n<line_number-751>                                        ROUND,\n<line_number-752>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-753>                                        \"rounds number to a specified number of digits.\",\n<line_number-754>                                        new String[] {\n<line_number-755>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-756>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-757>                                        },\n<line_number-758>                                        FunctionCategory.NUM_FUNC),\n<line_number-759>                                new MongoFunction(\n<line_number-760>                                        ROUND,\n<line_number-761>                                        BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-762>                                        \"rounds number to a specified number of digits.\",\n<line_number-763>                                        new String[] {\n<line_number-764>                                            BsonTypeInfo.BSON_INT.getBsonName(),\n<line_number-765>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-766>                                        },\n<line_number-767>                                        FunctionCategory.NUM_FUNC),\n<line_number-768>                                new MongoFunction(\n<line_number-769>                                        ROUND,\n<line_number-770>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-771>                                        \"rounds number to a specified number of digits.\",\n<line_number-772>                                        new String[] {\n<line_number-773>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-774>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-775>                                        },\n<line_number-776>                                        FunctionCategory.NUM_FUNC),\n<line_number-777>                                new MongoFunction(\n<line_number-778>                                        ROUND,\n<line_number-779>                                        BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-780>                                        \"rounds number to a specified number of digits.\",\n<line_number-781>                                        new String[] {\n<line_number-782>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-783>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-784>                                        },\n<line_number-785>                                        FunctionCategory.NUM_FUNC),\n<line_number-786>                                new MongoFunction(\n<line_number-787>                                        ROUND,\n<line_number-788>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-789>                                        \"rounds number to a specified number of digits.\",\n<line_number-790>                                        new String[] {\n<line_number-791>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-792>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-793>                                        },\n<line_number-794>                                        FunctionCategory.NUM_FUNC),\n<line_number-795>                                new MongoFunction(\n<line_number-796>                                        ROUND,\n<line_number-797>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-798>                                        \"rounds number to a specified number of digits.\",\n<line_number-799>                                        new String[] {\n<line_number-800>                                            BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-801>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-802>                                        },\n<line_number-803>                                        FunctionCategory.NUM_FUNC),\n<line_number-804>                                new MongoFunction(\n<line_number-805>                                        ROUND,\n<line_number-806>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-807>                                        \"rounds number to a specified number of digits.\",\n<line_number-808>                                        new String[] {\n<line_number-809>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-810>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-811>                                        },\n<line_number-812>                                        FunctionCategory.NUM_FUNC),\n<line_number-813>                                new MongoFunction(\n<line_number-814>                                        ROUND,\n<line_number-815>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-816>                                        \"rounds number to a specified number of digits.\",\n<line_number-817>                                        new String[] {\n<line_number-818>                                            BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-819>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-820>                                        },\n<line_number-821>                                        FunctionCategory.NUM_FUNC),\n<line_number-822>                                new MongoFunction(\n<line_number-823>                                        SIN,\n<line_number-824>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-825>                                        \"returns the sine of an angle specified in radians.\",\n<line_number-826>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()},\n<line_number-827>                                        FunctionCategory.NUM_FUNC),\n<line_number-828>                                new MongoFunction(\n<line_number-829>                                        SIN,\n<line_number-830>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-831>                                        \"returns the sine of an angle specified in radians.\",\n<line_number-832>                                        new String[] {BsonTypeInfo.BSON_LONG.getBsonName()},\n<line_number-833>                                        FunctionCategory.NUM_FUNC),\n<line_number-834>                                new MongoFunction(\n<line_number-835>                                        SIN,\n<line_number-836>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-837>                                        \"returns the sine of an angle specified in radians.\",\n<line_number-838>                                        new String[] {BsonTypeInfo.BSON_DOUBLE.getBsonName()},\n<line_number-839>                                        FunctionCategory.NUM_FUNC),\n<line_number-840>                                new MongoFunction(\n<line_number-841>                                        SIN,\n<line_number-842>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-843>                                        \"returns the sine of an angle specified in radians.\",\n<line_number-844>                                        new String[] {BsonTypeInfo.BSON_DECIMAL.getBsonName()},\n<line_number-845>                                        FunctionCategory.NUM_FUNC),\n<line_number-846>                                new MongoFunction(\n<line_number-847>                                        \"SIZE\",\n<line_number-848>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-849>                                        \"returns the size of an array.\",\n<line_number-850>                                        new String[] {BsonTypeInfo.BSON_ARRAY.getBsonName()}),\n<line_number-851>                                new MongoFunction(\n<line_number-852>                                        \"SPLIT\",\n<line_number-853>                                        BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-854>                                        \"returns a substring from a string, using a delimiter character to divide the string into a sequence of tokens.\",\n<line_number-855>                                        new String[] {\n<line_number-856>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-857>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-858>                                            BsonTypeInfo.BSON_INT.getBsonName()\n<line_number-859>                                        }),\n<line_number-860>                                new MongoFunction(\n<line_number-861>                                        SQRT,\n<line_number-862>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-863>                                        \"returns the square root of a positive number.\",\n<line_number-864>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()},\n<line_number-865>                                        FunctionCategory.NUM_FUNC),\n<line_number-866>                                new MongoFunction(\n<line_number-867>                                        SQRT,\n<line_number-868>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-869>                                        \"returns the square root of a positive number.\",\n<line_number-870>                                        new String[] {BsonTypeInfo.BSON_LONG.getBsonName()},\n<line_number-871>                                        FunctionCategory.NUM_FUNC),\n<line_number-872>                                new MongoFunction(\n<line_number-873>                                        SQRT,\n<line_number-874>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-875>                                        \"returns the square root of a positive number.\",\n<line_number-876>                                        new String[] {BsonTypeInfo.BSON_DOUBLE.getBsonName()},\n<line_number-877>                                        FunctionCategory.NUM_FUNC),\n<line_number-878>                                new MongoFunction(\n<line_number-879>                                        SQRT,\n<line_number-880>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-881>                                        \"returns the square root of a positive number.\",\n<line_number-882>                                        new String[] {BsonTypeInfo.BSON_DECIMAL.getBsonName()},\n<line_number-883>                                        FunctionCategory.NUM_FUNC),\n<line_number-884>                                new MongoFunction(\n<line_number-885>                                        SUBSTRING,\n<line_number-886>                                        BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-887>                                        \"takes a substring from a string\",\n<line_number-888>                                        new String[] {\n<line_number-889>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-890>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-891>                                        }),\n<line_number-892>                                new MongoFunction(\n<line_number-893>                                        SUBSTRING,\n<line_number-894>                                        BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-895>                                        \"takes a substring from a string\",\n<line_number-896>                                        new String[] {\n<line_number-897>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-898>                                            BsonTypeInfo.BSON_LONG.getBsonName(),\n<line_number-899>                                            BsonTypeInfo.BSON_LONG.getBsonName()\n<line_number-900>                                        },\n<line_number-901>                                        FunctionCategory.STRING_FUNC),\n<line_number-902>                                new MongoFunction(\n<line_number-903>                                        TAN,\n<line_number-904>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-905>                                        \"returns the tangent of an angle specified in radians.\",\n<line_number-906>                                        new String[] {BsonTypeInfo.BSON_INT.getBsonName()},\n<line_number-907>                                        FunctionCategory.NUM_FUNC),\n<line_number-908>                                new MongoFunction(\n<line_number-909>                                        TAN,\n<line_number-910>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-911>                                        \"returns the tangent of an angle specified in radians.\",\n<line_number-912>                                        new String[] {BsonTypeInfo.BSON_LONG.getBsonName()},\n<line_number-913>                                        FunctionCategory.NUM_FUNC),\n<line_number-914>                                new MongoFunction(\n<line_number-915>                                        TAN,\n<line_number-916>                                        BsonTypeInfo.BSON_DOUBLE.getBsonName(),\n<line_number-917>                                        \"returns the tangent of an angle specified in radians.\",\n<line_number-918>                                        new String[] {BsonTypeInfo.BSON_DOUBLE.getBsonName()},\n<line_number-919>                                        FunctionCategory.NUM_FUNC),\n<line_number-920>                                new MongoFunction(\n<line_number-921>                                        TAN,\n<line_number-922>                                        BsonTypeInfo.BSON_DECIMAL.getBsonName(),\n<line_number-923>                                        \"returns the tangent of an angle specified in radians.\",\n<line_number-924>                                        new String[] {BsonTypeInfo.BSON_DECIMAL.getBsonName()},\n<line_number-925>                                        FunctionCategory.NUM_FUNC),\n<line_number-926>                                new MongoFunction(\n<line_number-927>                                        \"TRIM\",\n<line_number-928>                                        BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-929>                                        \"returns the string str with all remstr prefixes and/or suffixes removed.\",\n<line_number-930>                                        new String[] {BsonTypeInfo.BSON_STRING.getBsonName()}),\n<line_number-931>                                new MongoFunction(\n<line_number-932>                                        \"TRIM\",\n<line_number-933>                                        BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-934>                                        \"returns the string str with all remstr prefixes and/or suffixes removed.\",\n<line_number-935>                                        new String[] {\n<line_number-936>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-937>                                            BsonTypeInfo.BSON_STRING.getBsonName()\n<line_number-938>                                        }),\n<line_number-939>                                new MongoFunction(\n<line_number-940>                                        \"TRIM\",\n<line_number-941>                                        BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-942>                                        \"returns the string str with all remstr prefixes and/or suffixes removed.\",\n<line_number-943>                                        new String[] {\n<line_number-944>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-945>                                            BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-946>                                            BsonTypeInfo.BSON_STRING.getBsonName()\n<line_number-947>                                        }),\n<line_number-948>                                new MongoFunction(\n<line_number-949>                                        \"UPPER\",\n<line_number-950>                                        BsonTypeInfo.BSON_STRING.getBsonName(),\n<line_number-951>                                        \"returns the provided string with all characters changed to uppercase.\",\n<line_number-952>                                        new String[] {BsonTypeInfo.BSON_STRING.getBsonName()})\n<line_number-953>                            });\n<line_number-954>        }\n<line_number-955>\n<line_number-956>        return instance;\n<line_number-957>    }\n<line_number-958>\n<line_number-959>    // Build the list of numeric, string, dateTime and system functions.\n<line_number-960>    private void initCategorizedFunctionsList() {\n<line_number-961>        StringBuilder numericFunctionsBuilder = new StringBuilder();\n<line_number-962>        StringBuilder stringFunctionsBuilder = new StringBuilder();\n<line_number-963>        StringBuilder dateTimeFunctionsBuilder = new StringBuilder();\n<line_number-964>        StringBuilder systemFunctionsBuilder = new StringBuilder();\n<line_number-965>\n<line_number-966>        Set<String> seenFunctions = new HashSet<>();\n<line_number-967>\n<line_number-968>        StringBuilder currBuilder = null;\n<line_number-969>        for (MongoFunction currFunc : functions) {\n<line_number-970>            switch (currFunc.functionCategory) {\n<line_number-971>                case NUM_FUNC:\n<line_number-972>                    {\n<line_number-973>                        currBuilder = numericFunctionsBuilder;\n<line_number-974>                        break;\n<line_number-975>                    }\n<line_number-976>\n<line_number-977>                case STRING_FUNC:\n<line_number-978>                    {\n<line_number-979>                        currBuilder = stringFunctionsBuilder;\n<line_number-980>                        break;\n<line_number-981>                    }\n<line_number-982>\n<line_number-983>                case SYSTEM_FUNC:\n<line_number-984>                    {\n<line_number-985>                        currBuilder = systemFunctionsBuilder;\n<line_number-986>                        break;\n<line_number-987>                    }\n<line_number-988>\n<line_number-989>                case TIME_DATE_FUNC:\n<line_number-990>                    {\n<line_number-991>                        currBuilder = dateTimeFunctionsBuilder;\n<line_number-992>\n<line_number-993>                        break;\n<line_number-994>                    }\n<line_number-995>\n<line_number-996>                case CONV_FUNC:\n<line_number-997>                case UNCATEGORIZED_FUNC:\n<line_number-998>                default:\n<line_number-999>                    {\n<line_number-1000>                        currBuilder = null;\n<line_number-1001>                        // Nothing to do\n<line_number-1002>                        break;\n<line_number-1003>                    }\n<line_number-1004>            }\n<line_number-1005>\n<line_number-1006>            if (null != currBuilder && !seenFunctions.contains(currFunc.name)) {\n<line_number-1007>                if (currBuilder.length() > 0) {\n<line_number-1008>                    currBuilder.append(',');\n<line_number-1009>                }\n<line_number-1010>                currBuilder.append(currFunc.name);\n<line_number-1011>                seenFunctions.add(currFunc.name);\n<line_number-1012>            }\n<line_number-1013>        }\n<line_number-1014>        numericFunctionsString = numericFunctionsBuilder.toString();\n<line_number-1015>        stringFunctionsString = stringFunctionsBuilder.toString();\n<line_number-1016>        dateFunctionsString = dateTimeFunctionsBuilder.toString();\n<line_number-1017>        systemFunctionsString = systemFunctionsBuilder.toString();\n<line_number-1018>    }\n<line_number-1019>}\n",
        "comments": [
          {
            "comment_code_range": "22-1019",
            "comment_linenumber": "21",
            "comment": "This class provides a singleton implementation for managing MongoDB functions, categorizing them into numeric, string, date/time, and system functions.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "23-30",
            "comment_linenumber": "22",
            "comment": "Enumeration representing different categories of MongoDB functions.",
            "comment_kind": "enum"
          },
          {
            "comment_code_range": "32-58",
            "comment_linenumber": "31",
            "comment": "Represents a MongoDB function with its name, return type, comment, argument types, and category.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "39-50",
            "comment_linenumber": "38",
            "comment": "Constructor initializing all properties of the MongoFunction class.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "52-58",
            "comment_linenumber": "51",
            "comment": "Constructor initializing MongoFunction with a default category of UNCATEGORIZED_FUNC.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "61-66",
            "comment_linenumber": "60",
            "comment": "Holds the instance of the singleton MongoFunctions class and arrays for categorized function strings.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "68-81",
            "comment_linenumber": "67",
            "comment": "Static final strings representing common function names used in MongoDB.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "89-92",
            "comment_linenumber": "88",
            "comment": "Constructor that initializes the MongoFunctions instance with a predefined list of MongoFunction objects.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "94-96",
            "comment_linenumber": "93",
            "comment": "Static method to retrieve the singleton instance of MongoFunctions, creating it if necessary.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "959-1018",
            "comment_linenumber": "958",
            "comment": "Initializes categorized function lists for numeric, string, date/time, and system functions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "968-1018",
            "comment_linenumber": "967",
            "comment": "Iterates through functions to categorize them and build corresponding strings, avoiding duplicates.",
            "comment_kind": "loop"
          }
        ],
        "structural_analysis": "The file 'MongoFunctions.java' defines a singleton class for managing MongoDB functions, categorizing them into various types such as numeric, string, date/time, and system functions. The top-level class 'MongoFunctions' contains an inner enum 'FunctionCategory' that categorizes the functions. The inner class 'MongoFunction' encapsulates the properties of each function, including its name, return type, comment, argument types, and category. The class maintains a static instance of itself to ensure a single instance is used throughout the application. It also contains static final strings for common function names. The constructor initializes the function list and categorizes them into respective strings. The method 'getInstance()' provides access to the singleton instance, creating it if it does not exist. The method 'initCategorizedFunctionsList()' builds categorized lists of functions, ensuring no duplicates are included. The file employs a loop to iterate through the functions and categorize them based on their type, appending them to the appropriate string builder.",
        "file_summary": "The 'MongoFunctions.java' file provides a singleton implementation for managing MongoDB functions, categorizing them into numeric, string, date/time, and system functions. It encapsulates the properties and behaviors of these functions, allowing for easy retrieval and categorization."
      }
    ]
  },
  "MongoJsonSchema.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoJsonSchema.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoJsonSchema.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoJsonSchema.java",
        "chunk_id": "MongoJsonSchema_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.BsonTypeInfo.*;\n<line_number-20>\n<line_number-21>import com.mongodb.jdbc.utils.BsonUtils;\n<line_number-22>import java.sql.DatabaseMetaData;\n<line_number-23>import java.sql.SQLException;\n<line_number-24>import java.util.HashMap;\n<line_number-25>import java.util.HashSet;\n<line_number-26>import java.util.LinkedHashMap;\n<line_number-27>import java.util.List;\n<line_number-28>import java.util.Map;\n<line_number-29>import java.util.Objects;\n<line_number-30>import java.util.Set;\n<line_number-31>import java.util.stream.Collectors;\n<line_number-32>import java.util.stream.Stream;\n<line_number-33>import org.bson.BsonInvalidOperationException;\n<line_number-34>import org.bson.BsonType;\n<line_number-35>import org.bson.BsonValue;\n<line_number-36>import org.bson.codecs.Codec;\n<line_number-37>import org.bson.codecs.pojo.annotations.BsonIgnore;\n<line_number-38>\n<line_number-39>public class MongoJsonSchema {\n<line_number-40>\n<line_number-41>    private static final Codec<MongoJsonSchema> CODEC =\n<line_number-42>            MongoDriver.getCodecRegistry().get(MongoJsonSchema.class);\n<line_number-43>\n<line_number-44>    public static class ScalarProperties {\n<line_number-45>        protected String name;\n<line_number-46>        protected boolean isRequired = true;\n<line_number-47>        protected BsonTypeInfo type;\n<line_number-48>\n<line_number-49>        public ScalarProperties(String name, BsonTypeInfo type, boolean isRequired) {\n<line_number-50>            this.name = name;\n<line_number-51>            this.isRequired = isRequired;\n<line_number-52>            this.type = type;\n<line_number-53>        }\n<line_number-54>\n<line_number-55>        public ScalarProperties(String name, BsonTypeInfo type) {\n<line_number-56>            this.name = name;\n<line_number-57>            this.type = type;\n<line_number-58>        }\n<line_number-59>    }\n<line_number-60>\n<line_number-61>    public String bsonType;\n<line_number-62>    public Map<String, MongoJsonSchema> properties;\n<line_number-63>    public Set<MongoJsonSchema> anyOf;\n<line_number-64>    public Set<String> required;\n<line_number-65>    public MongoJsonSchema items;\n<line_number-66>    public boolean additionalProperties;\n<line_number-67>\n<line_number-68>    /**\n<line_number-69>     * Converts a deserialized jsonSchema into a MongoJsonSchema. The MongoJsonSchema instance is\n<line_number-70>     * semantically equivalent to the base jsonSchema, but bsonType has to be a single type\n<line_number-71>     * otherwise the types will get pushed down in the anyOf list. After the conversion is done,\n<line_number-72>     * anyOfs are flattened.\n<line_number-73>     *\n<line_number-74>     * @param baseSchema The base json schema.\n<line_number-75>     * @return the corresponding MongoJsonSchema.\n<line_number-76>     */\n<line_number-77>    public static MongoJsonSchema toSimplifiedMongoJsonSchema(JsonSchema baseSchema) {\n<line_number-78>        MongoJsonSchema unsimplifiedSchema = toMongoJsonSchema(baseSchema);\n<line_number-79>        return flattenNestedAnyOfs(unsimplifiedSchema);\n<line_number-80>    }\n<line_number-81>\n<line_number-82>    /**\n<line_number-83>     * Converts a deserialized jsonSchema into a MongoJsonSchema. The MongoJsonSchema instance is\n<line_number-84>     * semantically equivalent to the base jsonSchema, but bsonType has to be a single type\n<line_number-85>     * otherwise the types will get pushed down in the anyOf list.\n<line_number-86>     *\n<line_number-87>     * @param baseSchema The base json schema.\n<line_number-88>     * @return the corresponding MongoJsonSchema.\n<line_number-89>     */\n<line_number-90>    private static MongoJsonSchema toMongoJsonSchema(JsonSchema baseSchema) {\n<line_number-91>        if (null == baseSchema) {\n<line_number-92>            return null;\n<line_number-93>        }\n<line_number-94>\n<line_number-95>        MongoJsonSchema result = new MongoJsonSchema();\n<line_number-96>        result.properties = toMongoJsonSchemaProperties(baseSchema.properties);\n<line_number-97>        if (null != baseSchema.anyOf) {\n<line_number-98>            result.anyOf = new HashSet<MongoJsonSchema>();\n<line_number-99>            for (JsonSchema baseAnyOf : baseSchema.anyOf) {\n<line_number-100>                result.anyOf.add(toSimplifiedMongoJsonSchema(baseAnyOf));\n<line_number-101>            }\n<line_number-102>        }\n<line_number-103>        result.required = baseSchema.required;\n<line_number-104>        if (baseSchema.items != null) {\n<line_number-105>            result.items = toMongoJsonSchemaItems(baseSchema.items);\n<line_number-106>        }\n<line_number-107>        result.additionalProperties =\n<line_number-108>                toMongoJsonSchemaAdditionalProperties(baseSchema.additionalProperties);\n<line_number-109>\n<line_number-110>        if (baseSchema.bsonType != null) {\n<line_number-111>            Set<String> bsonTypes = polymorphicBsonTypeToStringSet(baseSchema.bsonType);\n<line_number-112>            //  If there are many types in the set and it can not be reduced to one type after eliminating any Null\n<line_number-113>            //  type in the list, the types will be inserted in the list of anyOf to be handled as polymorphic type.\n<line_number-114>            if (bsonTypes.size() > 0 && bsonTypes.size() <= 2) {\n<line_number-115>                List<String> trimmedList =\n<line_number-116>                        bsonTypes\n<line_number-117>                                .stream()\n<line_number-118>                                .filter(t -> !t.equalsIgnoreCase(BSON_NULL.getBsonName()))\n<line_number-119>                                .collect(Collectors.toList());\n<line_number-120>\n<line_number-121>                if (trimmedList.size() == 1) {\n<line_number-122>                    String type = trimmedList.get(0);\n<line_number-123>                    if (BSON_ARRAY.getBsonName().equalsIgnoreCase(type)\n<line_number-124>                            && (null == baseSchema.items)) {\n<line_number-125>                        // The bson type is an array of unknowns items.\n<line_number-126>                        // The bson type is unknown and it's equivalent to any.\n<line_number-127>                        // Return an empty schema.\n<line_number-128>                        return new MongoJsonSchema();\n<line_number-129>                    } else {\n<line_number-130>                        result.bsonType = type;\n<line_number-131>                    }\n<line_number-132>                    return result;\n<line_number-133>                }\n<line_number-134>            }\n<line_number-135>\n<line_number-136>            // We'll need to add the types from bsontype set to the anyOf list.\n<line_number-137>            // If the list is null, create a new one.\n<line_number-138>            if (null == result.anyOf) {\n<line_number-139>                result.anyOf = new HashSet<MongoJsonSchema>();\n<line_number-140>            }\n<line_number-141>\n<line_number-142>            /**\n<line_number-143>             * Push down each bsontype from a bsontype array into a separate bsonType in an anyOf\n<line_number-144>             * schema. For example:\n<line_number-145>             *\n<line_number-146>             * <pre>\n<line_number-147>             * \"y\": {\n<line_number-148>             *     \"bsonType\": [\"string\", \"int\"]\n<line_number-149>             *  }\n<line_number-150>             * </pre>\n<line_number-151>             *\n<line_number-152>             * will become\n<line_number-153>             *\n<line_number-154>             * <pre>\n<line_number-155>             *  \"y\": {\n<line_number-156>             *      \"anyOf\": [\n<line_number-157>             *          {\"bsonType\": \"string\"},\n<line_number-158>             *          {\"bsonType\": \"int\"}\n<line_number-159>             *      ]\n<line_number-160>             *  }\n<line_number-161>             * </pre>\n<line_number-162>             */\n<line_number-163>            for (String currType : bsonTypes) {\n<line_number-164>                MongoJsonSchema anyOfSchema = new MongoJsonSchema();\n<line_number-165>                anyOfSchema.bsonType = currType;\n<line_number-166>\n<line_number-167>                if (BSON_ARRAY.getBsonName().equalsIgnoreCase(currType)) {\n<line_number-168>                    // Move the items down with the anyOf schema for the bsontype Array\n<line_number-169>                    // because they go together\n<line_number-170>                    anyOfSchema.items = toMongoJsonSchemaItems(baseSchema.items);\n<line_number-171>                } else if (BSON_OBJECT.getBsonName().equalsIgnoreCase(currType)) {\n<line_number-172>                    // Move the object related properties down with the anyof schema for the 'object'\n<line_number-173>                    anyOfSchema.properties = toMongoJsonSchemaProperties(baseSchema.properties);\n<line_number-174>                    anyOfSchema.required = baseSchema.required;\n<line_number-175>                    anyOfSchema.additionalProperties =\n<line_number-176>                            toMongoJsonSchemaAdditionalProperties(baseSchema.additionalProperties);\n<line_number-177>                    result.properties = null;\n<line_number-178>                    result.required = null;\n<line_number-179>                    result.additionalProperties = false;\n<line_number-180>                }\n<line_number-181>                // Add the bsontype information as a new anyOf schema\n<line_number-182>                if (!result.anyOf.contains(anyOfSchema)) {\n<line_number-183>                    result.anyOf.add(anyOfSchema);\n<line_number-184>                }\n<line_number-185>            }\n<line_number-186>        }\n<line_number-187>\n<line_number-188>        return result;\n<line_number-189>    }\n<line_number-190>\n<line_number-191>    /**\n<line_number-192>     * Converts a polymorphic items field which can either be a JsonSchema or an Array of JsonSchema\n<line_number-193>     * to a set of MongoJsonSchema.\n<line_number-194>     *\n<line_number-195>     * @param polymorphicItems The original polymorphic field.\n<line_number-196>     * @return any, represented by an empty MongoJsonSchema.\n<line_number-197>     * @throws BsonInvalidOperationException If the BsonValue is neither JsonSchema or an Array.\n<line_number-198>     */\n<line_number-199>    private static MongoJsonSchema toMongoJsonSchemaItems(BsonValue polymorphicItems)\n<line_number-200>            throws BsonInvalidOperationException {\n<line_number-201>        MongoJsonSchema result = null;\n<line_number-202>        if (polymorphicItems == null) {\n<line_number-203>            return null;\n<line_number-204>        }\n<line_number-205>\n<line_number-206>        // The only expected types for Items are BsonArray or BsonDocument\n<line_number-207>        if (!(polymorphicItems.isArray() || polymorphicItems.isDocument())) {\n<line_number-208>            throw new BsonInvalidOperationException(\n<line_number-209>                    \"Value expected to be of type \"\n<line_number-210>                            + BsonType.ARRAY\n<line_number-211>                            + \" or \"\n<line_number-212>                            + BsonType.DOCUMENT\n<line_number-213>                            + \" but  is of unexpected type \"\n<line_number-214>                            + polymorphicItems.getBsonType());\n<line_number-215>        }\n<line_number-216>\n<line_number-217>        return new MongoJsonSchema();\n<line_number-218>    }\n<line_number-219>\n<line_number-220>    /**\n<line_number-221>     * Converts a polymorphic additionalProperties which can either be a boolean or a Document to a\n<line_number-222>     * boolean.\n<line_number-223>     *\n<line_number-224>     * @param polymorphicAdditionalProperties The original polymorphic additionalProperties field.\n<line_number-225>     * @return the corresponding boolean value.\n<line_number-226>     * @throws BsonInvalidOperationException If the BsonValue is neither a Boolean or a Document.\n<line_number-227>     */\n<line_number-228>    private static boolean toMongoJsonSchemaAdditionalProperties(\n<line_number-229>            BsonValue polymorphicAdditionalProperties) throws BsonInvalidOperationException {\n<line_number-230>        if (polymorphicAdditionalProperties == null) {\n<line_number-231>            // By default, additional properties is false\n<line_number-232>            return false;\n<line_number-233>        }\n<line_number-234>\n<line_number-235>        // The only expected types for additionalProperties are Document or Boolean\n<line_number-236>        if (!(polymorphicAdditionalProperties.isBoolean()\n<line_number-237>                || polymorphicAdditionalProperties.isDocument())) {\n<line_number-238>            throw new BsonInvalidOperationException(\n<line_number-239>                    \"Value expected to be of type \"\n<line_number-240>                            + BsonType.BOOLEAN\n<line_number-241>                            + \" or \"\n<line_number-242>                            + BsonType.DOCUMENT\n<line_number-243>                            + \" but is of unexpected type \"\n<line_number-244>                            + polymorphicAdditionalProperties.getBsonType());\n<line_number-245>        }\n<line_number-246>\n<line_number-247>        // If additionalProperties is a document, return \"true\", otherwise return the boolean value.\n<line_number-248>        return polymorphicAdditionalProperties.isDocument()\n<line_number-249>                ? true\n<line_number-250>                : polymorphicAdditionalProperties.asBoolean().getValue();\n<line_number-251>    }\n<line_number-252>\n<line_number-253>    /**\n<line_number-254>     * Converts a polymorphic bsonType which can either be a BsonArray or a BsonString to a set of\n<line_number-255>     * Strings.\n<line_number-256>     *\n<line_number-257>     * @param polymorphicBsonType The original polymorphic type.\n<line_number-258>     * @return the corresponding String set.\n<line_number-259>     * @throws BsonInvalidOperationException If the BsonValue is neither a BsonArray or a\n<line_number-260>     *     BsonString.\n<line_number-261>     */\n<line_number-262>    private static Set<String> polymorphicBsonTypeToStringSet(BsonValue polymorphicBsonType)\n<line_number-263>            throws BsonInvalidOperationException {\n<line_number-264>        Set<String> result;\n<line_number-265>        if (polymorphicBsonType.isArray()) {\n<line_number-266>            result =\n<line_number-267>                    polymorphicBsonType\n<line_number-268>                            .asArray()\n<line_number-269>                            .stream()\n<line_number-270>                            .map(val -> val.asString().getValue())\n<line_number-271>                            .collect(Collectors.toSet());\n<line_number-272>        } else if (polymorphicBsonType.isString()) {\n<line_number-273>            result = new HashSet<String>();\n<line_number-274>            result.add(polymorphicBsonType.asString().getValue());\n<line_number-275>        } else {\n<line_number-276>            throw new BsonInvalidOperationException(\n<line_number-277>                    \"Value expected to be of type \"\n<line_number-278>                            + BsonType.ARRAY\n<line_number-279>                            + \" or \"\n<line_number-280>                            + BsonType.STRING\n<line_number-281>                            + \" but  is of unexpected type \"\n<line_number-282>                            + polymorphicBsonType.getBsonType());\n<line_number-283>        }\n<line_number-284>\n<line_number-285>        return result;\n<line_number-286>    }\n<line_number-287>\n<line_number-288>    /**\n<line_number-289>     * Flattens nested anyOf.\n<line_number-290>     *\n<line_number-291>     * @param ioSchema The schema to simplify. ioSchema will be modified directly.\n<line_number-292>     * @return the simplified schema for convenience.\n<line_number-293>     */\n<line_number-294>    private static MongoJsonSchema flattenNestedAnyOfs(MongoJsonSchema ioSchema) {\n<line_number-295>        if (null == ioSchema) {\n<line_number-296>            return null;\n<line_number-297>        }\n<line_number-298>\n<line_number-299>        MongoJsonSchema result = ioSchema;\n<line_number-300>        if (result.anyOf != null && !result.anyOf.isEmpty()) {\n<line_number-301>            result.anyOf =\n<line_number-302>                    result.anyOf\n<line_number-303>                            .stream()\n<line_number-304>                            .flatMap(\n<line_number-305>                                    anyOf -> {\n<line_number-306>                                        if (anyOf == null) {\n<line_number-307>                                            return Stream.empty();\n<line_number-308>                                        } else if (anyOf.anyOf != null && !anyOf.anyOf.isEmpty()) {\n<line_number-309>                                            return anyOf.anyOf.stream();\n<line_number-310>                                        } else {\n<line_number-311>                                            return Stream.of(anyOf);\n<line_number-312>                                        }\n<line_number-313>                                    })\n<line_number-314>                            .collect(Collectors.toSet());\n<line_number-315>        }\n<line_number-316>\n<line_number-317>        // Last step is to reduce a single anyOf to the corresponding bsonType, properties, items, etc...\n<line_number-318>        if (result.anyOf != null && result.anyOf.size() == 1 && result.bsonType == null) {\n<line_number-319>            MongoJsonSchema singleAnyOf = result.anyOf.toArray(new MongoJsonSchema[0])[0];\n<line_number-320>            result.bsonType = singleAnyOf.bsonType;\n<line_number-321>            result.properties = singleAnyOf.properties;\n<line_number-322>            result.items = singleAnyOf.items;\n<line_number-323>            result.required = singleAnyOf.required;\n<line_number-324>            result.additionalProperties = singleAnyOf.additionalProperties;\n<line_number-325>            result.anyOf = null;\n<line_number-326>        }\n<line_number-327>\n<line_number-328>        return result;\n<line_number-329>    }\n<line_number-330>\n<line_number-331>    public static MongoJsonSchema createEmptyObjectSchema() {\n<line_number-332>        MongoJsonSchema ret = new MongoJsonSchema();\n<line_number-333>        ret.bsonType = \"object\";\n<line_number-334>        ret.properties = new LinkedHashMap<>();\n<line_number-335>        ret.required = new HashSet<>();\n<line_number-336>        return ret;\n<line_number-337>    }\n<line_number-338>\n<line_number-339>    public static MongoJsonSchema createScalarSchema(String type) {\n<line_number-340>        MongoJsonSchema ret = new MongoJsonSchema();\n<line_number-341>        ret.bsonType = type;\n<line_number-342>        return ret;\n<line_number-343>    }\n<line_number-344>\n<line_number-345>    private static Map<String, MongoJsonSchema> toMongoJsonSchemaProperties(\n<line_number-346>            Map<String, JsonSchema> from) {\n<line_number-347>        if (null == from) {\n<line_number-348>            return null;\n<line_number-349>        }\n<line_number-350>        Map<String, MongoJsonSchema> to = new HashMap<String, MongoJsonSchema>();\n<line_number-351>        for (Map.Entry<String, JsonSchema> entry : from.entrySet()) {\n<line_number-352>            to.put(entry.getKey(), toSimplifiedMongoJsonSchema(entry.getValue()));\n<line_number-353>        }\n<line_number-354>        return to;\n<line_number-355>    }\n<line_number-356>\n<line_number-357>    /**\n<line_number-358>     * Adds scalar properties to a MongoJsonSchema. Below is an example for adding a scalar\n<line_number-359>     * property:\n<line_number-360>     *\n<line_number-361>     * <pre>\n<line_number-362>     * {\n<line_number-363>     *   \"bsonType\": \"object\",\n<line_number-364>     *   \"properties\": {\n<line_number-365>     *     \"bar\": { \"bsonType\": \"int\" }\n<line_number-366>     *   }\n<line_number-367>     * }\n<line_number-368>     * </pre>\n<line_number-369>     *\n<line_number-370>     * will become\n<line_number-371>     *\n<line_number-372>     * <pre>\n<line_number-373>     * {\n<line_number-374>     *   \"bsonType\": \"object\",\n<line_number-375>     *   \"properties\": {\n<line_number-376>     *     \"bar\": { \"bsonType\": \"int\" },\n<line_number-377>     *     \"foo\": { \"bsonType\": \"bool\" }\n<line_number-378>     *   },\n<line_number-379>     *   \"required\": [foo]\n<line_number-380>     * }\n<line_number-381>     * </pre>\n<line_number-382>     *\n<line_number-383>     * @param scalarProperties Contains the basic info (name, bsonType and required flag) for each\n<line_number-384>     *     key. Each property is converted into a scalar MongoJsonSchema and added to this parent\n<line_number-385>     *     schema.\n<line_number-386>     */\n<line_number-387>    @SafeVarargs\n<line_number-388>    public final void addScalarKeys(ScalarProperties... scalarProperties) {\n<line_number-389>        if (properties == null) {\n<line_number-390>            properties = new LinkedHashMap<>();\n<line_number-391>        }\n<line_number-392>        if (required == null) {\n<line_number-393>            required = new HashSet<>();\n<line_number-394>        }\n<line_number-395>        for (ScalarProperties prop : scalarProperties) {\n<line_number-396>            if (prop.isRequired) {\n<line_number-397>                required.add(prop.name);\n<line_number-398>            }\n<line_number-399>            properties.put(prop.name, createScalarSchema(prop.type.getBsonName()));\n<line_number-400>        }\n<line_number-401>    }\n<line_number-402>\n<line_number-403>    @Override\n<line_number-404>    public boolean equals(Object obj) {\n<line_number-405>        if (!(obj instanceof MongoJsonSchema)) {\n<line_number-406>            return false;\n<line_number-407>        }\n<line_number-408>        MongoJsonSchema other = (MongoJsonSchema) obj;\n<line_number-409>        return Objects.equals(bsonType, other.bsonType)\n<line_number-410>                && Objects.equals(properties, other.properties)\n<line_number-411>                && Objects.equals(anyOf, other.anyOf)\n<line_number-412>                && Objects.equals(required, other.required)\n<line_number-413>                && Objects.equals(items, other.items)\n<line_number-414>                && additionalProperties == other.additionalProperties;\n<line_number-415>    }\n<line_number-416>\n<line_number-417>    @Override\n<line_number-418>    public int hashCode() {\n<line_number-419>        return Objects.hash(bsonType, properties, anyOf, required, items, additionalProperties);\n<line_number-420>    }\n<line_number-421>\n<line_number-422>    @Override\n<line_number-423>    public String toString() {\n<line_number-424>        return BsonUtils.toString(CODEC, this);\n<line_number-425>    }\n<line_number-426>\n<line_number-427>    // Any is represented by the empty json schema {}, so all fields\n<line_number-428>    // will be null or false\n<line_number-429>    public boolean isAny() {\n<line_number-430>        return bsonType == null\n<line_number-431>                && properties == null\n<line_number-432>                && anyOf == null\n<line_number-433>                && required == null\n<line_number-434>                && items == null\n<line_number-435>                && additionalProperties == false;\n<line_number-436>    }\n<line_number-437>\n<line_number-438>    public boolean isObject() {\n<line_number-439>        return bsonType != null && bsonType.equals(\"object\");\n<line_number-440>    }\n<line_number-441>\n<line_number-442>    /**\n<line_number-443>     * Gets the nullability of a column (field) in this schemas list of properties. Its nullability\n<line_number-444>     * is determined as follows:\n<line_number-445>     *\n<line_number-446>     * <ul>\n<line_number-447>     *   <li>If it is not present in this schema's list of properties:\n<line_number-448>     *       <ul>\n<line_number-449>     *         <li>If it is required or this schema allows additional properties, it is considered\n<line_number-450>     *             unknown nullability\n<line_number-451>     *         <li>Otherwise, an exception is thrown\n<line_number-452>     *       </ul>\n<line_number-453>     *\n<line_number-454>     *   <li>If it is a scalar schema (i.e. not Any or AnyOf):\n<line_number-455>     *       <ul>\n<line_number-456>     *         <li>If its bson type is Null, it is considered nullable\n<line_number-457>     *         <li>Otherwise, its nullability depends on whether it is required\n<line_number-458>     *       </ul>\n<line_number-459>     *\n<line_number-460>     *   <li>If it is an Any schema, it is considered nullable\n<line_number-461>     *   <li>If it is an AnyOf schema, it is considered nullable if one of the component schemas in\n<line_number-462>     *       the AnyOf list is Null\n<line_number-463>     *       <ul>\n<line_number-464>     *         <li>This relies on the assumption that schemata returned by MongoSQL are simplified\n<line_number-465>     *       </ul>\n<line_number-466>     *\n<line_number-467>     * </ul>\n<line_number-468>     *\n<line_number-469>     * @param columnName The name of the column (or \"field\") for which to return nullability\n<line_number-470>     *     information\n<line_number-471>     * @return The nullability of the argument\n<line_number-472>     * @throws SQLException If the argued column is not in this schema, or if this schema is invalid\n<line_number-473>     */\n<line_number-474>    public int getColumnNullability(String columnName) throws SQLException {\n<line_number-475>        boolean required = this.required != null && this.required.contains(columnName);\n<line_number-476>\n<line_number-477>        MongoJsonSchema columnSchema = this.properties.get(columnName);\n<line_number-478>        if (columnSchema == null) {\n<line_number-479>            if (required || this.additionalProperties) {\n<line_number-480>                // Even if it is required, we do not know the schema of the field.\n<line_number-481>                // If it has bson type Null, it would be nullable; otherwise it would\n<line_number-482>                // not be nullable. Therefore, we indicate it is unknown nullability.\n<line_number-483>                return DatabaseMetaData.columnNullableUnknown;\n<line_number-484>            }\n<line_number-485>            throw new SQLException(\n<line_number-486>                    \"nullability info requested for invalid column '\" + columnName + \"'\");\n<line_number-487>        }\n<line_number-488>\n<line_number-489>        if (columnSchema.isAny()) {\n<line_number-490>            return DatabaseMetaData.columnNullable;\n<line_number-491>        }\n<line_number-492>\n<line_number-493>        int nullable = required ? DatabaseMetaData.columnNoNulls : DatabaseMetaData.columnNullable;\n<line_number-494>        if (columnSchema.bsonType != null) {\n<line_number-495>            return columnSchema.bsonType.equals(BSON_NULL.getBsonName())\n<line_number-496>                    ? DatabaseMetaData.columnNullable\n<line_number-497>                    : nullable;\n<line_number-498>        }\n<line_number-499>\n<line_number-500>        // Otherwise, the schema must be an AnyOf\n<line_number-501>        if (columnSchema.anyOf == null) {\n<line_number-502>            throw new SQLException(\n<line_number-503>                    \"invalid schema: both bsonType and anyOf are null and this is not ANY\");\n<line_number-504>        }\n<line_number-505>\n<line_number-506>        for (MongoJsonSchema anyOfSchema : columnSchema.anyOf) {\n<line_number-507>            if (anyOfSchema.bsonType == null) {\n<line_number-508>                // Schemata returned by MongoSQL must be simplified. Having nested anyOf is invalid.\n<line_number-509>                throw new SQLException(\n<line_number-510>                        \"invalid schema: anyOf subschema must have bsonType field; nested anyOf must be simplified\");\n<line_number-511>            }\n<line_number-512>\n<line_number-513>            if (anyOfSchema.bsonType.equals(BSON_NULL.getBsonName())) {\n<line_number-514>                return DatabaseMetaData.columnNullable;\n<line_number-515>            }\n<line_number-516>        }\n<line_number-517>\n<line_number-518>        return nullable;\n<line_number-519>    }\n<line_number-520>\n<line_number-521>    /**\n<line_number-522>     * Gets the bson type for this schema as a BsonTypeInfo enum value.\n<line_number-523>     *\n<line_number-524>     * @return The relevant BsonTypeInfo value\n<line_number-525>     * @throws SQLException If this schema is invalid\n<line_number-526>     */\n<line_number-527>    @BsonIgnore\n<line_number-528>    public BsonTypeInfo getBsonTypeInfo() throws SQLException {\n<line_number-529>        if (this.bsonType != null) {\n<line_number-530>            return getBsonTypeInfoByName(this.bsonType);\n<line_number-531>        }\n<line_number-532>\n<line_number-533>        if (this.isAny()) {\n<line_number-534>            return BSON_BSON;\n<line_number-535>        }\n<line_number-536>\n<line_number-537>        // Otherwise, the schema must be an AnyOf\n<line_number-538>        if (this.anyOf == null) {\n<line_number-539>            throw new SQLException(\n<line_number-540>                    \"invalid schema: both bsonType and anyOf are null and this is not ANY\");\n<line_number-541>        }\n<line_number-542>\n<line_number-543>        BsonTypeInfo info = null;\n<line_number-544>        for (MongoJsonSchema anyOfSchema : this.anyOf) {\n<line_number-545>            if (anyOfSchema.bsonType == null) {\n<line_number-546>                // Schemata returned by MongoSQL must be simplified. Having nested anyOf is invalid.\n<line_number-547>                throw new SQLException(\n<line_number-548>                        \"invalid schema: anyOf subschema must have bsonType field; nested anyOf must be simplified\");\n<line_number-549>            }\n<line_number-550>\n<line_number-551>            if (!anyOfSchema.bsonType.equals(BSON_NULL.getBsonName())) {\n<line_number-552>                // If info is not null, there must be more than one non-\"null\" anyOf type, so\n<line_number-553>                // we default to \"bson\".\n<line_number-554>                if (info != null) {\n<line_number-555>                    info = BSON_BSON;\n<line_number-556>                } else {\n<line_number-557>                    info = getBsonTypeInfoByName(anyOfSchema.bsonType);\n<line_number-558>                }\n<line_number-559>            }\n<line_number-560>        }\n<line_number-561>\n<line_number-562>        return info;\n<line_number-563>    }\n<line_number-564>}\n",
        "comments": [
          {
            "comment_code_range": "39-64",
            "comment_linenumber": "38",
            "comment": "Represents a MongoDB JSON schema, including properties, types, and validation rules.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "44-58",
            "comment_linenumber": "43",
            "comment": "Holds scalar properties for the MongoJsonSchema, including name, type, and required status.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "68-76",
            "comment_linenumber": "67",
            "comment": "Converts a deserialized jsonSchema into a MongoJsonSchema, ensuring bsonType is a single type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "82-90",
            "comment_linenumber": "81",
            "comment": "Converts a deserialized jsonSchema into a MongoJsonSchema, handling bsonType and flattening anyOf.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "191-199",
            "comment_linenumber": "190",
            "comment": "Converts polymorphic items field to a MongoJsonSchema, ensuring valid types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "220-228",
            "comment_linenumber": "219",
            "comment": "Converts polymorphic additionalProperties to a boolean, validating types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "253-261",
            "comment_linenumber": "252",
            "comment": "Converts polymorphic bsonType to a set of Strings, ensuring valid types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "288-294",
            "comment_linenumber": "287",
            "comment": "Flattens nested anyOf schemas for simplification.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "331-336",
            "comment_linenumber": "330",
            "comment": "Creates an empty MongoJsonSchema representing an object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "339-342",
            "comment_linenumber": "338",
            "comment": "Creates a MongoJsonSchema for a scalar type based on the provided type string.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "357-386",
            "comment_linenumber": "356",
            "comment": "Adds scalar properties to the MongoJsonSchema, converting them into scalar MongoJsonSchemas.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "442-472",
            "comment_linenumber": "441",
            "comment": "Determines the nullability of a column in the schema based on its properties and required status.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "521-563",
            "comment_linenumber": "520",
            "comment": "Gets the bson type for this schema as a BsonTypeInfo enum value, validating the schema.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoJsonSchema.java' defines a class that represents a MongoDB JSON schema, encapsulating properties, types, and validation rules. It employs a combination of static methods and instance methods to convert between JSON schema representations and MongoDB's BSON schema format. The class contains a nested static class 'ScalarProperties' that holds information about scalar properties, including their names, types, and whether they are required. The main class has several public static methods for creating schemas, converting JSON schemas to MongoDB schemas, and adding scalar properties. It also includes private methods for handling specific conversions and validations. The class maintains fields for BSON type, properties, required fields, and additional properties, allowing for a flexible representation of JSON schemas. The methods are designed to handle various BSON types and ensure that the resulting MongoJsonSchema is valid and simplified. The class also implements equals, hashCode, and toString methods for proper object comparison and representation.",
        "file_summary": "The 'MongoJsonSchema.java' file provides a representation of MongoDB JSON schemas, facilitating the conversion between JSON schema formats and MongoDB's BSON schema. It includes methods for creating schemas, adding properties, and determining nullability, ensuring that the schemas are valid and conform to MongoDB's requirements."
      }
    ]
  },
  "MongoJsonSchemaResult.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoJsonSchemaResult.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoJsonSchemaResult.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoJsonSchemaResult.java",
        "chunk_id": "MongoJsonSchemaResult_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.util.List;\n<line_number-20>import java.util.Map;\n<line_number-21>\n<line_number-22>public class MongoJsonSchemaResult {\n<line_number-23>    public int ok;\n<line_number-24>    public Map<String, String> metadata;\n<line_number-25>    public MongoVersionedJsonSchema schema;\n<line_number-26>    public List<List<String>> selectOrder;\n<line_number-27>}\n",
        "comments": [
          {
            "comment_code_range": "22-27",
            "comment_linenumber": "21",
            "comment": "Represents the result of a MongoDB JSON schema operation, encapsulating status, metadata, schema details, and selection order.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "23-23",
            "comment_linenumber": "22",
            "comment": "Indicates the success status of the operation, where 1 means success and 0 means failure.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "24-24",
            "comment_linenumber": "23",
            "comment": "Contains metadata related to the JSON schema operation, represented as key-value pairs.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "25-25",
            "comment_linenumber": "24",
            "comment": "Holds the versioned JSON schema object that defines the structure of the data.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "26-26",
            "comment_linenumber": "25",
            "comment": "Specifies the order of selection for the fields in the JSON schema, represented as a list of lists.",
            "comment_kind": "field"
          }
        ],
        "structural_analysis": "The file 'MongoJsonSchemaResult.java' defines a single public class that encapsulates the result of a MongoDB JSON schema operation. It is part of the 'com.mongodb.jdbc' package, indicating its role in JDBC-related functionalities for MongoDB. The class contains four public fields: 'ok', which is an integer indicating the success status of the operation; 'metadata', a map that holds additional information about the operation; 'schema', which is an instance of 'MongoVersionedJsonSchema' representing the actual schema; and 'selectOrder', a list of lists that defines the order in which fields are selected. The class does not contain any methods or constructors, suggesting it is a simple data structure used for transferring data.",
        "file_summary": "This file defines the 'MongoJsonSchemaResult' class, which serves as a data structure to represent the outcome of a JSON schema operation in MongoDB, including its success status, associated metadata, the schema itself, and the order of selected fields."
      }
    ]
  },
  "MongoListTablesResult.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoListTablesResult.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoListTablesResult.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoListTablesResult.java",
        "chunk_id": "MongoListTablesResult_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>public class MongoListTablesResult {\n<line_number-20>    public static final String TABLE = \"table\";\n<line_number-21>    public static final String COLLECTION = \"collection\";\n<line_number-22>\n<line_number-23>    public String name;\n<line_number-24>    public String type;\n<line_number-25>\n<line_number-26>    public void setType(String type) {\n<line_number-27>        // If mongodb type is COLLECTION, map it as TABLE.\n<line_number-28>        // Otherwise, keep the type as is.\n<line_number-29>        this.type = type.equalsIgnoreCase(COLLECTION) ? TABLE : type;\n<line_number-30>    }\n<line_number-31>}\n",
        "comments": [
          {
            "comment_code_range": "19-31",
            "comment_linenumber": "18",
            "comment": "Represents the result of a MongoDB list tables operation, encapsulating table name and type.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "26-30",
            "comment_linenumber": "25",
            "comment": "Sets the type of the table; maps 'collection' to 'table' for consistency.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoListTablesResult.java' is part of the 'com.mongodb.jdbc' package and serves as a data structure to represent the result of a MongoDB operation that lists tables. It follows a simple object-oriented design pattern, encapsulating properties related to tables in MongoDB. The primary class, 'MongoListTablesResult', contains two static final string constants for 'table' and 'collection', which are used to standardize the representation of table types. The class has two public fields, 'name' and 'type', which store the name of the table and its type, respectively. The method 'setType' is responsible for setting the type of the table, with a specific mapping logic that converts 'collection' to 'table'. This class does not implement any interfaces or extend any other classes, indicating it is a standalone data structure. There are no constructors defined, implying default initialization of fields. The method 'setType' includes a conditional operation to ensure that the type is set correctly based on the input value, demonstrating basic business logic for type handling.",
        "file_summary": "This file defines the 'MongoListTablesResult' class, which models the result of a MongoDB operation that lists tables, including their names and types. It provides a method to set the type of the table with specific mapping logic for MongoDB collections."
      }
    ]
  },
  "MongoPreparedStatement.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoPreparedStatement.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoPreparedStatement.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoPreparedStatement.java",
        "chunk_id": "MongoPreparedStatement_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import com.mongodb.jdbc.logging.AutoLoggable;\n<line_number-20>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-21>import java.io.InputStream;\n<line_number-22>import java.io.Reader;\n<line_number-23>import java.math.BigDecimal;\n<line_number-24>import java.net.URL;\n<line_number-25>import java.sql.Array;\n<line_number-26>import java.sql.Blob;\n<line_number-27>import java.sql.Clob;\n<line_number-28>import java.sql.Connection;\n<line_number-29>import java.sql.Date;\n<line_number-30>import java.sql.NClob;\n<line_number-31>import java.sql.ParameterMetaData;\n<line_number-32>import java.sql.PreparedStatement;\n<line_number-33>import java.sql.Ref;\n<line_number-34>import java.sql.ResultSet;\n<line_number-35>import java.sql.ResultSetMetaData;\n<line_number-36>import java.sql.RowId;\n<line_number-37>import java.sql.SQLException;\n<line_number-38>import java.sql.SQLFeatureNotSupportedException;\n<line_number-39>import java.sql.SQLWarning;\n<line_number-40>import java.sql.SQLXML;\n<line_number-41>import java.sql.Time;\n<line_number-42>import java.sql.Timestamp;\n<line_number-43>import java.util.Calendar;\n<line_number-44>\n<line_number-45>@AutoLoggable\n<line_number-46>public class MongoPreparedStatement implements PreparedStatement {\n<line_number-47>    private String sql;\n<line_number-48>    private MongoStatement statement;\n<line_number-49>    protected MongoLogger logger;\n<line_number-50>\n<line_number-51>    public MongoPreparedStatement(String sql, MongoStatement statement) throws SQLException {\n<line_number-52>        this.logger =\n<line_number-53>                new MongoLogger(\n<line_number-54>                        this.getClass().getCanonicalName(),\n<line_number-55>                        statement.getParentLogger(),\n<line_number-56>                        statement.getStatementId());\n<line_number-57>        this.sql = sql;\n<line_number-58>        this.statement = statement;\n<line_number-59>    }\n<line_number-60>\n<line_number-61>    @Override\n<line_number-62>    public void addBatch() throws SQLException {\n<line_number-63>        throw new SQLFeatureNotSupportedException(\n<line_number-64>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-65>    }\n<line_number-66>\n<line_number-67>    @Override\n<line_number-68>    public void clearParameters() throws SQLException {\n<line_number-69>        throw new SQLFeatureNotSupportedException(\n<line_number-70>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-71>    }\n<line_number-72>\n<line_number-73>    @Override\n<line_number-74>    public boolean execute() throws SQLException {\n<line_number-75>        return statement.execute(sql);\n<line_number-76>    }\n<line_number-77>\n<line_number-78>    @Override\n<line_number-79>    public ResultSet executeQuery() throws SQLException {\n<line_number-80>        return statement.executeQuery(sql);\n<line_number-81>    }\n<line_number-82>\n<line_number-83>    @Override\n<line_number-84>    public ResultSet executeQuery(String sql) throws SQLException {\n<line_number-85>        return statement.executeQuery(sql);\n<line_number-86>    }\n<line_number-87>\n<line_number-88>    @Override\n<line_number-89>    public int executeUpdate() throws SQLException {\n<line_number-90>        return statement.executeUpdate(sql);\n<line_number-91>    }\n<line_number-92>\n<line_number-93>    @Override\n<line_number-94>    public int executeUpdate(String sql) throws SQLException {\n<line_number-95>        return statement.executeUpdate(sql);\n<line_number-96>    }\n<line_number-97>\n<line_number-98>    @Override\n<line_number-99>    public void close() throws SQLException {\n<line_number-100>        statement.close();\n<line_number-101>    }\n<line_number-102>\n<line_number-103>    @Override\n<line_number-104>    public int getMaxFieldSize() throws SQLException {\n<line_number-105>        return statement.getMaxFieldSize();\n<line_number-106>    }\n<line_number-107>\n<line_number-108>    @Override\n<line_number-109>    public void setMaxFieldSize(int max) throws SQLException {\n<line_number-110>        statement.setMaxFieldSize(max);\n<line_number-111>    }\n<line_number-112>\n<line_number-113>    @Override\n<line_number-114>    public int getMaxRows() throws SQLException {\n<line_number-115>        return statement.getMaxRows();\n<line_number-116>    }\n<line_number-117>\n<line_number-118>    @Override\n<line_number-119>    public void setMaxRows(int max) throws SQLException {\n<line_number-120>        statement.setMaxRows(max);\n<line_number-121>    }\n<line_number-122>\n<line_number-123>    @Override\n<line_number-124>    public void setEscapeProcessing(boolean enable) throws SQLException {\n<line_number-125>        statement.setEscapeProcessing(enable);\n<line_number-126>    }\n<line_number-127>\n<line_number-128>    @Override\n<line_number-129>    public int getQueryTimeout() throws SQLException {\n<line_number-130>        return statement.getQueryTimeout();\n<line_number-131>    }\n<line_number-132>\n<line_number-133>    @Override\n<line_number-134>    public void setQueryTimeout(int seconds) throws SQLException {\n<line_number-135>        statement.setQueryTimeout(seconds);\n<line_number-136>    }\n<line_number-137>\n<line_number-138>    @Override\n<line_number-139>    public void cancel() throws SQLException {\n<line_number-140>        statement.cancel();\n<line_number-141>    }\n<line_number-142>\n<line_number-143>    @Override\n<line_number-144>    public SQLWarning getWarnings() throws SQLException {\n<line_number-145>        return statement.getWarnings();\n<line_number-146>    }\n<line_number-147>\n<line_number-148>    @Override\n<line_number-149>    public void clearWarnings() throws SQLException {\n<line_number-150>        statement.clearWarnings();\n<line_number-151>    }\n<line_number-152>\n<line_number-153>    @Override\n<line_number-154>    public void setCursorName(String name) throws SQLException {\n<line_number-155>        statement.setCursorName(name);\n<line_number-156>    }\n<line_number-157>\n<line_number-158>    @Override\n<line_number-159>    public boolean execute(String sql) throws SQLException {\n<line_number-160>        return statement.execute(sql);\n<line_number-161>    }\n<line_number-162>\n<line_number-163>    @Override\n<line_number-164>    public ResultSet getResultSet() throws SQLException {\n<line_number-165>        return statement.getResultSet();\n<line_number-166>    }\n<line_number-167>\n<line_number-168>    @Override\n<line_number-169>    public int getUpdateCount() throws SQLException {\n<line_number-170>        return statement.getUpdateCount();\n<line_number-171>    }\n<line_number-172>\n<line_number-173>    @Override\n<line_number-174>    public boolean getMoreResults() throws SQLException {\n<line_number-175>        return statement.getMoreResults();\n<line_number-176>    }\n<line_number-177>\n<line_number-178>    @Override\n<line_number-179>    public void setFetchDirection(int direction) throws SQLException {\n<line_number-180>        statement.setFetchDirection(direction);\n<line_number-181>    }\n<line_number-182>\n<line_number-183>    @Override\n<line_number-184>    public int getFetchDirection() throws SQLException {\n<line_number-185>        return statement.getFetchDirection();\n<line_number-186>    }\n<line_number-187>\n<line_number-188>    @Override\n<line_number-189>    public void setFetchSize(int rows) throws SQLException {\n<line_number-190>        statement.setFetchSize(rows);\n<line_number-191>    }\n<line_number-192>\n<line_number-193>    @Override\n<line_number-194>    public int getFetchSize() throws SQLException {\n<line_number-195>        return statement.getFetchSize();\n<line_number-196>    }\n<line_number-197>\n<line_number-198>    @Override\n<line_number-199>    public int getResultSetConcurrency() throws SQLException {\n<line_number-200>        return statement.getResultSetConcurrency();\n<line_number-201>    }\n<line_number-202>\n<line_number-203>    @Override\n<line_number-204>    public int getResultSetType() throws SQLException {\n<line_number-205>        return statement.getResultSetType();\n<line_number-206>    }\n<line_number-207>\n<line_number-208>    @Override\n<line_number-209>    public void addBatch(String sql) throws SQLException {\n<line_number-210>        statement.addBatch(sql);\n<line_number-211>    }\n<line_number-212>\n<line_number-213>    @Override\n<line_number-214>    public void clearBatch() throws SQLException {\n<line_number-215>        statement.clearBatch();\n<line_number-216>    }\n<line_number-217>\n<line_number-218>    @Override\n<line_number-219>    public int[] executeBatch() throws SQLException {\n<line_number-220>        return statement.executeBatch();\n<line_number-221>    }\n<line_number-222>\n<line_number-223>    @Override\n<line_number-224>    public Connection getConnection() throws SQLException {\n<line_number-225>        return statement.getConnection();\n<line_number-226>    }\n<line_number-227>\n<line_number-228>    @Override\n<line_number-229>    public boolean getMoreResults(int current) throws SQLException {\n<line_number-230>        return statement.getMoreResults(current);\n<line_number-231>    }\n<line_number-232>\n<line_number-233>    @Override\n<line_number-234>    public ResultSet getGeneratedKeys() throws SQLException {\n<line_number-235>        return statement.getGeneratedKeys();\n<line_number-236>    }\n<line_number-237>\n<line_number-238>    @Override\n<line_number-239>    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {\n<line_number-240>        return statement.executeUpdate(sql, autoGeneratedKeys);\n<line_number-241>    }\n<line_number-242>\n<line_number-243>    @Override\n<line_number-244>    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {\n<line_number-245>        return statement.executeUpdate(sql, columnIndexes);\n<line_number-246>    }\n<line_number-247>\n<line_number-248>    @Override\n<line_number-249>    public int executeUpdate(String sql, String[] columnNames) throws SQLException {\n<line_number-250>        return statement.executeUpdate(sql, columnNames);\n<line_number-251>    }\n<line_number-252>\n<line_number-253>    @Override\n<line_number-254>    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {\n<line_number-255>        return statement.execute(sql, autoGeneratedKeys);\n<line_number-256>    }\n<line_number-257>\n<line_number-258>    @Override\n<line_number-259>    public boolean execute(String sql, int[] columnIndexes) throws SQLException {\n<line_number-260>        return statement.execute(sql, columnIndexes);\n<line_number-261>    }\n<line_number-262>\n<line_number-263>    @Override\n<line_number-264>    public boolean execute(String sql, String[] columnNames) throws SQLException {\n<line_number-265>        return statement.execute(sql, columnNames);\n<line_number-266>    }\n<line_number-267>\n<line_number-268>    @Override\n<line_number-269>    public int getResultSetHoldability() throws SQLException {\n<line_number-270>        return statement.getResultSetHoldability();\n<line_number-271>    }\n<line_number-272>\n<line_number-273>    @Override\n<line_number-274>    public boolean isClosed() throws SQLException {\n<line_number-275>        return statement.isClosed();\n<line_number-276>    }\n<line_number-277>\n<line_number-278>    @Override\n<line_number-279>    public void setPoolable(boolean poolable) throws SQLException {\n<line_number-280>        statement.setPoolable(poolable);\n<line_number-281>    }\n<line_number-282>\n<line_number-283>    @Override\n<line_number-284>    public boolean isPoolable() throws SQLException {\n<line_number-285>        return statement.isPoolable();\n<line_number-286>    }\n<line_number-287>\n<line_number-288>    @Override\n<line_number-289>    public void closeOnCompletion() throws SQLException {\n<line_number-290>        statement.closeOnCompletion();\n<line_number-291>    }\n<line_number-292>\n<line_number-293>    @Override\n<line_number-294>    public boolean isCloseOnCompletion() throws SQLException {\n<line_number-295>        return statement.isCloseOnCompletion();\n<line_number-296>    }\n<line_number-297>\n<line_number-298>    @Override\n<line_number-299>    public ResultSetMetaData getMetaData() throws SQLException {\n<line_number-300>        // This is not an efficient way to do this... at all.\n<line_number-301>        ResultSet rs = executeQuery(\"select * from (\" + sql + \") orig_query limit 1\");\n<line_number-302>        return rs.getMetaData();\n<line_number-303>    }\n<line_number-304>\n<line_number-305>    // Supporting any of these set methods will require adding that functionality to ADF or\n<line_number-306>    // having a SQL parser in Java.\n<line_number-307>    @Override\n<line_number-308>    public ParameterMetaData getParameterMetaData() throws SQLException {\n<line_number-309>        throw new SQLFeatureNotSupportedException(\n<line_number-310>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-311>    }\n<line_number-312>\n<line_number-313>    @Override\n<line_number-314>    public void setArray(int parameterIndex, Array x) throws SQLException {\n<line_number-315>        throw new SQLFeatureNotSupportedException(\n<line_number-316>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-317>    }\n<line_number-318>\n<line_number-319>    @Override\n<line_number-320>    public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {\n<line_number-321>        throw new SQLFeatureNotSupportedException(\n<line_number-322>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-323>    }\n<line_number-324>\n<line_number-325>    @Override\n<line_number-326>    public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {\n<line_number-327>        throw new SQLFeatureNotSupportedException(\n<line_number-328>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-329>    }\n<line_number-330>\n<line_number-331>    @Override\n<line_number-332>    public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {\n<line_number-333>        throw new SQLFeatureNotSupportedException(\n<line_number-334>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-335>    }\n<line_number-336>\n<line_number-337>    @Override\n<line_number-338>    public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {\n<line_number-339>        throw new SQLFeatureNotSupportedException(\n<line_number-340>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-341>    }\n<line_number-342>\n<line_number-343>    @Override\n<line_number-344>    public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {\n<line_number-345>        throw new SQLFeatureNotSupportedException(\n<line_number-346>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-347>    }\n<line_number-348>\n<line_number-349>    @Override\n<line_number-350>    public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {\n<line_number-351>        throw new SQLFeatureNotSupportedException(\n<line_number-352>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-353>    }\n<line_number-354>\n<line_number-355>    @Override\n<line_number-356>    public void setBinaryStream(int parameterIndex, InputStream x, long length)\n<line_number-357>            throws SQLException {\n<line_number-358>        throw new SQLFeatureNotSupportedException(\n<line_number-359>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-360>    }\n<line_number-361>\n<line_number-362>    @Override\n<line_number-363>    public void setBlob(int parameterIndex, Blob x) throws SQLException {\n<line_number-364>        throw new SQLFeatureNotSupportedException(\n<line_number-365>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-366>    }\n<line_number-367>\n<line_number-368>    @Override\n<line_number-369>    public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {\n<line_number-370>        throw new SQLFeatureNotSupportedException(\n<line_number-371>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-372>    }\n<line_number-373>\n<line_number-374>    @Override\n<line_number-375>    public void setBlob(int parameterIndex, InputStream inputStream, long length)\n<line_number-376>            throws SQLException {\n<line_number-377>        throw new SQLFeatureNotSupportedException(\n<line_number-378>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-379>    }\n<line_number-380>\n<line_number-381>    @Override\n<line_number-382>    public void setBoolean(int parameterIndex, boolean x) throws SQLException {\n<line_number-383>        throw new SQLFeatureNotSupportedException(\n<line_number-384>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-385>    }\n<line_number-386>\n<line_number-387>    @Override\n<line_number-388>    public void setByte(int parameterIndex, byte x) throws SQLException {\n<line_number-389>        throw new SQLFeatureNotSupportedException(\n<line_number-390>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-391>    }\n<line_number-392>\n<line_number-393>    @Override\n<line_number-394>    public void setBytes(int parameterIndex, byte[] x) throws SQLException {\n<line_number-395>        throw new SQLFeatureNotSupportedException(\n<line_number-396>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-397>    }\n<line_number-398>\n<line_number-399>    @Override\n<line_number-400>    public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {\n<line_number-401>        throw new SQLFeatureNotSupportedException(\n<line_number-402>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-403>    }\n<line_number-404>\n<line_number-405>    @Override\n<line_number-406>    public void setCharacterStream(int parameterIndex, Reader reader, int length)\n<line_number-407>            throws SQLException {\n<line_number-408>        throw new SQLFeatureNotSupportedException(\n<line_number-409>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-410>    }\n<line_number-411>\n<line_number-412>    @Override\n<line_number-413>    public void setCharacterStream(int parameterIndex, Reader reader, long length)\n<line_number-414>            throws SQLException {\n<line_number-415>        throw new SQLFeatureNotSupportedException(\n<line_number-416>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-417>    }\n<line_number-418>\n<line_number-419>    @Override\n<line_number-420>    public void setClob(int parameterIndex, Clob x) throws SQLException {\n<line_number-421>        throw new SQLFeatureNotSupportedException(\n<line_number-422>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-423>    }\n<line_number-424>\n<line_number-425>    @Override\n<line_number-426>    public void setClob(int parameterIndex, Reader reader) throws SQLException {\n<line_number-427>        throw new SQLFeatureNotSupportedException(\n<line_number-428>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-429>    }\n<line_number-430>\n<line_number-431>    @Override\n<line_number-432>    public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {\n<line_number-433>        throw new SQLFeatureNotSupportedException(\n<line_number-434>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-435>    }\n<line_number-436>\n<line_number-437>    @Override\n<line_number-438>    public void setDate(int parameterIndex, Date x) throws SQLException {\n<line_number-439>        throw new SQLFeatureNotSupportedException(\n<line_number-440>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-441>    }\n<line_number-442>\n<line_number-443>    @Override\n<line_number-444>    public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {\n<line_number-445>        throw new SQLFeatureNotSupportedException(\n<line_number-446>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-447>    }\n<line_number-448>\n<line_number-449>    @Override\n<line_number-450>    public void setDouble(int parameterIndex, double x) throws SQLException {\n<line_number-451>        throw new SQLFeatureNotSupportedException(\n<line_number-452>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-453>    }\n<line_number-454>\n<line_number-455>    @Override\n<line_number-456>    public void setFloat(int parameterIndex, float x) throws SQLException {\n<line_number-457>        throw new SQLFeatureNotSupportedException(\n<line_number-458>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-459>    }\n<line_number-460>\n<line_number-461>    @Override\n<line_number-462>    public void setInt(int parameterIndex, int x) throws SQLException {\n<line_number-463>        throw new SQLFeatureNotSupportedException(\n<line_number-464>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-465>    }\n<line_number-466>\n<line_number-467>    @Override\n<line_number-468>    public void setLong(int parameterIndex, long x) throws SQLException {\n<line_number-469>        throw new SQLFeatureNotSupportedException(\n<line_number-470>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-471>    }\n<line_number-472>\n<line_number-473>    @Override\n<line_number-474>    public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {\n<line_number-475>        throw new SQLFeatureNotSupportedException(\n<line_number-476>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-477>    }\n<line_number-478>\n<line_number-479>    @Override\n<line_number-480>    public void setNCharacterStream(int parameterIndex, Reader value, long length)\n<line_number-481>            throws SQLException {\n<line_number-482>        throw new SQLFeatureNotSupportedException(\n<line_number-483>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-484>    }\n<line_number-485>\n<line_number-486>    @Override\n<line_number-487>    public void setNClob(int parameterIndex, NClob value) throws SQLException {\n<line_number-488>        throw new SQLFeatureNotSupportedException(\n<line_number-489>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-490>    }\n<line_number-491>\n<line_number-492>    @Override\n<line_number-493>    public void setNClob(int parameterIndex, Reader reader) throws SQLException {\n<line_number-494>        throw new SQLFeatureNotSupportedException(\n<line_number-495>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-496>    }\n<line_number-497>\n<line_number-498>    @Override\n<line_number-499>    public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {\n<line_number-500>        throw new SQLFeatureNotSupportedException(\n<line_number-501>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-502>    }\n<line_number-503>\n<line_number-504>    @Override\n<line_number-505>    public void setNString(int parameterIndex, String value) throws SQLException {\n<line_number-506>        throw new SQLFeatureNotSupportedException(\n<line_number-507>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-508>    }\n<line_number-509>\n<line_number-510>    @Override\n<line_number-511>    public void setNull(int parameterIndex, int sqlType) throws SQLException {\n<line_number-512>        throw new SQLFeatureNotSupportedException(\n<line_number-513>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-514>    }\n<line_number-515>\n<line_number-516>    @Override\n<line_number-517>    public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException {\n<line_number-518>        throw new SQLFeatureNotSupportedException(\n<line_number-519>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-520>    }\n<line_number-521>\n<line_number-522>    @Override\n<line_number-523>    public void setObject(int parameterIndex, Object x) throws SQLException {\n<line_number-524>        throw new SQLFeatureNotSupportedException(\n<line_number-525>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-526>    }\n<line_number-527>\n<line_number-528>    @Override\n<line_number-529>    public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {\n<line_number-530>        throw new SQLFeatureNotSupportedException(\n<line_number-531>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-532>    }\n<line_number-533>\n<line_number-534>    @Override\n<line_number-535>    public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength)\n<line_number-536>            throws SQLException {\n<line_number-537>        throw new SQLFeatureNotSupportedException(\n<line_number-538>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-539>    }\n<line_number-540>\n<line_number-541>    @Override\n<line_number-542>    public void setRef(int parameterIndex, Ref x) throws SQLException {\n<line_number-543>        throw new SQLFeatureNotSupportedException(\n<line_number-544>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-545>    }\n<line_number-546>\n<line_number-547>    @Override\n<line_number-548>    public void setRowId(int parameterIndex, RowId x) throws SQLException {\n<line_number-549>        throw new SQLFeatureNotSupportedException(\n<line_number-550>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-551>    }\n<line_number-552>\n<line_number-553>    @Override\n<line_number-554>    public void setShort(int parameterIndex, short x) throws SQLException {\n<line_number-555>        throw new SQLFeatureNotSupportedException(\n<line_number-556>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-557>    }\n<line_number-558>\n<line_number-559>    @Override\n<line_number-560>    public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {\n<line_number-561>        throw new SQLFeatureNotSupportedException(\n<line_number-562>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-563>    }\n<line_number-564>\n<line_number-565>    @Override\n<line_number-566>    public void setString(int parameterIndex, String x) throws SQLException {\n<line_number-567>        throw new SQLFeatureNotSupportedException(\n<line_number-568>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-569>    }\n<line_number-570>\n<line_number-571>    @Override\n<line_number-572>    public void setTime(int parameterIndex, Time x) throws SQLException {\n<line_number-573>        throw new SQLFeatureNotSupportedException(\n<line_number-574>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-575>    }\n<line_number-576>\n<line_number-577>    @Override\n<line_number-578>    public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {\n<line_number-579>        throw new SQLFeatureNotSupportedException(\n<line_number-580>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-581>    }\n<line_number-582>\n<line_number-583>    @Override\n<line_number-584>    public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {\n<line_number-585>        throw new SQLFeatureNotSupportedException(\n<line_number-586>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-587>    }\n<line_number-588>\n<line_number-589>    @Override\n<line_number-590>    public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {\n<line_number-591>        throw new SQLFeatureNotSupportedException(\n<line_number-592>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-593>    }\n<line_number-594>\n<line_number-595>    @Override\n<line_number-596>    @Deprecated\n<line_number-597>    public void setUnicodeStream(int parameterIndex, InputStream x, int length)\n<line_number-598>            throws SQLException {\n<line_number-599>        throw new SQLFeatureNotSupportedException(\n<line_number-600>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-601>    }\n<line_number-602>\n<line_number-603>    @Override\n<line_number-604>    public void setURL(int parameterIndex, URL x) throws SQLException {\n<line_number-605>        throw new SQLFeatureNotSupportedException(\n<line_number-606>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-607>    }\n<line_number-608>\n<line_number-609>    // java.sql.Wrapper impl\n<line_number-610>    @Override\n<line_number-611>    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n<line_number-612>        return iface.isInstance(this);\n<line_number-613>    }\n<line_number-614>\n<line_number-615>    @SuppressWarnings(\"unchecked\")\n<line_number-616>    @Override\n<line_number-617>    public <T> T unwrap(Class<T> iface) throws SQLException {\n<line_number-618>        return (T) this;\n<line_number-619>    }\n<line_number-620>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC components.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "45-46",
            "comment_linenumber": "44",
            "comment": "The MongoPreparedStatement class implements the PreparedStatement interface, providing methods to execute SQL statements against a MongoDB database.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "51-59",
            "comment_linenumber": "50",
            "comment": "Constructor initializes the MongoPreparedStatement with a SQL string and a MongoStatement, setting up logging.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "61-64",
            "comment_linenumber": "60",
            "comment": "Throws SQLFeatureNotSupportedException as batch operations are not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "67-70",
            "comment_linenumber": "66",
            "comment": "Throws SQLFeatureNotSupportedException as parameter clearing is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "73-75",
            "comment_linenumber": "72",
            "comment": "Executes the SQL statement and returns a boolean indicating success.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "78-81",
            "comment_linenumber": "77",
            "comment": "Executes the SQL query and returns a ResultSet containing the results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "84-86",
            "comment_linenumber": "83",
            "comment": "Executes the provided SQL query and returns a ResultSet.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "89-91",
            "comment_linenumber": "88",
            "comment": "Executes an update statement and returns the number of affected rows.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "94-96",
            "comment_linenumber": "93",
            "comment": "Executes an update with the provided SQL and returns the number of affected rows.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "98-100",
            "comment_linenumber": "97",
            "comment": "Closes the statement associated with this prepared statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "103-106",
            "comment_linenumber": "102",
            "comment": "Returns the maximum field size for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "109-111",
            "comment_linenumber": "108",
            "comment": "Sets the maximum field size for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "113-116",
            "comment_linenumber": "112",
            "comment": "Returns the maximum number of rows for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "119-121",
            "comment_linenumber": "118",
            "comment": "Sets the maximum number of rows for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "123-126",
            "comment_linenumber": "122",
            "comment": "Sets whether escape processing is enabled for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "128-131",
            "comment_linenumber": "127",
            "comment": "Returns the query timeout for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "134-136",
            "comment_linenumber": "133",
            "comment": "Sets the query timeout for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "138-140",
            "comment_linenumber": "137",
            "comment": "Cancels the execution of this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "143-146",
            "comment_linenumber": "142",
            "comment": "Returns any SQL warnings associated with this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "149-151",
            "comment_linenumber": "148",
            "comment": "Clears any SQL warnings for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "154-156",
            "comment_linenumber": "153",
            "comment": "Sets the cursor name for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "159-161",
            "comment_linenumber": "158",
            "comment": "Executes the provided SQL statement and returns a boolean indicating success.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "164-166",
            "comment_linenumber": "163",
            "comment": "Returns the current ResultSet for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "168-170",
            "comment_linenumber": "167",
            "comment": "Returns the update count for the last executed statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "173-175",
            "comment_linenumber": "172",
            "comment": "Checks if there are more results available.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "178-181",
            "comment_linenumber": "177",
            "comment": "Sets the fetch direction for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "184-186",
            "comment_linenumber": "183",
            "comment": "Returns the fetch direction for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "189-191",
            "comment_linenumber": "188",
            "comment": "Sets the fetch size for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "194-196",
            "comment_linenumber": "193",
            "comment": "Returns the fetch size for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "199-201",
            "comment_linenumber": "198",
            "comment": "Returns the concurrency type for the ResultSet.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "204-206",
            "comment_linenumber": "203",
            "comment": "Returns the type of ResultSet for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "208-210",
            "comment_linenumber": "207",
            "comment": "Adds a SQL statement to the batch for execution.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "213-215",
            "comment_linenumber": "212",
            "comment": "Clears the batch of SQL statements.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "219-221",
            "comment_linenumber": "218",
            "comment": "Executes the batch of SQL statements and returns an array of update counts.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "224-226",
            "comment_linenumber": "223",
            "comment": "Returns the connection associated with this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "229-231",
            "comment_linenumber": "228",
            "comment": "Returns whether there are more results available based on the current result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "234-236",
            "comment_linenumber": "233",
            "comment": "Returns the generated keys from the last executed statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "239-241",
            "comment_linenumber": "238",
            "comment": "Executes an update statement with auto-generated keys and returns the count.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "244-246",
            "comment_linenumber": "243",
            "comment": "Executes an update statement with specified column indexes and returns the count.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "249-251",
            "comment_linenumber": "248",
            "comment": "Executes an update statement with specified column names and returns the count.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "254-256",
            "comment_linenumber": "253",
            "comment": "Executes the provided SQL statement with auto-generated keys and returns a boolean indicating success.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "259-261",
            "comment_linenumber": "258",
            "comment": "Executes the provided SQL statement with specified column indexes and returns a boolean indicating success.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "264-266",
            "comment_linenumber": "263",
            "comment": "Executes the provided SQL statement with specified column names and returns a boolean indicating success.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "268-270",
            "comment_linenumber": "267",
            "comment": "Returns the holdability of the ResultSet.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "273-275",
            "comment_linenumber": "272",
            "comment": "Checks if this statement is closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "278-280",
            "comment_linenumber": "277",
            "comment": "Sets whether this statement is poolable.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "283-285",
            "comment_linenumber": "282",
            "comment": "Checks if this statement is poolable.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "288-290",
            "comment_linenumber": "287",
            "comment": "Marks this statement to close on completion.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "293-295",
            "comment_linenumber": "292",
            "comment": "Checks if this statement is set to close on completion.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "298-302",
            "comment_linenumber": "297",
            "comment": "Retrieves metadata about the ResultSet, executing a query to obtain it.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "305-306",
            "comment_linenumber": "304",
            "comment": "Notes that supporting set methods requires additional functionality in ADF or a SQL parser.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "308-310",
            "comment_linenumber": "307",
            "comment": "Throws SQLFeatureNotSupportedException as parameter metadata retrieval is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "313-316",
            "comment_linenumber": "312",
            "comment": "Throws SQLFeatureNotSupportedException as setting an array parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "320-322",
            "comment_linenumber": "319",
            "comment": "Throws SQLFeatureNotSupportedException as setting an ASCII stream parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "325-328",
            "comment_linenumber": "324",
            "comment": "Throws SQLFeatureNotSupportedException as setting an ASCII stream parameter with length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "331-334",
            "comment_linenumber": "330",
            "comment": "Throws SQLFeatureNotSupportedException as setting an ASCII stream parameter with long length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "337-340",
            "comment_linenumber": "336",
            "comment": "Throws SQLFeatureNotSupportedException as setting a BigDecimal parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "343-346",
            "comment_linenumber": "342",
            "comment": "Throws SQLFeatureNotSupportedException as setting a binary stream parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "349-352",
            "comment_linenumber": "348",
            "comment": "Throws SQLFeatureNotSupportedException as setting a binary stream parameter with length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "355-358",
            "comment_linenumber": "354",
            "comment": "Throws SQLFeatureNotSupportedException as setting a binary stream parameter with long length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "361-364",
            "comment_linenumber": "360",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Blob parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "368-371",
            "comment_linenumber": "367",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Blob parameter from an InputStream is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "374-377",
            "comment_linenumber": "373",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Blob parameter from an InputStream with long length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "381-384",
            "comment_linenumber": "380",
            "comment": "Throws SQLFeatureNotSupportedException as setting a boolean parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "387-390",
            "comment_linenumber": "386",
            "comment": "Throws SQLFeatureNotSupportedException as setting a byte parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "393-396",
            "comment_linenumber": "392",
            "comment": "Throws SQLFeatureNotSupportedException as setting byte array parameters is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "400-403",
            "comment_linenumber": "399",
            "comment": "Throws SQLFeatureNotSupportedException as setting a character stream parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "406-409",
            "comment_linenumber": "405",
            "comment": "Throws SQLFeatureNotSupportedException as setting a character stream parameter with length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "412-415",
            "comment_linenumber": "411",
            "comment": "Throws SQLFeatureNotSupportedException as setting a character stream parameter with long length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "419-422",
            "comment_linenumber": "418",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Clob parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "425-428",
            "comment_linenumber": "424",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Clob parameter from a Reader is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "431-434",
            "comment_linenumber": "430",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Clob parameter from a Reader with long length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "437-440",
            "comment_linenumber": "436",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Date parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "443-446",
            "comment_linenumber": "442",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Date parameter with Calendar is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "449-452",
            "comment_linenumber": "448",
            "comment": "Throws SQLFeatureNotSupportedException as setting a double parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "455-458",
            "comment_linenumber": "454",
            "comment": "Throws SQLFeatureNotSupportedException as setting a float parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "461-464",
            "comment_linenumber": "460",
            "comment": "Throws SQLFeatureNotSupportedException as setting an int parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "467-470",
            "comment_linenumber": "466",
            "comment": "Throws SQLFeatureNotSupportedException as setting a long parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "473-476",
            "comment_linenumber": "472",
            "comment": "Throws SQLFeatureNotSupportedException as setting a NCharacterStream parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "479-482",
            "comment_linenumber": "478",
            "comment": "Throws SQLFeatureNotSupportedException as setting a NCharacterStream parameter with long length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "487-489",
            "comment_linenumber": "486",
            "comment": "Throws SQLFeatureNotSupportedException as setting a NClob parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "493-495",
            "comment_linenumber": "492",
            "comment": "Throws SQLFeatureNotSupportedException as setting a NClob parameter from a Reader is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "499-501",
            "comment_linenumber": "498",
            "comment": "Throws SQLFeatureNotSupportedException as setting a NClob parameter from a Reader with long length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "505-507",
            "comment_linenumber": "504",
            "comment": "Throws SQLFeatureNotSupportedException as setting a NString parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "511-513",
            "comment_linenumber": "510",
            "comment": "Throws SQLFeatureNotSupportedException as setting a null parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "517-519",
            "comment_linenumber": "516",
            "comment": "Throws SQLFeatureNotSupportedException as setting a null parameter with type name is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "523-525",
            "comment_linenumber": "522",
            "comment": "Throws SQLFeatureNotSupportedException as setting an object parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "528-531",
            "comment_linenumber": "527",
            "comment": "Throws SQLFeatureNotSupportedException as setting an object parameter with target SQL type is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "534-537",
            "comment_linenumber": "533",
            "comment": "Throws SQLFeatureNotSupportedException as setting an object parameter with target SQL type and scale or length is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "541-544",
            "comment_linenumber": "540",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Ref parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "547-550",
            "comment_linenumber": "546",
            "comment": "Throws SQLFeatureNotSupportedException as setting a RowId parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "553-556",
            "comment_linenumber": "552",
            "comment": "Throws SQLFeatureNotSupportedException as setting a short parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "559-562",
            "comment_linenumber": "558",
            "comment": "Throws SQLFeatureNotSupportedException as setting a SQLXML parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "565-568",
            "comment_linenumber": "564",
            "comment": "Throws SQLFeatureNotSupportedException as setting a String parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "571-574",
            "comment_linenumber": "570",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Time parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "577-580",
            "comment_linenumber": "576",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Time parameter with Calendar is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "583-586",
            "comment_linenumber": "582",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Timestamp parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "589-592",
            "comment_linenumber": "588",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Timestamp parameter with Calendar is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "595-600",
            "comment_linenumber": "594",
            "comment": "Throws SQLFeatureNotSupportedException as setting a Unicode stream parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "603-606",
            "comment_linenumber": "602",
            "comment": "Throws SQLFeatureNotSupportedException as setting a URL parameter is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "609-613",
            "comment_linenumber": "608",
            "comment": "Implements the Wrapper interface to check if this instance is a wrapper for a given interface.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "617-619",
            "comment_linenumber": "616",
            "comment": "Unwraps this instance as the specified interface type.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoPreparedStatement.java' defines the MongoPreparedStatement class, which implements the PreparedStatement interface for MongoDB JDBC operations. It serves as a bridge between SQL commands and MongoDB's execution model, allowing users to prepare and execute SQL statements. The class is annotated with @AutoLoggable for logging purposes. It contains a constructor that initializes the SQL string and a MongoStatement instance, which is responsible for executing the SQL commands. Most methods in this class delegate their functionality to the MongoStatement instance, throwing SQLFeatureNotSupportedException for unsupported operations. The class maintains a logger for tracking operations and errors. It provides methods for executing queries, updates, and managing statement properties, but does not support batch operations or parameter setting methods, which are common in traditional JDBC implementations. The class is designed to be used in a multi-threaded environment, ensuring that logging and statement execution are handled appropriately.",
        "file_summary": "The MongoPreparedStatement class provides an implementation of the PreparedStatement interface for executing SQL statements against a MongoDB database. It allows for query execution and result retrieval while logging operations, but does not support batch processing or many parameter-setting methods typical in standard JDBC implementations."
      }
    ]
  },
  "MongoResultSet.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoResultSet.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoResultSet.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoResultSet.java",
        "chunk_id": "MongoResultSet_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import com.google.common.base.Preconditions;\n<line_number-20>import com.mongodb.client.MongoCursor;\n<line_number-21>import com.mongodb.jdbc.logging.AutoLoggable;\n<line_number-22>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-23>import java.io.ByteArrayInputStream;\n<line_number-24>import java.io.InputStream;\n<line_number-25>import java.io.Reader;\n<line_number-26>import java.io.UnsupportedEncodingException;\n<line_number-27>import java.math.BigDecimal;\n<line_number-28>import java.sql.Array;\n<line_number-29>import java.sql.Blob;\n<line_number-30>import java.sql.Clob;\n<line_number-31>import java.sql.Date;\n<line_number-32>import java.sql.NClob;\n<line_number-33>import java.sql.Ref;\n<line_number-34>import java.sql.ResultSet;\n<line_number-35>import java.sql.ResultSetMetaData;\n<line_number-36>import java.sql.RowId;\n<line_number-37>import java.sql.SQLException;\n<line_number-38>import java.sql.SQLFeatureNotSupportedException;\n<line_number-39>import java.sql.SQLType;\n<line_number-40>import java.sql.SQLWarning;\n<line_number-41>import java.sql.SQLXML;\n<line_number-42>import java.sql.Statement;\n<line_number-43>import java.sql.Time;\n<line_number-44>import java.sql.Timestamp;\n<line_number-45>import java.sql.Types;\n<line_number-46>import java.text.ParseException;\n<line_number-47>import java.text.SimpleDateFormat;\n<line_number-48>import java.util.Calendar;\n<line_number-49>import java.util.List;\n<line_number-50>import java.util.Objects;\n<line_number-51>import java.util.TimeZone;\n<line_number-52>import java.util.logging.Level;\n<line_number-53>import javax.sql.rowset.serial.SerialBlob;\n<line_number-54>import javax.sql.rowset.serial.SerialClob;\n<line_number-55>import javax.sql.rowset.serial.SerialException;\n<line_number-56>import org.bson.BsonBinary;\n<line_number-57>import org.bson.BsonBinarySubType;\n<line_number-58>import org.bson.BsonDocument;\n<line_number-59>import org.bson.BsonType;\n<line_number-60>import org.bson.BsonValue;\n<line_number-61>import org.bson.UuidRepresentation;\n<line_number-62>import org.bson.internal.UuidHelper;\n<line_number-63>import org.bson.types.Decimal128;\n<line_number-64>\n<line_number-65>@AutoLoggable\n<line_number-66>public class MongoResultSet implements ResultSet {\n<line_number-67>    private static final TimeZone UTC = TimeZone.getTimeZone(\"UTC\");\n<line_number-68>\n<line_number-69>    // dateFormat cannot be static due to a threading bug in the library.\n<line_number-70>    protected SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n<line_number-71>\n<line_number-72>    // The current row\n<line_number-73>    protected BsonDocument current;\n<line_number-74>    // cursor over all rows\n<line_number-75>    protected MongoCursor<BsonDocument> cursor;\n<line_number-76>\n<line_number-77>    // The one-indexed number of the current row. Will be zero until\n<line_number-78>    // next() is called for the first time.\n<line_number-79>    protected int rowNum = 0;\n<line_number-80>\n<line_number-81>    protected boolean closed = false;\n<line_number-82>    protected MongoStatement statement;\n<line_number-83>    protected boolean wasNull = false;\n<line_number-84>    protected MongoResultSetMetaData rsMetaData;\n<line_number-85>    protected MongoLogger logger;\n<line_number-86>    // Boolean marker true if the JSON representation is Extended JSON. False otherwise.\n<line_number-87>    protected boolean extJsonMode;\n<line_number-88>    protected UuidRepresentation uuidRepresentation;\n<line_number-89>\n<line_number-90>    private MongoJsonSchema jsonSchema;\n<line_number-91>\n<line_number-92>    /**\n<line_number-93>     * Constructor for a MongoResultset tied to a connection and statement.\n<line_number-94>     *\n<line_number-95>     * @param statement The statement this resultset is related to.\n<line_number-96>     * @param cursor The resultset cursor.\n<line_number-97>     * @param resultSetchema The resultset schema.\n<line_number-98>     * @param selectOrder The select list order.\n<line_number-99>     * @param extJsonMode The JSON mode.\n<line_number-100>     * @throws SQLException\n<line_number-101>     */\n<line_number-102>    public MongoResultSet(\n<line_number-103>            MongoStatement statement,\n<line_number-104>            MongoCursor<BsonDocument> cursor,\n<line_number-105>            MongoJsonSchema resultSetchema,\n<line_number-106>            List<List<String>> selectOrder,\n<line_number-107>            boolean extJsonMode,\n<line_number-108>            UuidRepresentation uuidRepresentation)\n<line_number-109>            throws SQLException {\n<line_number-110>        Preconditions.checkNotNull(statement);\n<line_number-111>        this.statement = statement;\n<line_number-112>        this.logger =\n<line_number-113>                new MongoLogger(\n<line_number-114>                        this.getClass().getCanonicalName(),\n<line_number-115>                        statement.getParentLogger(),\n<line_number-116>                        statement.getStatementId());\n<line_number-117>        logger.setQueryDiagnostics(statement.getQueryDiagnostics());\n<line_number-118>        this.extJsonMode = extJsonMode;\n<line_number-119>        this.uuidRepresentation = uuidRepresentation;\n<line_number-120>        setUpResultset(\n<line_number-121>                cursor,\n<line_number-122>                resultSetchema,\n<line_number-123>                selectOrder,\n<line_number-124>                true,\n<line_number-125>                statement.getParentLogger(),\n<line_number-126>                statement.getStatementId());\n<line_number-127>    }\n<line_number-128>\n<line_number-129>    /**\n<line_number-130>     * Constructor for a MongoResultSet not tied to a statement used for MongoDatabaseMetaData.\n<line_number-131>     *\n<line_number-132>     * @param parentLogger The parent connection logger.\n<line_number-133>     * @param cursor The resultset cursor.\n<line_number-134>     * @param schema The resultset schema.\n<line_number-135>     * @throws SQLException\n<line_number-136>     */\n<line_number-137>    public MongoResultSet(\n<line_number-138>            MongoLogger parentLogger, MongoCursor<BsonDocument> cursor, MongoJsonSchema schema)\n<line_number-139>            throws SQLException {\n<line_number-140>        this.logger = new MongoLogger(this.getClass().getCanonicalName(), parentLogger);\n<line_number-141>        setUpResultset(cursor, schema, null, false, parentLogger, null);\n<line_number-142>    }\n<line_number-143>\n<line_number-144>    private void setUpResultset(\n<line_number-145>            MongoCursor<BsonDocument> cursor,\n<line_number-146>            MongoJsonSchema schema,\n<line_number-147>            List<List<String>> selectOrder,\n<line_number-148>            boolean sortFieldsAlphabetically,\n<line_number-149>            MongoLogger parentLogger,\n<line_number-150>            Integer statementId)\n<line_number-151>            throws SQLException {\n<line_number-152>        Preconditions.checkNotNull(cursor);\n<line_number-153>        this.jsonSchema = schema;\n<line_number-154>        // dateFormat is not thread safe, so we do not want to make it a static field.\n<line_number-155>        dateFormat.setTimeZone(UTC);\n<line_number-156>        // Only sort the columns alphabetically for SQL statement result sets and not for database metadata result sets.\n<line_number-157>        // The JDBC specification provides the order for each database metadata result set.\n<line_number-158>        // Because a lot BI tools will access database metadata columns by index, the specification order must be respected.\n<line_number-159>        this.cursor = cursor;\n<line_number-160>\n<line_number-161>        this.rsMetaData =\n<line_number-162>                new MongoResultSetMetaData(\n<line_number-163>                        schema,\n<line_number-164>                        selectOrder,\n<line_number-165>                        sortFieldsAlphabetically,\n<line_number-166>                        parentLogger,\n<line_number-167>                        statementId,\n<line_number-168>                        logger.getQueryDiagnostics());\n<line_number-169>    }\n<line_number-170>\n<line_number-171>    // This is only used for testing, and that is why it has package level access, and the\n<line_number-172>    // tests have been moved into this package.\n<line_number-173>    BsonDocument getCurrent() {\n<line_number-174>        return current;\n<line_number-175>    }\n<line_number-176>\n<line_number-177>    private void checkBounds(int i) throws SQLException {\n<line_number-178>        checkClosed();\n<line_number-179>        if (current == null) {\n<line_number-180>            throw new SQLException(\"No current row in the result set. Make sure to call next().\");\n<line_number-181>        }\n<line_number-182>        if (i > rsMetaData.getColumnCount()) {\n<line_number-183>            throw new SQLException(\"Index out of bounds: '\" + i + \"'.\");\n<line_number-184>        }\n<line_number-185>    }\n<line_number-186>\n<line_number-187>    @Override\n<line_number-188>    public boolean next() throws SQLException {\n<line_number-189>        checkClosed();\n<line_number-190>        try {\n<line_number-191>            boolean result;\n<line_number-192>            result = cursor.hasNext();\n<line_number-193>            logger.log(Level.FINER, \"cursor.hasNext()? \" + String.valueOf(result));\n<line_number-194>            if (result) {\n<line_number-195>                logger.log(Level.FINEST, \"Getting row \" + (rowNum + 1));\n<line_number-196>                long startTime = System.nanoTime();\n<line_number-197>                current = cursor.next();\n<line_number-198>                long endTime = System.nanoTime();\n<line_number-199>                logger.log(\n<line_number-200>                        Level.FINER,\n<line_number-201>                        \"Moved to next row in \"\n<line_number-202>                                + ((endTime - startTime) / 1000000d)\n<line_number-203>                                + \" milliseconds\");\n<line_number-204>                ++rowNum;\n<line_number-205>            }\n<line_number-206>            return result;\n<line_number-207>        } catch (Exception e) {\n<line_number-208>            throw new SQLException(e);\n<line_number-209>        }\n<line_number-210>    }\n<line_number-211>\n<line_number-212>    @Override\n<line_number-213>    public void close() throws SQLException {\n<line_number-214>        if (closed) {\n<line_number-215>            return;\n<line_number-216>        }\n<line_number-217>        cursor.close();\n<line_number-218>        closed = true;\n<line_number-219>        if (statement != null && !statement.isClosed && statement.isCloseOnCompletion()) {\n<line_number-220>            statement.close();\n<line_number-221>        }\n<line_number-222>    }\n<line_number-223>\n<line_number-224>    @Override\n<line_number-225>    public boolean isLast() throws SQLException {\n<line_number-226>        checkClosed();\n<line_number-227>        return !cursor.hasNext();\n<line_number-228>    }\n<line_number-229>\n<line_number-230>    private BsonValue getBsonValue(int columnIndex) throws SQLException {\n<line_number-231>        checkBounds(columnIndex);\n<line_number-232>        MongoColumnInfo columnInfo = rsMetaData.getColumnInfo(columnIndex);\n<line_number-233>        BsonDocument datasource = this.current.get(columnInfo.getTableName()).asDocument();\n<line_number-234>        return datasource.get(columnInfo.getColumnName());\n<line_number-235>    }\n<line_number-236>\n<line_number-237>    private BsonValue getBsonValue(String columnLabel) throws SQLException {\n<line_number-238>        int columnIndex;\n<line_number-239>        if (rsMetaData.hasColumnWithLabel(columnLabel)) {\n<line_number-240>            try {\n<line_number-241>                columnIndex = rsMetaData.getColumnPositionFromLabel(columnLabel);\n<line_number-242>                return getBsonValue(columnIndex + 1);\n<line_number-243>            } catch (Exception e) {\n<line_number-244>                throw new SQLException(e.getMessage());\n<line_number-245>            }\n<line_number-246>        } else {\n<line_number-247>            throw new SQLException(String.format(\"column label '%s' not found\", columnLabel));\n<line_number-248>        }\n<line_number-249>    }\n<line_number-250>\n<line_number-251>    private void checkClosed() throws SQLException {\n<line_number-252>        if (closed) throw new SQLException(\"MongoResultSet is closed.\");\n<line_number-253>    }\n<line_number-254>\n<line_number-255>    @Override\n<line_number-256>    public boolean wasNull() throws SQLException {\n<line_number-257>        checkClosed();\n<line_number-258>        return wasNull;\n<line_number-259>    }\n<line_number-260>\n<line_number-261>    /**\n<line_number-262>     * Returns true if the Object obj is null. Crucially, it also must set the value of `wasNull`,\n<line_number-263>     * since that is part of the JDBC API.\n<line_number-264>     *\n<line_number-265>     * @param obj the object to check.\n<line_number-266>     * @return true if the object is Null, False otherwise.\n<line_number-267>     */\n<line_number-268>    private boolean checkNull(BsonValue obj) throws SQLException {\n<line_number-269>        // reset wasNull from previous check.\n<line_number-270>        wasNull = false;\n<line_number-271>        if (obj == null) {\n<line_number-272>            wasNull = true;\n<line_number-273>            return true;\n<line_number-274>        }\n<line_number-275>        switch (BsonTypeInfo.getBsonTypeInfoFromBsonValue(obj).getBsonType()) {\n<line_number-276>            case NULL:\n<line_number-277>            case UNDEFINED:\n<line_number-278>                wasNull = true;\n<line_number-279>                return true;\n<line_number-280>        }\n<line_number-281>        return false;\n<line_number-282>    }\n<line_number-283>\n<line_number-284>    @Deprecated\n<line_number-285>    @Override\n<line_number-286>    public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {\n<line_number-287>        throw new SQLFeatureNotSupportedException(\n<line_number-288>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-289>    }\n<line_number-290>\n<line_number-291>    private byte[] handleBytesConversionFailure(String from) throws SQLException {\n<line_number-292>        throw new SQLException(\"The \" + from + \" type cannot be converted to blob.\");\n<line_number-293>    }\n<line_number-294>\n<line_number-295>    private byte[] getBytes(BsonValue o) throws SQLException {\n<line_number-296>        if (checkNull(o)) {\n<line_number-297>            return null;\n<line_number-298>        }\n<line_number-299>        // we only allow getting Strings and Binaries as Bytes so that\n<line_number-300>        // we can conveniently ignore Endianess issues. Null and undefined\n<line_number-301>        // are still supported because Bytes's can be null.\n<line_number-302>        BsonTypeInfo bsonType = BsonTypeInfo.getBsonTypeInfoFromBsonValue(o);\n<line_number-303>        switch (bsonType.getBsonType()) {\n<line_number-304>            case BINARY:\n<line_number-305>                return o.asBinary().getData();\n<line_number-306>            case NULL:\n<line_number-307>                return null;\n<line_number-308>            case UNDEFINED:\n<line_number-309>                // this is consistent with $convert in mongodb.\n<line_number-310>                return null;\n<line_number-311>            default:\n<line_number-312>                return handleBytesConversionFailure(bsonType.getBsonName());\n<line_number-313>        }\n<line_number-314>    }\n<line_number-315>\n<line_number-316>    @Override\n<line_number-317>    public byte[] getBytes(int columnIndex) throws SQLException {\n<line_number-318>        BsonValue out = getBsonValue(columnIndex);\n<line_number-319>        return getBytes(out);\n<line_number-320>    }\n<line_number-321>\n<line_number-322>    @Override\n<line_number-323>    public byte[] getBytes(String columnLabel) throws SQLException {\n<line_number-324>        BsonValue out = getBsonValue(columnLabel);\n<line_number-325>        return getBytes(out);\n<line_number-326>    }\n<line_number-327>\n<line_number-328>    protected static ByteArrayInputStream getNewByteArrayInputStream(byte[] bytes) {\n<line_number-329>        if (bytes == null) {\n<line_number-330>            return null;\n<line_number-331>        }\n<line_number-332>        return new ByteArrayInputStream(bytes);\n<line_number-333>    }\n<line_number-334>\n<line_number-335>    @Override\n<line_number-336>    public java.io.InputStream getAsciiStream(int columnIndex) throws SQLException {\n<line_number-337>        final String encoding = \"ASCII\";\n<line_number-338>        try {\n<line_number-339>            return getNewByteArrayInputStream(getString(columnIndex).getBytes(encoding));\n<line_number-340>        } catch (UnsupportedEncodingException e) {\n<line_number-341>            throw new SQLException(\"The JVM claims not to support the encoding: \" + encoding + \".\");\n<line_number-342>        }\n<line_number-343>    }\n<line_number-344>\n<line_number-345>    @Override\n<line_number-346>    public java.io.InputStream getAsciiStream(String columnLabel) throws SQLException {\n<line_number-347>        final String encoding = \"ASCII\";\n<line_number-348>        try {\n<line_number-349>            return getNewByteArrayInputStream(getString(columnLabel).getBytes(encoding));\n<line_number-350>        } catch (UnsupportedEncodingException e) {\n<line_number-351>            throw new SQLException(\"The JVM claims not to support the encoding: \" + encoding + \".\");\n<line_number-352>        }\n<line_number-353>    }\n<line_number-354>\n<line_number-355>    @Deprecated\n<line_number-356>    @Override\n<line_number-357>    public java.io.InputStream getUnicodeStream(int columnIndex) throws SQLException {\n<line_number-358>        final String encoding = \"UTF-8\";\n<line_number-359>        try {\n<line_number-360>            return getNewByteArrayInputStream(getString(columnIndex).getBytes(encoding));\n<line_number-361>        } catch (UnsupportedEncodingException e) {\n<line_number-362>            throw new SQLException(\"The JVM claims not to support the encoding: \" + encoding + \".\");\n<line_number-363>        }\n<line_number-364>    }\n<line_number-365>\n<line_number-366>    @Deprecated\n<line_number-367>    @Override\n<line_number-368>    public java.io.InputStream getUnicodeStream(String columnLabel) throws SQLException {\n<line_number-369>        final String encoding = \"UTF-8\";\n<line_number-370>        try {\n<line_number-371>            return getNewByteArrayInputStream(getString(columnLabel).getBytes(encoding));\n<line_number-372>        } catch (UnsupportedEncodingException e) {\n<line_number-373>            throw new SQLException(\"The JVM claims not to support the encoding: \" + encoding + \".\");\n<line_number-374>        }\n<line_number-375>    }\n<line_number-376>\n<line_number-377>    @Override\n<line_number-378>    public java.io.InputStream getBinaryStream(int columnIndex) throws SQLException {\n<line_number-379>        return getNewByteArrayInputStream(getBytes(columnIndex));\n<line_number-380>    }\n<line_number-381>\n<line_number-382>    @Override\n<line_number-383>    public java.io.InputStream getBinaryStream(String columnLabel) throws SQLException {\n<line_number-384>        return getNewByteArrayInputStream(getBytes(columnLabel));\n<line_number-385>    }\n<line_number-386>\n<line_number-387>    private String handleStringConversionFailure(String from) throws SQLException {\n<line_number-388>        throw new SQLException(\"The \" + from + \" type cannot be converted to string.\");\n<line_number-389>    }\n<line_number-390>\n<line_number-391>    private String getString(BsonValue o) throws SQLException {\n<line_number-392>        if (checkNull(o)) {\n<line_number-393>            return null;\n<line_number-394>        }\n<line_number-395>        return new MongoBsonValue(o, extJsonMode, uuidRepresentation).toString();\n<line_number-396>    }\n<line_number-397>\n<line_number-398>    @Override\n<line_number-399>    public String getString(String columnLabel) throws SQLException {\n<line_number-400>        BsonValue out = getBsonValue(columnLabel);\n<line_number-401>        return getString(out);\n<line_number-402>    }\n<line_number-403>\n<line_number-404>    @Override\n<line_number-405>    public String getString(int columnIndex) throws SQLException {\n<line_number-406>        BsonValue out = getBsonValue(columnIndex);\n<line_number-407>        return getString(out);\n<line_number-408>    }\n<line_number-409>\n<line_number-410>    private boolean handleBooleanConversionFailure(String from) throws SQLException {\n<line_number-411>        throw new SQLException(\"The \" + from + \" type cannot be converted to boolean.\");\n<line_number-412>    }\n<line_number-413>\n<line_number-414>    private boolean getBoolean(BsonValue o) throws SQLException {\n<line_number-415>        if (checkNull(o)) {\n<line_number-416>            return false;\n<line_number-417>        }\n<line_number-418>        BsonTypeInfo bsonType = BsonTypeInfo.getBsonTypeInfoFromBsonValue(o);\n<line_number-419>        switch (bsonType.getBsonType()) {\n<line_number-420>            case BOOLEAN:\n<line_number-421>                return o.asBoolean().getValue();\n<line_number-422>            case DECIMAL128:\n<line_number-423>                {\n<line_number-424>                    Decimal128 v = o.asDecimal128().getValue();\n<line_number-425>                    return !Objects.equals(v, Decimal128.POSITIVE_ZERO)\n<line_number-426>                            && !Objects.equals(v, Decimal128.NEGATIVE_ZERO);\n<line_number-427>                }\n<line_number-428>            case DOUBLE:\n<line_number-429>                return o.asDouble().getValue() != 0.0;\n<line_number-430>            case INT32:\n<line_number-431>                return o.asInt32().getValue() != 0;\n<line_number-432>            case INT64:\n<line_number-433>                return o.asInt64().getValue() != 0;\n<line_number-434>            case NULL:\n<line_number-435>            case UNDEFINED:\n<line_number-436>                // this is consistent with $convert in mongodb insofar as getBoolean\n<line_number-437>                // returns false for null values.\n<line_number-438>                return false;\n<line_number-439>            case STRING:\n<line_number-440>                // mongodb $convert converts all strings to true, even the empty string.\n<line_number-441>                return true;\n<line_number-442>            default:\n<line_number-443>                return handleBooleanConversionFailure(bsonType.getBsonName());\n<line_number-444>        }\n<line_number-445>    }\n<line_number-446>\n<line_number-447>    @Override\n<line_number-448>    public boolean getBoolean(String columnLabel) throws SQLException {\n<line_number-449>        BsonValue out = getBsonValue(columnLabel);\n<line_number-450>        return getBoolean(out);\n<line_number-451>    }\n<line_number-452>\n<line_number-453>    @Override\n<line_number-454>    public boolean getBoolean(int columnIndex) throws SQLException {\n<line_number-455>        BsonValue out = getBsonValue(columnIndex);\n<line_number-456>        return getBoolean(out);\n<line_number-457>    }\n<line_number-458>\n<line_number-459>    protected byte getByte(BsonValue o) throws SQLException {\n<line_number-460>        // Just be lazy, I doubt this will be called often.\n<line_number-461>        // HotSpot should inline these, anyway.\n<line_number-462>        return (byte) getLong(o);\n<line_number-463>    }\n<line_number-464>\n<line_number-465>    @Override\n<line_number-466>    public byte getByte(String columnLabel) throws SQLException {\n<line_number-467>        BsonValue out = getBsonValue(columnLabel);\n<line_number-468>        return getByte(out);\n<line_number-469>    }\n<line_number-470>\n<line_number-471>    @Override\n<line_number-472>    public byte getByte(int columnIndex) throws SQLException {\n<line_number-473>        BsonValue out = getBsonValue(columnIndex);\n<line_number-474>        return getByte(out);\n<line_number-475>    }\n<line_number-476>\n<line_number-477>    private short getShort(BsonValue o) throws SQLException {\n<line_number-478>        // Just be lazy, I doubt this will be called often.\n<line_number-479>        // HotSpot should inline these, anyway.\n<line_number-480>        return (short) getLong(o);\n<line_number-481>    }\n<line_number-482>\n<line_number-483>    @Override\n<line_number-484>    public short getShort(String columnLabel) throws SQLException {\n<line_number-485>        BsonValue out = getBsonValue(columnLabel);\n<line_number-486>        return getShort(out);\n<line_number-487>    }\n<line_number-488>\n<line_number-489>    @Override\n<line_number-490>    public short getShort(int columnIndex) throws SQLException {\n<line_number-491>        BsonValue out = getBsonValue(columnIndex);\n<line_number-492>        return getShort(out);\n<line_number-493>    }\n<line_number-494>\n<line_number-495>    private int getInt(BsonValue o) throws SQLException {\n<line_number-496>        if (checkNull(o)) {\n<line_number-497>            return 0;\n<line_number-498>        }\n<line_number-499>        return (int) getLong(o);\n<line_number-500>    }\n<line_number-501>\n<line_number-502>    @Override\n<line_number-503>    public int getInt(String columnLabel) throws SQLException {\n<line_number-504>        BsonValue out = getBsonValue(columnLabel);\n<line_number-505>        return getInt(out);\n<line_number-506>    }\n<line_number-507>\n<line_number-508>    @Override\n<line_number-509>    public int getInt(int columnIndex) throws SQLException {\n<line_number-510>        BsonValue out = getBsonValue(columnIndex);\n<line_number-511>        return getInt(out);\n<line_number-512>    }\n<line_number-513>\n<line_number-514>    private long handleLongConversionFailure(String from) throws SQLException {\n<line_number-515>        throw new SQLException(\"The \" + from + \" type cannot be converted to integral type.\");\n<line_number-516>    }\n<line_number-517>\n<line_number-518>    private long getLong(BsonValue o) throws SQLException {\n<line_number-519>        if (checkNull(o)) {\n<line_number-520>            return 0L;\n<line_number-521>        }\n<line_number-522>        BsonTypeInfo bsonType = BsonTypeInfo.getBsonTypeInfoFromBsonValue(o);\n<line_number-523>        switch (o.getBsonType()) {\n<line_number-524>            case BOOLEAN:\n<line_number-525>                return o.asBoolean().getValue() ? 1 : 0;\n<line_number-526>            case DATE_TIME:\n<line_number-527>                // This is what $convert does.\n<line_number-528>                return o.asDateTime().getValue();\n<line_number-529>            case DECIMAL128:\n<line_number-530>                return o.asDecimal128().longValue();\n<line_number-531>            case DOUBLE:\n<line_number-532>                return (long) o.asDouble().getValue();\n<line_number-533>            case INT32:\n<line_number-534>                return o.asInt32().getValue();\n<line_number-535>            case INT64:\n<line_number-536>                return o.asInt64().getValue();\n<line_number-537>            case NULL:\n<line_number-538>                return 0L;\n<line_number-539>            case STRING:\n<line_number-540>                try {\n<line_number-541>                    return Long.parseLong(o.asString().getValue());\n<line_number-542>                } catch (NumberFormatException e) {\n<line_number-543>                    throw new SQLException(e);\n<line_number-544>                }\n<line_number-545>            case UNDEFINED:\n<line_number-546>                // this is consistent with $convert in mongodb insofar as getLong\n<line_number-547>                // returns 0.0 for null values.\n<line_number-548>                return 0L;\n<line_number-549>            default:\n<line_number-550>                return handleLongConversionFailure(bsonType.getBsonName());\n<line_number-551>        }\n<line_number-552>    }\n<line_number-553>\n<line_number-554>    @Override\n<line_number-555>    public long getLong(String columnLabel) throws SQLException {\n<line_number-556>        BsonValue out = getBsonValue(columnLabel);\n<line_number-557>        return getLong(out);\n<line_number-558>    }\n<line_number-559>\n<line_number-560>    @Override\n<line_number-561>    public long getLong(int columnIndex) throws SQLException {\n<line_number-562>        BsonValue out = getBsonValue(columnIndex);\n<line_number-563>        return getLong(out);\n<line_number-564>    }\n<line_number-565>\n<line_number-566>    private float getFloat(BsonValue o) throws SQLException {\n<line_number-567>        return (float) getDouble(o);\n<line_number-568>    }\n<line_number-569>\n<line_number-570>    @Override\n<line_number-571>    public float getFloat(String columnLabel) throws SQLException {\n<line_number-572>        BsonValue out = getBsonValue(columnLabel);\n<line_number-573>        return getFloat(out);\n<line_number-574>    }\n<line_number-575>\n<line_number-576>    @Override\n<line_number-577>    public float getFloat(int columnIndex) throws SQLException {\n<line_number-578>        BsonValue out = getBsonValue(columnIndex);\n<line_number-579>        return getFloat(out);\n<line_number-580>    }\n<line_number-581>\n<line_number-582>    private double handleDoubleConversionFailure(String from) throws SQLException {\n<line_number-583>        throw new SQLException(\"The \" + from + \" type cannot be converted to double.\");\n<line_number-584>    }\n<line_number-585>\n<line_number-586>    private double getDouble(BsonValue o) throws SQLException {\n<line_number-587>        if (checkNull(o)) {\n<line_number-588>            return 0.0;\n<line_number-589>        }\n<line_number-590>        BsonTypeInfo bsonType = BsonTypeInfo.getBsonTypeInfoFromBsonValue(o);\n<line_number-591>        switch (o.getBsonType()) {\n<line_number-592>            case BOOLEAN:\n<line_number-593>                return o.asBoolean().getValue() ? 1.0 : 0.0;\n<line_number-594>            case DATE_TIME:\n<line_number-595>                // This is what $convert does.\n<line_number-596>                return (double) o.asDateTime().getValue();\n<line_number-597>            case DECIMAL128:\n<line_number-598>                return o.asDecimal128().doubleValue();\n<line_number-599>            case DOUBLE:\n<line_number-600>                return o.asDouble().getValue();\n<line_number-601>            case INT32:\n<line_number-602>                return o.asInt32().getValue();\n<line_number-603>            case INT64:\n<line_number-604>                return (double) o.asInt64().getValue();\n<line_number-605>            case STRING:\n<line_number-606>                try {\n<line_number-607>                    return Double.parseDouble(o.asString().getValue());\n<line_number-608>                } catch (NumberFormatException e) {\n<line_number-609>                    throw new SQLException(e);\n<line_number-610>                }\n<line_number-611>            case NULL:\n<line_number-612>            case UNDEFINED:\n<line_number-613>                // this is consistent with $convert in mongodb insofar as getDouble\n<line_number-614>                // returns 0.0 for null values.\n<line_number-615>                return 0.0;\n<line_number-616>            default:\n<line_number-617>                return handleDoubleConversionFailure(bsonType.getBsonName());\n<line_number-618>        }\n<line_number-619>    }\n<line_number-620>\n<line_number-621>    @Override\n<line_number-622>    public double getDouble(String columnLabel) throws SQLException {\n<line_number-623>        BsonValue out = getBsonValue(columnLabel);\n<line_number-624>        return getDouble(out);\n<line_number-625>    }\n<line_number-626>\n<line_number-627>    @Override\n<line_number-628>    public double getDouble(int columnIndex) throws SQLException {\n<line_number-629>        BsonValue out = getBsonValue(columnIndex);\n<line_number-630>        return getDouble(out);\n<line_number-631>    }\n<line_number-632>\n<line_number-633>    @Deprecated\n<line_number-634>    @Override\n<line_number-635>    public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {\n<line_number-636>        throw new SQLFeatureNotSupportedException(\n<line_number-637>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-638>    }\n<line_number-639>\n<line_number-640>    // Advanced features:\n<line_number-641>\n<line_number-642>    @Override\n<line_number-643>    public SQLWarning getWarnings() throws SQLException {\n<line_number-644>        checkClosed();\n<line_number-645>        return null;\n<line_number-646>    }\n<line_number-647>\n<line_number-648>    @Override\n<line_number-649>    public void clearWarnings() throws SQLException {\n<line_number-650>        checkClosed();\n<line_number-651>    }\n<line_number-652>\n<line_number-653>    @Override\n<line_number-654>    public String getCursorName() throws SQLException {\n<line_number-655>        if (this.statement.cursorName != null) {\n<line_number-656>            return this.statement.cursorName;\n<line_number-657>        }\n<line_number-658>        if (this.cursor != null) {\n<line_number-659>            return String.valueOf(this.cursor.getServerCursor().getId());\n<line_number-660>        }\n<line_number-661>        return \"\";\n<line_number-662>    }\n<line_number-663>\n<line_number-664>    @Override\n<line_number-665>    public ResultSetMetaData getMetaData() throws SQLException {\n<line_number-666>        checkClosed();\n<line_number-667>        return rsMetaData;\n<line_number-668>    }\n<line_number-669>\n<line_number-670>    private Object getObject(BsonValue o, int columnType) throws SQLException {\n<line_number-671>        // If the value is an SQL NULL, the driver returns a Java null.\n<line_number-672>        if (checkNull(o)) {\n<line_number-673>            return null;\n<line_number-674>        }\n<line_number-675>        switch (columnType) {\n<line_number-676>            case Types.BIGINT:\n<line_number-677>                return getLong(o);\n<line_number-678>            case Types.INTEGER:\n<line_number-679>            case Types.SMALLINT:\n<line_number-680>            case Types.TINYINT:\n<line_number-681>                return getInt(o);\n<line_number-682>            case Types.BINARY:\n<line_number-683>            case Types.LONGVARBINARY:\n<line_number-684>            case Types.VARBINARY:\n<line_number-685>                if (o.getBsonType() == BsonType.BINARY) {\n<line_number-686>                    BsonBinary binary = o.asBinary();\n<line_number-687>                    if (binary.getType() == BsonBinarySubType.UUID_STANDARD.getValue()\n<line_number-688>                            || binary.getType() == BsonBinarySubType.UUID_LEGACY.getValue()) {\n<line_number-689>                        // Handle UUID\n<line_number-690>                        return UuidHelper.decodeBinaryToUuid(\n<line_number-691>                                binary.getData(), binary.getType(), uuidRepresentation);\n<line_number-692>                    }\n<line_number-693>                }\n<line_number-694>                return o.asBinary().getData();\n<line_number-695>            case Types.BIT:\n<line_number-696>            case Types.BOOLEAN:\n<line_number-697>                return getBoolean(o);\n<line_number-698>            case Types.DOUBLE:\n<line_number-699>            case Types.FLOAT:\n<line_number-700>                return getDouble(o);\n<line_number-701>            case Types.DECIMAL:\n<line_number-702>            case Types.NUMERIC:\n<line_number-703>                return o.asDecimal128().decimal128Value().bigDecimalValue();\n<line_number-704>            case Types.CHAR:\n<line_number-705>            case Types.LONGNVARCHAR:\n<line_number-706>            case Types.LONGVARCHAR:\n<line_number-707>            case Types.NCHAR:\n<line_number-708>            case Types.NVARCHAR:\n<line_number-709>            case Types.VARCHAR:\n<line_number-710>                return getString(o);\n<line_number-711>            case Types.REAL:\n<line_number-712>                return getFloat(o);\n<line_number-713>            case Types.TIMESTAMP:\n<line_number-714>                return new Timestamp(o.asDateTime().getValue());\n<line_number-715>            case Types.NULL:\n<line_number-716>                return null;\n<line_number-717>\n<line_number-718>            case Types.OTHER:\n<line_number-719>                if (o.getBsonType() == BsonType.NULL) {\n<line_number-720>                    return null;\n<line_number-721>                }\n<line_number-722>                // These types are wrapped in MongoBsonValue so that\n<line_number-723>                // if they are stringified via toString() they will be\n<line_number-724>                // represented as extended JSON.\n<line_number-725>                return new MongoBsonValue(o, extJsonMode, uuidRepresentation);\n<line_number-726>\n<line_number-727>            case Types.ARRAY:\n<line_number-728>            case Types.BLOB:\n<line_number-729>            case Types.CLOB:\n<line_number-730>            case Types.DATALINK:\n<line_number-731>            case Types.DATE:\n<line_number-732>            case Types.DISTINCT:\n<line_number-733>            case Types.JAVA_OBJECT:\n<line_number-734>            case Types.NCLOB:\n<line_number-735>            case Types.REF:\n<line_number-736>            case Types.REF_CURSOR:\n<line_number-737>            case Types.ROWID:\n<line_number-738>            case Types.SQLXML:\n<line_number-739>            case Types.STRUCT:\n<line_number-740>            case Types.TIME:\n<line_number-741>            case Types.TIME_WITH_TIMEZONE:\n<line_number-742>            case Types.TIMESTAMP_WITH_TIMEZONE:\n<line_number-743>                // not supported\n<line_number-744>                break;\n<line_number-745>        }\n<line_number-746>        throw new SQLException(\"getObject not supported for column type \" + columnType);\n<line_number-747>    }\n<line_number-748>\n<line_number-749>    @Override\n<line_number-750>    public Object getObject(int columnIndex) throws SQLException {\n<line_number-751>        BsonValue out = getBsonValue(columnIndex);\n<line_number-752>        int columnType = rsMetaData.getColumnType(columnIndex);\n<line_number-753>        return getObject(out, columnType);\n<line_number-754>    }\n<line_number-755>\n<line_number-756>    @Override\n<line_number-757>    public Object getObject(String columnLabel) throws SQLException {\n<line_number-758>        int columnIndex = findColumn(columnLabel);\n<line_number-759>        return getObject(columnIndex);\n<line_number-760>    }\n<line_number-761>\n<line_number-762>    @Override\n<line_number-763>    public Object getObject(int columnIndex, java.util.Map<String, Class<?>> map)\n<line_number-764>            throws SQLException {\n<line_number-765>        BsonValue out = getBsonValue(columnIndex);\n<line_number-766>        if (checkNull(out)) {\n<line_number-767>            return null;\n<line_number-768>        }\n<line_number-769>        String columnTypeName = rsMetaData.getColumnTypeName(columnIndex);\n<line_number-770>        Class<?> type = map.get(columnTypeName);\n<line_number-771>        if (type == null) {\n<line_number-772>            return null;\n<line_number-773>        }\n<line_number-774>        return type.cast(out);\n<line_number-775>    }\n<line_number-776>\n<line_number-777>    @Override\n<line_number-778>    public Object getObject(String columnLabel, java.util.Map<String, Class<?>> map)\n<line_number-779>            throws SQLException {\n<line_number-780>        return getObject(findColumn(columnLabel), map);\n<line_number-781>    }\n<line_number-782>\n<line_number-783>    @Override\n<line_number-784>    public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {\n<line_number-785>        BsonValue out = getBsonValue(columnIndex);\n<line_number-786>        if (checkNull(out)) {\n<line_number-787>            return null;\n<line_number-788>        }\n<line_number-789>        return type.cast(out);\n<line_number-790>    }\n<line_number-791>\n<line_number-792>    @Override\n<line_number-793>    public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {\n<line_number-794>        return getObject(findColumn(columnLabel), type);\n<line_number-795>    }\n<line_number-796>\n<line_number-797>    // ----------------------------------------------------------------\n<line_number-798>\n<line_number-799>    @Override\n<line_number-800>    public int findColumn(String columnLabel) throws SQLException {\n<line_number-801>        checkClosed();\n<line_number-802>        if (!rsMetaData.hasColumnWithLabel(columnLabel)) {\n<line_number-803>            throw new SQLException(\"No such column: '\" + columnLabel + \"'.\");\n<line_number-804>        }\n<line_number-805>        try {\n<line_number-806>            return rsMetaData.getColumnPositionFromLabel(columnLabel) + 1;\n<line_number-807>        } catch (Exception e) {\n<line_number-808>            throw new SQLException(e.getMessage());\n<line_number-809>        }\n<line_number-810>    }\n<line_number-811>\n<line_number-812>    // --------------------------JDBC 2.0-----------------------------------\n<line_number-813>\n<line_number-814>    // ---------------------------------------------------------------------\n<line_number-815>    // Getters and Setters\n<line_number-816>    // ---------------------------------------------------------------------\n<line_number-817>\n<line_number-818>    @Override\n<line_number-819>    public java.io.Reader getCharacterStream(int columnIndex) throws SQLException {\n<line_number-820>        throw new SQLFeatureNotSupportedException(\n<line_number-821>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-822>    }\n<line_number-823>\n<line_number-824>    @Override\n<line_number-825>    public java.io.Reader getCharacterStream(String columnLabel) throws SQLException {\n<line_number-826>        throw new SQLFeatureNotSupportedException(\n<line_number-827>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-828>    }\n<line_number-829>\n<line_number-830>    private BigDecimal handleBigDecimalConversionFailure(String from) throws SQLException {\n<line_number-831>        throw new SQLException(\"The \" + from + \" type cannot be converted to BigDecimal.\");\n<line_number-832>    }\n<line_number-833>\n<line_number-834>    private BigDecimal getBigDecimal(BsonValue o) throws SQLException {\n<line_number-835>        if (checkNull(o)) {\n<line_number-836>            return BigDecimal.ZERO;\n<line_number-837>        }\n<line_number-838>        BsonTypeInfo bsonType = BsonTypeInfo.getBsonTypeInfoFromBsonValue(o);\n<line_number-839>        switch (o.getBsonType()) {\n<line_number-840>            case BOOLEAN:\n<line_number-841>                return o.asBoolean().getValue() ? BigDecimal.ONE : BigDecimal.ZERO;\n<line_number-842>            case DATE_TIME:\n<line_number-843>                // This is what $convert does.\n<line_number-844>                return new BigDecimal(o.asDateTime().getValue());\n<line_number-845>            case DECIMAL128:\n<line_number-846>                return o.asDecimal128().decimal128Value().bigDecimalValue();\n<line_number-847>            case DOUBLE:\n<line_number-848>                return new BigDecimal(o.asDouble().getValue());\n<line_number-849>            case INT32:\n<line_number-850>                return new BigDecimal(o.asInt32().getValue());\n<line_number-851>            case INT64:\n<line_number-852>                return new BigDecimal(o.asInt64().getValue());\n<line_number-853>            case NULL:\n<line_number-854>            case UNDEFINED:\n<line_number-855>                // this is consistent with $convert in mongodb insofar as getBigDecimal\n<line_number-856>                // returns 0.0 for null values.\n<line_number-857>                return BigDecimal.ZERO;\n<line_number-858>            case STRING:\n<line_number-859>                try {\n<line_number-860>                    return new BigDecimal(o.asString().getValue());\n<line_number-861>                } catch (NumberFormatException | ArithmeticException e) {\n<line_number-862>                    throw new SQLException(e);\n<line_number-863>                }\n<line_number-864>            default:\n<line_number-865>                return handleBigDecimalConversionFailure(bsonType.getBsonName());\n<line_number-866>        }\n<line_number-867>    }\n<line_number-868>\n<line_number-869>    @Override\n<line_number-870>    public BigDecimal getBigDecimal(int columnIndex) throws SQLException {\n<line_number-871>        BsonValue out = getBsonValue(columnIndex);\n<line_number-872>        return getBigDecimal(out);\n<line_number-873>    }\n<line_number-874>\n<line_number-875>    @Override\n<line_number-876>    public BigDecimal getBigDecimal(String columnLabel) throws SQLException {\n<line_number-877>        BsonValue out = getBsonValue(columnLabel);\n<line_number-878>        return getBigDecimal(out);\n<line_number-879>    }\n<line_number-880>\n<line_number-881>    // ---------------------------------------------------------------------\n<line_number-882>    // Traversal/Positioning\n<line_number-883>    // ---------------------------------------------------------------------\n<line_number-884>\n<line_number-885>    @Override\n<line_number-886>    public boolean isBeforeFirst() throws SQLException {\n<line_number-887>        throw new SQLFeatureNotSupportedException(\n<line_number-888>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-889>    }\n<line_number-890>\n<line_number-891>    @Override\n<line_number-892>    public boolean isAfterLast() throws SQLException {\n<line_number-893>        throw new SQLFeatureNotSupportedException(\n<line_number-894>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-895>    }\n<line_number-896>\n<line_number-897>    @Override\n<line_number-898>    public boolean isFirst() throws SQLException {\n<line_number-899>        checkClosed();\n<line_number-900>        return rowNum == 1;\n<line_number-901>    }\n<line_number-902>\n<line_number-903>    @Override\n<line_number-904>    public void beforeFirst() throws SQLException {\n<line_number-905>        throw new SQLFeatureNotSupportedException(\n<line_number-906>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-907>    }\n<line_number-908>\n<line_number-909>    @Override\n<line_number-910>    public void afterLast() throws SQLException {\n<line_number-911>        throw new SQLFeatureNotSupportedException(\n<line_number-912>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-913>    }\n<line_number-914>\n<line_number-915>    @Override\n<line_number-916>    public boolean first() throws SQLException {\n<line_number-917>        throw new SQLFeatureNotSupportedException(\n<line_number-918>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-919>    }\n<line_number-920>\n<line_number-921>    @Override\n<line_number-922>    public boolean last() throws SQLException {\n<line_number-923>        throw new SQLFeatureNotSupportedException(\n<line_number-924>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-925>    }\n<line_number-926>\n<line_number-927>    @Override\n<line_number-928>    public int getRow() throws SQLException {\n<line_number-929>        checkClosed();\n<line_number-930>        return rowNum;\n<line_number-931>    }\n<line_number-932>\n<line_number-933>    @Override\n<line_number-934>    public boolean absolute(int row) throws SQLException {\n<line_number-935>        throw new SQLFeatureNotSupportedException(\n<line_number-936>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-937>    }\n<line_number-938>\n<line_number-939>    @Override\n<line_number-940>    public boolean relative(int rows) throws SQLException {\n<line_number-941>        throw new SQLFeatureNotSupportedException(\n<line_number-942>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-943>    }\n<line_number-944>\n<line_number-945>    @Override\n<line_number-946>    public boolean previous() throws SQLException {\n<line_number-947>        throw new SQLFeatureNotSupportedException(\n<line_number-948>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-949>    }\n<line_number-950>\n<line_number-951>    // ---------------------------------------------------------------------\n<line_number-952>    // Properties\n<line_number-953>    // ---------------------------------------------------------------------\n<line_number-954>\n<line_number-955>    @Override\n<line_number-956>    public void setFetchDirection(int direction) throws SQLException {\n<line_number-957>        throw new SQLFeatureNotSupportedException(\n<line_number-958>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-959>    }\n<line_number-960>\n<line_number-961>    @Override\n<line_number-962>    public int getFetchDirection() throws SQLException {\n<line_number-963>        checkClosed();\n<line_number-964>        return ResultSet.FETCH_FORWARD;\n<line_number-965>    }\n<line_number-966>\n<line_number-967>    @Override\n<line_number-968>    public void setFetchSize(int rows) throws SQLException {\n<line_number-969>        throw new SQLFeatureNotSupportedException(\n<line_number-970>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-971>    }\n<line_number-972>\n<line_number-973>    @Override\n<line_number-974>    public int getFetchSize() throws SQLException {\n<line_number-975>        throw new SQLFeatureNotSupportedException(\n<line_number-976>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-977>    }\n<line_number-978>\n<line_number-979>    @Override\n<line_number-980>    public int getType() throws SQLException {\n<line_number-981>        checkClosed();\n<line_number-982>        return ResultSet.TYPE_FORWARD_ONLY;\n<line_number-983>    }\n<line_number-984>\n<line_number-985>    @Override\n<line_number-986>    public int getConcurrency() throws SQLException {\n<line_number-987>        checkClosed();\n<line_number-988>        return ResultSet.CONCUR_READ_ONLY;\n<line_number-989>    }\n<line_number-990>\n<line_number-991>    // ---------------------------------------------------------------------\n<line_number-992>    // Updates\n<line_number-993>    // ---------------------------------------------------------------------\n<line_number-994>\n<line_number-995>    @Override\n<line_number-996>    public boolean rowUpdated() throws SQLException {\n<line_number-997>        throw new SQLFeatureNotSupportedException(\n<line_number-998>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-999>    }\n<line_number-1000>\n<line_number-1001>    @Override\n<line_number-1002>    public boolean rowInserted() throws SQLException {\n<line_number-1003>        throw new SQLFeatureNotSupportedException(\n<line_number-1004>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1005>    }\n<line_number-1006>\n<line_number-1007>    @Override\n<line_number-1008>    public boolean rowDeleted() throws SQLException {\n<line_number-1009>        throw new SQLFeatureNotSupportedException(\n<line_number-1010>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1011>    }\n<line_number-1012>\n<line_number-1013>    @Override\n<line_number-1014>    public void updateNull(int columnIndex) throws SQLException {\n<line_number-1015>        throw new SQLFeatureNotSupportedException(\n<line_number-1016>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1017>    }\n<line_number-1018>\n<line_number-1019>    @Override\n<line_number-1020>    public void updateBoolean(int columnIndex, boolean x) throws SQLException {\n<line_number-1021>        throw new SQLFeatureNotSupportedException(\n<line_number-1022>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1023>    }\n<line_number-1024>\n<line_number-1025>    @Override\n<line_number-1026>    public void updateByte(int columnIndex, byte x) throws SQLException {\n<line_number-1027>        throw new SQLFeatureNotSupportedException(\n<line_number-1028>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1029>    }\n<line_number-1030>\n<line_number-1031>    @Override\n<line_number-1032>    public void updateShort(int columnIndex, short x) throws SQLException {\n<line_number-1033>        throw new SQLFeatureNotSupportedException(\n<line_number-1034>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1035>    }\n<line_number-1036>\n<line_number-1037>    @Override\n<line_number-1038>    public void updateInt(int columnIndex, int x) throws SQLException {\n<line_number-1039>        throw new SQLFeatureNotSupportedException(\n<line_number-1040>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1041>    }\n<line_number-1042>\n<line_number-1043>    @Override\n<line_number-1044>    public void updateLong(int columnIndex, long x) throws SQLException {\n<line_number-1045>        throw new SQLFeatureNotSupportedException(\n<line_number-1046>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1047>    }\n<line_number-1048>\n<line_number-1049>    @Override\n<line_number-1050>    public void updateFloat(int columnIndex, float x) throws SQLException {\n<line_number-1051>        throw new SQLFeatureNotSupportedException(\n<line_number-1052>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1053>    }\n<line_number-1054>\n<line_number-1055>    @Override\n<line_number-1056>    public void updateDouble(int columnIndex, double x) throws SQLException {\n<line_number-1057>        throw new SQLFeatureNotSupportedException(\n<line_number-1058>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1059>    }\n<line_number-1060>\n<line_number-1061>    @Override\n<line_number-1062>    public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {\n<line_number-1063>        throw new SQLFeatureNotSupportedException(\n<line_number-1064>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1065>    }\n<line_number-1066>\n<line_number-1067>    @Override\n<line_number-1068>    public void updateString(int columnIndex, String x) throws SQLException {\n<line_number-1069>        throw new SQLFeatureNotSupportedException(\n<line_number-1070>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1071>    }\n<line_number-1072>\n<line_number-1073>    @Override\n<line_number-1074>    public void updateBytes(int columnIndex, byte[] x) throws SQLException {\n<line_number-1075>        throw new SQLFeatureNotSupportedException(\n<line_number-1076>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1077>    }\n<line_number-1078>\n<line_number-1079>    @Override\n<line_number-1080>    public void updateDate(int columnIndex, Date x) throws SQLException {\n<line_number-1081>        throw new SQLFeatureNotSupportedException(\n<line_number-1082>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1083>    }\n<line_number-1084>\n<line_number-1085>    @Override\n<line_number-1086>    public void updateTime(int columnIndex, Time x) throws SQLException {\n<line_number-1087>        throw new SQLFeatureNotSupportedException(\n<line_number-1088>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1089>    }\n<line_number-1090>\n<line_number-1091>    @Override\n<line_number-1092>    public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {\n<line_number-1093>        throw new SQLFeatureNotSupportedException(\n<line_number-1094>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1095>    }\n<line_number-1096>\n<line_number-1097>    @Override\n<line_number-1098>    public void updateAsciiStream(int columnIndex, java.io.InputStream x, int length)\n<line_number-1099>            throws SQLException {\n<line_number-1100>        throw new SQLFeatureNotSupportedException(\n<line_number-1101>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1102>    }\n<line_number-1103>\n<line_number-1104>    @Override\n<line_number-1105>    public void updateBinaryStream(int columnIndex, java.io.InputStream x, int length)\n<line_number-1106>            throws SQLException {\n<line_number-1107>        throw new SQLFeatureNotSupportedException(\n<line_number-1108>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1109>    }\n<line_number-1110>\n<line_number-1111>    @Override\n<line_number-1112>    public void updateCharacterStream(int columnIndex, java.io.Reader x, int length)\n<line_number-1113>            throws SQLException {\n<line_number-1114>        throw new SQLFeatureNotSupportedException(\n<line_number-1115>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1116>    }\n<line_number-1117>\n<line_number-1118>    @Override\n<line_number-1119>    public void updateObject(int columnIndex, Object x, int scaleOrLength) throws SQLException {\n<line_number-1120>        throw new SQLFeatureNotSupportedException(\n<line_number-1121>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1122>    }\n<line_number-1123>\n<line_number-1124>    @Override\n<line_number-1125>    public void updateObject(int columnIndex, Object x) throws SQLException {\n<line_number-1126>        throw new SQLFeatureNotSupportedException(\n<line_number-1127>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1128>    }\n<line_number-1129>\n<line_number-1130>    @Override\n<line_number-1131>    public void updateNull(String columnLabel) throws SQLException {\n<line_number-1132>        throw new SQLFeatureNotSupportedException(\n<line_number-1133>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1134>    }\n<line_number-1135>\n<line_number-1136>    @Override\n<line_number-1137>    public void updateBoolean(String columnLabel, boolean x) throws SQLException {\n<line_number-1138>        throw new SQLFeatureNotSupportedException(\n<line_number-1139>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1140>    }\n<line_number-1141>\n<line_number-1142>    @Override\n<line_number-1143>    public void updateByte(String columnLabel, byte x) throws SQLException {\n<line_number-1144>        throw new SQLFeatureNotSupportedException(\n<line_number-1145>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1146>    }\n<line_number-1147>\n<line_number-1148>    @Override\n<line_number-1149>    public void updateShort(String columnLabel, short x) throws SQLException {\n<line_number-1150>        throw new SQLFeatureNotSupportedException(\n<line_number-1151>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1152>    }\n<line_number-1153>\n<line_number-1154>    @Override\n<line_number-1155>    public void updateInt(String columnLabel, int x) throws SQLException {\n<line_number-1156>        throw new SQLFeatureNotSupportedException(\n<line_number-1157>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1158>    }\n<line_number-1159>\n<line_number-1160>    @Override\n<line_number-1161>    public void updateLong(String columnLabel, long x) throws SQLException {\n<line_number-1162>        throw new SQLFeatureNotSupportedException(\n<line_number-1163>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1164>    }\n<line_number-1165>\n<line_number-1166>    @Override\n<line_number-1167>    public void updateFloat(String columnLabel, float x) throws SQLException {\n<line_number-1168>        throw new SQLFeatureNotSupportedException(\n<line_number-1169>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1170>    }\n<line_number-1171>\n<line_number-1172>    @Override\n<line_number-1173>    public void updateDouble(String columnLabel, double x) throws SQLException {\n<line_number-1174>        throw new SQLFeatureNotSupportedException(\n<line_number-1175>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1176>    }\n<line_number-1177>\n<line_number-1178>    @Override\n<line_number-1179>    public void updateBigDecimal(String columnLabel, BigDecimal x) throws SQLException {\n<line_number-1180>        throw new SQLFeatureNotSupportedException(\n<line_number-1181>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1182>    }\n<line_number-1183>\n<line_number-1184>    @Override\n<line_number-1185>    public void updateString(String columnLabel, String x) throws SQLException {\n<line_number-1186>        throw new SQLFeatureNotSupportedException(\n<line_number-1187>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1188>    }\n<line_number-1189>\n<line_number-1190>    @Override\n<line_number-1191>    public void updateBytes(String columnLabel, byte[] x) throws SQLException {\n<line_number-1192>        throw new SQLFeatureNotSupportedException(\n<line_number-1193>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1194>    }\n<line_number-1195>\n<line_number-1196>    @Override\n<line_number-1197>    public void updateDate(String columnLabel, Date x) throws SQLException {\n<line_number-1198>        throw new SQLFeatureNotSupportedException(\n<line_number-1199>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1200>    }\n<line_number-1201>\n<line_number-1202>    @Override\n<line_number-1203>    public void updateTime(String columnLabel, Time x) throws SQLException {\n<line_number-1204>        throw new SQLFeatureNotSupportedException(\n<line_number-1205>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1206>    }\n<line_number-1207>\n<line_number-1208>    @Override\n<line_number-1209>    public void updateTimestamp(String columnLabel, Timestamp x) throws SQLException {\n<line_number-1210>        throw new SQLFeatureNotSupportedException(\n<line_number-1211>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1212>    }\n<line_number-1213>\n<line_number-1214>    @Override\n<line_number-1215>    public void updateAsciiStream(String columnLabel, java.io.InputStream x, int length)\n<line_number-1216>            throws SQLException {\n<line_number-1217>        throw new SQLFeatureNotSupportedException(\n<line_number-1218>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1219>    }\n<line_number-1220>\n<line_number-1221>    @Override\n<line_number-1222>    public void updateBinaryStream(String columnLabel, java.io.InputStream x, int length)\n<line_number-1223>            throws SQLException {\n<line_number-1224>        throw new SQLFeatureNotSupportedException(\n<line_number-1225>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1226>    }\n<line_number-1227>\n<line_number-1228>    @Override\n<line_number-1229>    public void updateCharacterStream(String columnLabel, java.io.Reader reader, int length)\n<line_number-1230>            throws SQLException {\n<line_number-1231>        throw new SQLFeatureNotSupportedException(\n<line_number-1232>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1233>    }\n<line_number-1234>\n<line_number-1235>    @Override\n<line_number-1236>    public void updateObject(String columnLabel, Object x, int scaleOrLength) throws SQLException {\n<line_number-1237>        throw new SQLFeatureNotSupportedException(\n<line_number-1238>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1239>    }\n<line_number-1240>\n<line_number-1241>    @Override\n<line_number-1242>    public void updateObject(String columnLabel, Object x) throws SQLException {\n<line_number-1243>        throw new SQLFeatureNotSupportedException(\n<line_number-1244>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1245>    }\n<line_number-1246>\n<line_number-1247>    @Override\n<line_number-1248>    public void insertRow() throws SQLException {\n<line_number-1249>        throw new SQLFeatureNotSupportedException(\n<line_number-1250>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1251>    }\n<line_number-1252>\n<line_number-1253>    @Override\n<line_number-1254>    public void updateRow() throws SQLException {\n<line_number-1255>        throw new SQLFeatureNotSupportedException(\n<line_number-1256>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1257>    }\n<line_number-1258>\n<line_number-1259>    @Override\n<line_number-1260>    public void deleteRow() throws SQLException {\n<line_number-1261>        throw new SQLFeatureNotSupportedException(\n<line_number-1262>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1263>    }\n<line_number-1264>\n<line_number-1265>    @Override\n<line_number-1266>    public void refreshRow() throws SQLException {\n<line_number-1267>        throw new SQLFeatureNotSupportedException(\n<line_number-1268>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1269>    }\n<line_number-1270>\n<line_number-1271>    @Override\n<line_number-1272>    public void cancelRowUpdates() throws SQLException {\n<line_number-1273>        throw new SQLFeatureNotSupportedException(\n<line_number-1274>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1275>    }\n<line_number-1276>\n<line_number-1277>    @Override\n<line_number-1278>    public void moveToInsertRow() throws SQLException {\n<line_number-1279>        throw new SQLFeatureNotSupportedException(\n<line_number-1280>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1281>    }\n<line_number-1282>\n<line_number-1283>    @Override\n<line_number-1284>    public void moveToCurrentRow() throws SQLException {\n<line_number-1285>        throw new SQLFeatureNotSupportedException(\n<line_number-1286>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1287>    }\n<line_number-1288>\n<line_number-1289>    @Override\n<line_number-1290>    public Statement getStatement() throws SQLException {\n<line_number-1291>        checkClosed();\n<line_number-1292>        return statement;\n<line_number-1293>    }\n<line_number-1294>\n<line_number-1295>    @Override\n<line_number-1296>    public Ref getRef(int columnIndex) throws SQLException {\n<line_number-1297>        throw new SQLFeatureNotSupportedException(\n<line_number-1298>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1299>    }\n<line_number-1300>\n<line_number-1301>    protected Blob getNewBlob(byte[] bytes) throws SQLException {\n<line_number-1302>        if (bytes == null) {\n<line_number-1303>            return null;\n<line_number-1304>        }\n<line_number-1305>        try {\n<line_number-1306>            return new SerialBlob(bytes);\n<line_number-1307>        } catch (SerialException e) {\n<line_number-1308>            throw new SQLException(e);\n<line_number-1309>        }\n<line_number-1310>    }\n<line_number-1311>\n<line_number-1312>    @Override\n<line_number-1313>    public Blob getBlob(String columnLabel) throws SQLException {\n<line_number-1314>        BsonValue out = getBsonValue(columnLabel);\n<line_number-1315>        return getNewBlob(getBytes(out));\n<line_number-1316>    }\n<line_number-1317>\n<line_number-1318>    @Override\n<line_number-1319>    public Blob getBlob(int columnIndex) throws SQLException {\n<line_number-1320>        BsonValue out = getBsonValue(columnIndex);\n<line_number-1321>        return getNewBlob(getBytes(out));\n<line_number-1322>    }\n<line_number-1323>\n<line_number-1324>    protected Clob getClob(BsonValue o) throws SQLException {\n<line_number-1325>        if (checkNull(o)) {\n<line_number-1326>            return null;\n<line_number-1327>        }\n<line_number-1328>        return new SerialClob(getString(o).toCharArray());\n<line_number-1329>    }\n<line_number-1330>\n<line_number-1331>    @Override\n<line_number-1332>    public Clob getClob(String columnLabel) throws SQLException {\n<line_number-1333>        BsonValue out = getBsonValue(columnLabel);\n<line_number-1334>        return getClob(out);\n<line_number-1335>    }\n<line_number-1336>\n<line_number-1337>    @Override\n<line_number-1338>    public Clob getClob(int columnIndex) throws SQLException {\n<line_number-1339>        BsonValue out = getBsonValue(columnIndex);\n<line_number-1340>        return getClob(out);\n<line_number-1341>    }\n<line_number-1342>\n<line_number-1343>    @Override\n<line_number-1344>    public Array getArray(int columnIndex) throws SQLException {\n<line_number-1345>        throw new SQLFeatureNotSupportedException(\n<line_number-1346>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1347>    }\n<line_number-1348>\n<line_number-1349>    @Override\n<line_number-1350>    public Ref getRef(String columnLabel) throws SQLException {\n<line_number-1351>        throw new SQLFeatureNotSupportedException(\n<line_number-1352>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1353>    }\n<line_number-1354>\n<line_number-1355>    @Override\n<line_number-1356>    public Array getArray(String columnLabel) throws SQLException {\n<line_number-1357>        throw new SQLFeatureNotSupportedException(\n<line_number-1358>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1359>    }\n<line_number-1360>\n<line_number-1361>    private java.util.Date handleUtilDateConversionFailure(String from) throws SQLException {\n<line_number-1362>        throw new SQLException(\"The \" + from + \" type cannot be converted to java.util.Date\");\n<line_number-1363>    }\n<line_number-1364>\n<line_number-1365>    private java.util.Date getUtilDate(BsonValue o) throws SQLException {\n<line_number-1366>        if (checkNull(o)) {\n<line_number-1367>            return null;\n<line_number-1368>        }\n<line_number-1369>        BsonTypeInfo bsonType = BsonTypeInfo.getBsonTypeInfoFromBsonValue(o);\n<line_number-1370>        switch (o.getBsonType()) {\n<line_number-1371>            case DATE_TIME:\n<line_number-1372>                return new java.util.Date(o.asDateTime().getValue());\n<line_number-1373>            case DECIMAL128:\n<line_number-1374>                return new Date(o.asDecimal128().longValue());\n<line_number-1375>            case DOUBLE:\n<line_number-1376>                return new Date((long) o.asDouble().getValue());\n<line_number-1377>            case INT32:\n<line_number-1378>                return new Date(o.asInt32().getValue());\n<line_number-1379>            case INT64:\n<line_number-1380>                return new Date(o.asInt64().getValue());\n<line_number-1381>            case UNDEFINED:\n<line_number-1382>                // this is consistent with $convert in mongodb.\n<line_number-1383>            case NULL:\n<line_number-1384>                return null;\n<line_number-1385>            case STRING:\n<line_number-1386>                try {\n<line_number-1387>                    return dateFormat.parse(o.asString().getValue());\n<line_number-1388>                } catch (ParseException e) {\n<line_number-1389>                    throw new SQLException(e);\n<line_number-1390>                }\n<line_number-1391>            default:\n<line_number-1392>                return handleUtilDateConversionFailure(bsonType.getBsonName());\n<line_number-1393>        }\n<line_number-1394>    }\n<line_number-1395>\n<line_number-1396>    private Date getDate(BsonValue o) throws SQLException {\n<line_number-1397>        java.util.Date utilDate = getUtilDate(o);\n<line_number-1398>        return (utilDate == null) ? null : new Date(utilDate.getTime());\n<line_number-1399>    }\n<line_number-1400>\n<line_number-1401>    @Override\n<line_number-1402>    public Date getDate(String columnLabel) throws SQLException {\n<line_number-1403>        BsonValue out = getBsonValue(columnLabel);\n<line_number-1404>        return getDate(out);\n<line_number-1405>    }\n<line_number-1406>\n<line_number-1407>    @Override\n<line_number-1408>    public Date getDate(int columnIndex) throws SQLException {\n<line_number-1409>        BsonValue out = getBsonValue(columnIndex);\n<line_number-1410>        return getDate(out);\n<line_number-1411>    }\n<line_number-1412>\n<line_number-1413>    @Override\n<line_number-1414>    public Date getDate(int columnIndex, Calendar cal) throws SQLException {\n<line_number-1415>        Date d = getDate(columnIndex);\n<line_number-1416>        if (d == null) {\n<line_number-1417>            return null;\n<line_number-1418>        }\n<line_number-1419>        cal.setTime(d);\n<line_number-1420>        return new Date(cal.getTime().getTime());\n<line_number-1421>    }\n<line_number-1422>\n<line_number-1423>    @Override\n<line_number-1424>    public Date getDate(String columnLabel, Calendar cal) throws SQLException {\n<line_number-1425>        Date d = getDate(columnLabel);\n<line_number-1426>        if (d == null) {\n<line_number-1427>            return null;\n<line_number-1428>        }\n<line_number-1429>        cal.setTime(d);\n<line_number-1430>        return new Date(cal.getTime().getTime());\n<line_number-1431>    }\n<line_number-1432>\n<line_number-1433>    protected Time getTime(BsonValue o) throws SQLException {\n<line_number-1434>        java.util.Date utilDate = getUtilDate(o);\n<line_number-1435>        return (utilDate == null) ? null : new Time(utilDate.getTime());\n<line_number-1436>    }\n<line_number-1437>\n<line_number-1438>    @Override\n<line_number-1439>    public Time getTime(String columnLabel) throws SQLException {\n<line_number-1440>        BsonValue out = getBsonValue(columnLabel);\n<line_number-1441>        return getTime(out);\n<line_number-1442>    }\n<line_number-1443>\n<line_number-1444>    @Override\n<line_number-1445>    public Time getTime(int columnIndex) throws SQLException {\n<line_number-1446>        BsonValue out = getBsonValue(columnIndex);\n<line_number-1447>        return getTime(out);\n<line_number-1448>    }\n<line_number-1449>\n<line_number-1450>    @Override\n<line_number-1451>    public Time getTime(int columnIndex, Calendar cal) throws SQLException {\n<line_number-1452>        Time d = getTime(columnIndex);\n<line_number-1453>        if (d == null) {\n<line_number-1454>            return null;\n<line_number-1455>        }\n<line_number-1456>        cal.setTime(d);\n<line_number-1457>        return new Time(cal.getTime().getTime());\n<line_number-1458>    }\n<line_number-1459>\n<line_number-1460>    @Override\n<line_number-1461>    public Time getTime(String columnLabel, Calendar cal) throws SQLException {\n<line_number-1462>        Time d = getTime(columnLabel);\n<line_number-1463>        if (d == null) {\n<line_number-1464>            return null;\n<line_number-1465>        }\n<line_number-1466>        cal.setTime(d);\n<line_number-1467>        return new Time(cal.getTime().getTime());\n<line_number-1468>    }\n<line_number-1469>\n<line_number-1470>    protected Timestamp getTimestamp(BsonValue o) throws SQLException {\n<line_number-1471>        java.util.Date utilDate = getUtilDate(o);\n<line_number-1472>        return (utilDate == null) ? null : new Timestamp(utilDate.getTime());\n<line_number-1473>    }\n<line_number-1474>\n<line_number-1475>    @Override\n<line_number-1476>    public Timestamp getTimestamp(String columnLabel) throws SQLException {\n<line_number-1477>        BsonValue out = getBsonValue(columnLabel);\n<line_number-1478>        return getTimestamp(out);\n<line_number-1479>    }\n<line_number-1480>\n<line_number-1481>    @Override\n<line_number-1482>    public Timestamp getTimestamp(int columnIndex) throws SQLException {\n<line_number-1483>        BsonValue out = getBsonValue(columnIndex);\n<line_number-1484>        return getTimestamp(out);\n<line_number-1485>    }\n<line_number-1486>\n<line_number-1487>    @Override\n<line_number-1488>    public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {\n<line_number-1489>        Timestamp d = getTimestamp(columnIndex);\n<line_number-1490>        if (d == null) {\n<line_number-1491>            return null;\n<line_number-1492>        }\n<line_number-1493>        cal.setTime(d);\n<line_number-1494>        return new Timestamp(cal.getTime().getTime());\n<line_number-1495>    }\n<line_number-1496>\n<line_number-1497>    @Override\n<line_number-1498>    public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {\n<line_number-1499>        Timestamp d = getTimestamp(columnLabel);\n<line_number-1500>        if (d == null) {\n<line_number-1501>            return null;\n<line_number-1502>        }\n<line_number-1503>        cal.setTime(d);\n<line_number-1504>        return new Timestamp(cal.getTime().getTime());\n<line_number-1505>    }\n<line_number-1506>\n<line_number-1507>    // -------------------------- JDBC 3.0 ----------------------------------------\n<line_number-1508>\n<line_number-1509>    @Override\n<line_number-1510>    public java.net.URL getURL(int columnIndex) throws SQLException {\n<line_number-1511>        throw new SQLFeatureNotSupportedException(\n<line_number-1512>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1513>    }\n<line_number-1514>\n<line_number-1515>    @Override\n<line_number-1516>    public java.net.URL getURL(String columnLabel) throws SQLException {\n<line_number-1517>        throw new SQLFeatureNotSupportedException(\n<line_number-1518>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1519>    }\n<line_number-1520>\n<line_number-1521>    @Override\n<line_number-1522>    public void updateRef(int columnIndex, java.sql.Ref x) throws SQLException {\n<line_number-1523>        throw new SQLFeatureNotSupportedException(\n<line_number-1524>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1525>    }\n<line_number-1526>\n<line_number-1527>    @Override\n<line_number-1528>    public void updateRef(String columnLabel, java.sql.Ref x) throws SQLException {\n<line_number-1529>        throw new SQLFeatureNotSupportedException(\n<line_number-1530>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1531>    }\n<line_number-1532>\n<line_number-1533>    @Override\n<line_number-1534>    public void updateBlob(int columnIndex, java.sql.Blob x) throws SQLException {\n<line_number-1535>        throw new SQLFeatureNotSupportedException(\n<line_number-1536>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1537>    }\n<line_number-1538>\n<line_number-1539>    @Override\n<line_number-1540>    public void updateBlob(String columnLabel, java.sql.Blob x) throws SQLException {\n<line_number-1541>        throw new SQLFeatureNotSupportedException(\n<line_number-1542>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1543>    }\n<line_number-1544>\n<line_number-1545>    @Override\n<line_number-1546>    public void updateClob(int columnIndex, java.sql.Clob x) throws SQLException {\n<line_number-1547>        throw new SQLFeatureNotSupportedException(\n<line_number-1548>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1549>    }\n<line_number-1550>\n<line_number-1551>    @Override\n<line_number-1552>    public void updateClob(String columnLabel, java.sql.Clob x) throws SQLException {\n<line_number-1553>        throw new SQLFeatureNotSupportedException(\n<line_number-1554>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1555>    }\n<line_number-1556>\n<line_number-1557>    @Override\n<line_number-1558>    public void updateArray(int columnIndex, java.sql.Array x) throws SQLException {\n<line_number-1559>        throw new SQLFeatureNotSupportedException(\n<line_number-1560>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1561>    }\n<line_number-1562>\n<line_number-1563>    @Override\n<line_number-1564>    public void updateArray(String columnLabel, java.sql.Array x) throws SQLException {\n<line_number-1565>        throw new SQLFeatureNotSupportedException(\n<line_number-1566>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1567>    }\n<line_number-1568>\n<line_number-1569>    // ------------------------- JDBC 4.0 -----------------------------------\n<line_number-1570>\n<line_number-1571>    @Override\n<line_number-1572>    public RowId getRowId(int columnIndex) throws SQLException {\n<line_number-1573>        throw new SQLFeatureNotSupportedException(\n<line_number-1574>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1575>    }\n<line_number-1576>\n<line_number-1577>    @Override\n<line_number-1578>    public RowId getRowId(String columnLabel) throws SQLException {\n<line_number-1579>        throw new SQLFeatureNotSupportedException(\n<line_number-1580>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1581>    }\n<line_number-1582>\n<line_number-1583>    @Override\n<line_number-1584>    public void updateRowId(int columnIndex, RowId x) throws SQLException {\n<line_number-1585>        throw new SQLFeatureNotSupportedException(\n<line_number-1586>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1587>    }\n<line_number-1588>\n<line_number-1589>    @Override\n<line_number-1590>    public void updateRowId(String columnLabel, RowId x) throws SQLException {\n<line_number-1591>        throw new SQLFeatureNotSupportedException(\n<line_number-1592>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1593>    }\n<line_number-1594>\n<line_number-1595>    @Override\n<line_number-1596>    public int getHoldability() throws SQLException {\n<line_number-1597>        throw new SQLFeatureNotSupportedException(\n<line_number-1598>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1599>    }\n<line_number-1600>\n<line_number-1601>    @Override\n<line_number-1602>    public boolean isClosed() throws SQLException {\n<line_number-1603>        return closed;\n<line_number-1604>    }\n<line_number-1605>\n<line_number-1606>    @Override\n<line_number-1607>    public void updateNString(int columnIndex, String nString) throws SQLException {\n<line_number-1608>        throw new SQLFeatureNotSupportedException(\n<line_number-1609>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1610>    }\n<line_number-1611>\n<line_number-1612>    @Override\n<line_number-1613>    public void updateNString(String columnLabel, String nString) throws SQLException {\n<line_number-1614>        throw new SQLFeatureNotSupportedException(\n<line_number-1615>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1616>    }\n<line_number-1617>\n<line_number-1618>    @Override\n<line_number-1619>    public void updateNClob(int columnIndex, NClob nClob) throws SQLException {\n<line_number-1620>        throw new SQLFeatureNotSupportedException(\n<line_number-1621>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1622>    }\n<line_number-1623>\n<line_number-1624>    @Override\n<line_number-1625>    public void updateNClob(String columnLabel, NClob nClob) throws SQLException {\n<line_number-1626>        throw new SQLFeatureNotSupportedException(\n<line_number-1627>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1628>    }\n<line_number-1629>\n<line_number-1630>    @Override\n<line_number-1631>    public NClob getNClob(int columnIndex) throws SQLException {\n<line_number-1632>        throw new SQLFeatureNotSupportedException(\n<line_number-1633>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1634>    }\n<line_number-1635>\n<line_number-1636>    @Override\n<line_number-1637>    public NClob getNClob(String columnLabel) throws SQLException {\n<line_number-1638>        throw new SQLFeatureNotSupportedException(\n<line_number-1639>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1640>    }\n<line_number-1641>\n<line_number-1642>    @Override\n<line_number-1643>    public SQLXML getSQLXML(int columnIndex) throws SQLException {\n<line_number-1644>        throw new SQLFeatureNotSupportedException(\n<line_number-1645>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1646>    }\n<line_number-1647>\n<line_number-1648>    @Override\n<line_number-1649>    public SQLXML getSQLXML(String columnLabel) throws SQLException {\n<line_number-1650>        throw new SQLFeatureNotSupportedException(\n<line_number-1651>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1652>    }\n<line_number-1653>\n<line_number-1654>    @Override\n<line_number-1655>    public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {\n<line_number-1656>        throw new SQLFeatureNotSupportedException(\n<line_number-1657>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1658>    }\n<line_number-1659>\n<line_number-1660>    @Override\n<line_number-1661>    public void updateSQLXML(String columnLabel, SQLXML xmlObject) throws SQLException {\n<line_number-1662>        throw new SQLFeatureNotSupportedException(\n<line_number-1663>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1664>    }\n<line_number-1665>\n<line_number-1666>    @Override\n<line_number-1667>    public String getNString(int columnIndex) throws SQLException {\n<line_number-1668>        return getString(columnIndex);\n<line_number-1669>    }\n<line_number-1670>\n<line_number-1671>    @Override\n<line_number-1672>    public String getNString(String columnLabel) throws SQLException {\n<line_number-1673>        return getString(columnLabel);\n<line_number-1674>    }\n<line_number-1675>\n<line_number-1676>    @Override\n<line_number-1677>    public java.io.Reader getNCharacterStream(int columnIndex) throws SQLException {\n<line_number-1678>        return new java.io.StringReader(getString(columnIndex));\n<line_number-1679>    }\n<line_number-1680>\n<line_number-1681>    @Override\n<line_number-1682>    public java.io.Reader getNCharacterStream(String columnLabel) throws SQLException {\n<line_number-1683>        return new java.io.StringReader(getString(columnLabel));\n<line_number-1684>    }\n<line_number-1685>\n<line_number-1686>    @Override\n<line_number-1687>    public void updateNCharacterStream(int columnIndex, java.io.Reader x, long length)\n<line_number-1688>            throws SQLException {\n<line_number-1689>        throw new SQLFeatureNotSupportedException(\n<line_number-1690>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1691>    }\n<line_number-1692>\n<line_number-1693>    @Override\n<line_number-1694>    public void updateNCharacterStream(String columnLabel, java.io.Reader reader, long length)\n<line_number-1695>            throws SQLException {\n<line_number-1696>        throw new SQLFeatureNotSupportedException(\n<line_number-1697>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1698>    }\n<line_number-1699>\n<line_number-1700>    @Override\n<line_number-1701>    public void updateAsciiStream(int columnIndex, java.io.InputStream x, long length)\n<line_number-1702>            throws SQLException {\n<line_number-1703>        throw new SQLFeatureNotSupportedException(\n<line_number-1704>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1705>    }\n<line_number-1706>\n<line_number-1707>    @Override\n<line_number-1708>    public void updateBinaryStream(int columnIndex, java.io.InputStream x, long length)\n<line_number-1709>            throws SQLException {\n<line_number-1710>        throw new SQLFeatureNotSupportedException(\n<line_number-1711>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1712>    }\n<line_number-1713>\n<line_number-1714>    @Override\n<line_number-1715>    public void updateCharacterStream(int columnIndex, java.io.Reader x, long length)\n<line_number-1716>            throws SQLException {\n<line_number-1717>        throw new SQLFeatureNotSupportedException(\n<line_number-1718>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1719>    }\n<line_number-1720>\n<line_number-1721>    @Override\n<line_number-1722>    public void updateAsciiStream(String columnLabel, java.io.InputStream x, long length)\n<line_number-1723>            throws SQLException {\n<line_number-1724>        throw new SQLFeatureNotSupportedException(\n<line_number-1725>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1726>    }\n<line_number-1727>\n<line_number-1728>    @Override\n<line_number-1729>    public void updateBinaryStream(String columnLabel, java.io.InputStream x, long length)\n<line_number-1730>            throws SQLException {\n<line_number-1731>        throw new SQLFeatureNotSupportedException(\n<line_number-1732>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1733>    }\n<line_number-1734>\n<line_number-1735>    @Override\n<line_number-1736>    public void updateCharacterStream(String columnLabel, java.io.Reader reader, long length)\n<line_number-1737>            throws SQLException {\n<line_number-1738>        throw new SQLFeatureNotSupportedException(\n<line_number-1739>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1740>    }\n<line_number-1741>\n<line_number-1742>    @Override\n<line_number-1743>    public void updateBlob(int columnIndex, InputStream inputStream, long length)\n<line_number-1744>            throws SQLException {\n<line_number-1745>        throw new SQLFeatureNotSupportedException(\n<line_number-1746>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1747>    }\n<line_number-1748>\n<line_number-1749>    @Override\n<line_number-1750>    public void updateBlob(String columnLabel, InputStream inputStream, long length)\n<line_number-1751>            throws SQLException {\n<line_number-1752>        throw new SQLFeatureNotSupportedException(\n<line_number-1753>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1754>    }\n<line_number-1755>\n<line_number-1756>    @Override\n<line_number-1757>    public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {\n<line_number-1758>        throw new SQLFeatureNotSupportedException(\n<line_number-1759>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1760>    }\n<line_number-1761>\n<line_number-1762>    @Override\n<line_number-1763>    public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {\n<line_number-1764>        throw new SQLFeatureNotSupportedException(\n<line_number-1765>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1766>    }\n<line_number-1767>\n<line_number-1768>    @Override\n<line_number-1769>    public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {\n<line_number-1770>        throw new SQLFeatureNotSupportedException(\n<line_number-1771>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1772>    }\n<line_number-1773>\n<line_number-1774>    @Override\n<line_number-1775>    public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {\n<line_number-1776>        throw new SQLFeatureNotSupportedException(\n<line_number-1777>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1778>    }\n<line_number-1779>\n<line_number-1780>    // ---\n<line_number-1781>\n<line_number-1782>    @Override\n<line_number-1783>    public void updateNCharacterStream(int columnIndex, java.io.Reader x) throws SQLException {\n<line_number-1784>        throw new SQLFeatureNotSupportedException(\n<line_number-1785>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1786>    }\n<line_number-1787>\n<line_number-1788>    @Override\n<line_number-1789>    public void updateNCharacterStream(String columnLabel, java.io.Reader reader)\n<line_number-1790>            throws SQLException {\n<line_number-1791>        throw new SQLFeatureNotSupportedException(\n<line_number-1792>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1793>    }\n<line_number-1794>\n<line_number-1795>    @Override\n<line_number-1796>    public void updateAsciiStream(int columnIndex, java.io.InputStream x) throws SQLException {\n<line_number-1797>        throw new SQLFeatureNotSupportedException(\n<line_number-1798>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1799>    }\n<line_number-1800>\n<line_number-1801>    @Override\n<line_number-1802>    public void updateBinaryStream(int columnIndex, java.io.InputStream x) throws SQLException {\n<line_number-1803>        throw new SQLFeatureNotSupportedException(\n<line_number-1804>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1805>    }\n<line_number-1806>\n<line_number-1807>    @Override\n<line_number-1808>    public void updateCharacterStream(int columnIndex, java.io.Reader x) throws SQLException {\n<line_number-1809>        throw new SQLFeatureNotSupportedException(\n<line_number-1810>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1811>    }\n<line_number-1812>\n<line_number-1813>    @Override\n<line_number-1814>    public void updateAsciiStream(String columnLabel, java.io.InputStream x) throws SQLException {\n<line_number-1815>        throw new SQLFeatureNotSupportedException(\n<line_number-1816>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1817>    }\n<line_number-1818>\n<line_number-1819>    @Override\n<line_number-1820>    public void updateBinaryStream(String columnLabel, java.io.InputStream x) throws SQLException {\n<line_number-1821>        throw new SQLFeatureNotSupportedException(\n<line_number-1822>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1823>    }\n<line_number-1824>\n<line_number-1825>    @Override\n<line_number-1826>    public void updateCharacterStream(String columnLabel, java.io.Reader reader)\n<line_number-1827>            throws SQLException {\n<line_number-1828>        throw new SQLFeatureNotSupportedException(\n<line_number-1829>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1830>    }\n<line_number-1831>\n<line_number-1832>    @Override\n<line_number-1833>    public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {\n<line_number-1834>        throw new SQLFeatureNotSupportedException(\n<line_number-1835>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1836>    }\n<line_number-1837>\n<line_number-1838>    @Override\n<line_number-1839>    public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {\n<line_number-1840>        throw new SQLFeatureNotSupportedException(\n<line_number-1841>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1842>    }\n<line_number-1843>\n<line_number-1844>    @Override\n<line_number-1845>    public void updateClob(int columnIndex, Reader reader) throws SQLException {\n<line_number-1846>        throw new SQLFeatureNotSupportedException(\n<line_number-1847>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1848>    }\n<line_number-1849>\n<line_number-1850>    @Override\n<line_number-1851>    public void updateClob(String columnLabel, Reader reader) throws SQLException {\n<line_number-1852>        throw new SQLFeatureNotSupportedException(\n<line_number-1853>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1854>    }\n<line_number-1855>\n<line_number-1856>    @Override\n<line_number-1857>    public void updateNClob(int columnIndex, Reader reader) throws SQLException {\n<line_number-1858>        throw new SQLFeatureNotSupportedException(\n<line_number-1859>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1860>    }\n<line_number-1861>\n<line_number-1862>    @Override\n<line_number-1863>    public void updateNClob(String columnLabel, Reader reader) throws SQLException {\n<line_number-1864>        throw new SQLFeatureNotSupportedException(\n<line_number-1865>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1866>    }\n<line_number-1867>\n<line_number-1868>    // ------------------------- JDBC 4.2 -----------------------------------\n<line_number-1869>\n<line_number-1870>    @Override\n<line_number-1871>    public void updateObject(int columnIndex, Object x, SQLType targetSqlType, int scaleOrLength)\n<line_number-1872>            throws SQLException {\n<line_number-1873>        throw new SQLFeatureNotSupportedException(\n<line_number-1874>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1875>    }\n<line_number-1876>\n<line_number-1877>    @Override\n<line_number-1878>    public void updateObject(String columnLabel, Object x, SQLType targetSqlType, int scaleOrLength)\n<line_number-1879>            throws SQLException {\n<line_number-1880>        throw new SQLFeatureNotSupportedException(\n<line_number-1881>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1882>    }\n<line_number-1883>\n<line_number-1884>    @Override\n<line_number-1885>    public void updateObject(int columnIndex, Object x, SQLType targetSqlType) throws SQLException {\n<line_number-1886>        throw new SQLFeatureNotSupportedException(\n<line_number-1887>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1888>    }\n<line_number-1889>\n<line_number-1890>    @Override\n<line_number-1891>    public void updateObject(String columnLabel, Object x, SQLType targetSqlType)\n<line_number-1892>            throws SQLException {\n<line_number-1893>        throw new SQLFeatureNotSupportedException(\n<line_number-1894>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-1895>    }\n<line_number-1896>\n<line_number-1897>    // java.sql.Wrapper impl\n<line_number-1898>    @Override\n<line_number-1899>    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n<line_number-1900>        return iface.isInstance(this);\n<line_number-1901>    }\n<line_number-1902>\n<line_number-1903>    @SuppressWarnings(\"unchecked\")\n<line_number-1904>    @Override\n<line_number-1905>    public <T> T unwrap(Class<T> iface) throws SQLException {\n<line_number-1906>        return (T) this;\n<line_number-1907>    }\n<line_number-1908>}\n",
        "comments": [
          {
            "comment_code_range": "65-66",
            "comment_linenumber": "64",
            "comment": "Defines the MongoResultSet class which implements the ResultSet interface for MongoDB data retrieval.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "92-127",
            "comment_linenumber": "91",
            "comment": "Constructor for a MongoResultSet tied to a connection and statement, initializing the result set with the provided cursor and schema.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "129-142",
            "comment_linenumber": "128",
            "comment": "Constructor for a MongoResultSet not tied to a statement, used for MongoDatabaseMetaData.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "144-168",
            "comment_linenumber": "143",
            "comment": "Sets up the result set with the provided cursor, schema, and select order, ensuring proper initialization.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "171-175",
            "comment_linenumber": "170",
            "comment": "Package-private method to retrieve the current BsonDocument for testing purposes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "177-185",
            "comment_linenumber": "176",
            "comment": "Checks the bounds of the current row index and throws SQLException if out of bounds or if no current row exists.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "187-210",
            "comment_linenumber": "186",
            "comment": "Advances the cursor to the next row in the result set, logging the operation and handling exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "212-222",
            "comment_linenumber": "211",
            "comment": "Closes the result set and releases any resources associated with it, ensuring proper cleanup.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "224-228",
            "comment_linenumber": "223",
            "comment": "Checks if the cursor is at the last row of the result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "230-234",
            "comment_linenumber": "229",
            "comment": "Retrieves the BsonValue for the specified column index from the current row.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "237-247",
            "comment_linenumber": "236",
            "comment": "Retrieves the BsonValue for the specified column label from the current row.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "251-253",
            "comment_linenumber": "250",
            "comment": "Checks if the result set is closed and throws SQLException if it is.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "255-259",
            "comment_linenumber": "254",
            "comment": "Returns true if the last retrieved value was null, adhering to JDBC API requirements.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "261-281",
            "comment_linenumber": "260",
            "comment": "Checks if the provided BsonValue is null or undefined, updating the wasNull flag accordingly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "284-288",
            "comment_linenumber": "283",
            "comment": "Deprecated method for retrieving BigDecimal, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "291-312",
            "comment_linenumber": "290",
            "comment": "Handles conversion failures for byte arrays, throwing SQLException.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "315-320",
            "comment_linenumber": "314",
            "comment": "Retrieves byte array representation of the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "322-327",
            "comment_linenumber": "321",
            "comment": "Retrieves byte array representation of the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "328-332",
            "comment_linenumber": "327",
            "comment": "Creates a new ByteArrayInputStream from the provided byte array.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "335-341",
            "comment_linenumber": "334",
            "comment": "Retrieves an ASCII stream for the specified column index, converting the string to bytes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "346-352",
            "comment_linenumber": "345",
            "comment": "Retrieves an ASCII stream for the specified column label, converting the string to bytes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "355-373",
            "comment_linenumber": "354",
            "comment": "Deprecated method for retrieving Unicode stream, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "377-384",
            "comment_linenumber": "376",
            "comment": "Retrieves a binary stream for the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "387-394",
            "comment_linenumber": "386",
            "comment": "Retrieves a binary stream for the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "398-408",
            "comment_linenumber": "397",
            "comment": "Retrieves string representation of the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "410-412",
            "comment_linenumber": "409",
            "comment": "Handles conversion failures for boolean values, throwing SQLException.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "414-444",
            "comment_linenumber": "413",
            "comment": "Retrieves boolean value from the specified BsonValue, handling various BSON types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "447-451",
            "comment_linenumber": "446",
            "comment": "Retrieves boolean value for the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "453-457",
            "comment_linenumber": "452",
            "comment": "Retrieves boolean value for the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "459-461",
            "comment_linenumber": "458",
            "comment": "Retrieves byte value from the specified BsonValue.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "465-469",
            "comment_linenumber": "464",
            "comment": "Retrieves byte value for the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "471-475",
            "comment_linenumber": "470",
            "comment": "Retrieves byte value for the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "477-481",
            "comment_linenumber": "476",
            "comment": "Retrieves short value from the specified BsonValue.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "483-487",
            "comment_linenumber": "482",
            "comment": "Retrieves short value for the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "489-493",
            "comment_linenumber": "488",
            "comment": "Retrieves short value for the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "495-499",
            "comment_linenumber": "494",
            "comment": "Retrieves int value from the specified BsonValue.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "502-506",
            "comment_linenumber": "501",
            "comment": "Retrieves int value for the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "508-512",
            "comment_linenumber": "507",
            "comment": "Retrieves int value for the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "514-516",
            "comment_linenumber": "513",
            "comment": "Handles conversion failures for long values, throwing SQLException.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "518-550",
            "comment_linenumber": "517",
            "comment": "Retrieves long value from the specified BsonValue, handling various BSON types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "554-558",
            "comment_linenumber": "553",
            "comment": "Retrieves long value for the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "561-565",
            "comment_linenumber": "560",
            "comment": "Retrieves long value for the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "567-571",
            "comment_linenumber": "566",
            "comment": "Retrieves float value from the specified BsonValue.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "574-578",
            "comment_linenumber": "573",
            "comment": "Retrieves float value for the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "581-585",
            "comment_linenumber": "580",
            "comment": "Retrieves float value for the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "586-588",
            "comment_linenumber": "585",
            "comment": "Handles conversion failures for double values, throwing SQLException.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "590-619",
            "comment_linenumber": "589",
            "comment": "Retrieves double value from the specified BsonValue, handling various BSON types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "622-626",
            "comment_linenumber": "621",
            "comment": "Retrieves double value for the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "628-632",
            "comment_linenumber": "627",
            "comment": "Retrieves double value for the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "633-637",
            "comment_linenumber": "632",
            "comment": "Deprecated method for retrieving BigDecimal, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "640-646",
            "comment_linenumber": "639",
            "comment": "Retrieves SQL warnings for the current result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "648-651",
            "comment_linenumber": "647",
            "comment": "Clears any warnings associated with the current result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "653-661",
            "comment_linenumber": "652",
            "comment": "Retrieves the cursor name associated with the current statement or cursor.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "664-668",
            "comment_linenumber": "663",
            "comment": "Retrieves metadata for the current result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "670-746",
            "comment_linenumber": "669",
            "comment": "Retrieves an object from the result set based on the specified column type, handling various BSON types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "749-755",
            "comment_linenumber": "748",
            "comment": "Retrieves an object based on the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "757-761",
            "comment_linenumber": "756",
            "comment": "Retrieves an object based on the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "763-781",
            "comment_linenumber": "762",
            "comment": "Retrieves an object based on the specified column index and a mapping of SQL types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "783-795",
            "comment_linenumber": "782",
            "comment": "Retrieves an object based on the specified column label and a mapping of SQL types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "797-799",
            "comment_linenumber": "796",
            "comment": "Retrieves an object based on the specified column index and type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "801-803",
            "comment_linenumber": "800",
            "comment": "Retrieves an object based on the specified column label and type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "805-810",
            "comment_linenumber": "804",
            "comment": "Finds the column index based on the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "812-814",
            "comment_linenumber": "811",
            "comment": "Retrieves the character stream for the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "825-827",
            "comment_linenumber": "824",
            "comment": "Retrieves the character stream for the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "830-866",
            "comment_linenumber": "829",
            "comment": "Handles conversion failures for BigDecimal, throwing SQLException.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "868-879",
            "comment_linenumber": "867",
            "comment": "Retrieves BigDecimal value from the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "881-879",
            "comment_linenumber": "880",
            "comment": "Retrieves BigDecimal value from the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "882-892",
            "comment_linenumber": "881",
            "comment": "Checks if the cursor is before the first row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "894-896",
            "comment_linenumber": "893",
            "comment": "Checks if the cursor is after the last row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "898-900",
            "comment_linenumber": "897",
            "comment": "Checks if the cursor is at the first row.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "903-905",
            "comment_linenumber": "902",
            "comment": "Moves the cursor before the first row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "907-909",
            "comment_linenumber": "906",
            "comment": "Moves the cursor after the last row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "911-919",
            "comment_linenumber": "910",
            "comment": "Moves the cursor to the first row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "921-923",
            "comment_linenumber": "920",
            "comment": "Moves the cursor to the last row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "927-931",
            "comment_linenumber": "926",
            "comment": "Retrieves the current row number.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "933-935",
            "comment_linenumber": "932",
            "comment": "Moves the cursor to the specified row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "939-941",
            "comment_linenumber": "938",
            "comment": "Moves the cursor relative to the current position, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "945-949",
            "comment_linenumber": "944",
            "comment": "Moves the cursor to the previous row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "951-953",
            "comment_linenumber": "950",
            "comment": "Sets the fetch direction for the result set, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "961-963",
            "comment_linenumber": "960",
            "comment": "Retrieves the fetch direction for the result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "967-969",
            "comment_linenumber": "966",
            "comment": "Sets the fetch size for the result set, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "973-975",
            "comment_linenumber": "972",
            "comment": "Retrieves the fetch size for the result set, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "979-981",
            "comment_linenumber": "978",
            "comment": "Retrieves the type of the result set, indicating it is forward-only.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "986-988",
            "comment_linenumber": "985",
            "comment": "Retrieves the concurrency type of the result set, indicating it is read-only.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "991-1011",
            "comment_linenumber": "990",
            "comment": "Checks if the current row has been updated, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1013-1015",
            "comment_linenumber": "1012",
            "comment": "Checks if the current row has been inserted, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1017-1019",
            "comment_linenumber": "1016",
            "comment": "Checks if the current row has been deleted, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1021-1023",
            "comment_linenumber": "1020",
            "comment": "Updates the current row to null, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1025-1027",
            "comment_linenumber": "1024",
            "comment": "Updates the current row to a boolean value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1029-1031",
            "comment_linenumber": "1028",
            "comment": "Updates the current row to a byte value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1033-1035",
            "comment_linenumber": "1032",
            "comment": "Updates the current row to a short value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1037-1039",
            "comment_linenumber": "1036",
            "comment": "Updates the current row to an int value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1041-1043",
            "comment_linenumber": "1040",
            "comment": "Updates the current row to a long value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1045-1047",
            "comment_linenumber": "1044",
            "comment": "Updates the current row to a float value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1049-1051",
            "comment_linenumber": "1048",
            "comment": "Updates the current row to a double value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1053-1055",
            "comment_linenumber": "1052",
            "comment": "Updates the current row to a BigDecimal value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1057-1059",
            "comment_linenumber": "1056",
            "comment": "Updates the current row to a string value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1061-1063",
            "comment_linenumber": "1060",
            "comment": "Updates the current row to a byte array, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1065-1067",
            "comment_linenumber": "1064",
            "comment": "Updates the current row to a date value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1069-1071",
            "comment_linenumber": "1068",
            "comment": "Updates the current row to a time value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1073-1075",
            "comment_linenumber": "1072",
            "comment": "Updates the current row to a timestamp value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1077-1079",
            "comment_linenumber": "1076",
            "comment": "Updates the current row to an ASCII stream, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1081-1083",
            "comment_linenumber": "1080",
            "comment": "Updates the current row to a binary stream, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1085-1087",
            "comment_linenumber": "1084",
            "comment": "Updates the current row to a character stream, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1089-1091",
            "comment_linenumber": "1088",
            "comment": "Updates the current row to an object, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1093-1095",
            "comment_linenumber": "1092",
            "comment": "Updates the current row to a null value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1097-1099",
            "comment_linenumber": "1096",
            "comment": "Inserts a new row into the result set, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1101-1103",
            "comment_linenumber": "1100",
            "comment": "Updates the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1105-1107",
            "comment_linenumber": "1104",
            "comment": "Deletes the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1109-1111",
            "comment_linenumber": "1108",
            "comment": "Refreshes the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1113-1115",
            "comment_linenumber": "1112",
            "comment": "Cancels any updates to the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1117-1119",
            "comment_linenumber": "1116",
            "comment": "Moves to the insert row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1121-1123",
            "comment_linenumber": "1120",
            "comment": "Moves to the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1129-1131",
            "comment_linenumber": "1128",
            "comment": "Retrieves the statement associated with this result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1295-1301",
            "comment_linenumber": "1294",
            "comment": "Creates a new Blob from the provided byte array.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1312-1316",
            "comment_linenumber": "1311",
            "comment": "Retrieves a Blob based on the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1318-1322",
            "comment_linenumber": "1317",
            "comment": "Retrieves a Blob based on the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1324-1328",
            "comment_linenumber": "1323",
            "comment": "Creates a new Clob from the provided BsonValue.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1331-1335",
            "comment_linenumber": "1330",
            "comment": "Retrieves a Clob based on the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1338-1341",
            "comment_linenumber": "1337",
            "comment": "Retrieves a Clob based on the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1343-1345",
            "comment_linenumber": "1342",
            "comment": "Retrieves an Array based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1350-1352",
            "comment_linenumber": "1349",
            "comment": "Retrieves a Ref based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1355-1357",
            "comment_linenumber": "1354",
            "comment": "Retrieves an Array based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1361-1363",
            "comment_linenumber": "1360",
            "comment": "Handles conversion failures for java.util.Date, throwing SQLException.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1365-1394",
            "comment_linenumber": "1364",
            "comment": "Retrieves java.util.Date from the specified BsonValue, handling various BSON types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1401-1411",
            "comment_linenumber": "1400",
            "comment": "Retrieves Date based on the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1414-1416",
            "comment_linenumber": "1413",
            "comment": "Retrieves Date based on the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1418-1420",
            "comment_linenumber": "1417",
            "comment": "Retrieves Date based on the specified column index and Calendar.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1423-1425",
            "comment_linenumber": "1422",
            "comment": "Retrieves Date based on the specified column label and Calendar.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1433-1435",
            "comment_linenumber": "1432",
            "comment": "Retrieves Time from the specified BsonValue.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1438-1440",
            "comment_linenumber": "1437",
            "comment": "Retrieves Time based on the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1444-1446",
            "comment_linenumber": "1443",
            "comment": "Retrieves Time based on the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1451-1453",
            "comment_linenumber": "1450",
            "comment": "Retrieves Time based on the specified column index and Calendar.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1458-1460",
            "comment_linenumber": "1457",
            "comment": "Retrieves Time based on the specified column label and Calendar.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1470-1472",
            "comment_linenumber": "1469",
            "comment": "Retrieves Timestamp from the specified BsonValue.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1475-1477",
            "comment_linenumber": "1474",
            "comment": "Retrieves Timestamp based on the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1481-1483",
            "comment_linenumber": "1480",
            "comment": "Retrieves Timestamp based on the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1489-1491",
            "comment_linenumber": "1488",
            "comment": "Retrieves Timestamp based on the specified column index and Calendar.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1496-1498",
            "comment_linenumber": "1495",
            "comment": "Retrieves Timestamp based on the specified column label and Calendar.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1501-1503",
            "comment_linenumber": "1500",
            "comment": "Retrieves URL based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1515-1517",
            "comment_linenumber": "1514",
            "comment": "Retrieves URL based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1521-1523",
            "comment_linenumber": "1520",
            "comment": "Updates the current row to a Ref value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1527-1529",
            "comment_linenumber": "1526",
            "comment": "Updates the current row to a Ref value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1533-1535",
            "comment_linenumber": "1532",
            "comment": "Updates the current row to a Blob value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1539-1541",
            "comment_linenumber": "1538",
            "comment": "Updates the current row to a Blob value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1545-1547",
            "comment_linenumber": "1544",
            "comment": "Updates the current row to a Clob value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1551-1553",
            "comment_linenumber": "1550",
            "comment": "Updates the current row to a Clob value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1557-1559",
            "comment_linenumber": "1556",
            "comment": "Updates the current row to an Array value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1563-1565",
            "comment_linenumber": "1562",
            "comment": "Updates the current row to a Ref value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1569-1571",
            "comment_linenumber": "1568",
            "comment": "Updates the current row to an Array value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1575-1577",
            "comment_linenumber": "1574",
            "comment": "Retrieves RowId based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1581-1583",
            "comment_linenumber": "1580",
            "comment": "Retrieves RowId based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1587-1589",
            "comment_linenumber": "1586",
            "comment": "Updates the current row to a RowId value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1593-1595",
            "comment_linenumber": "1592",
            "comment": "Updates the current row to a RowId value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1599-1601",
            "comment_linenumber": "1598",
            "comment": "Retrieves the holdability of the result set, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1603-1605",
            "comment_linenumber": "1602",
            "comment": "Checks if the result set is closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1607-1609",
            "comment_linenumber": "1606",
            "comment": "Updates the current row to an NString value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1613-1615",
            "comment_linenumber": "1612",
            "comment": "Updates the current row to an NString value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1619-1621",
            "comment_linenumber": "1618",
            "comment": "Updates the current row to an NClob value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1625-1627",
            "comment_linenumber": "1624",
            "comment": "Updates the current row to an NClob value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1631-1633",
            "comment_linenumber": "1630",
            "comment": "Retrieves an NClob based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1637-1639",
            "comment_linenumber": "1636",
            "comment": "Retrieves an NClob based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1643-1645",
            "comment_linenumber": "1642",
            "comment": "Retrieves SQLXML based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1649-1651",
            "comment_linenumber": "1648",
            "comment": "Retrieves SQLXML based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1655-1657",
            "comment_linenumber": "1654",
            "comment": "Updates the current row to an SQLXML value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1661-1663",
            "comment_linenumber": "1660",
            "comment": "Updates the current row to an SQLXML value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1667-1669",
            "comment_linenumber": "1666",
            "comment": "Retrieves NString based on the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1671-1673",
            "comment_linenumber": "1670",
            "comment": "Retrieves NString based on the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1676-1678",
            "comment_linenumber": "1675",
            "comment": "Retrieves NCharacterStream based on the specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1681-1683",
            "comment_linenumber": "1680",
            "comment": "Retrieves NCharacterStream based on the specified column label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1686-1688",
            "comment_linenumber": "1685",
            "comment": "Updates the current row to an NCharacterStream value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1691-1693",
            "comment_linenumber": "1690",
            "comment": "Updates the current row to an NCharacterStream value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1697-1699",
            "comment_linenumber": "1696",
            "comment": "Updates the current row to an ASCII stream value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1701-1703",
            "comment_linenumber": "1700",
            "comment": "Updates the current row to a binary stream value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1705-1707",
            "comment_linenumber": "1704",
            "comment": "Updates the current row to a character stream value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1710-1712",
            "comment_linenumber": "1709",
            "comment": "Updates the current row to an ASCII stream value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1715-1717",
            "comment_linenumber": "1714",
            "comment": "Updates the current row to a binary stream value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1720-1722",
            "comment_linenumber": "1719",
            "comment": "Updates the current row to a character stream value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1725-1727",
            "comment_linenumber": "1724",
            "comment": "Updates the current row to an object value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1730-1732",
            "comment_linenumber": "1729",
            "comment": "Updates the current row to a null value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1735-1737",
            "comment_linenumber": "1734",
            "comment": "Inserts a new row into the result set, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1740-1742",
            "comment_linenumber": "1739",
            "comment": "Updates the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1745-1747",
            "comment_linenumber": "1744",
            "comment": "Deletes the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1750-1752",
            "comment_linenumber": "1749",
            "comment": "Refreshes the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1755-1757",
            "comment_linenumber": "1754",
            "comment": "Cancels any updates to the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1760-1762",
            "comment_linenumber": "1759",
            "comment": "Moves to the insert row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1765-1767",
            "comment_linenumber": "1764",
            "comment": "Moves to the current row, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1770-1772",
            "comment_linenumber": "1769",
            "comment": "Retrieves the statement associated with this result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1775-1777",
            "comment_linenumber": "1774",
            "comment": "Retrieves a Ref based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1780-1782",
            "comment_linenumber": "1779",
            "comment": "Retrieves a Blob based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1785-1787",
            "comment_linenumber": "1784",
            "comment": "Retrieves a Blob based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1790-1792",
            "comment_linenumber": "1789",
            "comment": "Retrieves a Clob based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1795-1797",
            "comment_linenumber": "1794",
            "comment": "Retrieves a Clob based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1800-1802",
            "comment_linenumber": "1799",
            "comment": "Retrieves an Array based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1805-1807",
            "comment_linenumber": "1804",
            "comment": "Retrieves a Ref based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1810-1812",
            "comment_linenumber": "1809",
            "comment": "Retrieves an Array based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1815-1817",
            "comment_linenumber": "1814",
            "comment": "Retrieves a RowId based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1820-1822",
            "comment_linenumber": "1819",
            "comment": "Retrieves a RowId based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1825-1827",
            "comment_linenumber": "1824",
            "comment": "Updates the current row to a RowId value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1830-1832",
            "comment_linenumber": "1829",
            "comment": "Updates the current row to a RowId value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1835-1837",
            "comment_linenumber": "1834",
            "comment": "Retrieves the holdability of the result set, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1840-1842",
            "comment_linenumber": "1839",
            "comment": "Checks if the result set is closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1845-1847",
            "comment_linenumber": "1844",
            "comment": "Updates the current row to an NString value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1851-1853",
            "comment_linenumber": "1850",
            "comment": "Updates the current row to an NString value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1857-1859",
            "comment_linenumber": "1856",
            "comment": "Updates the current row to an NClob value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1863-1865",
            "comment_linenumber": "1862",
            "comment": "Updates the current row to an NClob value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1869-1871",
            "comment_linenumber": "1868",
            "comment": "Retrieves an NClob based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1875-1877",
            "comment_linenumber": "1874",
            "comment": "Retrieves an NClob based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1881-1883",
            "comment_linenumber": "1880",
            "comment": "Retrieves SQLXML based on the specified column index, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1887-1889",
            "comment_linenumber": "1886",
            "comment": "Retrieves SQLXML based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1891-1893",
            "comment_linenumber": "1890",
            "comment": "Updates the current row to an SQLXML value, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1895-1897",
            "comment_linenumber": "1894",
            "comment": "Updates the current row to an SQLXML value based on the specified column label, not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1899-1901",
            "comment_linenumber": "1898",
            "comment": "Checks if the current object is an instance of the specified interface.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1903-1907",
            "comment_linenumber": "1902",
            "comment": "Unwraps the current object as the specified interface type.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file defines the MongoResultSet class, which implements the ResultSet interface for MongoDB data retrieval. It contains various methods to handle data types and operations specific to MongoDB, including methods for retrieving and converting BSON values to Java types. The class maintains state information such as the current row, cursor, and metadata. It includes two constructors for initializing the result set with or without a statement. The class also implements error handling for unsupported operations and provides logging capabilities. The methods are organized to handle various data types, including BigDecimal, byte arrays, and date/time types, while ensuring compliance with JDBC standards.",
        "file_summary": "This file implements the MongoResultSet class, which provides a JDBC-compliant interface for accessing MongoDB data. It handles data retrieval, conversion, and error management, ensuring that MongoDB data can be accessed in a manner consistent with standard SQL operations."
      }
    ]
  },
  "MongoResultSetMetaData.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoResultSetMetaData.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoResultSetMetaData.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoResultSetMetaData.java",
        "chunk_id": "MongoResultSetMetaData_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import com.mongodb.jdbc.logging.AutoLoggable;\n<line_number-20>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-21>import com.mongodb.jdbc.logging.QueryDiagnostics;\n<line_number-22>import java.math.BigDecimal;\n<line_number-23>import java.sql.ResultSetMetaData;\n<line_number-24>import java.sql.SQLException;\n<line_number-25>import java.sql.Timestamp;\n<line_number-26>import java.sql.Types;\n<line_number-27>import java.util.ArrayList;\n<line_number-28>import java.util.Arrays;\n<line_number-29>import java.util.HashMap;\n<line_number-30>import java.util.List;\n<line_number-31>import java.util.Map;\n<line_number-32>import java.util.stream.Collectors;\n<line_number-33>import org.bson.BsonType;\n<line_number-34>import org.bson.BsonValue;\n<line_number-35>\n<line_number-36>@AutoLoggable\n<line_number-37>public class MongoResultSetMetaData implements ResultSetMetaData {\n<line_number-38>\n<line_number-39>    private static class NameSpace {\n<line_number-40>        String datasource;\n<line_number-41>        String columnLabel;\n<line_number-42>\n<line_number-43>        NameSpace(String datasource, String columnLabel) {\n<line_number-44>            this.datasource = datasource;\n<line_number-45>            this.columnLabel = columnLabel;\n<line_number-46>        }\n<line_number-47>    }\n<line_number-48>\n<line_number-49>    private static class DatasourceAndIndex {\n<line_number-50>        String datasource;\n<line_number-51>        int index;\n<line_number-52>\n<line_number-53>        DatasourceAndIndex(String datasource, int index) {\n<line_number-54>            this.datasource = datasource;\n<line_number-55>            this.index = index;\n<line_number-56>        }\n<line_number-57>    }\n<line_number-58>\n<line_number-59>    // A mapping from columnLabel name to datasource name and index.\n<line_number-60>    private Map<String, List<DatasourceAndIndex>> columnLabels;\n<line_number-61>    // A mapping from index position to NameSpace (datasource, columnLabel).\n<line_number-62>    private List<NameSpace> columnIndices;\n<line_number-63>    // A mapping from index position to ColumnTypeInfo.\n<line_number-64>    private List<MongoColumnInfo> columnInfo;\n<line_number-65>    protected final int UNKNOWN_LENGTH = 0;\n<line_number-66>    protected MongoLogger logger;\n<line_number-67>\n<line_number-68>    /**\n<line_number-69>     * Constructor.\n<line_number-70>     *\n<line_number-71>     * @param schema The resultset schema.\n<line_number-72>     * @param sortFieldsAlphabetically Flag to set the fields sort order. True if fields must be\n<line_number-73>     *     sorted alphabetically. False otherwise.\n<line_number-74>     * @param parentLogger The parent connection logger.\n<line_number-75>     * @param statementId The statement id for the logger or null if this resultset is not tied to a\n<line_number-76>     *     statement.\n<line_number-77>     */\n<line_number-78>    public MongoResultSetMetaData(\n<line_number-79>            MongoJsonSchema schema,\n<line_number-80>            List<List<String>> selectOrder,\n<line_number-81>            boolean sortFieldsAlphabetically,\n<line_number-82>            MongoLogger parentLogger,\n<line_number-83>            Integer statementId,\n<line_number-84>            QueryDiagnostics queryDiagnostics)\n<line_number-85>            throws SQLException {\n<line_number-86>        this.logger =\n<line_number-87>                (statementId == null)\n<line_number-88>                        ? new MongoLogger(this.getClass().getCanonicalName(), parentLogger)\n<line_number-89>                        : new MongoLogger(\n<line_number-90>                                this.getClass().getCanonicalName(), parentLogger, statementId);\n<line_number-91>        if (queryDiagnostics != null) {\n<line_number-92>            logger.setQueryDiagnostics(queryDiagnostics);\n<line_number-93>        } else {\n<line_number-94>            logger.setResultSetSchema(schema);\n<line_number-95>        }\n<line_number-96>\n<line_number-97>        assertDatasourceSchema(schema);\n<line_number-98>\n<line_number-99>        columnLabels = new HashMap<String, List<DatasourceAndIndex>>();\n<line_number-100>        columnIndices = new ArrayList<NameSpace>();\n<line_number-101>        columnInfo = new ArrayList<MongoColumnInfo>();\n<line_number-102>\n<line_number-103>        if (selectOrder == null || selectOrder.isEmpty()) {\n<line_number-104>            String[] datasources = schema.properties.keySet().toArray(new String[0]);\n<line_number-105>            Arrays.sort(datasources);\n<line_number-106>\n<line_number-107>            for (String datasource : datasources) {\n<line_number-108>                processDataSource(schema, datasource, sortFieldsAlphabetically);\n<line_number-109>            }\n<line_number-110>        } else {\n<line_number-111>            processSelectOrder(selectOrder, schema);\n<line_number-112>        }\n<line_number-113>    }\n<line_number-114>\n<line_number-115>    private void assertDatasourceSchema(MongoJsonSchema schema) throws SQLException {\n<line_number-116>        // A Datasource Schema must be an Object Schema, and unlike Object Schemata in general,\n<line_number-117>        // the properties field cannot be null.\n<line_number-118>        if (!schema.isObject() || schema.properties == null) {\n<line_number-119>            throw new SQLException(\"ResultSetMetaData json schema must be object with properties\");\n<line_number-120>        }\n<line_number-121>    }\n<line_number-122>\n<line_number-123>    private void processDataSource(\n<line_number-124>            MongoJsonSchema schema, String datasource, boolean sortFieldsAlphabetically)\n<line_number-125>            throws SQLException {\n<line_number-126>        MongoJsonSchema datasourceSchema = schema.properties.get(datasource);\n<line_number-127>        assertDatasourceSchema(datasourceSchema);\n<line_number-128>\n<line_number-129>        List<String> fields = null;\n<line_number-130>        if (sortFieldsAlphabetically) {\n<line_number-131>            fields =\n<line_number-132>                    datasourceSchema\n<line_number-133>                            .properties\n<line_number-134>                            .keySet()\n<line_number-135>                            .stream()\n<line_number-136>                            .sorted()\n<line_number-137>                            .collect(Collectors.toList());\n<line_number-138>        } else {\n<line_number-139>            fields = datasourceSchema.properties.keySet().stream().collect(Collectors.toList());\n<line_number-140>        }\n<line_number-141>\n<line_number-142>        for (String field : fields) {\n<line_number-143>            processColumnInfo(datasource, field, datasourceSchema);\n<line_number-144>        }\n<line_number-145>    };\n<line_number-146>\n<line_number-147>    private void processSelectOrder(List<List<String>> selectOrder, MongoJsonSchema schema)\n<line_number-148>            throws SQLException {\n<line_number-149>\n<line_number-150>        // reset columnIndices and columnInfo to empty lists and populate in select order\n<line_number-151>        columnIndices = new ArrayList<NameSpace>();\n<line_number-152>        columnInfo = new ArrayList<MongoColumnInfo>();\n<line_number-153>        for (List<String> column : selectOrder) {\n<line_number-154>            String datasource = column.get(0);\n<line_number-155>            String field = column.get(1);\n<line_number-156>            MongoJsonSchema datasourceSchema = schema.properties.get(datasource);\n<line_number-157>            assertDatasourceSchema(datasourceSchema);\n<line_number-158>            processColumnInfo(datasource, field, datasourceSchema);\n<line_number-159>        }\n<line_number-160>    }\n<line_number-161>\n<line_number-162>    private void processColumnInfo(\n<line_number-163>            String datasource, String field, MongoJsonSchema datasourceSchema) throws SQLException {\n<line_number-164>        MongoJsonSchema columnSchema = datasourceSchema.properties.get(field);\n<line_number-165>        BsonTypeInfo columnBsonTypeInfo = columnSchema.getBsonTypeInfo();\n<line_number-166>        int nullability = datasourceSchema.getColumnNullability(field);\n<line_number-167>        columnIndices.add(new NameSpace(datasource, field));\n<line_number-168>        columnInfo.add(new MongoColumnInfo(datasource, field, columnBsonTypeInfo, nullability));\n<line_number-169>        if (!columnLabels.containsKey(field)) {\n<line_number-170>            List<DatasourceAndIndex> datasourceAndIndexList = new ArrayList<>();\n<line_number-171>            datasourceAndIndexList.add(\n<line_number-172>                    new DatasourceAndIndex(datasource, columnIndices.size() - 1));\n<line_number-173>            columnLabels.put(field, datasourceAndIndexList);\n<line_number-174>        } else {\n<line_number-175>            columnLabels\n<line_number-176>                    .get(field)\n<line_number-177>                    .add(new DatasourceAndIndex(datasource, columnIndices.size() - 1));\n<line_number-178>        }\n<line_number-179>    }\n<line_number-180>\n<line_number-181>    // This gets the datasource for a given columnLabel.\n<line_number-182>    // It is only used in our unit tests.\n<line_number-183>    protected String getDatasource(String columnLabel) throws Exception {\n<line_number-184>        List<DatasourceAndIndex> columnsForLabel = columnLabels.get(columnLabel);\n<line_number-185>        if (columnsForLabel.size() > 1) {\n<line_number-186>            throw new Exception(\n<line_number-187>                    String.format(\n<line_number-188>                            \"Multiple columns with the label '%s' exist. Use indexes to avoid ambiguity.\",\n<line_number-189>                            columnLabel));\n<line_number-190>        } else {\n<line_number-191>            return columnsForLabel.get(0).datasource;\n<line_number-192>        }\n<line_number-193>    }\n<line_number-194>\n<line_number-195>    protected void checkBounds(int i) throws SQLException {\n<line_number-196>        if (i > getColumnCount()) {\n<line_number-197>            throw new SQLException(\"Index out of bounds: '\" + i + \"'.\");\n<line_number-198>        }\n<line_number-199>    }\n<line_number-200>\n<line_number-201>    public MongoColumnInfo getColumnInfo(int column) throws SQLException {\n<line_number-202>        checkBounds(column);\n<line_number-203>        return columnInfo.get(column - 1);\n<line_number-204>    }\n<line_number-205>\n<line_number-206>    @Override\n<line_number-207>    public boolean isAutoIncrement(int column) throws SQLException {\n<line_number-208>        checkBounds(column);\n<line_number-209>        return false;\n<line_number-210>    }\n<line_number-211>\n<line_number-212>    @Override\n<line_number-213>    public boolean isSearchable(int column) throws SQLException {\n<line_number-214>        checkBounds(column);\n<line_number-215>        return true;\n<line_number-216>    }\n<line_number-217>\n<line_number-218>    @Override\n<line_number-219>    public boolean isCurrency(int column) throws SQLException {\n<line_number-220>        checkBounds(column);\n<line_number-221>        return false;\n<line_number-222>    }\n<line_number-223>\n<line_number-224>    @Override\n<line_number-225>    public String getSchemaName(int column) throws SQLException {\n<line_number-226>        checkBounds(column);\n<line_number-227>        return \"\";\n<line_number-228>    }\n<line_number-229>\n<line_number-230>    @Override\n<line_number-231>    public int getColumnCount() throws SQLException {\n<line_number-232>        return columnIndices.size();\n<line_number-233>    }\n<line_number-234>\n<line_number-235>    public boolean hasColumnWithLabel(String label) {\n<line_number-236>        return columnLabels.containsKey(label);\n<line_number-237>    }\n<line_number-238>\n<line_number-239>    public int getColumnPositionFromLabel(String label) throws Exception {\n<line_number-240>        List<DatasourceAndIndex> columnsForLabel = columnLabels.get(label);\n<line_number-241>        if (columnsForLabel.size() > 1) {\n<line_number-242>            throw new Exception(\n<line_number-243>                    \"Multiple columns with the label '\"\n<line_number-244>                            + label\n<line_number-245>                            + \"' exist. Use indexes to avoid ambiguity.\");\n<line_number-246>        } else {\n<line_number-247>            return columnsForLabel.get(0).index;\n<line_number-248>        }\n<line_number-249>    }\n<line_number-250>\n<line_number-251>    @Override\n<line_number-252>    public boolean isReadOnly(int column) throws SQLException {\n<line_number-253>        checkBounds(column);\n<line_number-254>        return true;\n<line_number-255>    }\n<line_number-256>\n<line_number-257>    @Override\n<line_number-258>    public boolean isWritable(int column) throws SQLException {\n<line_number-259>        checkBounds(column);\n<line_number-260>        return false;\n<line_number-261>    }\n<line_number-262>\n<line_number-263>    @Override\n<line_number-264>    public boolean isDefinitelyWritable(int column) throws SQLException {\n<line_number-265>        checkBounds(column);\n<line_number-266>        return false;\n<line_number-267>    }\n<line_number-268>\n<line_number-269>    @Override\n<line_number-270>    public int isNullable(int column) throws SQLException {\n<line_number-271>        return getColumnInfo(column).getNullability();\n<line_number-272>    }\n<line_number-273>\n<line_number-274>    @Override\n<line_number-275>    public String getColumnLabel(int column) throws SQLException {\n<line_number-276>        return getColumnInfo(column).getColumnAlias();\n<line_number-277>    }\n<line_number-278>\n<line_number-279>    @Override\n<line_number-280>    public String getColumnName(int column) throws SQLException {\n<line_number-281>        return getColumnInfo(column).getColumnName();\n<line_number-282>    }\n<line_number-283>\n<line_number-284>    @Override\n<line_number-285>    public String getTableName(int column) throws SQLException {\n<line_number-286>        return getColumnInfo(column).getTableAlias();\n<line_number-287>    }\n<line_number-288>\n<line_number-289>    @Override\n<line_number-290>    public String getCatalogName(int column) throws SQLException {\n<line_number-291>        return getColumnInfo(column).getDatabase();\n<line_number-292>    }\n<line_number-293>\n<line_number-294>    @Override\n<line_number-295>    public int getColumnType(int column) throws SQLException {\n<line_number-296>        return getColumnInfo(column).getJDBCType();\n<line_number-297>    }\n<line_number-298>\n<line_number-299>    @Override\n<line_number-300>    public String getColumnTypeName(int column) throws SQLException {\n<line_number-301>        return getColumnInfo(column).getBsonTypeName();\n<line_number-302>    }\n<line_number-303>\n<line_number-304>    // java.sql.Wrapper impl\n<line_number-305>    @Override\n<line_number-306>    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n<line_number-307>        return iface.isInstance(this);\n<line_number-308>    }\n<line_number-309>\n<line_number-310>    @SuppressWarnings(\"unchecked\")\n<line_number-311>    @Override\n<line_number-312>    public <T> T unwrap(Class<T> iface) throws SQLException {\n<line_number-313>        return (T) this;\n<line_number-314>    }\n<line_number-315>\n<line_number-316>    @Override\n<line_number-317>    public boolean isCaseSensitive(int column) throws SQLException {\n<line_number-318>        MongoColumnInfo ci = getColumnInfo(column);\n<line_number-319>        if (ci.isPolymorphic()) {\n<line_number-320>            return true;\n<line_number-321>        }\n<line_number-322>        BsonType t = ci.getBsonTypeEnum();\n<line_number-323>        switch (t) {\n<line_number-324>            case ARRAY:\n<line_number-325>            case BINARY:\n<line_number-326>            case BOOLEAN:\n<line_number-327>            case DATE_TIME:\n<line_number-328>            case DB_POINTER:\n<line_number-329>            case DECIMAL128:\n<line_number-330>            case DOCUMENT:\n<line_number-331>            case DOUBLE:\n<line_number-332>            case INT32:\n<line_number-333>            case INT64:\n<line_number-334>            case MAX_KEY:\n<line_number-335>            case MIN_KEY:\n<line_number-336>            case NULL:\n<line_number-337>            case OBJECT_ID:\n<line_number-338>            case TIMESTAMP:\n<line_number-339>            case UNDEFINED:\n<line_number-340>                return false;\n<line_number-341>            case JAVASCRIPT:\n<line_number-342>            case JAVASCRIPT_WITH_SCOPE:\n<line_number-343>            case REGULAR_EXPRESSION:\n<line_number-344>            case STRING:\n<line_number-345>            case SYMBOL:\n<line_number-346>                return true;\n<line_number-347>        }\n<line_number-348>        return false;\n<line_number-349>    }\n<line_number-350>\n<line_number-351>    @Override\n<line_number-352>    public boolean isSigned(int column) throws SQLException {\n<line_number-353>        MongoColumnInfo ci = getColumnInfo(column);\n<line_number-354>        if (ci.isPolymorphic()) {\n<line_number-355>            return true;\n<line_number-356>        }\n<line_number-357>        BsonType t = ci.getBsonTypeEnum();\n<line_number-358>        switch (t) {\n<line_number-359>            case DOUBLE:\n<line_number-360>            case DECIMAL128:\n<line_number-361>            case INT32:\n<line_number-362>            case INT64:\n<line_number-363>                return true;\n<line_number-364>            case ARRAY:\n<line_number-365>            case BINARY:\n<line_number-366>            case BOOLEAN:\n<line_number-367>            case DATE_TIME:\n<line_number-368>            case DB_POINTER:\n<line_number-369>            case DOCUMENT:\n<line_number-370>            case MAX_KEY:\n<line_number-371>            case MIN_KEY:\n<line_number-372>            case NULL:\n<line_number-373>            case OBJECT_ID:\n<line_number-374>            case TIMESTAMP:\n<line_number-375>            case UNDEFINED:\n<line_number-376>            case JAVASCRIPT:\n<line_number-377>            case JAVASCRIPT_WITH_SCOPE:\n<line_number-378>            case REGULAR_EXPRESSION:\n<line_number-379>            case STRING:\n<line_number-380>            case SYMBOL:\n<line_number-381>                return false;\n<line_number-382>        }\n<line_number-383>        return false;\n<line_number-384>    }\n<line_number-385>\n<line_number-386>    @Override\n<line_number-387>    public int getColumnDisplaySize(int column) throws SQLException {\n<line_number-388>        MongoColumnInfo ci = getColumnInfo(column);\n<line_number-389>        if (ci.isPolymorphic()) {\n<line_number-390>            return UNKNOWN_LENGTH;\n<line_number-391>        }\n<line_number-392>        BsonType t = ci.getBsonTypeEnum();\n<line_number-393>        switch (t) {\n<line_number-394>            case ARRAY:\n<line_number-395>                return UNKNOWN_LENGTH;\n<line_number-396>            case BINARY:\n<line_number-397>                return UNKNOWN_LENGTH;\n<line_number-398>            case BOOLEAN:\n<line_number-399>                return 1;\n<line_number-400>            case DATE_TIME:\n<line_number-401>                //24 characters to display.\n<line_number-402>                return 24;\n<line_number-403>            case DB_POINTER:\n<line_number-404>                return 0;\n<line_number-405>            case DECIMAL128:\n<line_number-406>                return 34;\n<line_number-407>            case DOCUMENT:\n<line_number-408>                return UNKNOWN_LENGTH;\n<line_number-409>            case DOUBLE:\n<line_number-410>                return 15;\n<line_number-411>            case INT32:\n<line_number-412>                return 10;\n<line_number-413>            case INT64:\n<line_number-414>                return 19;\n<line_number-415>            case JAVASCRIPT:\n<line_number-416>                return UNKNOWN_LENGTH;\n<line_number-417>            case JAVASCRIPT_WITH_SCOPE:\n<line_number-418>                return UNKNOWN_LENGTH;\n<line_number-419>            case MAX_KEY:\n<line_number-420>                return 0;\n<line_number-421>            case MIN_KEY:\n<line_number-422>                return 0;\n<line_number-423>            case NULL:\n<line_number-424>                return 0;\n<line_number-425>            case OBJECT_ID:\n<line_number-426>                return 24;\n<line_number-427>            case REGULAR_EXPRESSION:\n<line_number-428>                return UNKNOWN_LENGTH;\n<line_number-429>            case STRING:\n<line_number-430>                return UNKNOWN_LENGTH;\n<line_number-431>            case SYMBOL:\n<line_number-432>                return UNKNOWN_LENGTH;\n<line_number-433>            case TIMESTAMP:\n<line_number-434>                return UNKNOWN_LENGTH;\n<line_number-435>            case UNDEFINED:\n<line_number-436>                return 0;\n<line_number-437>        }\n<line_number-438>        throw new SQLException(\"unknown bson type: \" + t);\n<line_number-439>    }\n<line_number-440>\n<line_number-441>    @Override\n<line_number-442>    public int getPrecision(int column) throws SQLException {\n<line_number-443>        MongoColumnInfo ci = getColumnInfo(column);\n<line_number-444>        if (ci.isPolymorphic()) {\n<line_number-445>            return UNKNOWN_LENGTH;\n<line_number-446>        }\n<line_number-447>        BsonType t = ci.getBsonTypeEnum();\n<line_number-448>        switch (t) {\n<line_number-449>            case ARRAY:\n<line_number-450>                return UNKNOWN_LENGTH;\n<line_number-451>            case BINARY:\n<line_number-452>                return UNKNOWN_LENGTH;\n<line_number-453>            case BOOLEAN:\n<line_number-454>                return 1;\n<line_number-455>            case DATE_TIME:\n<line_number-456>                return 24;\n<line_number-457>            case DB_POINTER:\n<line_number-458>                return 0;\n<line_number-459>            case DECIMAL128:\n<line_number-460>                return 34;\n<line_number-461>            case DOCUMENT:\n<line_number-462>                return UNKNOWN_LENGTH;\n<line_number-463>            case DOUBLE:\n<line_number-464>                return 15;\n<line_number-465>            case INT32:\n<line_number-466>                return 10;\n<line_number-467>            case INT64:\n<line_number-468>                return 19;\n<line_number-469>            case JAVASCRIPT:\n<line_number-470>                return UNKNOWN_LENGTH;\n<line_number-471>            case JAVASCRIPT_WITH_SCOPE:\n<line_number-472>                return UNKNOWN_LENGTH;\n<line_number-473>            case MAX_KEY:\n<line_number-474>                return 0;\n<line_number-475>            case MIN_KEY:\n<line_number-476>                return 0;\n<line_number-477>            case NULL:\n<line_number-478>                return 0;\n<line_number-479>            case OBJECT_ID:\n<line_number-480>                return 24;\n<line_number-481>            case REGULAR_EXPRESSION:\n<line_number-482>                return UNKNOWN_LENGTH;\n<line_number-483>            case STRING:\n<line_number-484>                return UNKNOWN_LENGTH;\n<line_number-485>            case SYMBOL:\n<line_number-486>                return UNKNOWN_LENGTH;\n<line_number-487>            case TIMESTAMP:\n<line_number-488>                return 0;\n<line_number-489>            case UNDEFINED:\n<line_number-490>                return 0;\n<line_number-491>        }\n<line_number-492>        throw new SQLException(\"unknown bson type: \" + t);\n<line_number-493>    }\n<line_number-494>\n<line_number-495>    @Override\n<line_number-496>    public int getScale(int column) throws SQLException {\n<line_number-497>        MongoColumnInfo ci = getColumnInfo(column);\n<line_number-498>        if (ci.isPolymorphic()) {\n<line_number-499>            return UNKNOWN_LENGTH;\n<line_number-500>        }\n<line_number-501>        BsonType t = ci.getBsonTypeEnum();\n<line_number-502>        switch (t) {\n<line_number-503>            case ARRAY:\n<line_number-504>            case BINARY:\n<line_number-505>            case BOOLEAN:\n<line_number-506>            case DATE_TIME:\n<line_number-507>            case DB_POINTER:\n<line_number-508>            case DOCUMENT:\n<line_number-509>            case INT32:\n<line_number-510>            case INT64:\n<line_number-511>            case JAVASCRIPT:\n<line_number-512>            case JAVASCRIPT_WITH_SCOPE:\n<line_number-513>            case MAX_KEY:\n<line_number-514>            case MIN_KEY:\n<line_number-515>            case NULL:\n<line_number-516>            case OBJECT_ID:\n<line_number-517>            case REGULAR_EXPRESSION:\n<line_number-518>            case STRING:\n<line_number-519>            case SYMBOL:\n<line_number-520>            case TIMESTAMP:\n<line_number-521>            case UNDEFINED:\n<line_number-522>                return 0;\n<line_number-523>            case DECIMAL128:\n<line_number-524>                return 34;\n<line_number-525>            case DOUBLE:\n<line_number-526>                return 15;\n<line_number-527>        }\n<line_number-528>        throw new SQLException(\"unknown bson type: \" + t);\n<line_number-529>    }\n<line_number-530>\n<line_number-531>    // --------------------------JDBC 2.0-----------------------------------\n<line_number-532>    @Override\n<line_number-533>    public String getColumnClassName(int column) throws SQLException {\n<line_number-534>        String intClassName = int.class.getName();\n<line_number-535>        String booleanClassName = boolean.class.getName();\n<line_number-536>        String stringClassName = String.class.getName();\n<line_number-537>        String floatClassName = float.class.getName();\n<line_number-538>        String doubleClassName = double.class.getName();\n<line_number-539>        String bigDecimalClassName = BigDecimal.class.getName();\n<line_number-540>        String timestampClassName = Timestamp.class.getName();\n<line_number-541>        String bsonClassName = BsonValue.class.getName();\n<line_number-542>\n<line_number-543>        int columnType = getColumnType(column);\n<line_number-544>        switch (columnType) {\n<line_number-545>            case Types.ARRAY:\n<line_number-546>                // not supported\n<line_number-547>                break;\n<line_number-548>            case Types.BIGINT:\n<line_number-549>                return intClassName;\n<line_number-550>            case Types.BINARY:\n<line_number-551>                // not supported\n<line_number-552>                break;\n<line_number-553>            case Types.BIT:\n<line_number-554>                return booleanClassName;\n<line_number-555>            case Types.BLOB:\n<line_number-556>                // not supported\n<line_number-557>                break;\n<line_number-558>            case Types.BOOLEAN:\n<line_number-559>                return booleanClassName;\n<line_number-560>            case Types.CHAR:\n<line_number-561>                // not supported\n<line_number-562>                break;\n<line_number-563>            case Types.CLOB:\n<line_number-564>                // not supported\n<line_number-565>                break;\n<line_number-566>            case Types.DATALINK:\n<line_number-567>                // not supported\n<line_number-568>                break;\n<line_number-569>            case Types.DATE:\n<line_number-570>                // not supported\n<line_number-571>                break;\n<line_number-572>            case Types.DECIMAL:\n<line_number-573>                return bigDecimalClassName;\n<line_number-574>            case Types.DISTINCT:\n<line_number-575>                // not supported\n<line_number-576>                break;\n<line_number-577>            case Types.DOUBLE:\n<line_number-578>                return doubleClassName;\n<line_number-579>            case Types.FLOAT:\n<line_number-580>                return floatClassName;\n<line_number-581>            case Types.INTEGER:\n<line_number-582>                return intClassName;\n<line_number-583>            case Types.JAVA_OBJECT:\n<line_number-584>                // not supported\n<line_number-585>                break;\n<line_number-586>            case Types.LONGNVARCHAR:\n<line_number-587>                return stringClassName;\n<line_number-588>            case Types.LONGVARBINARY:\n<line_number-589>                // not supported\n<line_number-590>                break;\n<line_number-591>            case Types.LONGVARCHAR:\n<line_number-592>                return stringClassName;\n<line_number-593>            case Types.NCHAR:\n<line_number-594>                return stringClassName;\n<line_number-595>            case Types.NCLOB:\n<line_number-596>                // not supported\n<line_number-597>                break;\n<line_number-598>            case Types.NULL:\n<line_number-599>                return null;\n<line_number-600>            case Types.NUMERIC:\n<line_number-601>                return doubleClassName;\n<line_number-602>            case Types.NVARCHAR:\n<line_number-603>                return stringClassName;\n<line_number-604>            case Types.OTHER:\n<line_number-605>                return bsonClassName;\n<line_number-606>            case Types.REAL:\n<line_number-607>                // not supported\n<line_number-608>                break;\n<line_number-609>            case Types.REF:\n<line_number-610>                // not supported\n<line_number-611>                break;\n<line_number-612>            case Types.REF_CURSOR:\n<line_number-613>                // not supported\n<line_number-614>                break;\n<line_number-615>            case Types.ROWID:\n<line_number-616>                // not supported\n<line_number-617>                break;\n<line_number-618>            case Types.SMALLINT:\n<line_number-619>                return intClassName;\n<line_number-620>            case Types.SQLXML:\n<line_number-621>                // not supported\n<line_number-622>                break;\n<line_number-623>            case Types.STRUCT:\n<line_number-624>                // not supported\n<line_number-625>                break;\n<line_number-626>            case Types.TIME:\n<line_number-627>                // not supported\n<line_number-628>                break;\n<line_number-629>            case Types.TIME_WITH_TIMEZONE:\n<line_number-630>                // not supported\n<line_number-631>                break;\n<line_number-632>            case Types.TIMESTAMP:\n<line_number-633>                return timestampClassName;\n<line_number-634>            case Types.TIMESTAMP_WITH_TIMEZONE:\n<line_number-635>                // not supported\n<line_number-636>                break;\n<line_number-637>            case Types.TINYINT:\n<line_number-638>                return intClassName;\n<line_number-639>            case Types.VARBINARY:\n<line_number-640>                // not supported\n<line_number-641>                break;\n<line_number-642>            case Types.VARCHAR:\n<line_number-643>                return stringClassName;\n<line_number-644>        }\n<line_number-645>        throw new SQLException(\"getObject not supported for column type \" + columnType);\n<line_number-646>    }\n<line_number-647>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC integration.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "36-37",
            "comment_linenumber": "35",
            "comment": "This class implements ResultSetMetaData for MongoDB, providing metadata about the result set columns.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "68-77",
            "comment_linenumber": "67",
            "comment": "Constructor initializes the MongoResultSetMetaData with schema, select order, and logging details.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "115-121",
            "comment_linenumber": "114",
            "comment": "Validates that the provided schema is an object schema with non-null properties.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "123-145",
            "comment_linenumber": "122",
            "comment": "Processes a data source schema, extracting fields and populating column information.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "147-160",
            "comment_linenumber": "146",
            "comment": "Processes the select order to populate column indices and information based on the specified order.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "162-179",
            "comment_linenumber": "161",
            "comment": "Processes column information for a given field in the data source schema.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "181-183",
            "comment_linenumber": "180",
            "comment": "Retrieves the data source for a given column label, used primarily in unit tests.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "195-199",
            "comment_linenumber": "194",
            "comment": "Checks if the provided index is within the bounds of the column count.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "201-203",
            "comment_linenumber": "200",
            "comment": "Returns the MongoColumnInfo for a specified column index.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "206-210",
            "comment_linenumber": "205",
            "comment": "Indicates whether the specified column is auto-incremented.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "212-216",
            "comment_linenumber": "211",
            "comment": "Indicates whether the specified column is searchable.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "218-222",
            "comment_linenumber": "217",
            "comment": "Indicates whether the specified column represents currency.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "224-227",
            "comment_linenumber": "223",
            "comment": "Returns the schema name for the specified column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "230-232",
            "comment_linenumber": "229",
            "comment": "Returns the total number of columns in the result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "235-237",
            "comment_linenumber": "234",
            "comment": "Checks if a column exists with the specified label.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "239-247",
            "comment_linenumber": "238",
            "comment": "Retrieves the column position based on its label, throwing an exception if multiple columns exist.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "251-254",
            "comment_linenumber": "250",
            "comment": "Indicates whether the specified column is read-only.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "257-260",
            "comment_linenumber": "256",
            "comment": "Indicates whether the specified column is writable.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "263-266",
            "comment_linenumber": "262",
            "comment": "Indicates whether the specified column is definitely writable.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "269-271",
            "comment_linenumber": "268",
            "comment": "Returns the nullability of the specified column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "274-276",
            "comment_linenumber": "273",
            "comment": "Returns the label for the specified column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "279-281",
            "comment_linenumber": "278",
            "comment": "Returns the name for the specified column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "284-286",
            "comment_linenumber": "283",
            "comment": "Returns the table name for the specified column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "289-291",
            "comment_linenumber": "288",
            "comment": "Returns the catalog name for the specified column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "294-296",
            "comment_linenumber": "293",
            "comment": "Returns the JDBC type for the specified column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "299-301",
            "comment_linenumber": "298",
            "comment": "Returns the BSON type name for the specified column.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "304-308",
            "comment_linenumber": "303",
            "comment": "Implements the Wrapper interface to check if this instance is a wrapper for the specified interface.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "311-313",
            "comment_linenumber": "310",
            "comment": "Unwraps this instance as the specified interface type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "316-348",
            "comment_linenumber": "315",
            "comment": "Determines if the specified column is case-sensitive based on its BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "351-383",
            "comment_linenumber": "350",
            "comment": "Determines if the specified column is signed based on its BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "386-438",
            "comment_linenumber": "385",
            "comment": "Returns the display size for the specified column based on its BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "441-492",
            "comment_linenumber": "440",
            "comment": "Returns the precision for the specified column based on its BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "495-529",
            "comment_linenumber": "494",
            "comment": "Returns the scale for the specified column based on its BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "531-645",
            "comment_linenumber": "530",
            "comment": "Maps JDBC column types to Java class names for the specified column.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoResultSetMetaData.java' defines a class that implements the ResultSetMetaData interface for MongoDB JDBC integration. It provides metadata about the columns in a result set, including their types, names, and other properties. The class contains nested static classes for managing data source and column information, and it utilizes various MongoDB-specific types and logging mechanisms. The constructor initializes the metadata based on a provided schema and select order, while several methods handle validation, processing of data sources, and retrieval of column information. The class is designed to be used in conjunction with MongoDB's JSON schema and logging framework, ensuring that the metadata accurately reflects the structure of the underlying data. It also includes error handling for various operations, ensuring robustness in database interactions.",
        "file_summary": "This file provides the implementation of MongoResultSetMetaData, which is responsible for managing and providing metadata about the columns in a MongoDB result set. It includes methods for retrieving column information, validating schemas, and processing data sources, facilitating integration with JDBC."
      }
    ]
  },
  "MongoRunCmdListTablesResult.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoRunCmdListTablesResult.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoRunCmdListTablesResult.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoRunCmdListTablesResult.java",
        "chunk_id": "MongoRunCmdListTablesResult_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2023-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.util.ArrayList;\n<line_number-20>\n<line_number-21>public class MongoRunCmdListTablesResult {\n<line_number-22>    public CursorInfo cursor;\n<line_number-23>\n<line_number-24>    public CursorInfo getCursor() {\n<line_number-25>        return cursor;\n<line_number-26>    }\n<line_number-27>\n<line_number-28>    public static class CursorInfo {\n<line_number-29>        public long id;\n<line_number-30>        public String ns;\n<line_number-31>        public ArrayList<MongoListTablesResult> firstBatch;\n<line_number-32>\n<line_number-33>        public long getId() {\n<line_number-34>            return id;\n<line_number-35>        }\n<line_number-36>\n<line_number-37>        public String getNs() {\n<line_number-38>            return ns;\n<line_number-39>        }\n<line_number-40>\n<line_number-41>        public ArrayList<MongoListTablesResult> getFirstBatch() {\n<line_number-42>            return firstBatch;\n<line_number-43>        }\n<line_number-44>    }\n<line_number-45>}\n",
        "comments": [
          {
            "comment_code_range": "21-45",
            "comment_linenumber": "20",
            "comment": "Represents the result of a MongoDB command to list tables, encapsulating cursor information.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "24-26",
            "comment_linenumber": "23",
            "comment": "Returns the cursor information associated with the result.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "28-44",
            "comment_linenumber": "27",
            "comment": "Encapsulates information about the cursor, including its ID, namespace, and the first batch of results.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "33-35",
            "comment_linenumber": "32",
            "comment": "Returns the ID of the cursor.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "37-39",
            "comment_linenumber": "36",
            "comment": "Returns the namespace associated with the cursor.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "41-43",
            "comment_linenumber": "40",
            "comment": "Returns the first batch of results from the cursor.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoRunCmdListTablesResult.java' defines a class that models the result of a MongoDB command to list tables. It follows a simple data structure pattern, encapsulating cursor information necessary for handling the results of the command. The top-level class 'MongoRunCmdListTablesResult' contains a single field 'cursor' of type 'CursorInfo', which is another static inner class. The 'CursorInfo' class holds details about the cursor, including its ID, namespace, and an ArrayList of 'MongoListTablesResult' objects representing the first batch of results. Each class and method is public, allowing for easy access from other packages. The methods in both classes provide getters for their respective fields, ensuring encapsulation while allowing external access to the data. There are no complex control flows or external dependencies, making this a straightforward data transfer object (DTO) design.",
        "file_summary": "This file defines the 'MongoRunCmdListTablesResult' class, which encapsulates the result of a MongoDB command to list tables, including cursor information and the first batch of results."
      }
    ]
  },
  "MongoSerializationException.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoSerializationException.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoSerializationException.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoSerializationException.java",
        "chunk_id": "MongoSerializationException_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>public class MongoSerializationException extends Exception {\n<line_number-20>    public MongoSerializationException(String message) {\n<line_number-21>        super(message);\n<line_number-22>    }\n<line_number-23>\n<line_number-24>    public MongoSerializationException(String message, Throwable cause) {\n<line_number-25>        super(message, cause);\n<line_number-26>    }\n<line_number-27>}\n",
        "comments": [
          {
            "comment_code_range": "17-27",
            "comment_linenumber": "16",
            "comment": "Custom exception class for handling serialization errors specific to MongoDB operations, extending the base Exception class.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "20-22",
            "comment_linenumber": "19",
            "comment": "Constructor that accepts a message string to describe the exception.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "24-26",
            "comment_linenumber": "23",
            "comment": "Constructor that accepts a message string and a Throwable cause for more detailed exception chaining.",
            "comment_kind": "constructor"
          }
        ],
        "structural_analysis": "File overview: The file 'MongoSerializationException.java' defines a custom exception class for handling serialization errors in MongoDB operations. It follows standard Java exception handling practices. \n\nTop-level types: \n- Signature: MongoSerializationException, class, extends Exception. \n  - Role: This class is responsible for representing exceptions that occur during the serialization process in MongoDB. \n  - Lifecycle notes: It is a mutable class that can be instantiated with specific error messages and causes. \n\nMembers: \n- Fields / properties: None defined. \n- Constructors: \n  - MongoSerializationException(String message): Initializes the exception with a specific message. \n  - MongoSerializationException(String message, Throwable cause): Initializes the exception with a message and a cause. \n\nMethod deep-dive: \n- No additional methods are defined beyond the constructors. \n\nRelationships: \n- This class extends the standard Exception class, inheriting its behavior. \n\nExternal touchpoints: \n- No public APIs or external frameworks are directly referenced in this file. \n\nAlgorithms / domain logic: \n- The class does not contain any algorithms or domain logic beyond standard exception handling. \n\nObservations & caveats: \n- The class is designed to be used in conjunction with MongoDB serialization processes, but no specific serialization logic is implemented within this class itself.",
        "file_summary": "The 'MongoSerializationException.java' file defines a custom exception for handling serialization errors in MongoDB operations, providing constructors for detailed error reporting."
      }
    ]
  },
  "MongoStatement.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoStatement.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoStatement.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoStatement.java",
        "chunk_id": "MongoStatement_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import com.google.common.base.Preconditions;\n<line_number-20>import com.mongodb.MongoExecutionTimeoutException;\n<line_number-21>import com.mongodb.client.MongoCursor;\n<line_number-22>import com.mongodb.client.MongoDatabase;\n<line_number-23>import com.mongodb.client.MongoIterable;\n<line_number-24>import com.mongodb.jdbc.logging.AutoLoggable;\n<line_number-25>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-26>import com.mongodb.jdbc.logging.QueryDiagnostics;\n<line_number-27>import com.mongodb.jdbc.mongosql.GetNamespacesResult;\n<line_number-28>import com.mongodb.jdbc.mongosql.MongoSQLException;\n<line_number-29>import com.mongodb.jdbc.mongosql.MongoSQLTranslate;\n<line_number-30>import com.mongodb.jdbc.mongosql.TranslateResult;\n<line_number-31>import java.sql.*;\n<line_number-32>import java.util.*;\n<line_number-33>import java.util.concurrent.TimeUnit;\n<line_number-34>import java.util.logging.Level;\n<line_number-35>import org.apache.commons.text.StringEscapeUtils;\n<line_number-36>import org.bson.BsonDocument;\n<line_number-37>import org.bson.BsonInt32;\n<line_number-38>import org.bson.BsonString;\n<line_number-39>\n<line_number-40>@AutoLoggable\n<line_number-41>public class MongoStatement implements Statement {\n<line_number-42>    private static final BsonInt32 BSON_ONE_INT_VALUE = new BsonInt32(1);\n<line_number-43>\n<line_number-44>    // Likely, the actual mongo sql command will not\n<line_number-45>    // need a database or collection, since those\n<line_number-46>    // must be parsed from the query.\n<line_number-47>    private MongoDatabase currentDB;\n<line_number-48>    private MongoResultSet resultSet;\n<line_number-49>    private MongoConnection conn;\n<line_number-50>    protected boolean isClosed = false;\n<line_number-51>    protected boolean closeOnCompletion = false;\n<line_number-52>    private int fetchSize = 0;\n<line_number-53>    private int maxQuerySec = 0;\n<line_number-54>    private MongoLogger logger;\n<line_number-55>    private int statementId;\n<line_number-56>    String cursorName;\n<line_number-57>\n<line_number-58>    public MongoStatement(MongoConnection conn, String databaseName) throws SQLException {\n<line_number-59>        Preconditions.checkNotNull(conn);\n<line_number-60>        Preconditions.checkNotNull(databaseName);\n<line_number-61>        this.statementId = conn.getNextStatementId();\n<line_number-62>        logger = new MongoLogger(this.getClass().getCanonicalName(), conn.getLogger(), statementId);\n<line_number-63>        this.conn = conn;\n<line_number-64>\n<line_number-65>        try {\n<line_number-66>            currentDB = conn.getDatabase(databaseName);\n<line_number-67>        } catch (IllegalArgumentException e) {\n<line_number-68>            throw new SQLException(\"Database name %s is invalid\", databaseName);\n<line_number-69>        }\n<line_number-70>    }\n<line_number-71>\n<line_number-72>    protected MongoLogger getParentLogger() {\n<line_number-73>        return conn.getLogger();\n<line_number-74>    }\n<line_number-75>\n<line_number-76>    protected int getStatementId() {\n<line_number-77>        return statementId;\n<line_number-78>    }\n<line_number-79>\n<line_number-80>    protected QueryDiagnostics getQueryDiagnostics() {\n<line_number-81>        return logger.getQueryDiagnostics();\n<line_number-82>    }\n<line_number-83>\n<line_number-84>    protected BsonDocument constructQueryDocument(String sql) {\n<line_number-85>        BsonDocument stage = new BsonDocument();\n<line_number-86>        BsonDocument sqlDoc = new BsonDocument();\n<line_number-87>        sqlDoc.put(\"statement\", new BsonString(sql));\n<line_number-88>        stage.put(\"$sql\", sqlDoc);\n<line_number-89>        return stage;\n<line_number-90>    }\n<line_number-91>\n<line_number-92>    protected void checkClosed() throws SQLException {\n<line_number-93>        if (isClosed) {\n<line_number-94>            throw new SQLException(\"Connection is closed.\");\n<line_number-95>        }\n<line_number-96>    }\n<line_number-97>\n<line_number-98>    private BsonDocument constructSQLGetResultSchemaDocument(String sql) {\n<line_number-99>        BsonDocument command = new BsonDocument();\n<line_number-100>        command.put(\"sqlGetResultSchema\", BSON_ONE_INT_VALUE);\n<line_number-101>        command.put(\"query\", new BsonString(sql));\n<line_number-102>        command.put(\"schemaVersion\", BSON_ONE_INT_VALUE);\n<line_number-103>        return command;\n<line_number-104>    }\n<line_number-105>\n<line_number-106>    // ----------------------------------------------------------------------\n<line_number-107>\n<line_number-108>    @Override\n<line_number-109>    public int executeUpdate(String sql) throws SQLException {\n<line_number-110>        throw new SQLFeatureNotSupportedException(\n<line_number-111>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-112>    }\n<line_number-113>\n<line_number-114>    @Override\n<line_number-115>    public void close() {\n<line_number-116>        // closing an already closed Statement is a no-op.\n<line_number-117>        if (isClosed) {\n<line_number-118>            return;\n<line_number-119>        }\n<line_number-120>        isClosed = true;\n<line_number-121>        closeExistingResultSet();\n<line_number-122>    }\n<line_number-123>\n<line_number-124>    @Override\n<line_number-125>    public int getMaxFieldSize() throws SQLException {\n<line_number-126>        checkClosed();\n<line_number-127>        return 0;\n<line_number-128>    }\n<line_number-129>\n<line_number-130>    @Override\n<line_number-131>    public void setMaxFieldSize(int max) throws SQLException {\n<line_number-132>        checkClosed();\n<line_number-133>    }\n<line_number-134>\n<line_number-135>    @Override\n<line_number-136>    public int getMaxRows() throws SQLException {\n<line_number-137>        checkClosed();\n<line_number-138>        return 0;\n<line_number-139>    }\n<line_number-140>\n<line_number-141>    @Override\n<line_number-142>    public void setMaxRows(int max) throws SQLException {\n<line_number-143>        checkClosed();\n<line_number-144>    }\n<line_number-145>\n<line_number-146>    @Override\n<line_number-147>    public void setEscapeProcessing(boolean enable) throws SQLException {\n<line_number-148>        checkClosed();\n<line_number-149>    }\n<line_number-150>\n<line_number-151>    @Override\n<line_number-152>    public int getQueryTimeout() throws SQLException {\n<line_number-153>        checkClosed();\n<line_number-154>        return maxQuerySec;\n<line_number-155>    }\n<line_number-156>\n<line_number-157>    @Override\n<line_number-158>    public void setQueryTimeout(int seconds) throws SQLException {\n<line_number-159>        checkClosed();\n<line_number-160>        maxQuerySec = seconds;\n<line_number-161>    }\n<line_number-162>\n<line_number-163>    // Close any existing resultsets associated with this statement.\n<line_number-164>    protected void closeExistingResultSet() {\n<line_number-165>        try {\n<line_number-166>            if (resultSet != null) {\n<line_number-167>                resultSet.close();\n<line_number-168>            }\n<line_number-169>        } catch (SQLException ignored) {\n<line_number-170>            // The cursor might have already been closed by the server. Ignore exceptiong\n<line_number-171>        } finally {\n<line_number-172>            resultSet = null;\n<line_number-173>        }\n<line_number-174>    }\n<line_number-175>\n<line_number-176>    @Override\n<line_number-177>    public SQLWarning getWarnings() throws SQLException {\n<line_number-178>        checkClosed();\n<line_number-179>        return null;\n<line_number-180>    }\n<line_number-181>\n<line_number-182>    @Override\n<line_number-183>    public void clearWarnings() throws SQLException {\n<line_number-184>        checkClosed();\n<line_number-185>    }\n<line_number-186>\n<line_number-187>    @Override\n<line_number-188>    public void setCursorName(String name) throws SQLException {\n<line_number-189>        checkClosed();\n<line_number-190>        this.cursorName = name;\n<line_number-191>    }\n<line_number-192>\n<line_number-193>    // ----------------------- Multiple Results --------------------------\n<line_number-194>\n<line_number-195>    @Override\n<line_number-196>    public boolean execute(String sql) throws SQLException {\n<line_number-197>        executeQuery(sql);\n<line_number-198>        return resultSet != null;\n<line_number-199>    }\n<line_number-200>\n<line_number-201>    private ResultSet executeAtlasDataFederationQuery(String sql) throws SQLException {\n<line_number-202>        BsonDocument getSchemaCmd = constructSQLGetResultSchemaDocument(sql);\n<line_number-203>\n<line_number-204>        BsonDocument sqlStage = constructQueryDocument(sql);\n<line_number-205>        MongoIterable<BsonDocument> iterable =\n<line_number-206>                currentDB\n<line_number-207>                        .aggregate(Collections.singletonList(sqlStage), BsonDocument.class)\n<line_number-208>                        .maxTime(maxQuerySec, TimeUnit.SECONDS);\n<line_number-209>\n<line_number-210>        if (fetchSize != 0) {\n<line_number-211>            iterable = iterable.batchSize(fetchSize);\n<line_number-212>        }\n<line_number-213>\n<line_number-214>        MongoCursor<BsonDocument> cursor = iterable.cursor();\n<line_number-215>        MongoJsonSchemaResult schemaResult =\n<line_number-216>                currentDB\n<line_number-217>                        .withCodecRegistry(MongoDriver.REGISTRY)\n<line_number-218>                        .runCommand(getSchemaCmd, MongoJsonSchemaResult.class);\n<line_number-219>        MongoJsonSchema resultsetSchema = schemaResult.schema.mongoJsonSchema;\n<line_number-220>        List<List<String>> selectOrder = schemaResult.selectOrder;\n<line_number-221>        logger.setResultSetSchema(resultsetSchema);\n<line_number-222>        logger.log(Level.FINE, \"ResultSet schema: \" + resultsetSchema);\n<line_number-223>        resultSet =\n<line_number-224>                new MongoResultSet(\n<line_number-225>                        this,\n<line_number-226>                        cursor,\n<line_number-227>                        resultsetSchema,\n<line_number-228>                        selectOrder,\n<line_number-229>                        conn.getExtJsonMode(),\n<line_number-230>                        conn.getUuidRepresentation());\n<line_number-231>\n<line_number-232>        return resultSet;\n<line_number-233>    }\n<line_number-234>\n<line_number-235>    private ResultSet executeDirectClusterQuery(String sql)\n<line_number-236>            throws MongoSQLException, MongoSerializationException, SQLException {\n<line_number-237>        MongoSQLTranslate mongoSQLTranslate = conn.getMongosqlTranslate();\n<line_number-238>        String dbName = currentDB.getName();\n<line_number-239>\n<line_number-240>        // Retrieve the namespaces for the query\n<line_number-241>        GetNamespacesResult namespaceResult =\n<line_number-242>                mongoSQLTranslate.getNamespaces(currentDB.getName(), sql);\n<line_number-243>\n<line_number-244>        logger.log(Level.FINE, \"Namespaces: \" + namespaceResult);\n<line_number-245>        List<GetNamespacesResult.Namespace> namespaces = namespaceResult.namespaces;\n<line_number-246>        // Check to see if namespaces returned a database. It would only do this\n<line_number-247>        // if the query contains a qualified namespace. In this event, we must\n<line_number-248>        // switch currentDB to the query's database for proper operation.\n<line_number-249>        if (!namespaces.isEmpty() && !namespaces.get(0).database.isEmpty()) {\n<line_number-250>            dbName = namespaces.get(0).database;\n<line_number-251>            currentDB = conn.getDatabase(dbName);\n<line_number-252>        }\n<line_number-253>\n<line_number-254>        // Translate the SQL query\n<line_number-255>        BsonDocument catalogDoc =\n<line_number-256>                mongoSQLTranslate.buildCatalogDocument(currentDB, dbName, namespaces);\n<line_number-257>        logger.log(Level.FINE, \"Query catalog: \" + catalogDoc);\n<line_number-258>        logger.setNamespacesSchema(catalogDoc);\n<line_number-259>        TranslateResult translateResponse = mongoSQLTranslate.translate(sql, dbName, catalogDoc);\n<line_number-260>        logger.setPipeline(translateResponse.pipeline);\n<line_number-261>        logger.setResultSetSchema(translateResponse.resultSetSchema);\n<line_number-262>        logger.log(Level.FINE, \"Translate response: \" + translateResponse);\n<line_number-263>\n<line_number-264>        MongoIterable<BsonDocument> iterable = null;\n<line_number-265>        if (translateResponse.targetCollection != null\n<line_number-266>                && !translateResponse.targetCollection.isEmpty()) {\n<line_number-267>            iterable =\n<line_number-268>                    currentDB\n<line_number-269>                            .getCollection(translateResponse.targetCollection)\n<line_number-270>                            .aggregate(translateResponse.pipeline, BsonDocument.class)\n<line_number-271>                            .maxTime(maxQuerySec, TimeUnit.SECONDS);\n<line_number-272>        } else {\n<line_number-273>            // If there are no target collection execute the pipeline against the DB directly\n<line_number-274>            iterable =\n<line_number-275>                    currentDB\n<line_number-276>                            .aggregate(translateResponse.pipeline, BsonDocument.class)\n<line_number-277>                            .maxTime(maxQuerySec, TimeUnit.SECONDS);\n<line_number-278>        }\n<line_number-279>\n<line_number-280>        if (fetchSize != 0) {\n<line_number-281>            iterable = iterable.batchSize(fetchSize);\n<line_number-282>        }\n<line_number-283>\n<line_number-284>        resultSet =\n<line_number-285>                new MongoResultSet(\n<line_number-286>                        this,\n<line_number-287>                        iterable.cursor(),\n<line_number-288>                        translateResponse.resultSetSchema,\n<line_number-289>                        translateResponse.selectOrder,\n<line_number-290>                        conn.getExtJsonMode(),\n<line_number-291>                        conn.getUuidRepresentation());\n<line_number-292>\n<line_number-293>        return resultSet;\n<line_number-294>    }\n<line_number-295>\n<line_number-296>    @Override\n<line_number-297>    @SuppressWarnings(\"unchecked\")\n<line_number-298>    public ResultSet executeQuery(String sql) throws SQLException {\n<line_number-299>        checkClosed();\n<line_number-300>        closeExistingResultSet();\n<line_number-301>        logger.setSqlQuery(sql);\n<line_number-302>        long startTime = System.nanoTime();\n<line_number-303>        logger.log(Level.INFO, StringEscapeUtils.escapeJava(sql));\n<line_number-304>        ResultSet result = null;\n<line_number-305>        try {\n<line_number-306>            if (conn.getClusterType() == MongoConnection.MongoClusterType.AtlasDataFederation) {\n<line_number-307>                result = executeAtlasDataFederationQuery(sql);\n<line_number-308>            } else if (conn.getClusterType() == MongoConnection.MongoClusterType.Enterprise) {\n<line_number-309>                result = executeDirectClusterQuery(sql);\n<line_number-310>            } else {\n<line_number-311>                throw new SQLException(\"Unsupported cluster type: \" + conn.clusterType);\n<line_number-312>            }\n<line_number-313>        } catch (MongoExecutionTimeoutException e) {\n<line_number-314>            throw new SQLTimeoutException(e);\n<line_number-315>        } catch (MongoSQLException | MongoSerializationException e) {\n<line_number-316>            throw new RuntimeException(e);\n<line_number-317>        }\n<line_number-318>        long endTime = System.nanoTime();\n<line_number-319>        logger.log(\n<line_number-320>                Level.FINE,\n<line_number-321>                \"Query executed in \" + ((endTime - startTime) / 1000000000d) + \" seconds\");\n<line_number-322>\n<line_number-323>        return result;\n<line_number-324>    }\n<line_number-325>\n<line_number-326>    @Override\n<line_number-327>    public ResultSet getResultSet() throws SQLException {\n<line_number-328>        checkClosed();\n<line_number-329>        return resultSet;\n<line_number-330>    }\n<line_number-331>\n<line_number-332>    @Override\n<line_number-333>    public int getUpdateCount() throws SQLException {\n<line_number-334>        checkClosed();\n<line_number-335>        return -1;\n<line_number-336>    }\n<line_number-337>\n<line_number-338>    @Override\n<line_number-339>    public boolean getMoreResults() throws SQLException {\n<line_number-340>        checkClosed();\n<line_number-341>        // We only support one SQL query every time and no stored procedure support\n<line_number-342>        return false;\n<line_number-343>    }\n<line_number-344>\n<line_number-345>    // --------------------------JDBC 2.0-----------------------------\n<line_number-346>\n<line_number-347>    @Override\n<line_number-348>    public void setFetchDirection(int direction) throws SQLException {\n<line_number-349>        throw new SQLFeatureNotSupportedException(\n<line_number-350>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-351>    }\n<line_number-352>\n<line_number-353>    @Override\n<line_number-354>    public int getFetchDirection() throws SQLException {\n<line_number-355>        throw new SQLFeatureNotSupportedException(\n<line_number-356>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-357>    }\n<line_number-358>\n<line_number-359>    @Override\n<line_number-360>    public void setFetchSize(int rows) throws SQLException {\n<line_number-361>        checkClosed();\n<line_number-362>        if (rows < 0) {\n<line_number-363>            throw new SQLException(\"Invalid fetch size: \" + rows + \". Fetch size must be >= 0.\");\n<line_number-364>        }\n<line_number-365>        fetchSize = rows;\n<line_number-366>    }\n<line_number-367>\n<line_number-368>    @Override\n<line_number-369>    public int getFetchSize() throws SQLException {\n<line_number-370>        checkClosed();\n<line_number-371>        return fetchSize;\n<line_number-372>    }\n<line_number-373>\n<line_number-374>    @Override\n<line_number-375>    public int getResultSetConcurrency() throws SQLException {\n<line_number-376>        checkClosed();\n<line_number-377>        return ResultSet.CONCUR_READ_ONLY;\n<line_number-378>    }\n<line_number-379>\n<line_number-380>    @Override\n<line_number-381>    public int getResultSetType() throws SQLException {\n<line_number-382>        checkClosed();\n<line_number-383>        return ResultSet.TYPE_FORWARD_ONLY;\n<line_number-384>    }\n<line_number-385>\n<line_number-386>    @Override\n<line_number-387>    public void addBatch(String sql) throws SQLException {\n<line_number-388>        throw new SQLFeatureNotSupportedException(\n<line_number-389>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-390>    }\n<line_number-391>\n<line_number-392>    @Override\n<line_number-393>    public void clearBatch() throws SQLException {\n<line_number-394>        throw new SQLFeatureNotSupportedException(\n<line_number-395>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-396>    }\n<line_number-397>\n<line_number-398>    @Override\n<line_number-399>    public int[] executeBatch() throws SQLException {\n<line_number-400>        throw new SQLFeatureNotSupportedException(\n<line_number-401>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-402>    }\n<line_number-403>\n<line_number-404>    @Override\n<line_number-405>    public void cancel() throws SQLException {\n<line_number-406>        throw new SQLFeatureNotSupportedException(\n<line_number-407>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-408>    }\n<line_number-409>\n<line_number-410>    @Override\n<line_number-411>    public Connection getConnection() throws SQLException {\n<line_number-412>        checkClosed();\n<line_number-413>        return conn;\n<line_number-414>    }\n<line_number-415>\n<line_number-416>    // --------------------------JDBC 3.0-----------------------------\n<line_number-417>\n<line_number-418>    @Override\n<line_number-419>    public boolean getMoreResults(int current) throws SQLException {\n<line_number-420>        checkClosed();\n<line_number-421>        if (current != CLOSE_CURRENT_RESULT\n<line_number-422>                && current != KEEP_CURRENT_RESULT\n<line_number-423>                && current != CLOSE_ALL_RESULTS) {\n<line_number-424>            throw new SQLException(\"Invalid input.\");\n<line_number-425>        }\n<line_number-426>        if (current == KEEP_CURRENT_RESULT || current == CLOSE_ALL_RESULTS) {\n<line_number-427>            throw new SQLFeatureNotSupportedException(\n<line_number-428>                    Thread.currentThread().getStackTrace()[1].toString());\n<line_number-429>        }\n<line_number-430>\n<line_number-431>        if (current == CLOSE_CURRENT_RESULT) {\n<line_number-432>            closeExistingResultSet();\n<line_number-433>        }\n<line_number-434>\n<line_number-435>        return false;\n<line_number-436>    }\n<line_number-437>\n<line_number-438>    @Override\n<line_number-439>    public ResultSet getGeneratedKeys() throws SQLException {\n<line_number-440>        throw new SQLFeatureNotSupportedException(\n<line_number-441>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-442>    }\n<line_number-443>\n<line_number-444>    @Override\n<line_number-445>    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {\n<line_number-446>        throw new SQLFeatureNotSupportedException(\n<line_number-447>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-448>    }\n<line_number-449>\n<line_number-450>    @Override\n<line_number-451>    public int executeUpdate(String sql, int columnIndexes[]) throws SQLException {\n<line_number-452>        throw new SQLFeatureNotSupportedException(\n<line_number-453>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-454>    }\n<line_number-455>\n<line_number-456>    @Override\n<line_number-457>    public int executeUpdate(String sql, String columnNames[]) throws SQLException {\n<line_number-458>        throw new SQLFeatureNotSupportedException(\n<line_number-459>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-460>    }\n<line_number-461>\n<line_number-462>    @Override\n<line_number-463>    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {\n<line_number-464>        checkClosed();\n<line_number-465>        if (autoGeneratedKeys == NO_GENERATED_KEYS) {\n<line_number-466>            return execute(sql);\n<line_number-467>        }\n<line_number-468>        throw new SQLFeatureNotSupportedException(\n<line_number-469>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-470>    }\n<line_number-471>\n<line_number-472>    @Override\n<line_number-473>    public boolean execute(String sql, int columnIndexes[]) throws SQLException {\n<line_number-474>        throw new SQLFeatureNotSupportedException(\n<line_number-475>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-476>    }\n<line_number-477>\n<line_number-478>    @Override\n<line_number-479>    public boolean execute(String sql, String columnNames[]) throws SQLException {\n<line_number-480>        throw new SQLFeatureNotSupportedException(\n<line_number-481>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-482>    }\n<line_number-483>\n<line_number-484>    @Override\n<line_number-485>    public int getResultSetHoldability() throws SQLException {\n<line_number-486>        throw new SQLFeatureNotSupportedException(\n<line_number-487>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-488>    }\n<line_number-489>\n<line_number-490>    @Override\n<line_number-491>    public boolean isClosed() {\n<line_number-492>        return isClosed;\n<line_number-493>    }\n<line_number-494>\n<line_number-495>    @Override\n<line_number-496>    public void setPoolable(boolean poolable) throws SQLException {\n<line_number-497>        checkClosed();\n<line_number-498>    }\n<line_number-499>\n<line_number-500>    @Override\n<line_number-501>    public boolean isPoolable() throws SQLException {\n<line_number-502>        checkClosed();\n<line_number-503>        return false;\n<line_number-504>    }\n<line_number-505>\n<line_number-506>    // --------------------------JDBC 4.1 -----------------------------\n<line_number-507>\n<line_number-508>    @Override\n<line_number-509>    public void closeOnCompletion() throws SQLException {\n<line_number-510>        checkClosed();\n<line_number-511>        closeOnCompletion = true;\n<line_number-512>    }\n<line_number-513>\n<line_number-514>    @Override\n<line_number-515>    public boolean isCloseOnCompletion() throws SQLException {\n<line_number-516>        checkClosed();\n<line_number-517>        return closeOnCompletion;\n<line_number-518>    }\n<line_number-519>\n<line_number-520>    // --------------------------JDBC 4.2 -----------------------------\n<line_number-521>\n<line_number-522>    @Override\n<line_number-523>    public long getLargeUpdateCount() throws SQLException {\n<line_number-524>        throw new SQLFeatureNotSupportedException(\n<line_number-525>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-526>    }\n<line_number-527>\n<line_number-528>    @Override\n<line_number-529>    public void setLargeMaxRows(long max) throws SQLException {\n<line_number-530>        throw new SQLFeatureNotSupportedException(\n<line_number-531>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-532>    }\n<line_number-533>\n<line_number-534>    @Override\n<line_number-535>    public long getLargeMaxRows() throws SQLException {\n<line_number-536>        checkClosed();\n<line_number-537>        return 0;\n<line_number-538>    }\n<line_number-539>\n<line_number-540>    @Override\n<line_number-541>    public long[] executeLargeBatch() throws SQLException {\n<line_number-542>        throw new SQLFeatureNotSupportedException(\n<line_number-543>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-544>    }\n<line_number-545>\n<line_number-546>    @Override\n<line_number-547>    public long executeLargeUpdate(String sql) throws SQLException {\n<line_number-548>        throw new SQLFeatureNotSupportedException(\n<line_number-549>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-550>    }\n<line_number-551>\n<line_number-552>    @Override\n<line_number-553>    public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {\n<line_number-554>        throw new SQLFeatureNotSupportedException(\n<line_number-555>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-556>    }\n<line_number-557>\n<line_number-558>    @Override\n<line_number-559>    public long executeLargeUpdate(String sql, int columnIndexes[]) throws SQLException {\n<line_number-560>        throw new SQLFeatureNotSupportedException(\n<line_number-561>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-562>    }\n<line_number-563>\n<line_number-564>    @Override\n<line_number-565>    public long executeLargeUpdate(String sql, String columnNames[]) throws SQLException {\n<line_number-566>        throw new SQLFeatureNotSupportedException(\n<line_number-567>                Thread.currentThread().getStackTrace()[1].toString());\n<line_number-568>    }\n<line_number-569>\n<line_number-570>    // java.sql.Wrapper impl\n<line_number-571>    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n<line_number-572>        return iface.isInstance(this);\n<line_number-573>    }\n<line_number-574>\n<line_number-575>    @SuppressWarnings(\"unchecked\")\n<line_number-576>    public <T> T unwrap(Class<T> iface) throws SQLException {\n<line_number-577>        return (T) this;\n<line_number-578>    }\n<line_number-579>}\n",
        "comments": [
          {
            "comment_code_range": "40-41",
            "comment_linenumber": "39",
            "comment": "This class implements the JDBC Statement interface for MongoDB, providing methods to execute SQL queries and manage database interactions.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "58-70",
            "comment_linenumber": "57",
            "comment": "Constructor initializes the MongoStatement with a MongoConnection and database name, ensuring both are non-null and retrieving the specified database.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "72-74",
            "comment_linenumber": "71",
            "comment": "Returns the parent logger associated with the MongoConnection for logging purposes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "76-78",
            "comment_linenumber": "75",
            "comment": "Returns the unique statement ID for this MongoStatement instance.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "80-82",
            "comment_linenumber": "79",
            "comment": "Retrieves query diagnostics from the logger for performance tracking.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "84-89",
            "comment_linenumber": "83",
            "comment": "Constructs a BsonDocument representing the SQL query for MongoDB execution.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "92-96",
            "comment_linenumber": "91",
            "comment": "Checks if the statement is closed and throws an SQLException if it is.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "98-103",
            "comment_linenumber": "97",
            "comment": "Constructs a BsonDocument for retrieving the result schema of a SQL query.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "108-111",
            "comment_linenumber": "107",
            "comment": "Executes an update SQL command, which is not supported in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "115-122",
            "comment_linenumber": "114",
            "comment": "Closes the statement, ensuring any associated result sets are also closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "124-138",
            "comment_linenumber": "123",
            "comment": "Gets the maximum field size for this statement, which is always 0 in this implementation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "141-144",
            "comment_linenumber": "140",
            "comment": "Sets the maximum number of rows for this statement, which is not implemented.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "146-149",
            "comment_linenumber": "145",
            "comment": "Enables or disables escape processing for this statement, which is not implemented.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "151-160",
            "comment_linenumber": "150",
            "comment": "Gets and sets the query timeout for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "163-173",
            "comment_linenumber": "162",
            "comment": "Closes any existing result sets associated with this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "176-180",
            "comment_linenumber": "175",
            "comment": "Retrieves any warnings associated with this statement, which are not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "182-185",
            "comment_linenumber": "181",
            "comment": "Clears any warnings associated with this statement, which are not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "187-190",
            "comment_linenumber": "186",
            "comment": "Sets the cursor name for this statement, which is not implemented.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "193-198",
            "comment_linenumber": "192",
            "comment": "Executes a SQL command and returns a boolean indicating if a result set is available.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "201-232",
            "comment_linenumber": "200",
            "comment": "Executes a query for Atlas Data Federation and returns the result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "235-294",
            "comment_linenumber": "234",
            "comment": "Executes a direct cluster query and returns the result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "296-323",
            "comment_linenumber": "295",
            "comment": "Executes a SQL query, determining the cluster type and calling the appropriate execution method.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "326-329",
            "comment_linenumber": "325",
            "comment": "Retrieves the current result set for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "332-335",
            "comment_linenumber": "331",
            "comment": "Returns the update count for this statement, which is always -1.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "338-343",
            "comment_linenumber": "337",
            "comment": "Indicates whether there are more results available, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "347-350",
            "comment_linenumber": "346",
            "comment": "Sets the fetch direction for this statement, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "353-356",
            "comment_linenumber": "352",
            "comment": "Gets the fetch direction for this statement, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "359-365",
            "comment_linenumber": "358",
            "comment": "Sets the fetch size for this statement, ensuring it is non-negative.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "368-371",
            "comment_linenumber": "367",
            "comment": "Gets the current fetch size for this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "374-377",
            "comment_linenumber": "373",
            "comment": "Returns the concurrency type for the result set, which is read-only.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "380-383",
            "comment_linenumber": "379",
            "comment": "Returns the type of the result set, which is forward-only.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "386-389",
            "comment_linenumber": "385",
            "comment": "Adds a SQL command to a batch, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "392-395",
            "comment_linenumber": "391",
            "comment": "Clears the current batch of SQL commands, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "399-402",
            "comment_linenumber": "398",
            "comment": "Executes a batch of SQL commands, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "405-407",
            "comment_linenumber": "404",
            "comment": "Cancels the current SQL command, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "410-413",
            "comment_linenumber": "409",
            "comment": "Retrieves the connection associated with this statement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "418-429",
            "comment_linenumber": "417",
            "comment": "Gets more results based on the current state, handling result set closure.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "439-441",
            "comment_linenumber": "438",
            "comment": "Retrieves generated keys from the executed statement, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "445-460",
            "comment_linenumber": "444",
            "comment": "Executes an update SQL command with various parameters, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "462-469",
            "comment_linenumber": "461",
            "comment": "Executes a SQL command with auto-generated keys, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "472-481",
            "comment_linenumber": "470",
            "comment": "Executes a SQL command with column indexes, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "484-487",
            "comment_linenumber": "483",
            "comment": "Retrieves the holdability of the result set, which is not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "490-493",
            "comment_linenumber": "489",
            "comment": "Checks if the statement is closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "496-498",
            "comment_linenumber": "495",
            "comment": "Sets the statement as poolable, which is not implemented.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "501-503",
            "comment_linenumber": "500",
            "comment": "Checks if the statement is poolable, which is not implemented.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "506-525",
            "comment_linenumber": "505",
            "comment": "Handles large update counts and batch executions, which are not supported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "570-579",
            "comment_linenumber": "569",
            "comment": "Implements the Wrapper interface for JDBC, allowing for type checking and unwrapping.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoStatement.java' defines a class that implements the JDBC Statement interface specifically for MongoDB. It provides methods to execute SQL queries, manage result sets, and handle database connections. The class utilizes various MongoDB client libraries and logging utilities to facilitate its operations. Key methods include 'executeQuery', which determines the cluster type and executes the appropriate query method, and 'close', which ensures proper resource management. The class maintains internal state variables for connection management, result sets, and logging. It also includes error handling for unsupported operations and manages query timeouts and fetch sizes. The class is designed to be used in a multi-threaded environment, ensuring thread safety through proper checks and exception handling.",
        "file_summary": "The 'MongoStatement.java' file provides an implementation of the JDBC Statement interface for MongoDB, enabling SQL query execution and result set management while integrating with MongoDB's database operations."
      }
    ]
  },
  "MongoVersionedJsonSchema.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoVersionedJsonSchema.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\MongoVersionedJsonSchema.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\MongoVersionedJsonSchema.java",
        "chunk_id": "MongoVersionedJsonSchema_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import org.bson.codecs.pojo.annotations.BsonCreator;\n<line_number-20>import org.bson.codecs.pojo.annotations.BsonProperty;\n<line_number-21>\n<line_number-22>public class MongoVersionedJsonSchema {\n<line_number-23>    public Integer version;\n<line_number-24>    public MongoJsonSchema mongoJsonSchema;\n<line_number-25>\n<line_number-26>    /** Empty Json schema. */\n<line_number-27>    public MongoVersionedJsonSchema() {}\n<line_number-28>\n<line_number-29>    /**\n<line_number-30>     * Deserialized json schema from a 'sqlgetschema' command.\n<line_number-31>     *\n<line_number-32>     * @param version The schema version.\n<line_number-33>     * @param schema The schema.\n<line_number-34>     */\n<line_number-35>    @BsonCreator\n<line_number-36>    public MongoVersionedJsonSchema(\n<line_number-37>            @BsonProperty(\"version\") final Integer version,\n<line_number-38>            @BsonProperty(\"jsonSchema\") JsonSchema schema) {\n<line_number-39>        this.version = version;\n<line_number-40>        this.mongoJsonSchema = MongoJsonSchema.toSimplifiedMongoJsonSchema(schema);\n<line_number-41>    }\n<line_number-42>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC integration.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "22-42",
            "comment_linenumber": "21",
            "comment": "Represents a versioned JSON schema for MongoDB, encapsulating the schema version and the corresponding JSON schema.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "26-27",
            "comment_linenumber": "25",
            "comment": "Default constructor for MongoVersionedJsonSchema, initializes an empty schema.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "29-41",
            "comment_linenumber": "28",
            "comment": "Constructor that initializes the MongoVersionedJsonSchema with a specified version and schema, converting the schema to a simplified MongoDB format.",
            "comment_kind": "constructor"
          }
        ],
        "structural_analysis": "The file 'MongoVersionedJsonSchema.java' is part of the 'com.mongodb.jdbc' package, which is likely designed for integrating MongoDB with JDBC. The primary class, 'MongoVersionedJsonSchema', encapsulates a versioned JSON schema, consisting of a version number and a corresponding JSON schema object. The class includes a default constructor for creating an empty schema and a parameterized constructor that initializes the version and schema properties, utilizing BSON annotations for serialization. The class relies on 'MongoJsonSchema' for converting a standard JSON schema into a MongoDB-compatible format. The use of BSON annotations indicates that this class is intended for use with BSON serialization, which is common in MongoDB applications. The class does not implement any interfaces or extend any other classes, indicating a straightforward data structure without additional behavior or complexity.",
        "file_summary": "This file defines the 'MongoVersionedJsonSchema' class, which represents a versioned JSON schema for MongoDB, including constructors for initializing the schema with or without a version."
      }
    ]
  },
  "NoCheckStateJsonWriter.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\NoCheckStateJsonWriter.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\NoCheckStateJsonWriter.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\NoCheckStateJsonWriter.java",
        "chunk_id": "NoCheckStateJsonWriter_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.io.Writer;\n<line_number-20>import org.bson.json.JsonWriter;\n<line_number-21>import org.bson.json.JsonWriterSettings;\n<line_number-22>\n<line_number-23>/**\n<line_number-24> * NoCheckStateJsonWriter will allow writing of any Json value. It does not validate it is\n<line_number-25> * constructing a valid document. Useful for writing Bson Values such as a BsonArray.\n<line_number-26> */\n<line_number-27>public class NoCheckStateJsonWriter extends JsonWriter {\n<line_number-28>\n<line_number-29>    public NoCheckStateJsonWriter(Writer writer, JsonWriterSettings settings) {\n<line_number-30>        super(writer, settings);\n<line_number-31>    }\n<line_number-32>\n<line_number-33>    @Override\n<line_number-34>    protected boolean checkState(State[] validStates) {\n<line_number-35>        return true;\n<line_number-36>    }\n<line_number-37>}\n",
        "comments": [
          {
            "comment_code_range": "23-25",
            "comment_linenumber": "22",
            "comment": "Describes the purpose of NoCheckStateJsonWriter, which allows writing any JSON value without validation, useful for Bson Values.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "29-31",
            "comment_linenumber": "28",
            "comment": "Constructor initializes the NoCheckStateJsonWriter with a Writer and JsonWriterSettings, passing them to the superclass.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "34-36",
            "comment_linenumber": "33",
            "comment": "Overrides the checkState method to always return true, allowing any state for JSON writing.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'NoCheckStateJsonWriter.java' defines a class that extends the functionality of the JsonWriter from the BSON library. The primary role of this class is to facilitate the writing of JSON values without enforcing validation checks, which is particularly useful when dealing with BSON types like BsonArray. The class is straightforward, containing a constructor that initializes its state and an overridden method that bypasses state checks. The NoCheckStateJsonWriter class does not maintain any internal state beyond what is provided by its superclass, and it is designed to be used in scenarios where flexibility in JSON writing is required. The class is not thread-safe and does not implement any design patterns beyond standard inheritance. It relies on external libraries such as BSON for JSON handling, specifically the JsonWriter and JsonWriterSettings classes. There are no complex algorithms or business logic present in this file, making it primarily a utility for JSON writing.",
        "file_summary": "This file contains the NoCheckStateJsonWriter class, which extends JsonWriter to allow writing JSON values without validation. It is designed for scenarios where BSON values need to be written directly, bypassing the usual state checks."
      }
    ]
  },
  "Pair.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\Pair.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\Pair.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\Pair.java",
        "chunk_id": "Pair_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.util.Objects;\n<line_number-20>\n<line_number-21>public class Pair<L, R> {\n<line_number-22>    private L left;\n<line_number-23>    private R right;\n<line_number-24>\n<line_number-25>    public Pair(L left, R right) {\n<line_number-26>        this.left = left;\n<line_number-27>        this.right = right;\n<line_number-28>    }\n<line_number-29>\n<line_number-30>    public L left() {\n<line_number-31>        return left;\n<line_number-32>    }\n<line_number-33>\n<line_number-34>    public R right() {\n<line_number-35>        return right;\n<line_number-36>    }\n<line_number-37>\n<line_number-38>    @Override\n<line_number-39>    public boolean equals(Object o) {\n<line_number-40>        if (this == o) return true;\n<line_number-41>        if (o == null || getClass() != o.getClass()) return false;\n<line_number-42>        Pair<?, ?> pair = (Pair<?, ?>) o;\n<line_number-43>        return Objects.equals(left, pair.left) && Objects.equals(right, pair.right);\n<line_number-44>    }\n<line_number-45>\n<line_number-46>    @Override\n<line_number-47>    public int hashCode() {\n<line_number-48>        return Objects.hash(left, right);\n<line_number-49>    }\n<line_number-50>}\n",
        "comments": [
          {
            "comment_code_range": "21-50",
            "comment_linenumber": "20",
            "comment": "Represents a generic pair of values, allowing for easy storage and retrieval of two related objects.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "25-28",
            "comment_linenumber": "24",
            "comment": "Constructor that initializes the pair with the specified left and right values.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "30-32",
            "comment_linenumber": "29",
            "comment": "Returns the left value of the pair.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "34-36",
            "comment_linenumber": "33",
            "comment": "Returns the right value of the pair.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "38-44",
            "comment_linenumber": "37",
            "comment": "Checks equality between this pair and another object, considering both left and right values.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "46-48",
            "comment_linenumber": "45",
            "comment": "Generates a hash code for the pair based on its left and right values.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'Pair.java' defines a generic class 'Pair' that encapsulates two related objects, referred to as 'left' and 'right'. This class is part of the 'com.mongodb.jdbc' package and is designed to facilitate the handling of pairs of values in a type-safe manner. The class is generic, allowing it to be instantiated with any object types for the left and right values. The class includes a constructor for initializing these values, as well as methods for retrieving them. It overrides the 'equals' and 'hashCode' methods to ensure that pairs can be compared and used effectively in collections. The class does not implement any interfaces or extend any other classes, making it a standalone utility class. The fields 'left' and 'right' are private, ensuring encapsulation, and the class provides public accessors for these fields. The design follows standard Java conventions for generic classes and provides a simple yet effective way to manage pairs of objects.",
        "file_summary": "The 'Pair.java' file defines a generic class that represents a pair of objects, providing methods to access the individual elements and to compare pairs for equality. It is a utility class commonly used in scenarios where two related values need to be handled together."
      }
    ]
  },
  "SortableBsonDocument.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\SortableBsonDocument.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\SortableBsonDocument.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\SortableBsonDocument.java",
        "chunk_id": "SortableBsonDocument_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import java.util.List;\n<line_number-20>import org.bson.BsonDocument;\n<line_number-21>\n<line_number-22>public class SortableBsonDocument extends BsonDocument implements Comparable<SortableBsonDocument> {\n<line_number-23>\n<line_number-24>    static class SortSpec {\n<line_number-25>        String key;\n<line_number-26>        ValueType type;\n<line_number-27>\n<line_number-28>        SortSpec(String key, ValueType type) {\n<line_number-29>            this.key = key;\n<line_number-30>            this.type = type;\n<line_number-31>        }\n<line_number-32>    }\n<line_number-33>\n<line_number-34>    enum ValueType {\n<line_number-35>        String,\n<line_number-36>        Int,\n<line_number-37>        Boolean,\n<line_number-38>    }\n<line_number-39>\n<line_number-40>    List<SortSpec> sortSpecs;\n<line_number-41>    BsonDocument nestedDocValue;\n<line_number-42>\n<line_number-43>    SortableBsonDocument(List<SortSpec> sortSpecs, String key, BsonDocument docValue) {\n<line_number-44>        super(key, docValue);\n<line_number-45>\n<line_number-46>        this.sortSpecs = sortSpecs;\n<line_number-47>        this.nestedDocValue = docValue;\n<line_number-48>    }\n<line_number-49>\n<line_number-50>    @Override\n<line_number-51>    public int compareTo(SortableBsonDocument o) {\n<line_number-52>        int r = 0;\n<line_number-53>        for (SortSpec sortSpec : this.sortSpecs) {\n<line_number-54>            switch (sortSpec.type) {\n<line_number-55>                case String:\n<line_number-56>                    r =\n<line_number-57>                            this.nestedDocValue\n<line_number-58>                                    .getString(sortSpec.key)\n<line_number-59>                                    .compareTo(o.nestedDocValue.getString(sortSpec.key));\n<line_number-60>                    break;\n<line_number-61>                case Int:\n<line_number-62>                    r =\n<line_number-63>                            this.nestedDocValue\n<line_number-64>                                    .getInt32(sortSpec.key)\n<line_number-65>                                    .compareTo(o.nestedDocValue.getInt32(sortSpec.key));\n<line_number-66>                    break;\n<line_number-67>                case Boolean:\n<line_number-68>                    r =\n<line_number-69>                            this.nestedDocValue\n<line_number-70>                                    .getBoolean(sortSpec.key)\n<line_number-71>                                    .compareTo(o.nestedDocValue.getBoolean(sortSpec.key));\n<line_number-72>                    break;\n<line_number-73>            }\n<line_number-74>\n<line_number-75>            if (r != 0) {\n<line_number-76>                return r;\n<line_number-77>            }\n<line_number-78>        }\n<line_number-79>\n<line_number-80>        return r;\n<line_number-81>    }\n<line_number-82>}\n",
        "comments": [
          {
            "comment_code_range": "22-82",
            "comment_linenumber": "21",
            "comment": "Represents a BSON document that can be sorted based on specified sorting criteria, implementing Comparable for natural ordering.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "24-32",
            "comment_linenumber": "23",
            "comment": "Defines the sorting specification including the key and its value type for sorting.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "34-38",
            "comment_linenumber": "33",
            "comment": "Enumerates the possible value types for sorting: String, Int, and Boolean.",
            "comment_kind": "enum"
          },
          {
            "comment_code_range": "43-48",
            "comment_linenumber": "42",
            "comment": "Constructor that initializes the SortableBsonDocument with sorting specifications and a BSON document value.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "50-80",
            "comment_linenumber": "49",
            "comment": "Compares this SortableBsonDocument with another based on the defined sorting specifications, returning an integer result.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "53-73",
            "comment_linenumber": "52",
            "comment": "Iterates through the sorting specifications and compares the corresponding values from the nested BSON documents.",
            "comment_kind": "block"
          }
        ],
        "structural_analysis": "The file 'SortableBsonDocument.java' defines a class that extends BsonDocument to provide sorting capabilities based on specified criteria. The primary design pattern used is the Composite pattern, allowing for complex sorting logic based on multiple fields. The top-level class 'SortableBsonDocument' implements the Comparable interface, enabling natural ordering based on the defined sorting specifications. \n\n### Top-level types:\n- **SortableBsonDocument**: A class that extends BsonDocument and implements Comparable. It is responsible for representing a BSON document that can be sorted based on specified criteria. It is mutable and not thread-safe.\n\n### Members:\n- **Fields**:\n  - `List<SortSpec> sortSpecs`: Holds the sorting specifications.\n  - `BsonDocument nestedDocValue`: The BSON document value associated with this instance.\n\n- **Constructor**:\n  - `SortableBsonDocument(List<SortSpec> sortSpecs, String key, BsonDocument docValue)`: Initializes the document with the provided sorting specifications and BSON document value.\n\n### Method deep-dive:\n- **compareTo(SortableBsonDocument o)**: \n  - **Parameters**: Another SortableBsonDocument to compare against.\n  - **Return type**: int, indicating the comparison result.\n  - **Behaviour**: Compares the current instance with another based on the sorting specifications. It retrieves values from the nested BSON document and compares them according to their types (String, Int, Boolean). If a non-zero result is found, it returns that; otherwise, it continues to the next specification.\n  - **Internal calls**: Calls to `getString`, `getInt32`, and `getBoolean` methods of BsonDocument.\n  - **Key control flow**: Uses a loop to iterate through sort specifications and a switch statement to handle different value types.\n\n### Relationships:\n- The class relies on the BsonDocument class from the BSON library, utilizing its methods to retrieve values for comparison.\n\n### External touchpoints:\n- Utilizes the BSON library for document representation and manipulation.\n\n### Observations & caveats:\n- The class does not handle null values or exceptions that may arise from missing keys in the BSON document, which could lead to runtime errors.",
        "file_summary": "The 'SortableBsonDocument.java' file defines a class that extends BsonDocument to facilitate sorting of BSON documents based on specified criteria. It allows for flexible sorting by defining multiple sorting specifications, making it useful for applications that require ordered BSON data."
      }
    ]
  },
  "AutoLoggable.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\AutoLoggable.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\logging\\AutoLoggable.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\AutoLoggable.java",
        "chunk_id": "AutoLoggable_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.logging;\n<line_number-18>\n<line_number-19>import java.lang.annotation.ElementType;\n<line_number-20>import java.lang.annotation.Retention;\n<line_number-21>import java.lang.annotation.RetentionPolicy;\n<line_number-22>import java.lang.annotation.Target;\n<line_number-23>\n<line_number-24>/**\n<line_number-25> * Annotation for identifying all classes which should log their public method entries. Used in\n<line_number-26> * conjunction with LoggingAspect to provide auto-logging of public methods entry.\n<line_number-27> */\n<line_number-28>@Retention(RetentionPolicy.CLASS)\n<line_number-29>@Target({ElementType.TYPE, ElementType.METHOD})\n<line_number-30>public @interface AutoLoggable {}\n",
        "comments": [
          {
            "comment_code_range": "24-27",
            "comment_linenumber": "23",
            "comment": "Defines an annotation for classes and methods that should log their public method entries, facilitating auto-logging via LoggingAspect.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Package declaration for logging-related functionality within the MongoDB JDBC driver.",
            "comment_kind": "other"
          }
        ],
        "structural_analysis": "The file is named 'AutoLoggable.java' and is part of the 'com.mongodb.jdbc.logging' package, which is responsible for logging functionalities in the MongoDB JDBC driver. The primary role of this file is to define an annotation that marks classes and methods for automatic logging of public method entries. This annotation is intended to be used in conjunction with a LoggingAspect, which likely implements aspect-oriented programming to intercept method calls and log their entries. The annotation is retained at the class level and method level, as indicated by the @Target annotation, and is retained in the class files but not available at runtime due to the RetentionPolicy.CLASS setting. This design allows for flexible logging without impacting runtime performance. There are no fields, constructors, or methods in this file, as it solely defines the annotation. The file does not interact with external libraries or frameworks directly but is designed to work with an aspect-oriented programming framework that handles the logging logic based on this annotation. There are no notable caveats or performance considerations within this file, as it serves a declarative purpose.",
        "file_summary": "This file defines the AutoLoggable annotation, which is used to mark classes and methods for automatic logging of public method entries in the MongoDB JDBC driver, facilitating easier debugging and monitoring of method calls."
      }
    ]
  },
  "DisableAutoLogging.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\DisableAutoLogging.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\logging\\DisableAutoLogging.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\DisableAutoLogging.java",
        "chunk_id": "DisableAutoLogging_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.logging;\n<line_number-18>\n<line_number-19>import java.lang.annotation.ElementType;\n<line_number-20>import java.lang.annotation.Retention;\n<line_number-21>import java.lang.annotation.RetentionPolicy;\n<line_number-22>import java.lang.annotation.Target;\n<line_number-23>\n<line_number-24>/**\n<line_number-25> * Annotation for identifying all methods which should be excluded from autologging the method\n<line_number-26> * entry. Used in conjunction with LoggingAspect to provide auto-logging of public methods entry.\n<line_number-27> */\n<line_number-28>@Retention(RetentionPolicy.CLASS)\n<line_number-29>@Target({ElementType.TYPE, ElementType.METHOD})\n<line_number-30>public @interface DisableAutoLogging {}\n",
        "comments": [
          {
            "comment_code_range": "1-14",
            "comment_linenumber": "15",
            "comment": "This section contains the copyright notice and licensing information for the file.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "17",
            "comment": "Defines the package for logging-related functionality in the MongoDB JDBC driver.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "24-27",
            "comment_linenumber": "24",
            "comment": "Defines an annotation to mark methods or classes that should not be automatically logged by the LoggingAspect.",
            "comment_kind": "annotation"
          },
          {
            "comment_code_range": "28-30",
            "comment_linenumber": "28",
            "comment": "Specifies that this annotation is retained in the class file and can be applied to types and methods.",
            "comment_kind": "other"
          }
        ],
        "structural_analysis": "The file is named 'DisableAutoLogging.java' and is part of the 'com.mongodb.jdbc.logging' package, which is responsible for logging functionalities in the MongoDB JDBC driver. The primary role of this file is to define an annotation that can be used to exclude certain methods or classes from being automatically logged by the logging aspect of the application. The annotation is retained in the class file and can be applied to both types and methods, allowing for flexible usage in various contexts. The file does not contain any fields or methods, as it solely defines the annotation. The annotation is marked with @Retention and @Target annotations to specify its retention policy and applicable targets, respectively. There are no external dependencies or complex control flows present in this file, making it straightforward in its purpose.",
        "file_summary": "This file defines the 'DisableAutoLogging' annotation, which is used to mark methods and classes that should be excluded from automatic logging in the MongoDB JDBC driver. It facilitates selective logging by working in conjunction with the LoggingAspect."
      }
    ]
  },
  "MongoLogger.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\MongoLogger.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\logging\\MongoLogger.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\MongoLogger.java",
        "chunk_id": "MongoLogger_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.logging;\n<line_number-18>\n<line_number-19>import com.mongodb.jdbc.MongoJsonSchema;\n<line_number-20>import java.sql.SQLException;\n<line_number-21>import java.util.List;\n<line_number-22>import java.util.logging.Handler;\n<line_number-23>import java.util.logging.Level;\n<line_number-24>import java.util.logging.Logger;\n<line_number-25>import org.bson.BsonArray;\n<line_number-26>import org.bson.BsonDocument;\n<line_number-27>\n<line_number-28>public class MongoLogger {\n<line_number-29>    private static final String ENTRY_PREFIX = \">> \";\n<line_number-30>\n<line_number-31>    private Logger logger;\n<line_number-32>    private Integer connectionId;\n<line_number-33>    private Integer statementId;\n<line_number-34>    private QueryDiagnostics queryDiagnostics = new QueryDiagnostics();\n<line_number-35>\n<line_number-36>    /**\n<line_number-37>     * Gets a logger, tied to a connection. Used for logging after a connection has been created.\n<line_number-38>     *\n<line_number-39>     * @param logger The logger.\n<line_number-40>     * @param connectionId The connection id.\n<line_number-41>     */\n<line_number-42>    public MongoLogger(Logger logger, int connectionId) {\n<line_number-43>        this.logger = logger;\n<line_number-44>        this.connectionId = connectionId;\n<line_number-45>    }\n<line_number-46>\n<line_number-47>    /**\n<line_number-48>     * Gets a logger, tied to a connection and a statement. Used for logging after a statement has\n<line_number-49>     * been created.\n<line_number-50>     *\n<line_number-51>     * @param className The classname to find the associated logger.\n<line_number-52>     * @param parentLogger The parent logger.\n<line_number-53>     * @param statementId The statement id.\n<line_number-54>     */\n<line_number-55>    public MongoLogger(String className, MongoLogger parentLogger, int statementId) {\n<line_number-56>        createLogger(className, parentLogger);\n<line_number-57>        this.statementId = statementId;\n<line_number-58>    }\n<line_number-59>\n<line_number-60>    /**\n<line_number-61>     * Gets a logger, tied to a connection but no statement. This is used for logging\n<line_number-62>     * DatabaseMetadata for example.\n<line_number-63>     *\n<line_number-64>     * @param className The classname to find the associated logger.\n<line_number-65>     * @param parentLogger The parent logger.\n<line_number-66>     */\n<line_number-67>    public MongoLogger(String className, MongoLogger parentLogger) {\n<line_number-68>        createLogger(className, parentLogger);\n<line_number-69>    }\n<line_number-70>\n<line_number-71>    /**\n<line_number-72>     * Create a logger for this class and attach it to the provided parent logger.\n<line_number-73>     *\n<line_number-74>     * @param className The classname to find the associated logger.\n<line_number-75>     * @param parentLogger The parent logger.\n<line_number-76>     */\n<line_number-77>    private void createLogger(String className, MongoLogger parentLogger) {\n<line_number-78>        String loggername =\n<line_number-79>                (parentLogger.connectionId == null)\n<line_number-80>                        ? className\n<line_number-81>                        : parentLogger.connectionId + \"_\" + className;\n<line_number-82>        this.logger = Logger.getLogger(loggername);\n<line_number-83>        logger.setLevel(parentLogger.logger.getLevel());\n<line_number-84>\n<line_number-85>        // This is a work-around for the simpler logic of calling `logger.setParent(parent); logger.setUseParentHandlers(true);`\n<line_number-86>        // after configuring the parent logger handlers for the connection.\n<line_number-87>        // This is to avoid issue with log managers which are restricting use of setParent like JBoss Log Manager for example.\n<line_number-88>        for (Handler handler : logger.getHandlers()) {\n<line_number-89>            // Clean the handler list to avoid any duplication of logs from transitive handlers\n<line_number-90>            logger.removeHandler(handler);\n<line_number-91>        }\n<line_number-92>        for (Handler handler : parentLogger.logger.getHandlers()) {\n<line_number-93>            // Add all parent handlers\n<line_number-94>            logger.addHandler(handler);\n<line_number-95>        }\n<line_number-96>        this.connectionId = parentLogger.connectionId;\n<line_number-97>    }\n<line_number-98>\n<line_number-99>    /**\n<line_number-100>     * Log a method entry. This is a convenience method that can be used to log entry to a method. A\n<line_number-101>     * LogRecord with message \"{@literal >>} callSignature\", log level FINER, and the given\n<line_number-102>     * sourceName is logged.\n<line_number-103>     *\n<line_number-104>     * @param sourceName Name of class that issued the logging request\n<line_number-105>     * @param callSignature The call signature, method and arguments, to log.\n<line_number-106>     */\n<line_number-107>    protected void logMethodEntry(String sourceName, String callSignature) {\n<line_number-108>        if ((null != logger) && logger.isLoggable(Level.FINER)) {\n<line_number-109>            logger.logp(\n<line_number-110>                    Level.FINER,\n<line_number-111>                    addConnectionStatementIdsToSourceName(sourceName),\n<line_number-112>                    null,\n<line_number-113>                    ENTRY_PREFIX + callSignature);\n<line_number-114>        }\n<line_number-115>    }\n<line_number-116>\n<line_number-117>    protected void logError(String sourceName, String msg, Throwable thrown) {\n<line_number-118>        if ((null != logger) && logger.isLoggable(Level.SEVERE)) {\n<line_number-119>            if (thrown instanceof SQLException) {\n<line_number-120>                StringBuilder sb = new StringBuilder();\n<line_number-121>                sb.append(msg);\n<line_number-122>                sb.append(\"\\n\");\n<line_number-123>                sb.append(\"SQL diagnostics: \");\n<line_number-124>                sb.append(getQueryDiagnostics());\n<line_number-125>                msg = sb.toString();\n<line_number-126>            }\n<line_number-127>\n<line_number-128>            logger.logp(\n<line_number-129>                    Level.SEVERE,\n<line_number-130>                    addConnectionStatementIdsToSourceName(sourceName),\n<line_number-131>                    null,\n<line_number-132>                    msg,\n<line_number-133>                    thrown);\n<line_number-134>        }\n<line_number-135>    }\n<line_number-136>\n<line_number-137>    /**\n<line_number-138>     * Log a message, with no arguments.\n<line_number-139>     *\n<line_number-140>     * <p>If the logger is currently enabled for the given message level then the given message is\n<line_number-141>     * forwarded to all the registered output Handler objects.\n<line_number-142>     *\n<line_number-143>     * @param level One of the message level identifiers, e.g., SEVERE\n<line_number-144>     * @param msg The string message (or a key in the message catalog)\n<line_number-145>     */\n<line_number-146>    public void log(Level level, String msg) {\n<line_number-147>        if ((null != logger) && logger.isLoggable(level)) {\n<line_number-148>            // Get access to caller\n<line_number-149>            StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace();\n<line_number-150>            StackTraceElement ste = stacktrace[2];\n<line_number-151>            String sourceClassName = ste.getClassName();\n<line_number-152>            String methodName = ste.getMethodName();\n<line_number-153>\n<line_number-154>            logger.logp(\n<line_number-155>                    level, addConnectionStatementIdsToSourceName(sourceClassName), methodName, msg);\n<line_number-156>        }\n<line_number-157>    }\n<line_number-158>\n<line_number-159>    /**\n<line_number-160>     * Log a message, with an array of object arguments.\n<line_number-161>     *\n<line_number-162>     * <p>If the logger is currently enabled for the given message level then a corresponding\n<line_number-163>     * LogRecord is created and forwarded to all the registered output Handler objects.\n<line_number-164>     *\n<line_number-165>     * @param level One of the message level identifiers, e.g., SEVERE\n<line_number-166>     * @param msg The string message (or a key in the message catalog)\n<line_number-167>     * @param params array of parameters to the message\n<line_number-168>     */\n<line_number-169>    public void log(Level level, String msg, Object params[]) {\n<line_number-170>        if ((null != logger) && logger.isLoggable(level)) {\n<line_number-171>            // Get access to caller\n<line_number-172>            StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace();\n<line_number-173>            StackTraceElement ste = stacktrace[2];\n<line_number-174>            String sourceClassName = ste.getClassName();\n<line_number-175>            String methodName = ste.getMethodName();\n<line_number-176>\n<line_number-177>            logger.logp(\n<line_number-178>                    level,\n<line_number-179>                    addConnectionStatementIdsToSourceName(sourceClassName),\n<line_number-180>                    methodName,\n<line_number-181>                    msg,\n<line_number-182>                    params);\n<line_number-183>        }\n<line_number-184>    }\n<line_number-185>\n<line_number-186>    /**\n<line_number-187>     * Log a message, with associated Throwable information.\n<line_number-188>     *\n<line_number-189>     * <p>If the logger is currently enabled for the given message level then the given arguments\n<line_number-190>     * are stored in a LogRecord which is forwarded to all registered output handlers.\n<line_number-191>     *\n<line_number-192>     * <p>Note that the thrown argument is stored in the LogRecord thrown property, rather than the\n<line_number-193>     * LogRecord parameters property. Thus it is processed specially by output Formatters and is not\n<line_number-194>     * treated as a formatting parameter to the LogRecord message property.\n<line_number-195>     *\n<line_number-196>     * @param level One of the message level identifiers, e.g., SEVERE\n<line_number-197>     * @param msg The string message (or a key in the message catalog)\n<line_number-198>     * @param thrown Throwable associated with log message.\n<line_number-199>     */\n<line_number-200>    public void log(Level level, String msg, Throwable thrown) {\n<line_number-201>        if ((null != logger) && logger.isLoggable(level)) {\n<line_number-202>            // Get access to caller\n<line_number-203>            StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace();\n<line_number-204>            StackTraceElement ste = stacktrace[2];\n<line_number-205>            String sourceClassName = ste.getClassName();\n<line_number-206>            String methodName = ste.getMethodName();\n<line_number-207>\n<line_number-208>            logger.logp(\n<line_number-209>                    level,\n<line_number-210>                    addConnectionStatementIdsToSourceName(sourceClassName),\n<line_number-211>                    methodName,\n<line_number-212>                    msg,\n<line_number-213>                    thrown);\n<line_number-214>        }\n<line_number-215>    }\n<line_number-216>\n<line_number-217>    /**\n<line_number-218>     * Add the connection and statement ids before the source name if they are available.\n<line_number-219>     *\n<line_number-220>     * @param sourceName The source name.\n<line_number-221>     * @return the source name with the connection and statement ids suffixes.\n<line_number-222>     */\n<line_number-223>    protected String addConnectionStatementIdsToSourceName(String sourceName) {\n<line_number-224>        // Add the statement id\n<line_number-225>        if (statementId != null) {\n<line_number-226>            sourceName = \"[stmt-\" + statementId + \"] \" + sourceName;\n<line_number-227>        }\n<line_number-228>        // Add the connection id\n<line_number-229>        if (connectionId != null) {\n<line_number-230>            sourceName = \"[c-\" + connectionId + \"] \" + sourceName;\n<line_number-231>        }\n<line_number-232>\n<line_number-233>        return sourceName;\n<line_number-234>    }\n<line_number-235>\n<line_number-236>    public QueryDiagnostics getQueryDiagnostics() {\n<line_number-237>        return queryDiagnostics;\n<line_number-238>    }\n<line_number-239>\n<line_number-240>    public void setQueryDiagnostics(QueryDiagnostics queryDiagnostics) {\n<line_number-241>        this.queryDiagnostics = queryDiagnostics;\n<line_number-242>    }\n<line_number-243>\n<line_number-244>    public void setResultSetSchema(MongoJsonSchema resultSetSchema) {\n<line_number-245>        this.getQueryDiagnostics().setResultSetSchema(resultSetSchema);\n<line_number-246>    }\n<line_number-247>\n<line_number-248>    public void setNamespacesSchema(BsonDocument namespacesSchema) {\n<line_number-249>        this.getQueryDiagnostics().setQueryCatalog(namespacesSchema);\n<line_number-250>    }\n<line_number-251>\n<line_number-252>    public void setSqlQuery(String sql) {\n<line_number-253>        this.getQueryDiagnostics().setSqlQuery(sql);\n<line_number-254>    }\n<line_number-255>\n<line_number-256>    public void setPipeline(List<BsonDocument> pipeline) {\n<line_number-257>        this.getQueryDiagnostics().setPipeline(new BsonArray(pipeline));\n<line_number-258>    }\n<line_number-259>}\n",
        "comments": [
          {
            "comment_code_range": "28-259",
            "comment_linenumber": "27",
            "comment": "This class provides logging capabilities for MongoDB operations, allowing for detailed tracking of method entries, errors, and query diagnostics.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "42-45",
            "comment_linenumber": "41",
            "comment": "Constructor that initializes the logger with a specific connection ID for logging operations related to that connection.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "55-58",
            "comment_linenumber": "54",
            "comment": "Constructor that initializes the logger with a specific statement ID, creating a logger associated with a parent logger.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "67-69",
            "comment_linenumber": "66",
            "comment": "Constructor that initializes the logger without a statement ID, used for general logging purposes.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "77-96",
            "comment_linenumber": "76",
            "comment": "Creates a logger for the specified class and attaches it to the provided parent logger, ensuring proper logging hierarchy.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "107-115",
            "comment_linenumber": "106",
            "comment": "Logs method entry with a specific call signature, using the FINER log level.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "117-135",
            "comment_linenumber": "116",
            "comment": "Logs an error message along with a throwable, including SQL diagnostics if applicable.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "146-156",
            "comment_linenumber": "145",
            "comment": "Logs a message without arguments, forwarding it to all registered output handlers if enabled.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "169-183",
            "comment_linenumber": "168",
            "comment": "Logs a message with an array of object arguments, creating a corresponding log record.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "200-214",
            "comment_linenumber": "199",
            "comment": "Logs a message with associated throwable information, storing it in the log record's thrown property.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "223-233",
            "comment_linenumber": "222",
            "comment": "Adds connection and statement IDs to the source name if they are available, enhancing log context.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "236-238",
            "comment_linenumber": "235",
            "comment": "Returns the current query diagnostics object, which holds diagnostic information for queries.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "240-242",
            "comment_linenumber": "239",
            "comment": "Sets the query diagnostics object, allowing for custom diagnostics to be used.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "244-246",
            "comment_linenumber": "243",
            "comment": "Sets the result set schema in the query diagnostics, providing structure for the expected results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "248-250",
            "comment_linenumber": "247",
            "comment": "Sets the namespaces schema in the query diagnostics, defining the query catalog structure.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "252-254",
            "comment_linenumber": "251",
            "comment": "Sets the SQL query in the query diagnostics, allowing for tracking of the executed SQL.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "256-258",
            "comment_linenumber": "255",
            "comment": "Sets the pipeline in the query diagnostics, allowing for tracking of the MongoDB aggregation pipeline.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoLogger.java' is part of the 'com.mongodb.jdbc.logging' package and is responsible for providing logging functionalities specifically tailored for MongoDB operations. It employs a logging pattern that allows for detailed tracking of method calls, errors, and query diagnostics, enhancing the observability of database interactions. The primary class, 'MongoLogger', encapsulates the logging logic and maintains a reference to a Java 'Logger' instance. It includes multiple constructors to initialize the logger with varying levels of context (connection ID, statement ID, or both). The class also contains methods for logging method entries, errors, and messages, as well as for managing query diagnostics. The internal method 'createLogger' establishes the logger's hierarchy by associating it with a parent logger, ensuring that log messages are appropriately categorized. The class interacts with external libraries such as 'java.util.logging' for logging and 'org.bson' for BSON document handling. Overall, 'MongoLogger' serves as a critical component for monitoring and debugging MongoDB interactions within the application.",
        "file_summary": "The 'MongoLogger.java' file implements a logging utility for MongoDB operations, providing structured logging capabilities for method entries, errors, and query diagnostics. It enhances the ability to trace database interactions and diagnose issues effectively."
      }
    ]
  },
  "MongoSimpleFormatter.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\MongoSimpleFormatter.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\logging\\MongoSimpleFormatter.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\MongoSimpleFormatter.java",
        "chunk_id": "MongoSimpleFormatter_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2023-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.logging;\n<line_number-18>\n<line_number-19>import java.io.PrintWriter;\n<line_number-20>import java.io.StringWriter;\n<line_number-21>import java.util.Date;\n<line_number-22>import java.util.logging.Formatter;\n<line_number-23>import java.util.logging.LogRecord;\n<line_number-24>\n<line_number-25>public class MongoSimpleFormatter extends Formatter {\n<line_number-26>    private final String format = \"[%1$tF %1$tT.%1$tL] [%4$s] %2$s: %5$s %6$s %n\";\n<line_number-27>    private final Date date = new Date();\n<line_number-28>\n<line_number-29>    @Override\n<line_number-30>    public String format(LogRecord record) {\n<line_number-31>        date.setTime(record.getMillis());\n<line_number-32>        String source;\n<line_number-33>        if (record.getSourceClassName() != null) {\n<line_number-34>            source = record.getSourceClassName();\n<line_number-35>            if (record.getSourceMethodName() != null) {\n<line_number-36>                source += \" \" + record.getSourceMethodName();\n<line_number-37>            }\n<line_number-38>        } else {\n<line_number-39>            source = record.getLoggerName();\n<line_number-40>        }\n<line_number-41>        String message = formatMessage(record);\n<line_number-42>        String throwable = \"\";\n<line_number-43>        if (record.getThrown() != null) {\n<line_number-44>            StringWriter sw = new StringWriter();\n<line_number-45>            PrintWriter pw = new PrintWriter(sw);\n<line_number-46>            pw.println();\n<line_number-47>            record.getThrown().printStackTrace(pw);\n<line_number-48>            pw.close();\n<line_number-49>            throwable = sw.toString();\n<line_number-50>        }\n<line_number-51>        return String.format(\n<line_number-52>                format,\n<line_number-53>                date,\n<line_number-54>                source,\n<line_number-55>                record.getLoggerName(),\n<line_number-56>                record.getLevel().getLocalizedName(),\n<line_number-57>                message,\n<line_number-58>                throwable);\n<line_number-59>    }\n<line_number-60>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for logging utilities specific to MongoDB JDBC.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "25-59",
            "comment_linenumber": "24",
            "comment": "Implements a custom log formatter for MongoDB JDBC, extending the Formatter class to format log messages with a specific pattern.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "29-59",
            "comment_linenumber": "28",
            "comment": "Overrides the format method to customize the log message format, including timestamp, source, and exception stack trace if present.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "31-41",
            "comment_linenumber": "30",
            "comment": "Sets the date based on the log record's timestamp and constructs the source string from the class and method names if available.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "43-49",
            "comment_linenumber": "42",
            "comment": "Checks if the log record contains a throwable and captures its stack trace for inclusion in the formatted log message.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "51-58",
            "comment_linenumber": "50",
            "comment": "Formats the final log message string using the specified format pattern and the extracted components.",
            "comment_kind": "block"
          }
        ],
        "structural_analysis": "The file 'MongoSimpleFormatter.java' is part of the 'com.mongodb.jdbc.logging' package and defines a custom logging formatter for MongoDB JDBC. It extends the Java 'Formatter' class to provide a specific format for log messages. The primary role of the 'MongoSimpleFormatter' class is to format log records into a human-readable string that includes the timestamp, log level, source class/method, and any associated exception stack traces. The class contains a private field for the date format and overrides the 'format' method to implement the custom formatting logic. The method retrieves the timestamp from the log record, constructs the source string from the class and method names, and checks for any thrown exceptions to include their stack traces. The final formatted string is constructed using the specified format pattern. This class does not maintain any state beyond the formatting logic and is thread-safe due to the use of local variables within the 'format' method.",
        "file_summary": "This file provides a custom log formatter for MongoDB JDBC, allowing for structured and readable log output that includes timestamps, log levels, and exception details."
      }
    ]
  },
  "QueryDiagnostics.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\QueryDiagnostics.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\logging\\QueryDiagnostics.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\logging\\QueryDiagnostics.java",
        "chunk_id": "QueryDiagnostics_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2025-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.logging;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.utils.BsonUtils.JSON_WRITER_NO_INDENT_SETTINGS;\n<line_number-20>\n<line_number-21>import com.mongodb.jdbc.MongoDriver;\n<line_number-22>import com.mongodb.jdbc.MongoJsonSchema;\n<line_number-23>import com.mongodb.jdbc.utils.BsonUtils;\n<line_number-24>import org.bson.BsonArray;\n<line_number-25>import org.bson.BsonDocument;\n<line_number-26>import org.bson.codecs.Codec;\n<line_number-27>import org.bson.codecs.pojo.annotations.BsonProperty;\n<line_number-28>\n<line_number-29>public class QueryDiagnostics {\n<line_number-30>    private static final Codec<QueryDiagnostics> CODEC =\n<line_number-31>            MongoDriver.getCodecRegistry().get(QueryDiagnostics.class);\n<line_number-32>\n<line_number-33>    @BsonProperty private String sqlQuery;\n<line_number-34>    @BsonProperty private BsonDocument queryCatalog;\n<line_number-35>    @BsonProperty private MongoJsonSchema resultSetSchema;\n<line_number-36>    @BsonProperty private BsonArray pipeline;\n<line_number-37>\n<line_number-38>    public void setSqlQuery(String sqlQuery) {\n<line_number-39>        this.sqlQuery = sqlQuery;\n<line_number-40>    }\n<line_number-41>\n<line_number-42>    public void setQueryCatalog(BsonDocument queryCatalog) {\n<line_number-43>        this.queryCatalog = queryCatalog;\n<line_number-44>    }\n<line_number-45>\n<line_number-46>    public void setResultSetSchema(MongoJsonSchema resultSetSchema) {\n<line_number-47>        this.resultSetSchema = resultSetSchema;\n<line_number-48>    }\n<line_number-49>\n<line_number-50>    public void setPipeline(BsonArray pipeline) {\n<line_number-51>        this.pipeline = pipeline;\n<line_number-52>    }\n<line_number-53>\n<line_number-54>    public String getSqlQuery() {\n<line_number-55>        return sqlQuery;\n<line_number-56>    }\n<line_number-57>\n<line_number-58>    public BsonDocument getQueryCatalog() {\n<line_number-59>        return queryCatalog;\n<line_number-60>    }\n<line_number-61>\n<line_number-62>    public MongoJsonSchema getResultSetSchema() {\n<line_number-63>        return resultSetSchema;\n<line_number-64>    }\n<line_number-65>\n<line_number-66>    public BsonArray getPipeline() {\n<line_number-67>        return pipeline;\n<line_number-68>    }\n<line_number-69>\n<line_number-70>    @Override\n<line_number-71>    public String toString() {\n<line_number-72>        return BsonUtils.toString(CODEC, this, JSON_WRITER_NO_INDENT_SETTINGS);\n<line_number-73>    }\n<line_number-74>}\n",
        "comments": [
          {
            "comment_code_range": "29-74",
            "comment_linenumber": "28",
            "comment": "Represents diagnostic information for SQL queries, including the SQL string, query catalog, result set schema, and processing pipeline.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "38-40",
            "comment_linenumber": "37",
            "comment": "Sets the SQL query string for this diagnostic object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "42-44",
            "comment_linenumber": "41",
            "comment": "Sets the query catalog as a BSON document for this diagnostic object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "46-48",
            "comment_linenumber": "45",
            "comment": "Sets the result set schema as a MongoJsonSchema for this diagnostic object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "50-52",
            "comment_linenumber": "49",
            "comment": "Sets the processing pipeline as a BSON array for this diagnostic object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "54-56",
            "comment_linenumber": "53",
            "comment": "Returns the SQL query string associated with this diagnostic object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "58-60",
            "comment_linenumber": "57",
            "comment": "Returns the query catalog as a BSON document associated with this diagnostic object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "62-64",
            "comment_linenumber": "61",
            "comment": "Returns the result set schema as a MongoJsonSchema associated with this diagnostic object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "66-68",
            "comment_linenumber": "65",
            "comment": "Returns the processing pipeline as a BSON array associated with this diagnostic object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "70-73",
            "comment_linenumber": "69",
            "comment": "Returns a string representation of this diagnostic object using BSON utilities.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'QueryDiagnostics.java' is part of the 'com.mongodb.jdbc.logging' package and is responsible for encapsulating diagnostic information related to SQL queries executed against a MongoDB database. It employs a simple data structure to hold various attributes relevant to query diagnostics, including the SQL query string, a BSON document representing the query catalog, a schema for the result set, and a BSON array for the processing pipeline. The class utilizes BSON annotations to facilitate serialization and deserialization of its fields. The primary design pattern used here is a data transfer object (DTO), which is common in applications that require the transfer of data between layers. The class is not designed to be thread-safe and does not implement any specific lifecycle management, as it is intended to be instantiated and used in a single-threaded context. The class contains private fields for each of the attributes, with public setter and getter methods to manipulate and access these fields. The 'toString' method is overridden to provide a JSON-like string representation of the object, leveraging BSON utilities for formatting. The class does not have any complex control flow or external dependencies beyond BSON utilities and MongoDB driver components.",
        "file_summary": "The 'QueryDiagnostics.java' file defines a class that encapsulates diagnostic information for SQL queries executed against a MongoDB database. It provides methods to set and retrieve various attributes related to the query, including the SQL string, query catalog, result set schema, and processing pipeline."
      }
    ]
  },
  "CheckDriverVersionResult.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\CheckDriverVersionResult.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\CheckDriverVersionResult.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\CheckDriverVersionResult.java",
        "chunk_id": "CheckDriverVersionResult_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.mongosql;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.utils.BsonUtils.JSON_WRITER_NO_INDENT_SETTINGS;\n<line_number-20>\n<line_number-21>import com.mongodb.jdbc.MongoDriver;\n<line_number-22>import com.mongodb.jdbc.utils.BsonUtils;\n<line_number-23>import org.bson.codecs.Codec;\n<line_number-24>import org.bson.codecs.pojo.annotations.BsonCreator;\n<line_number-25>import org.bson.codecs.pojo.annotations.BsonProperty;\n<line_number-26>\n<line_number-27>public class CheckDriverVersionResult {\n<line_number-28>\n<line_number-29>    private static final Codec<CheckDriverVersionResult> CODEC =\n<line_number-30>            MongoDriver.getCodecRegistry().get(CheckDriverVersionResult.class);\n<line_number-31>\n<line_number-32>    @BsonProperty(\"compatible\")\n<line_number-33>    public final Boolean compatible;\n<line_number-34>\n<line_number-35>    @BsonCreator\n<line_number-36>    public CheckDriverVersionResult(@BsonProperty(\"compatible\") Boolean compatible) {\n<line_number-37>        this.compatible = (compatible != null) ? compatible : false;\n<line_number-38>    }\n<line_number-39>\n<line_number-40>    @Override\n<line_number-41>    public String toString() {\n<line_number-42>        return BsonUtils.toString(CODEC, this, JSON_WRITER_NO_INDENT_SETTINGS);\n<line_number-43>    }\n<line_number-44>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC SQL integration.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "27-44",
            "comment_linenumber": "26",
            "comment": "Represents the result of checking the MongoDB driver version compatibility, encapsulating the compatibility status.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "29-30",
            "comment_linenumber": "28",
            "comment": "Codec for serializing and deserializing CheckDriverVersionResult instances using BSON.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "32-33",
            "comment_linenumber": "31",
            "comment": "Indicates whether the driver version is compatible with the MongoDB server.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "35-38",
            "comment_linenumber": "34",
            "comment": "Constructor that initializes the compatibility status, defaulting to false if null.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "40-44",
            "comment_linenumber": "39",
            "comment": "Returns a string representation of the CheckDriverVersionResult instance in BSON format.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'CheckDriverVersionResult.java' is part of the MongoDB JDBC integration package, specifically designed to handle the results of driver version compatibility checks. It follows a simple data structure pattern, encapsulating the compatibility status of the MongoDB driver. The primary class, CheckDriverVersionResult, is responsible for holding the compatibility information and provides methods for serialization and string representation. The class utilizes BSON annotations for property mapping, ensuring compatibility with MongoDB's BSON format. The class is designed to be immutable, with a final field for compatibility status initialized through a constructor. The codec for BSON serialization is statically defined, allowing for efficient encoding and decoding of instances. The class does not have any external dependencies beyond the MongoDB JDBC library and BSON utilities, making it lightweight and focused on its specific role.",
        "file_summary": "This file defines the CheckDriverVersionResult class, which encapsulates the result of checking the compatibility of the MongoDB driver version. It provides a constructor for initialization, a method for string representation, and utilizes BSON for serialization."
      }
    ]
  },
  "GetMongosqlTranslateVersionResult.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\GetMongosqlTranslateVersionResult.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\GetMongosqlTranslateVersionResult.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\GetMongosqlTranslateVersionResult.java",
        "chunk_id": "GetMongosqlTranslateVersionResult_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.mongosql;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.utils.BsonUtils.JSON_WRITER_NO_INDENT_SETTINGS;\n<line_number-20>\n<line_number-21>import com.mongodb.jdbc.MongoDriver;\n<line_number-22>import com.mongodb.jdbc.utils.BsonUtils;\n<line_number-23>import org.bson.codecs.Codec;\n<line_number-24>import org.bson.codecs.pojo.annotations.BsonCreator;\n<line_number-25>import org.bson.codecs.pojo.annotations.BsonProperty;\n<line_number-26>\n<line_number-27>public class GetMongosqlTranslateVersionResult {\n<line_number-28>\n<line_number-29>    private static final Codec<GetMongosqlTranslateVersionResult> CODEC =\n<line_number-30>            MongoDriver.getCodecRegistry().get(GetMongosqlTranslateVersionResult.class);\n<line_number-31>\n<line_number-32>    @BsonProperty(\"version\")\n<line_number-33>    public final String version;\n<line_number-34>\n<line_number-35>    @BsonCreator\n<line_number-36>    public GetMongosqlTranslateVersionResult(@BsonProperty(\"version\") String version) {\n<line_number-37>        this.version = version;\n<line_number-38>    }\n<line_number-39>\n<line_number-40>    @Override\n<line_number-41>    public String toString() {\n<line_number-42>        return BsonUtils.toString(CODEC, this, JSON_WRITER_NO_INDENT_SETTINGS);\n<line_number-43>    }\n<line_number-44>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC MongoSQL translation results.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "27-44",
            "comment_linenumber": "26",
            "comment": "Represents the result of a MongoSQL translation version request, encapsulating the version information.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "29-30",
            "comment_linenumber": "28",
            "comment": "Codec for serializing and deserializing GetMongosqlTranslateVersionResult instances.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "32-33",
            "comment_linenumber": "31",
            "comment": "Holds the version string of the MongoSQL translation result.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "35-38",
            "comment_linenumber": "34",
            "comment": "Constructor that initializes the version field with the provided value.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "40-44",
            "comment_linenumber": "39",
            "comment": "Returns a string representation of the GetMongosqlTranslateVersionResult instance in JSON format.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'GetMongosqlTranslateVersionResult.java' is part of the MongoDB JDBC driver, specifically handling the translation of MongoSQL version results. It follows a simple data structure pattern, encapsulating the version information in a class. The primary class, GetMongosqlTranslateVersionResult, implements a constructor for initializing its fields and a toString method for JSON representation. The class utilizes BSON annotations for serialization, indicating its integration with MongoDB's BSON data format. The static CODEC field is used for encoding and decoding instances of this class, ensuring compatibility with MongoDB's codec registry. The class is designed to be immutable, as the version field is declared final and set only through the constructor. This design ensures thread safety and consistency of the version data throughout its lifecycle.",
        "file_summary": "This file defines the GetMongosqlTranslateVersionResult class, which encapsulates the version information returned from a MongoSQL translation request. It provides mechanisms for BSON serialization and a string representation in JSON format."
      }
    ]
  },
  "GetNamespacesResult.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\GetNamespacesResult.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\GetNamespacesResult.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\GetNamespacesResult.java",
        "chunk_id": "GetNamespacesResult_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.mongosql;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.utils.BsonUtils.JSON_WRITER_NO_INDENT_SETTINGS;\n<line_number-20>\n<line_number-21>import com.mongodb.jdbc.MongoDriver;\n<line_number-22>import com.mongodb.jdbc.utils.BsonUtils;\n<line_number-23>import java.util.List;\n<line_number-24>import org.bson.codecs.Codec;\n<line_number-25>import org.bson.codecs.pojo.annotations.BsonCreator;\n<line_number-26>import org.bson.codecs.pojo.annotations.BsonProperty;\n<line_number-27>\n<line_number-28>public class GetNamespacesResult {\n<line_number-29>\n<line_number-30>    private static final Codec<GetNamespacesResult> CODEC =\n<line_number-31>            MongoDriver.getCodecRegistry().get(GetNamespacesResult.class);\n<line_number-32>\n<line_number-33>    @BsonProperty(\"namespaces\")\n<line_number-34>    public final List<Namespace> namespaces;\n<line_number-35>\n<line_number-36>    @BsonCreator\n<line_number-37>    public GetNamespacesResult(@BsonProperty(\"namespaces\") List<Namespace> namespaces) {\n<line_number-38>        this.namespaces = namespaces;\n<line_number-39>    }\n<line_number-40>\n<line_number-41>    public static class Namespace {\n<line_number-42>        private static final Codec<Namespace> CODEC =\n<line_number-43>                MongoDriver.getCodecRegistry().get(Namespace.class);\n<line_number-44>\n<line_number-45>        @BsonProperty(\"database\")\n<line_number-46>        public final String database;\n<line_number-47>\n<line_number-48>        @BsonProperty(\"collection\")\n<line_number-49>        public final String collection;\n<line_number-50>\n<line_number-51>        @BsonCreator\n<line_number-52>        public Namespace(\n<line_number-53>                @BsonProperty(\"database\") String database,\n<line_number-54>                @BsonProperty(\"collection\") String collection) {\n<line_number-55>            this.database = database;\n<line_number-56>            this.collection = collection;\n<line_number-57>        }\n<line_number-58>\n<line_number-59>        @Override\n<line_number-60>        public String toString() {\n<line_number-61>            return BsonUtils.toString(CODEC, this, JSON_WRITER_NO_INDENT_SETTINGS);\n<line_number-62>        }\n<line_number-63>    }\n<line_number-64>\n<line_number-65>    @Override\n<line_number-66>    public String toString() {\n<line_number-67>        return BsonUtils.toString(CODEC, this, JSON_WRITER_NO_INDENT_SETTINGS);\n<line_number-68>    }\n<line_number-69>}\n",
        "comments": [
          {
            "comment_code_range": "28-69",
            "comment_linenumber": "27",
            "comment": "Represents the result of a GetNamespaces operation, encapsulating a list of Namespace objects.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "36-39",
            "comment_linenumber": "35",
            "comment": "Constructor that initializes the namespaces list from a BSON property.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "41-63",
            "comment_linenumber": "40",
            "comment": "Represents a single namespace consisting of a database and collection name.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "51-57",
            "comment_linenumber": "50",
            "comment": "Constructor that initializes the database and collection names from BSON properties.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "59-62",
            "comment_linenumber": "58",
            "comment": "Returns a string representation of the Namespace object in JSON format.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "65-68",
            "comment_linenumber": "64",
            "comment": "Returns a string representation of the GetNamespacesResult object in JSON format.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'GetNamespacesResult.java' defines a data structure for handling the results of a MongoDB GetNamespaces operation. It utilizes BSON annotations for serialization and deserialization. The primary class, GetNamespacesResult, contains a list of Namespace objects, which represent individual namespaces consisting of a database and collection name. The class employs a static Codec for BSON encoding and decoding, ensuring compatibility with MongoDB's BSON format. The Namespace class is nested within GetNamespacesResult, encapsulating the properties of a namespace. Both classes provide constructors annotated with @BsonCreator to facilitate the creation of instances from BSON data. Additionally, both classes override the toString method to provide a JSON representation of their instances using BsonUtils. The file imports necessary utilities from the MongoDB JDBC driver and BSON codec libraries, establishing dependencies for BSON handling.",
        "file_summary": "This file defines the GetNamespacesResult class, which encapsulates the result of a MongoDB GetNamespaces operation, including a list of Namespace objects. It provides constructors for BSON serialization and methods for JSON representation."
      }
    ]
  },
  "MongoSQLException.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\MongoSQLException.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\MongoSQLException.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\MongoSQLException.java",
        "chunk_id": "MongoSQLException_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.mongosql;\n<line_number-18>\n<line_number-19>public class MongoSQLException extends Exception {\n<line_number-20>    public MongoSQLException(String message) {\n<line_number-21>        super(message);\n<line_number-22>    }\n<line_number-23>\n<line_number-24>    public MongoSQLException(String message, Throwable cause) {\n<line_number-25>        super(message, cause);\n<line_number-26>    }\n<line_number-27>}\n",
        "comments": [
          {
            "comment_code_range": "19-27",
            "comment_linenumber": "18",
            "comment": "Custom exception class for handling MongoDB-related SQL exceptions, extending the base Exception class.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "20-21",
            "comment_linenumber": "19",
            "comment": "Constructor that accepts a message string to describe the exception.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "24-25",
            "comment_linenumber": "23",
            "comment": "Constructor that accepts a message string and a Throwable cause for the exception.",
            "comment_kind": "constructor"
          }
        ],
        "structural_analysis": "The file 'MongoSQLException.java' defines a custom exception class for handling SQL exceptions specific to MongoDB operations. It follows standard Java exception handling practices by extending the base 'Exception' class. The class contains two constructors: one that takes a message string and another that takes both a message and a Throwable cause, allowing for detailed exception reporting. This design allows developers to throw and catch MongoSQLException instances in their code, providing clarity on the nature of the errors encountered during MongoDB interactions. The class does not implement any additional methods or properties, focusing solely on exception handling.",
        "file_summary": "This file defines the MongoSQLException class, a custom exception for MongoDB-related SQL errors, facilitating better error handling in database operations."
      }
    ]
  },
  "MongoSQLTranslate.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\MongoSQLTranslate.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\MongoSQLTranslate.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\MongoSQLTranslate.java",
        "chunk_id": "MongoSQLTranslate_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.mongosql;\n<line_number-18>\n<line_number-19>import com.mongodb.client.AggregateIterable;\n<line_number-20>import com.mongodb.client.MongoCollection;\n<line_number-21>import com.mongodb.client.MongoDatabase;\n<line_number-22>import com.mongodb.client.model.Accumulators;\n<line_number-23>import com.mongodb.client.model.Aggregates;\n<line_number-24>import com.mongodb.client.model.Field;\n<line_number-25>import com.mongodb.client.model.Filters;\n<line_number-26>import com.mongodb.client.model.Projections;\n<line_number-27>import com.mongodb.jdbc.MongoDriver;\n<line_number-28>import com.mongodb.jdbc.MongoJsonSchema;\n<line_number-29>import com.mongodb.jdbc.MongoJsonSchemaResult;\n<line_number-30>import com.mongodb.jdbc.MongoSerializationException;\n<line_number-31>import com.mongodb.jdbc.logging.AutoLoggable;\n<line_number-32>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-33>import com.mongodb.jdbc.utils.BsonUtils;\n<line_number-34>import java.util.ArrayList;\n<line_number-35>import java.util.Arrays;\n<line_number-36>import java.util.List;\n<line_number-37>import java.util.logging.Level;\n<line_number-38>import java.util.stream.Collectors;\n<line_number-39>import org.bson.*;\n<line_number-40>import org.bson.codecs.DecoderContext;\n<line_number-41>import org.bson.conversions.Bson;\n<line_number-42>\n<line_number-43>@AutoLoggable\n<line_number-44>public class MongoSQLTranslate {\n<line_number-45>    public static final String SQL_SCHEMAS_COLLECTION = \"__sql_schemas\";\n<line_number-46>    private final MongoLogger logger;\n<line_number-47>\n<line_number-48>    /** Native method to send commands via JNI. */\n<line_number-49>    public native byte[] runCommand(byte[] command, int length);\n<line_number-50>\n<line_number-51>    public static final String ERROR_KEY = \"error\";\n<line_number-52>    public static final String IS_INTERNAL_ERROR_KEY = \"error_is_internal\";\n<line_number-53>\n<line_number-54>    public MongoSQLTranslate(MongoLogger logger) {\n<line_number-55>        this.logger = logger;\n<line_number-56>    }\n<line_number-57>\n<line_number-58>    /**\n<line_number-59>     * Executes the JNI runCommand and returns the response as a POJO.\n<line_number-60>     *\n<line_number-61>     * @param command The command to be executed.\n<line_number-62>     * @param responseClass The class of the response POJO.\n<line_number-63>     * @return The response POJO.\n<line_number-64>     * @throws MongoSerializationException If an error occurs during serialization or\n<line_number-65>     *     deserialization.\n<line_number-66>     * @throws MongoSQLException If an error occurs during command execution.\n<line_number-67>     */\n<line_number-68>    public <T> T runCommand(BsonDocument command, Class<T> responseClass)\n<line_number-69>            throws MongoSerializationException, MongoSQLException {\n<line_number-70>\n<line_number-71>        byte[] commandBytes = BsonUtils.serialize(command);\n<line_number-72>        byte[] responseBytes = runCommand(commandBytes, commandBytes.length);\n<line_number-73>        BsonDocument responseDoc = BsonUtils.deserialize(responseBytes);\n<line_number-74>\n<line_number-75>        BsonDocumentReader reader = new BsonDocumentReader(responseDoc);\n<line_number-76>        BsonValue error = responseDoc.get(ERROR_KEY);\n<line_number-77>        if (error != null) {\n<line_number-78>            String errorMessage =\n<line_number-79>                    String.format(\n<line_number-80>                            responseDoc.getBoolean(IS_INTERNAL_ERROR_KEY).getValue()\n<line_number-81>                                    ? \"Internal error: %s\"\n<line_number-82>                                    : \"Error executing command: %s\",\n<line_number-83>                            error.asString().getValue());\n<line_number-84>            throw new MongoSQLException(errorMessage);\n<line_number-85>        }\n<line_number-86>\n<line_number-87>        return MongoDriver.getCodecRegistry()\n<line_number-88>                .get(responseClass)\n<line_number-89>                .decode(reader, DecoderContext.builder().build());\n<line_number-90>    }\n<line_number-91>\n<line_number-92>    /**\n<line_number-93>     * Retrieves the version of the mongosqltranslate library.\n<line_number-94>     *\n<line_number-95>     * @return GetMongosqlTranslateVersionResult containing the version string.\n<line_number-96>     * @throws MongoSQLException If an error occurs during command execution.\n<line_number-97>     * @throws MongoSerializationException If an error occurs during serialization or\n<line_number-98>     *     deserialization.\n<line_number-99>     */\n<line_number-100>    public GetMongosqlTranslateVersionResult getMongosqlTranslateVersion()\n<line_number-101>            throws MongoSQLException, MongoSerializationException {\n<line_number-102>        BsonDocument command =\n<line_number-103>                new BsonDocument(\"command\", new BsonString(\"getMongosqlTranslateVersion\"))\n<line_number-104>                        .append(\"options\", new BsonDocument());\n<line_number-105>\n<line_number-106>        GetMongosqlTranslateVersionResult versionResult =\n<line_number-107>                runCommand(command, GetMongosqlTranslateVersionResult.class);\n<line_number-108>\n<line_number-109>        logger.log(Level.INFO, \"mongosqlTranslateVersion: \" + versionResult.version);\n<line_number-110>        return versionResult;\n<line_number-111>    }\n<line_number-112>\n<line_number-113>    /**\n<line_number-114>     * Checks if the JDBC driver version is compatible with the mongosqltranslate library.\n<line_number-115>     *\n<line_number-116>     * @return CheckDriverVersionResult containing the compatibility status.\n<line_number-117>     * @throws MongoSQLException If an error occurs during command execution.\n<line_number-118>     * @throws MongoSerializationException If an error occurs during serialization or\n<line_number-119>     *     deserialization.\n<line_number-120>     */\n<line_number-121>    public CheckDriverVersionResult checkDriverVersion()\n<line_number-122>            throws MongoSQLException, MongoSerializationException {\n<line_number-123>        BsonDocument options =\n<line_number-124>                new BsonDocument(\"driverVersion\", new BsonString(MongoDriver.getVersion()))\n<line_number-125>                        .append(\"odbcDriver\", new BsonBoolean(false));\n<line_number-126>        BsonDocument command =\n<line_number-127>                new BsonDocument(\"command\", new BsonString(\"checkDriverVersion\"))\n<line_number-128>                        .append(\"options\", options);\n<line_number-129>\n<line_number-130>        CheckDriverVersionResult checkDriverVersionResult =\n<line_number-131>                runCommand(command, CheckDriverVersionResult.class);\n<line_number-132>\n<line_number-133>        logger.log(\n<line_number-134>                Level.INFO, \"Driver Compatibility Status: \" + checkDriverVersionResult.compatible);\n<line_number-135>        return checkDriverVersionResult;\n<line_number-136>    }\n<line_number-137>\n<line_number-138>    /**\n<line_number-139>     * Executes a translate command based on the provided SQL and returns the response.\n<line_number-140>     *\n<line_number-141>     * @param sql The SQL query to translate.\n<line_number-142>     * @param dbName The database name.\n<line_number-143>     * @param schemaCatalog schema catalog\n<line_number-144>     * @return TranslateResult\n<line_number-145>     * @throws MongoSQLException If the command execution fails.\n<line_number-146>     * @throws MongoSerializationException If an error occurs during serialization or\n<line_number-147>     *     deserialization.\n<line_number-148>     */\n<line_number-149>    public TranslateResult translate(String sql, String dbName, BsonDocument schemaCatalog)\n<line_number-150>            throws MongoSQLException, MongoSerializationException {\n<line_number-151>\n<line_number-152>        // Setting excludeNamespaces to default value false and relaxSchemaChecking to default value true.\n<line_number-153>        // These options are not currently handled in the JDBC driver\n<line_number-154>        BsonDocument options =\n<line_number-155>                new BsonDocument(\"sql\", new BsonString(sql))\n<line_number-156>                        .append(\"db\", new BsonString(dbName))\n<line_number-157>                        .append(\"excludeNamespaces\", new BsonBoolean(false))\n<line_number-158>                        .append(\"relaxSchemaChecking\", new BsonBoolean(true))\n<line_number-159>                        .append(\"schemaCatalog\", schemaCatalog);\n<line_number-160>        BsonDocument translateCommand =\n<line_number-161>                new BsonDocument(\"command\", new BsonString(\"translate\")).append(\"options\", options);\n<line_number-162>\n<line_number-163>        return runCommand(translateCommand, TranslateResult.class);\n<line_number-164>    }\n<line_number-165>\n<line_number-166>    /**\n<line_number-167>     * Retrieves the namespaces involved in the given SQL query.\n<line_number-168>     *\n<line_number-169>     * @param dbName The name of the database.\n<line_number-170>     * @param sql The SQL query.\n<line_number-171>     * @return GetNamespacesResult containing the namespaces.\n<line_number-172>     * @throws MongoSQLException If an error occurs during command execution.\n<line_number-173>     * @throws MongoSerializationException If an error occurs during serialization or\n<line_number-174>     *     deserialization.\n<line_number-175>     */\n<line_number-176>    public GetNamespacesResult getNamespaces(String dbName, String sql)\n<line_number-177>            throws MongoSQLException, MongoSerializationException {\n<line_number-178>        BsonDocument options =\n<line_number-179>                new BsonDocument(\"sql\", new BsonString(sql)).append(\"db\", new BsonString(dbName));\n<line_number-180>        BsonDocument command =\n<line_number-181>                new BsonDocument(\"command\", new BsonString(\"getNamespaces\"))\n<line_number-182>                        .append(\"options\", options);\n<line_number-183>\n<line_number-184>        return runCommand(command, GetNamespacesResult.class);\n<line_number-185>    }\n<line_number-186>\n<line_number-187>    /**\n<line_number-188>     * Builds a catalog document containing the schema information for the specified collections.\n<line_number-189>     *\n<line_number-190>     * @param collections The list of collections to retrieve the schemas for.\n<line_number-191>     * @param dbName The name of the database where the collections must be.\n<line_number-192>     * @param mongoDatabase The current database for this connection.\n<line_number-193>     * @return the schema catalog for all the specified collections. The catalog document format is\n<line_number-194>     *     : { \"dbName\": { \"collection1\" : \"Schema1\", \"collection2\" : \"Schema2\", ... }}\n<line_number-195>     */\n<line_number-196>    public BsonDocument buildCatalogDocument(\n<line_number-197>            MongoDatabase mongoDatabase,\n<line_number-198>            String dbName,\n<line_number-199>            List<GetNamespacesResult.Namespace> collections)\n<line_number-200>            throws MongoSQLException {\n<line_number-201>\n<line_number-202>        // There is no collection tied to the query\n<line_number-203>        // For example \"SELECT 1\"\n<line_number-204>        if (collections == null || collections.isEmpty()) {\n<line_number-205>            MongoJsonSchema emptyObjectSchema = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-206>            // Create a catalog with an empty collection name and an empty schema\n<line_number-207>            // {\"test\": {\"\": {}}}\n<line_number-208>            return new BsonDocument(dbName, new BsonDocument(\"\", new BsonDocument()));\n<line_number-209>        }\n<line_number-210>\n<line_number-211>        // Create an aggregation pipeline to fetch the schema information for the specified collections.\n<line_number-212>        // The pipeline uses $in to query all the specified collections and projects them into the desired format:\n<line_number-213>        // \"dbName\": { \"collection1\" : \"Schema1\", \"collection2\" : \"Schema2\", ... }\n<line_number-214>        List<String> collectionNames =\n<line_number-215>                collections.stream().map(ns -> ns.collection).collect(Collectors.toList());\n<line_number-216>\n<line_number-217>        // Filter documents where _id is in the list of collection names\n<line_number-218>        Bson matchStage = Aggregates.match(Filters.in(\"_id\", collectionNames));\n<line_number-219>\n<line_number-220>        // Include only the 'schema' and '_id' fields\n<line_number-221>        Bson projectStage =\n<line_number-222>                Aggregates.project(\n<line_number-223>                        Projections.fields(\n<line_number-224>                                Projections.include(\"schema\"), Projections.include(\"_id\")));\n<line_number-225>\n<line_number-226>        // Accumulate collection names and their schemas into an array\n<line_number-227>        Bson groupStage =\n<line_number-228>                Aggregates.group(\n<line_number-229>                        null,\n<line_number-230>                        Accumulators.push(\n<line_number-231>                                \"collections\",\n<line_number-232>                                new BsonDocument(\"collectionName\", new BsonString(\"$_id\"))\n<line_number-233>                                        .append(\"schema\", new BsonString(\"$schema\"))));\n<line_number-234>\n<line_number-235>        // Convert the 'collections' array into a document mapping each collection name to its schema\n<line_number-236>        // under the database name\n<line_number-237>        Bson finalProjectStage =\n<line_number-238>                Aggregates.project(\n<line_number-239>                        Projections.fields(\n<line_number-240>                                Projections.excludeId(),\n<line_number-241>                                Projections.computed(\n<line_number-242>                                        dbName,\n<line_number-243>                                        new BsonDocument(\n<line_number-244>                                                \"$arrayToObject\",\n<line_number-245>                                                new BsonArray(\n<line_number-246>                                                        Arrays.asList(\n<line_number-247>                                                                new BsonDocument(\n<line_number-248>                                                                        \"$map\",\n<line_number-249>                                                                        new BsonDocument(\n<line_number-250>                                                                                        \"input\",\n<line_number-251>                                                                                        new BsonString(\n<line_number-252>                                                                                                \"$collections\"))\n<line_number-253>                                                                                .append(\n<line_number-254>                                                                                        \"as\",\n<line_number-255>                                                                                        new BsonString(\n<line_number-256>                                                                                                \"coll\"))\n<line_number-257>                                                                                .append(\n<line_number-258>                                                                                        \"in\",\n<line_number-259>                                                                                        new BsonDocument(\n<line_number-260>                                                                                                        \"k\",\n<line_number-261>                                                                                                        new BsonString(\n<line_number-262>                                                                                                                \"$$coll.collectionName\"))\n<line_number-263>                                                                                                .append(\n<line_number-264>                                                                                                        \"v\",\n<line_number-265>                                                                                                        new BsonString(\n<line_number-266>                                                                                                                \"$$coll.schema\"))))))))));\n<line_number-267>        List<Bson> pipeline =\n<line_number-268>                Arrays.asList(matchStage, projectStage, groupStage, finalProjectStage);\n<line_number-269>\n<line_number-270>        MongoCollection<BsonDocument> collection =\n<line_number-271>                mongoDatabase.getCollection(SQL_SCHEMAS_COLLECTION, BsonDocument.class);\n<line_number-272>        AggregateIterable<BsonDocument> result = collection.aggregate(pipeline);\n<line_number-273>\n<line_number-274>        BsonDocument catalog = null;\n<line_number-275>        boolean foundResult = false;\n<line_number-276>\n<line_number-277>        for (BsonDocument doc : result) {\n<line_number-278>            if (foundResult) {\n<line_number-279>                throw new MongoSQLException(\n<line_number-280>                        \"Multiple results returned while getting schema; expected only one.\");\n<line_number-281>            }\n<line_number-282>            catalog = doc;\n<line_number-283>            foundResult = true;\n<line_number-284>        }\n<line_number-285>        if (!foundResult) {\n<line_number-286>            logger.log(\n<line_number-287>                    Level.SEVERE,\n<line_number-288>                    \"No schema information found for any of the requested collections. Will use empty schemas. Hint: Generate schemas for your collections.\");\n<line_number-289>            BsonDocument schemas = new BsonDocument();\n<line_number-290>            for (String collectionName : collectionNames) {\n<line_number-291>                schemas.append(collectionName, new BsonDocument());\n<line_number-292>            }\n<line_number-293>            catalog = new BsonDocument(dbName, schemas);\n<line_number-294>        }\n<line_number-295>\n<line_number-296>        // Check that all expected collections are present in the result\n<line_number-297>        BsonDocument resultCollections = catalog.getDocument(dbName);\n<line_number-298>        List<String> returnedCollections = new ArrayList<>(resultCollections.keySet());\n<line_number-299>        List<String> missingCollections =\n<line_number-300>                collections\n<line_number-301>                        .stream()\n<line_number-302>                        .map(ns -> ns.collection)\n<line_number-303>                        .filter(c -> !returnedCollections.contains(c))\n<line_number-304>                        .collect(Collectors.toList());\n<line_number-305>\n<line_number-306>        if (!missingCollections.isEmpty()) {\n<line_number-307>            throw new MongoSQLException(\n<line_number-308>                    \"Could not retrieve schema for collections: \" + missingCollections);\n<line_number-309>        }\n<line_number-310>\n<line_number-311>        return catalog;\n<line_number-312>    }\n<line_number-313>\n<line_number-314>    /**\n<line_number-315>     * Retrieves the schema of a specific collection from the MongoDB database.\n<line_number-316>     *\n<line_number-317>     * @param mongoDatabase MongoDB database instance.\n<line_number-318>     * @param collectionName Name of the collection to retrieve the schema.\n<line_number-319>     * @return MongoJsonSchemaResult schema result of the collection.\n<line_number-320>     * @throws MongoSQLException If no schema is found for the given collection or an error occurs\n<line_number-321>     *     during command execution.\n<line_number-322>     * @throws MongoSerializationException If an error occurs during serialization or\n<line_number-323>     *     deserialization.\n<line_number-324>     */\n<line_number-325>    public MongoJsonSchemaResult getSchema(MongoDatabase mongoDatabase, String collectionName)\n<line_number-326>            throws MongoSerializationException, MongoSQLException {\n<line_number-327>\n<line_number-328>        // The pipeline formats the output to match the structure required by MongoJsonSchemaResult\n<line_number-329>        List<Bson> pipeline =\n<line_number-330>                Arrays.asList(\n<line_number-331>                        Aggregates.match(Filters.eq(\"_id\", collectionName)),\n<line_number-332>                        Aggregates.project(\n<line_number-333>                                Projections.fields(\n<line_number-334>                                        Projections.exclude(\"_id\"),\n<line_number-335>                                        Projections.computed(\"schema.jsonSchema\", \"$schema\"),\n<line_number-336>                                        Projections.computed(\"schema.version\", new BsonInt32(1)))),\n<line_number-337>                        Aggregates.addFields(new Field<>(\"ok\", new BsonInt32(1))));\n<line_number-338>\n<line_number-339>        MongoCollection<BsonDocument> schemasCollection =\n<line_number-340>                mongoDatabase.getCollection(SQL_SCHEMAS_COLLECTION, BsonDocument.class);\n<line_number-341>        AggregateIterable<BsonDocument> result = schemasCollection.aggregate(pipeline);\n<line_number-342>\n<line_number-343>        BsonDocument resultDoc = result.first();\n<line_number-344>\n<line_number-345>        if (resultDoc == null) {\n<line_number-346>            logger.log(\n<line_number-347>                    Level.SEVERE,\n<line_number-348>                    \"No schema information returned for the requested collections. Using an empty schema.\");\n<line_number-349>            resultDoc = new BsonDocument();\n<line_number-350>        }\n<line_number-351>\n<line_number-352>        BsonDocumentReader reader = new BsonDocumentReader(resultDoc);\n<line_number-353>        MongoJsonSchemaResult mongoJsonSchemaResult =\n<line_number-354>                MongoDriver.getCodecRegistry()\n<line_number-355>                        .get(MongoJsonSchemaResult.class)\n<line_number-356>                        .decode(reader, DecoderContext.builder().build());\n<line_number-357>        return mongoJsonSchemaResult;\n<line_number-358>    }\n<line_number-359>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC SQL translation functionalities.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "43-44",
            "comment_linenumber": "42",
            "comment": "Class responsible for translating SQL commands to MongoDB commands and handling their execution.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "54-56",
            "comment_linenumber": "53",
            "comment": "Constructor that initializes the MongoSQLTranslate class with a logger.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "68-90",
            "comment_linenumber": "67",
            "comment": "Executes a command using JNI and returns the response as a specified POJO type, handling serialization exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "100-110",
            "comment_linenumber": "99",
            "comment": "Retrieves the version of the mongosqltranslate library, logging the version information.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "121-135",
            "comment_linenumber": "120",
            "comment": "Checks if the JDBC driver version is compatible with the mongosqltranslate library, logging the compatibility status.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "149-163",
            "comment_linenumber": "148",
            "comment": "Translates a given SQL query into a MongoDB command and returns the result.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "176-184",
            "comment_linenumber": "175",
            "comment": "Retrieves the namespaces involved in a given SQL query, returning the result as a structured object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "196-311",
            "comment_linenumber": "195",
            "comment": "Builds a catalog document containing schema information for specified collections, handling cases with no collections.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "325-357",
            "comment_linenumber": "324",
            "comment": "Retrieves the schema of a specific collection from the MongoDB database, returning the schema result.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoSQLTranslate.java' is part of the 'com.mongodb.jdbc.mongosql' package and implements functionalities for translating SQL commands into MongoDB commands. It utilizes the MongoDB Java driver and JNI for command execution. The primary class, 'MongoSQLTranslate', is annotated with '@AutoLoggable' for logging purposes. It contains several public methods that handle various operations such as executing commands, retrieving library versions, checking driver compatibility, translating SQL queries, and fetching schema information. The class maintains a logger instance for logging important events and errors. The methods leverage BSON documents for command construction and response handling, ensuring compatibility with MongoDB's data structures. The class is designed to be thread-safe and can be instantiated with a logger for logging operations. Key methods include 'runCommand', which executes commands and handles serialization exceptions, and 'buildCatalogDocument', which constructs a schema catalog for specified collections, ensuring that all expected collections are present in the result. The file also includes error handling for scenarios where no schema information is found or multiple results are returned, ensuring robustness in command execution.",
        "file_summary": "The 'MongoSQLTranslate.java' file provides a class that translates SQL commands into MongoDB commands, executes them, and handles the responses. It includes methods for checking driver compatibility, retrieving library versions, and managing schema information for collections, making it essential for integrating SQL-based applications with MongoDB."
      }
    ]
  },
  "TranslateResult.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\TranslateResult.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\TranslateResult.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\mongosql\\TranslateResult.java",
        "chunk_id": "TranslateResult_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.mongosql;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.utils.BsonUtils.JSON_WRITER_NO_INDENT_SETTINGS;\n<line_number-20>\n<line_number-21>import com.mongodb.jdbc.JsonSchema;\n<line_number-22>import com.mongodb.jdbc.MongoDriver;\n<line_number-23>import com.mongodb.jdbc.MongoJsonSchema;\n<line_number-24>import com.mongodb.jdbc.utils.BsonUtils;\n<line_number-25>import java.util.List;\n<line_number-26>import org.bson.BsonDocument;\n<line_number-27>import org.bson.codecs.Codec;\n<line_number-28>import org.bson.codecs.pojo.annotations.BsonCreator;\n<line_number-29>import org.bson.codecs.pojo.annotations.BsonProperty;\n<line_number-30>\n<line_number-31>public class TranslateResult {\n<line_number-32>\n<line_number-33>    private static final Codec<TranslateResult> CODEC =\n<line_number-34>            MongoDriver.getCodecRegistry().get(TranslateResult.class);\n<line_number-35>\n<line_number-36>    public final String targetDb;\n<line_number-37>    public final String targetCollection;\n<line_number-38>    public final List<BsonDocument> pipeline;\n<line_number-39>    public final MongoJsonSchema resultSetSchema;\n<line_number-40>    public final List<List<String>> selectOrder;\n<line_number-41>\n<line_number-42>    @BsonCreator\n<line_number-43>    public TranslateResult(\n<line_number-44>            @BsonProperty(\"target_db\") String targetDb,\n<line_number-45>            @BsonProperty(\"target_collection\") String targetCollection,\n<line_number-46>            @BsonProperty(\"pipeline\") List<BsonDocument> pipeline,\n<line_number-47>            @BsonProperty(\"result_set_schema\") JsonSchema resultSetSchema,\n<line_number-48>            @BsonProperty(\"select_order\") List<List<String>> selectOrder) {\n<line_number-49>        this.targetDb = targetDb;\n<line_number-50>        this.targetCollection = targetCollection;\n<line_number-51>        this.pipeline = pipeline;\n<line_number-52>        this.resultSetSchema =\n<line_number-53>                (resultSetSchema != null)\n<line_number-54>                        ? MongoJsonSchema.toSimplifiedMongoJsonSchema(resultSetSchema)\n<line_number-55>                        : null;\n<line_number-56>        this.selectOrder = selectOrder;\n<line_number-57>    }\n<line_number-58>\n<line_number-59>    @Override\n<line_number-60>    public String toString() {\n<line_number-61>        return BsonUtils.toString(CODEC, this, JSON_WRITER_NO_INDENT_SETTINGS);\n<line_number-62>    }\n<line_number-63>}\n",
        "comments": [
          {
            "comment_code_range": "31-63",
            "comment_linenumber": "30",
            "comment": "Represents the result of a translation operation, encapsulating target database, collection, pipeline, schema, and selection order.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "42-57",
            "comment_linenumber": "41",
            "comment": "Constructor that initializes the TranslateResult with target database, collection, pipeline, result set schema, and selection order, converting the schema if necessary.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "59-62",
            "comment_linenumber": "58",
            "comment": "Overrides the toString method to provide a JSON representation of the TranslateResult using the defined codec.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'TranslateResult.java' is part of the 'com.mongodb.jdbc.mongosql' package and defines a class that encapsulates the results of a translation operation in a MongoDB context. The class utilizes BSON codecs for serialization and deserialization, adhering to the MongoDB Java driver conventions. \n\nTop-level type:\n- **TranslateResult**: This class is responsible for holding the results of a translation operation, including the target database, target collection, a processing pipeline, a schema for the result set, and the order of selections. It is designed to be immutable, with all fields declared as final and initialized through the constructor.\n\nMembers:\n- **Fields**:\n  - `CODEC`: A static final Codec instance for serializing and deserializing TranslateResult objects.\n  - `targetDb`: A String representing the target database name.\n  - `targetCollection`: A String representing the target collection name.\n  - `pipeline`: A List of BsonDocument representing the processing pipeline.\n  - `resultSetSchema`: A MongoJsonSchema object representing the schema of the result set.\n  - `selectOrder`: A List of Lists of Strings representing the order of selections.\n\n- **Constructor**:\n  - `TranslateResult(...)`: Initializes the fields with provided parameters, converting the resultSetSchema to a simplified format if it is not null.\n\n- **Method**:\n  - `toString()`: Returns a JSON string representation of the TranslateResult using the defined codec and BSON utilities.\n\nRelationships:\n- The class uses external classes such as `MongoDriver`, `JsonSchema`, and `BsonUtils` for its operations, indicating a dependency on the MongoDB Java driver and BSON utilities. \n\nObservations & caveats:\n- The class is designed to be thread-safe due to its immutable nature. The use of BSON codecs suggests that it is optimized for MongoDB interactions, ensuring efficient serialization and deserialization.",
        "file_summary": "The 'TranslateResult.java' file defines a class that encapsulates the results of a translation operation in a MongoDB context, including details such as the target database, collection, processing pipeline, schema, and selection order. It provides a constructor for initialization and overrides the toString method for JSON representation."
      }
    ]
  },
  "JdbcIdpInfo.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\JdbcIdpInfo.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\JdbcIdpInfo.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\JdbcIdpInfo.java",
        "chunk_id": "JdbcIdpInfo_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential;\n<line_number-20>import com.mongodb.lang.Nullable;\n<line_number-21>import java.util.List;\n<line_number-22>\n<line_number-23>public class JdbcIdpInfo implements MongoCredential.IdpInfo {\n<line_number-24>    private final String issuer;\n<line_number-25>\n<line_number-26>    @Nullable private final String clientId;\n<line_number-27>    private final List<String> requestScopes;\n<line_number-28>\n<line_number-29>    public JdbcIdpInfo(String issuer, String clientId, List<String> requestScopes) {\n<line_number-30>        this.issuer = issuer;\n<line_number-31>        this.clientId = clientId;\n<line_number-32>        this.requestScopes = requestScopes;\n<line_number-33>    }\n<line_number-34>\n<line_number-35>    public String getIssuer() {\n<line_number-36>        return this.issuer;\n<line_number-37>    }\n<line_number-38>\n<line_number-39>    @Nullable\n<line_number-40>    public String getClientId() {\n<line_number-41>        return this.clientId;\n<line_number-42>    }\n<line_number-43>\n<line_number-44>    public List<String> getRequestScopes() {\n<line_number-45>        return this.requestScopes;\n<line_number-46>    }\n<line_number-47>}\n",
        "comments": [
          {
            "comment_code_range": "17-47",
            "comment_linenumber": "16",
            "comment": "Represents information about an Identity Provider (IdP) for JDBC authentication, encapsulating issuer details, client ID, and requested scopes.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "29-33",
            "comment_linenumber": "28",
            "comment": "Constructor that initializes the JdbcIdpInfo with issuer, optional client ID, and request scopes.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "35-37",
            "comment_linenumber": "34",
            "comment": "Returns the issuer of the IdP.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "39-41",
            "comment_linenumber": "38",
            "comment": "Returns the optional client ID associated with the IdP, or null if not present.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "44-46",
            "comment_linenumber": "43",
            "comment": "Returns the list of requested scopes for the IdP.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'JdbcIdpInfo.java' defines a class that implements the MongoCredential.IdpInfo interface, serving as a data structure for holding information related to an Identity Provider (IdP) in a JDBC context. The class encapsulates three primary fields: 'issuer', 'clientId', and 'requestScopes'. The 'issuer' is a mandatory field, while 'clientId' is optional, denoted by the @Nullable annotation. The class provides a constructor for initializing these fields and three getter methods to retrieve their values. The class is designed to be immutable, as all fields are declared final, ensuring thread-safety and consistency once an instance is created. The use of the List<String> type for 'requestScopes' allows for flexibility in specifying multiple scopes. Overall, this class is a straightforward representation of IdP information, adhering to the principles of encapsulation and immutability.",
        "file_summary": "The 'JdbcIdpInfo.java' file defines a class that encapsulates the details of an Identity Provider (IdP) for JDBC authentication, including the issuer, an optional client ID, and the requested scopes. It provides methods to access these details, ensuring a clear and structured representation of IdP information."
      }
    ]
  },
  "JdbcOidcCallback.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\JdbcOidcCallback.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\JdbcOidcCallback.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\JdbcOidcCallback.java",
        "chunk_id": "JdbcOidcCallback_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential.OidcCallback;\n<line_number-20>import com.mongodb.MongoCredential.OidcCallbackContext;\n<line_number-21>import com.mongodb.MongoCredential.OidcCallbackResult;\n<line_number-22>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-23>import javax.security.auth.RefreshFailedException;\n<line_number-24>\n<line_number-25>public class JdbcOidcCallback implements OidcCallback {\n<line_number-26>    private final OidcAuthFlow oidcAuthFlow;\n<line_number-27>\n<line_number-28>    public JdbcOidcCallback() {\n<line_number-29>        this.oidcAuthFlow = new OidcAuthFlow();\n<line_number-30>    }\n<line_number-31>\n<line_number-32>    public JdbcOidcCallback(MongoLogger parentLogger) {\n<line_number-33>        this.oidcAuthFlow = new OidcAuthFlow(parentLogger);\n<line_number-34>    }\n<line_number-35>\n<line_number-36>    public OidcCallbackResult onRequest(OidcCallbackContext callbackContext) {\n<line_number-37>        String refreshToken = callbackContext.getRefreshToken();\n<line_number-38>        if (refreshToken != null && !refreshToken.isEmpty()) {\n<line_number-39>            try {\n<line_number-40>                return oidcAuthFlow.doRefresh(callbackContext);\n<line_number-41>            } catch (RefreshFailedException e) {\n<line_number-42>                throw new RuntimeException(e);\n<line_number-43>            }\n<line_number-44>        } else {\n<line_number-45>            try {\n<line_number-46>                return oidcAuthFlow.doAuthCodeFlow(callbackContext);\n<line_number-47>            } catch (OidcTimeoutException e) {\n<line_number-48>                throw new RuntimeException(e);\n<line_number-49>            }\n<line_number-50>        }\n<line_number-51>    }\n<line_number-52>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for JDBC OIDC callback handling.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "25-51",
            "comment_linenumber": "24",
            "comment": "Implements the OidcCallback interface to handle OIDC authentication flows, including refresh token and authorization code flows.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "28-30",
            "comment_linenumber": "27",
            "comment": "Default constructor initializes the OidcAuthFlow without a logger.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "32-34",
            "comment_linenumber": "31",
            "comment": "Constructor that initializes the OidcAuthFlow with a specified logger for logging purposes.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "36-51",
            "comment_linenumber": "35",
            "comment": "Handles OIDC callback requests by determining the flow to execute based on the presence of a refresh token.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "38-40",
            "comment_linenumber": "37",
            "comment": "Checks if a refresh token is available and attempts to refresh the authentication if so.",
            "comment_kind": "conditional"
          },
          {
            "comment_code_range": "44-46",
            "comment_linenumber": "43",
            "comment": "Handles the case where no refresh token is available by executing the authorization code flow.",
            "comment_kind": "conditional"
          }
        ],
        "structural_analysis": "The file 'JdbcOidcCallback.java' is part of the 'com.mongodb.jdbc.oidc' package and is responsible for handling OIDC (OpenID Connect) authentication callbacks in a JDBC context. It implements the OidcCallback interface, which defines methods for processing authentication requests. The primary design pattern used here is the callback pattern, allowing for flexible handling of authentication flows. The main class, JdbcOidcCallback, has two constructors: one that initializes an OidcAuthFlow instance without logging and another that accepts a MongoLogger instance for logging purposes. The class contains a method 'onRequest' that processes the OIDC callback context, determining whether to refresh the token or initiate an authorization code flow based on the presence of a refresh token. It handles exceptions related to token refresh failures and authorization timeouts by wrapping them in RuntimeExceptions. The class relies on external classes such as OidcAuthFlow for the actual authentication logic and MongoLogger for logging, indicating a dependency on these components for its functionality.",
        "file_summary": "The JdbcOidcCallback class facilitates OIDC authentication in JDBC applications by implementing the OidcCallback interface, managing both refresh token and authorization code flows."
      }
    ]
  },
  "JdbcOidcCallbackContext.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\JdbcOidcCallbackContext.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\JdbcOidcCallbackContext.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\JdbcOidcCallbackContext.java",
        "chunk_id": "JdbcOidcCallbackContext_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential.IdpInfo;\n<line_number-20>import com.mongodb.MongoCredential.OidcCallbackContext;\n<line_number-21>import java.time.Duration;\n<line_number-22>\n<line_number-23>public class JdbcOidcCallbackContext implements OidcCallbackContext {\n<line_number-24>    private Duration timeout;\n<line_number-25>    private int version;\n<line_number-26>    private String refreshToken;\n<line_number-27>    private IdpInfo idpInfo;\n<line_number-28>    private String userName;\n<line_number-29>\n<line_number-30>    public JdbcOidcCallbackContext(\n<line_number-31>            Duration timeout, int version, String refreshToken, IdpInfo idpInfo, String userName) {\n<line_number-32>        this.timeout = timeout;\n<line_number-33>        this.version = version;\n<line_number-34>        this.refreshToken = refreshToken;\n<line_number-35>        this.idpInfo = idpInfo;\n<line_number-36>        this.userName = userName;\n<line_number-37>    }\n<line_number-38>\n<line_number-39>    public String getUserName() {\n<line_number-40>        return this.userName;\n<line_number-41>    }\n<line_number-42>\n<line_number-43>    public Duration getTimeout() {\n<line_number-44>        return this.timeout;\n<line_number-45>    }\n<line_number-46>\n<line_number-47>    public int getVersion() {\n<line_number-48>        return this.version;\n<line_number-49>    }\n<line_number-50>\n<line_number-51>    public String getRefreshToken() {\n<line_number-52>        return this.refreshToken;\n<line_number-53>    }\n<line_number-54>\n<line_number-55>    public IdpInfo getIdpInfo() {\n<line_number-56>        return this.idpInfo;\n<line_number-57>    }\n<line_number-58>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for JDBC OIDC callback context handling.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "23-58",
            "comment_linenumber": "22",
            "comment": "Represents the context for OIDC callbacks in JDBC, encapsulating user and session information.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "30-37",
            "comment_linenumber": "29",
            "comment": "Constructor that initializes the JdbcOidcCallbackContext with timeout, version, refresh token, IDP info, and username.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "39-41",
            "comment_linenumber": "38",
            "comment": "Returns the username associated with the OIDC callback context.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "43-45",
            "comment_linenumber": "42",
            "comment": "Returns the timeout duration for the OIDC callback context.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "47-49",
            "comment_linenumber": "46",
            "comment": "Returns the version of the OIDC callback context.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "51-53",
            "comment_linenumber": "50",
            "comment": "Returns the refresh token associated with the OIDC callback context.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "55-57",
            "comment_linenumber": "54",
            "comment": "Returns the IDP information associated with the OIDC callback context.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file named JdbcOidcCallbackContext.java is part of the com.mongodb.jdbc.oidc package and is responsible for managing the context of OIDC callbacks in JDBC operations. It implements the OidcCallbackContext interface, ensuring it adheres to the expected contract for OIDC callback handling. The primary class, JdbcOidcCallbackContext, encapsulates several fields: timeout (Duration), version (int), refreshToken (String), idpInfo (IdpInfo), and userName (String). These fields are initialized through a constructor that takes all necessary parameters. The class provides getter methods for each field, allowing external access to the encapsulated data. The design follows standard Java conventions for encapsulation and provides a clear structure for managing OIDC callback context data. There are no complex algorithms or external dependencies beyond the standard Java libraries and MongoDB's credential classes.",
        "file_summary": "This file defines the JdbcOidcCallbackContext class, which encapsulates the context for OIDC callbacks in JDBC, including user information and session details. It provides methods to access various attributes related to the OIDC callback, ensuring a structured approach to handling authentication contexts."
      }
    ]
  },
  "OidcAuthFlow.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\OidcAuthFlow.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\OidcAuthFlow.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\OidcAuthFlow.java",
        "chunk_id": "OidcAuthFlow_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential.IdpInfo;\n<line_number-20>import com.mongodb.MongoCredential.OidcCallbackContext;\n<line_number-21>import com.mongodb.MongoCredential.OidcCallbackResult;\n<line_number-22>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-23>import com.nimbusds.oauth2.sdk.AuthorizationCode;\n<line_number-24>import com.nimbusds.oauth2.sdk.AuthorizationCodeGrant;\n<line_number-25>import com.nimbusds.oauth2.sdk.AuthorizationRequest;\n<line_number-26>import com.nimbusds.oauth2.sdk.ParseException;\n<line_number-27>import com.nimbusds.oauth2.sdk.RefreshTokenGrant;\n<line_number-28>import com.nimbusds.oauth2.sdk.ResponseType;\n<line_number-29>import com.nimbusds.oauth2.sdk.Scope;\n<line_number-30>import com.nimbusds.oauth2.sdk.TokenErrorResponse;\n<line_number-31>import com.nimbusds.oauth2.sdk.TokenRequest;\n<line_number-32>import com.nimbusds.oauth2.sdk.TokenResponse;\n<line_number-33>import com.nimbusds.oauth2.sdk.http.HTTPResponse;\n<line_number-34>import com.nimbusds.oauth2.sdk.id.ClientID;\n<line_number-35>import com.nimbusds.oauth2.sdk.id.Issuer;\n<line_number-36>import com.nimbusds.oauth2.sdk.id.State;\n<line_number-37>import com.nimbusds.oauth2.sdk.pkce.CodeChallengeMethod;\n<line_number-38>import com.nimbusds.oauth2.sdk.pkce.CodeVerifier;\n<line_number-39>import com.nimbusds.oauth2.sdk.token.RefreshToken;\n<line_number-40>import com.nimbusds.oauth2.sdk.token.Tokens;\n<line_number-41>import com.nimbusds.openid.connect.sdk.OIDCTokenResponse;\n<line_number-42>import com.nimbusds.openid.connect.sdk.OIDCTokenResponseParser;\n<line_number-43>import com.nimbusds.openid.connect.sdk.op.OIDCProviderMetadata;\n<line_number-44>import java.io.IOException;\n<line_number-45>import java.net.URI;\n<line_number-46>import java.time.Duration;\n<line_number-47>import java.util.HashSet;\n<line_number-48>import java.util.List;\n<line_number-49>import java.util.Set;\n<line_number-50>import java.util.logging.Level;\n<line_number-51>import java.util.logging.Logger;\n<line_number-52>import javax.security.auth.RefreshFailedException;\n<line_number-53>\n<line_number-54>public class OidcAuthFlow {\n<line_number-55>\n<line_number-56>    private static final Logger logger = Logger.getLogger(OidcAuthFlow.class.getName());\n<line_number-57>    private MongoLogger mongoLogger;\n<line_number-58>    private static final String OFFLINE_ACCESS = \"offline_access\";\n<line_number-59>    private static final String OPENID = \"openid\";\n<line_number-60>\n<line_number-61>    public OidcAuthFlow() {}\n<line_number-62>\n<line_number-63>    public OidcAuthFlow(MongoLogger parentLogger) {\n<line_number-64>        this.mongoLogger = new MongoLogger(OidcAuthFlow.class.getName(), parentLogger);\n<line_number-65>    }\n<line_number-66>\n<line_number-67>    /**\n<line_number-68>     * Builds the OIDC scopes for the authorization request by combining default scopes with\n<line_number-69>     * client-requested scopes that are supported by the Identity Provider. Adds openid and\n<line_number-70>     * offline_access scopes by default, and includes the clientID/.default if in the requested\n<line_number-71>     * scopes.\n<line_number-72>     *\n<line_number-73>     * @param clientID the OAuth2 client identifier\n<line_number-74>     * @param idpServerInfo server information containing requested scopes and other IdP details\n<line_number-75>     * @param providerMetadata OIDC provider metadata containing supported scopes\n<line_number-76>     * @return a Scope object containing all valid scopes to be requested\n<line_number-77>     */\n<line_number-78>    public Scope buildScopes(\n<line_number-79>            String clientID, IdpInfo idpServerInfo, OIDCProviderMetadata providerMetadata) {\n<line_number-80>        Set<String> scopes = new HashSet<>();\n<line_number-81>        Scope supportedScopes = providerMetadata.getScopes();\n<line_number-82>\n<line_number-83>        // Add openid and offline_access scopes by default\n<line_number-84>        scopes.add(OPENID);\n<line_number-85>        scopes.add(OFFLINE_ACCESS);\n<line_number-86>\n<line_number-87>        // Add custom scopes from request that are supported by the IdP\n<line_number-88>        List<String> requestedScopes = idpServerInfo.getRequestScopes();\n<line_number-89>        if (requestedScopes != null) {\n<line_number-90>            // Always add clientID/.default if it's in requestedScopes, this was needed for Azure OIDC.\n<line_number-91>            String clientIDDefault = clientID + \"/.default\";\n<line_number-92>            if (requestedScopes.contains(clientIDDefault)) {\n<line_number-93>                scopes.add(clientIDDefault);\n<line_number-94>            }\n<line_number-95>            if (supportedScopes != null) {\n<line_number-96>                for (String scope : requestedScopes) {\n<line_number-97>                    if (supportedScopes.contains(scope)) {\n<line_number-98>                        scopes.add(scope);\n<line_number-99>                    } else {\n<line_number-100>                        logger.warning(\n<line_number-101>                                \"Requested scope '\" + scope + \"' is not supported by the IdP\");\n<line_number-102>                    }\n<line_number-103>                }\n<line_number-104>            }\n<line_number-105>        }\n<line_number-106>\n<line_number-107>        Scope finalScopes = new Scope();\n<line_number-108>        for (String scope : scopes) {\n<line_number-109>            finalScopes.add(new Scope.Value(scope));\n<line_number-110>        }\n<line_number-111>        return finalScopes;\n<line_number-112>    }\n<line_number-113>\n<line_number-114>    public OidcCallbackResult doAuthCodeFlow(OidcCallbackContext callbackContext)\n<line_number-115>            throws OidcTimeoutException {\n<line_number-116>        IdpInfo idpServerInfo = callbackContext.getIdpInfo();\n<line_number-117>        String clientID = idpServerInfo.getClientId();\n<line_number-118>        String issuerURI = idpServerInfo.getIssuer();\n<line_number-119>\n<line_number-120>        // Check that the IdP information is valid\n<line_number-121>        if (!validateIdpInfo(idpServerInfo, clientID, issuerURI)) {\n<line_number-122>            return null;\n<line_number-123>        }\n<line_number-124>\n<line_number-125>        RFC8252HttpServer server = new RFC8252HttpServer();\n<line_number-126>        try {\n<line_number-127>            // Resolve OIDC provider metadata using the issuer URI and\n<line_number-128>            // extract authorization and token endpoint URIs.\n<line_number-129>            OIDCProviderMetadata providerMetadata =\n<line_number-130>                    OIDCProviderMetadata.resolve(new Issuer(issuerURI));\n<line_number-131>            URI authorizationEndpoint = providerMetadata.getAuthorizationEndpointURI();\n<line_number-132>            URI tokenEndpoint = providerMetadata.getTokenEndpointURI();\n<line_number-133>            Scope requestedScopes = buildScopes(clientID, idpServerInfo, providerMetadata);\n<line_number-134>\n<line_number-135>            // Start the local RFC8252 HTTP server to receive the redirect.\n<line_number-136>            server.start();\n<line_number-137>\n<line_number-138>            URI redirectURI =\n<line_number-139>                    new URI(\n<line_number-140>                            \"http://localhost:\"\n<line_number-141>                                    + RFC8252HttpServer.DEFAULT_REDIRECT_PORT\n<line_number-142>                                    + \"/redirect\");\n<line_number-143>            State state = new State();\n<line_number-144>            CodeVerifier codeVerifier = new CodeVerifier();\n<line_number-145>\n<line_number-146>            // Build the authorization request URI.\n<line_number-147>            AuthorizationRequest request =\n<line_number-148>                    new AuthorizationRequest.Builder(\n<line_number-149>                                    new ResponseType(ResponseType.Value.CODE),\n<line_number-150>                                    new ClientID(clientID))\n<line_number-151>                            .scope(requestedScopes)\n<line_number-152>                            .redirectionURI(redirectURI)\n<line_number-153>                            .state(state)\n<line_number-154>                            .codeChallenge(codeVerifier, CodeChallengeMethod.S256)\n<line_number-155>                            .endpointURI(authorizationEndpoint)\n<line_number-156>                            .build();\n<line_number-157>\n<line_number-158>            // Open the browser to the authorization request URI.\n<line_number-159>            try {\n<line_number-160>                openURL(request.toURI().toString());\n<line_number-161>            } catch (Exception e) {\n<line_number-162>                log(Level.SEVERE, \"Failed to open the browser: \" + e.getMessage());\n<line_number-163>                return null;\n<line_number-164>            }\n<line_number-165>\n<line_number-166>            // Wait for the authorization response from the local HTTP server.\n<line_number-167>            OidcResponse response = server.getOidcResponse(callbackContext.getTimeout());\n<line_number-168>            if (response == null || !state.getValue().equals(response.getState())) {\n<line_number-169>                log(Level.SEVERE, \"OIDC response is null or returned an invalid state\");\n<line_number-170>                return null;\n<line_number-171>            }\n<line_number-172>\n<line_number-173>            // Generate token request from the authorization code and PKCE verifier.\n<line_number-174>            AuthorizationCode code = new AuthorizationCode(response.getCode());\n<line_number-175>            AuthorizationCodeGrant codeGrant =\n<line_number-176>                    new AuthorizationCodeGrant(code, redirectURI, codeVerifier);\n<line_number-177>            TokenRequest tokenRequest =\n<line_number-178>                    new TokenRequest(tokenEndpoint, new ClientID(clientID), codeGrant);\n<line_number-179>\n<line_number-180>            // Sends the token exchange request and parse the response to obtain tokens.\n<line_number-181>            HTTPResponse httpResponse = tokenRequest.toHTTPRequest().send();\n<line_number-182>            TokenResponse tokenResponse = OIDCTokenResponseParser.parse(httpResponse);\n<line_number-183>            if (!tokenResponse.indicatesSuccess()) {\n<line_number-184>                log(Level.SEVERE, \"Token request failed with response: \" + httpResponse.getBody());\n<line_number-185>                return null;\n<line_number-186>            }\n<line_number-187>\n<line_number-188>            return getOidcCallbackResultFromTokenResponse((OIDCTokenResponse) tokenResponse);\n<line_number-189>        } catch (Exception e) {\n<line_number-190>            log(Level.SEVERE, \"Error during OIDC authentication \" + e.getMessage());\n<line_number-191>            if (e instanceof OidcTimeoutException) {\n<line_number-192>                throw (OidcTimeoutException) e;\n<line_number-193>            }\n<line_number-194>            return null;\n<line_number-195>        } finally {\n<line_number-196>            try {\n<line_number-197>                // Sleeping to ensure the server stays up long enough to respond to the browser's\n<line_number-198>                // request after the redirect.\n<line_number-199>                Thread.sleep(2000);\n<line_number-200>            } catch (InterruptedException e) {\n<line_number-201>                log(Level.WARNING, \"Thread interrupted \" + e.getMessage());\n<line_number-202>            }\n<line_number-203>            server.stop();\n<line_number-204>        }\n<line_number-205>    }\n<line_number-206>\n<line_number-207>    /**\n<line_number-208>     * Opens the specified URI in the default web browser, supporting macOS, Windows, and\n<line_number-209>     * Linux/Unix. This method uses platform-specific commands to invoke the browser.\n<line_number-210>     *\n<line_number-211>     * @param url the URL to be opened as a string\n<line_number-212>     * @throws Exception if no supported browser is found or an error occurs while attempting to\n<line_number-213>     *     open the URL\n<line_number-214>     */\n<line_number-215>    private void openURL(String url) throws Exception {\n<line_number-216>        String osName = System.getProperty(\"os.name\").toLowerCase();\n<line_number-217>        logger.log(Level.INFO, \"osName: \" + osName);\n<line_number-218>        Runtime runtime = Runtime.getRuntime();\n<line_number-219>\n<line_number-220>        if (osName.contains(\"windows\")) {\n<line_number-221>            runtime.exec(new String[] {\"rundll32\", \"url.dll,FileProtocolHandler\", url});\n<line_number-222>        } else if (osName.contains(\"mac os\")) {\n<line_number-223>            runtime.exec(new String[] {\"open\", url});\n<line_number-224>        } else {\n<line_number-225>            String[] browsers = {\"xdg-open\", \"firefox\", \"google-chrome\"};\n<line_number-226>            IOException lastError = null;\n<line_number-227>            for (String browser : browsers) {\n<line_number-228>                try {\n<line_number-229>                    // Check if browser exists\n<line_number-230>                    Process process = runtime.exec(new String[] {\"which\", browser});\n<line_number-231>                    if (process.waitFor() == 0) {\n<line_number-232>                        runtime.exec(new String[] {browser, url});\n<line_number-233>                    }\n<line_number-234>                } catch (IOException e) {\n<line_number-235>                    lastError = e;\n<line_number-236>                } catch (InterruptedException e) {\n<line_number-237>                    Thread.currentThread().interrupt();\n<line_number-238>                    break;\n<line_number-239>                }\n<line_number-240>            }\n<line_number-241>\n<line_number-242>            throw lastError != null\n<line_number-243>                    ? lastError\n<line_number-244>                    : new IOException(\"No web browser found to open the URL\");\n<line_number-245>        }\n<line_number-246>    }\n<line_number-247>\n<line_number-248>    private void log(Level level, String message) {\n<line_number-249>        if (mongoLogger != null) {\n<line_number-250>            mongoLogger.log(level, message);\n<line_number-251>        } else {\n<line_number-252>            logger.log(level, message);\n<line_number-253>        }\n<line_number-254>    }\n<line_number-255>\n<line_number-256>    public OidcCallbackResult doRefresh(OidcCallbackContext callbackContext)\n<line_number-257>            throws RefreshFailedException {\n<line_number-258>        IdpInfo idpServerInfo = callbackContext.getIdpInfo();\n<line_number-259>        String clientID = idpServerInfo.getClientId();\n<line_number-260>        String issuerURI = idpServerInfo.getIssuer();\n<line_number-261>\n<line_number-262>        // Check that the IdP information is valid\n<line_number-263>        if (!validateIdpInfo(idpServerInfo, clientID, issuerURI)) {\n<line_number-264>            return null;\n<line_number-265>        }\n<line_number-266>        try {\n<line_number-267>            // Use OpenID Connect Discovery to fetch the provider metadata\n<line_number-268>            OIDCProviderMetadata providerMetadata =\n<line_number-269>                    OIDCProviderMetadata.resolve(new Issuer(issuerURI));\n<line_number-270>            URI tokenEndpoint = providerMetadata.getTokenEndpointURI();\n<line_number-271>\n<line_number-272>            // This function will never be called without a refresh token (to be checked in the driver function),\n<line_number-273>            // but we throw an exception to be explicit about the fact that we expect a refresh token.\n<line_number-274>            String refreshToken = callbackContext.getRefreshToken();\n<line_number-275>            if (refreshToken == null) {\n<line_number-276>                throw new IllegalArgumentException(\"Refresh token is required\");\n<line_number-277>            }\n<line_number-278>\n<line_number-279>            RefreshTokenGrant refreshTokenGrant =\n<line_number-280>                    new RefreshTokenGrant(new RefreshToken(refreshToken));\n<line_number-281>            TokenRequest tokenRequest =\n<line_number-282>                    new TokenRequest(tokenEndpoint, new ClientID(clientID), refreshTokenGrant);\n<line_number-283>            HTTPResponse httpResponse = tokenRequest.toHTTPRequest().send();\n<line_number-284>\n<line_number-285>            try {\n<line_number-286>                TokenResponse tokenResponse = OIDCTokenResponseParser.parse(httpResponse);\n<line_number-287>                if (!tokenResponse.indicatesSuccess()) {\n<line_number-288>                    TokenErrorResponse errorResponse = tokenResponse.toErrorResponse();\n<line_number-289>                    String errorCode =\n<line_number-290>                            errorResponse.getErrorObject() != null\n<line_number-291>                                    ? errorResponse.getErrorObject().getCode()\n<line_number-292>                                    : null;\n<line_number-293>                    String errorDescription =\n<line_number-294>                            errorResponse.getErrorObject() != null\n<line_number-295>                                    ? errorResponse.getErrorObject().getDescription()\n<line_number-296>                                    : null;\n<line_number-297>                    throw new RefreshFailedException(\n<line_number-298>                            \"Token refresh failed with error: \"\n<line_number-299>                                    + \"code=\"\n<line_number-300>                                    + errorCode\n<line_number-301>                                    + \", description=\"\n<line_number-302>                                    + errorDescription);\n<line_number-303>                }\n<line_number-304>                return getOidcCallbackResultFromTokenResponse((OIDCTokenResponse) tokenResponse);\n<line_number-305>            } catch (ParseException e) {\n<line_number-306>                throw new RefreshFailedException(\n<line_number-307>                        \"Failed to parse server response: \"\n<line_number-308>                                + e.getMessage()\n<line_number-309>                                + \" [response=\"\n<line_number-310>                                + httpResponse.getBody()\n<line_number-311>                                + \"]\");\n<line_number-312>            }\n<line_number-313>\n<line_number-314>        } catch (Exception e) {\n<line_number-315>            log(Level.SEVERE, \"OpenID Connect: Error during token refresh. \" + e.getMessage());\n<line_number-316>            if (e instanceof RefreshFailedException) {\n<line_number-317>                throw (RefreshFailedException) e;\n<line_number-318>            }\n<line_number-319>            return null;\n<line_number-320>        }\n<line_number-321>    }\n<line_number-322>\n<line_number-323>    private boolean validateIdpInfo(IdpInfo idpInfo, String clientID, String issuerURI) {\n<line_number-324>        if (idpInfo == null) {\n<line_number-325>            log(Level.SEVERE, \"IdpServerInfo is null\");\n<line_number-326>            return false;\n<line_number-327>        }\n<line_number-328>        if (clientID == null || clientID.isEmpty()) {\n<line_number-329>            log(Level.SEVERE, \"Client ID is null or empty\");\n<line_number-330>            return false;\n<line_number-331>        }\n<line_number-332>        if (!issuerURI.startsWith(\"https\")) {\n<line_number-333>            log(Level.SEVERE, \"Issuer URI must be HTTPS\");\n<line_number-334>            return false;\n<line_number-335>        }\n<line_number-336>        return true;\n<line_number-337>    }\n<line_number-338>\n<line_number-339>    private OidcCallbackResult getOidcCallbackResultFromTokenResponse(\n<line_number-340>            OIDCTokenResponse tokenResponse) {\n<line_number-341>        Tokens tokens = tokenResponse.getOIDCTokens();\n<line_number-342>        String accessToken = tokens.getAccessToken().getValue();\n<line_number-343>        String refreshToken =\n<line_number-344>                tokens.getRefreshToken() != null ? tokens.getRefreshToken().getValue() : null;\n<line_number-345>        Duration expiresIn = Duration.ofSeconds(tokens.getAccessToken().getLifetime());\n<line_number-346>\n<line_number-347>        return new OidcCallbackResult(accessToken, expiresIn, refreshToken);\n<line_number-348>    }\n<line_number-349>}\n",
        "comments": [
          {
            "comment_code_range": "54-54",
            "comment_linenumber": "53",
            "comment": "Represents the OIDC authentication flow, handling authorization and token exchange processes.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "61-61",
            "comment_linenumber": "60",
            "comment": "Default constructor for OidcAuthFlow, initializes an instance without a logger.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "63-65",
            "comment_linenumber": "62",
            "comment": "Constructor that initializes OidcAuthFlow with a specified MongoLogger for logging.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "67-111",
            "comment_linenumber": "66",
            "comment": "Builds the OIDC scopes for the authorization request by combining default scopes with client-requested scopes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "114-204",
            "comment_linenumber": "113",
            "comment": "Executes the authorization code flow, handling the redirect and token exchange process.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "207-246",
            "comment_linenumber": "206",
            "comment": "Opens the specified URI in the default web browser using platform-specific commands.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "248-254",
            "comment_linenumber": "247",
            "comment": "Logs messages using either the MongoLogger or the default logger.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "256-320",
            "comment_linenumber": "255",
            "comment": "Handles the refresh token flow, requesting new tokens using a refresh token.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "323-337",
            "comment_linenumber": "322",
            "comment": "Validates the IdP information, ensuring it meets required criteria.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "339-348",
            "comment_linenumber": "338",
            "comment": "Extracts OIDC callback results from the token response, including access and refresh tokens.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'OidcAuthFlow.java' is part of the 'com.mongodb.jdbc.oidc' package and implements the OIDC authentication flow, primarily focusing on authorization and token management. It utilizes the OAuth2 and OpenID Connect protocols to facilitate secure authentication. The main class, OidcAuthFlow, contains methods for building authorization scopes, executing the authorization code flow, refreshing tokens, and validating IdP information. It employs a logger for logging purposes and handles exceptions related to the authentication process. The class is designed to be instantiated with or without a logger, allowing for flexible logging configurations. Key methods include buildScopes, doAuthCodeFlow, doRefresh, and utility methods for logging and opening URLs. The class interacts with external libraries for OAuth2 and OpenID Connect functionalities, ensuring compliance with the respective standards.",
        "file_summary": "The OidcAuthFlow class manages the OpenID Connect authentication flow, including authorization code exchange and token refresh processes. It builds necessary scopes for requests, validates IdP information, and handles logging throughout the authentication lifecycle."
      }
    ]
  },
  "OidcResponse.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\OidcResponse.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\OidcResponse.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\OidcResponse.java",
        "chunk_id": "OidcResponse_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc;\n<line_number-18>\n<line_number-19>public class OidcResponse {\n<line_number-20>    private String code;\n<line_number-21>    private String state;\n<line_number-22>    private String error;\n<line_number-23>    private String errorDescription;\n<line_number-24>\n<line_number-25>    public String getCode() {\n<line_number-26>        return code;\n<line_number-27>    }\n<line_number-28>\n<line_number-29>    public String getState() {\n<line_number-30>        return state;\n<line_number-31>    }\n<line_number-32>\n<line_number-33>    public String getError() {\n<line_number-34>        return error;\n<line_number-35>    }\n<line_number-36>\n<line_number-37>    public String getErrorDescription() {\n<line_number-38>        return errorDescription;\n<line_number-39>    }\n<line_number-40>\n<line_number-41>    public void setCode(String code) {\n<line_number-42>        this.code = code;\n<line_number-43>    }\n<line_number-44>\n<line_number-45>    public void setState(String state) {\n<line_number-46>        this.state = state;\n<line_number-47>    }\n<line_number-48>\n<line_number-49>    public void setError(String error) {\n<line_number-50>        this.error = error;\n<line_number-51>    }\n<line_number-52>\n<line_number-53>    public void setErrorDescription(String errorDescription) {\n<line_number-54>        this.errorDescription = errorDescription;\n<line_number-55>    }\n<line_number-56>\n<line_number-57>    @Override\n<line_number-58>    public String toString() {\n<line_number-59>        StringBuilder sb = new StringBuilder();\n<line_number-60>        if (code != null) {\n<line_number-61>            sb.append(\"Code: \").append(code).append(\"\\n\");\n<line_number-62>        }\n<line_number-63>        if (state != null) {\n<line_number-64>            sb.append(\"State: \").append(state).append(\"\\n\");\n<line_number-65>        }\n<line_number-66>        if (error != null) {\n<line_number-67>            sb.append(\"Error: \").append(error).append(\"\\n\");\n<line_number-68>        }\n<line_number-69>        if (errorDescription != null) {\n<line_number-70>            sb.append(\"Error Description: \").append(errorDescription).append(\"\\n\");\n<line_number-71>        }\n<line_number-72>        return sb.toString();\n<line_number-73>    }\n<line_number-74>}\n",
        "comments": [
          {
            "comment_code_range": "19-74",
            "comment_linenumber": "18",
            "comment": "Represents an OIDC response containing authorization code, state, error, and error description. Provides getters and setters for each field and a custom toString method for formatted output.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "25-27",
            "comment_linenumber": "24",
            "comment": "Returns the authorization code received in the OIDC response.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "29-31",
            "comment_linenumber": "28",
            "comment": "Returns the state parameter associated with the OIDC response.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "33-35",
            "comment_linenumber": "32",
            "comment": "Returns any error that occurred during the OIDC process.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "37-39",
            "comment_linenumber": "36",
            "comment": "Returns a description of the error that occurred during the OIDC process.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "41-43",
            "comment_linenumber": "40",
            "comment": "Sets the authorization code for the OIDC response.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "45-47",
            "comment_linenumber": "44",
            "comment": "Sets the state parameter for the OIDC response.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "49-51",
            "comment_linenumber": "48",
            "comment": "Sets any error that occurred during the OIDC process.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "53-55",
            "comment_linenumber": "52",
            "comment": "Sets the description of the error that occurred during the OIDC process.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "57-73",
            "comment_linenumber": "56",
            "comment": "Generates a string representation of the OIDC response, including code, state, error, and error description if they are not null.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'OidcResponse.java' defines a class that encapsulates the response from an OpenID Connect (OIDC) authentication process. It follows a simple data structure pattern, containing private fields for the authorization code, state, error, and error description. The class provides public getter and setter methods for each field, allowing for encapsulated access and modification of the response data. The toString method is overridden to provide a formatted string representation of the object, which is useful for logging or debugging purposes. The class does not implement any interfaces or extend any other classes, indicating it is a standalone data structure. The fields are all of type String and are private, ensuring that they can only be accessed through the provided methods. There are no complex algorithms or external dependencies in this file, making it straightforward and easy to understand.",
        "file_summary": "The 'OidcResponse.java' file defines a class that models the response from an OpenID Connect authentication process, encapsulating fields for the authorization code, state, error, and error description, along with appropriate accessors and a string representation method."
      }
    ]
  },
  "OidcTimeoutException.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\OidcTimeoutException.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\OidcTimeoutException.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\OidcTimeoutException.java",
        "chunk_id": "OidcTimeoutException_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc;\n<line_number-18>\n<line_number-19>public class OidcTimeoutException extends Exception {\n<line_number-20>    public OidcTimeoutException(String message) {\n<line_number-21>        super(message);\n<line_number-22>    }\n<line_number-23>}\n",
        "comments": [
          {
            "comment_code_range": "17-23",
            "comment_linenumber": "18",
            "comment": "Custom exception class for handling OIDC timeout errors, extending the base Exception class.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "20-22",
            "comment_linenumber": "21",
            "comment": "Constructor that initializes the exception with a specific error message.",
            "comment_kind": "constructor"
          }
        ],
        "structural_analysis": "File overview: The file 'OidcTimeoutException.java' defines a custom exception for handling OpenID Connect (OIDC) timeout scenarios within the MongoDB JDBC context. It follows standard Java exception handling practices. Top-level types: Class 'OidcTimeoutException' extends 'Exception', serving as a specialized error type for OIDC timeouts. Lifecycle notes: This class is not designed to be instantiated frequently; it is used to signal specific error conditions. Members: The class has a single constructor that takes a string message to describe the error. Method deep-dive: The constructor 'OidcTimeoutException(String message)' initializes the exception with the provided message, which can be retrieved later using the inherited 'getMessage()' method from the Exception class. Relationships: This class does not have any external dependencies or relationships with other classes in this file. External touchpoints: It may be used in conjunction with other OIDC-related classes or services in the broader application context. Observations & caveats: The class is straightforward and does not introduce complex logic or performance considerations.",
        "file_summary": "The 'OidcTimeoutException.java' file defines a custom exception for signaling timeout errors in OpenID Connect operations, enhancing error handling in the MongoDB JDBC implementation."
      }
    ]
  },
  "RFC8252HttpServer.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\RFC8252HttpServer.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\RFC8252HttpServer.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\RFC8252HttpServer.java",
        "chunk_id": "RFC8252HttpServer_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc;\n<line_number-18>\n<line_number-19>import com.sun.net.httpserver.HttpExchange;\n<line_number-20>import com.sun.net.httpserver.HttpHandler;\n<line_number-21>import com.sun.net.httpserver.HttpServer;\n<line_number-22>import java.io.IOException;\n<line_number-23>import java.io.OutputStream;\n<line_number-24>import java.io.UnsupportedEncodingException;\n<line_number-25>import java.net.HttpURLConnection;\n<line_number-26>import java.net.InetSocketAddress;\n<line_number-27>import java.net.URLDecoder;\n<line_number-28>import java.nio.charset.StandardCharsets;\n<line_number-29>import java.time.Duration;\n<line_number-30>import java.util.HashMap;\n<line_number-31>import java.util.Map;\n<line_number-32>import java.util.concurrent.BlockingQueue;\n<line_number-33>import java.util.concurrent.LinkedBlockingQueue;\n<line_number-34>import java.util.concurrent.TimeUnit;\n<line_number-35>import java.util.logging.Level;\n<line_number-36>import java.util.logging.Logger;\n<line_number-37>import org.thymeleaf.TemplateEngine;\n<line_number-38>import org.thymeleaf.context.Context;\n<line_number-39>import org.thymeleaf.templateresolver.ClassLoaderTemplateResolver;\n<line_number-40>\n<line_number-41>/**\n<line_number-42> * The RFC8252HttpServer class implements an OIDC (OpenID Connect) server based on RFC 8252. It\n<line_number-43> * handles the OIDC authorization code flow by providing endpoints for the callback and redirection.\n<line_number-44> * The server listens on a specified port (default is 27017) and processes incoming HTTP requests.\n<line_number-45> */\n<line_number-46>public class RFC8252HttpServer {\n<line_number-47>    public static final int DEFAULT_REDIRECT_PORT = 27097;\n<line_number-48>\n<line_number-49>    // SQL-2008: make sure this page exists and possibly update the link if the\n<line_number-50>    // docs team has a preference\n<line_number-51>    private static final String LOGIN_ERROR_URI =\n<line_number-52>            \"https://www.mongodb.com/docs/atlas/security-oidc\";\n<line_number-53>    private static final String PRODUCT_DOCS_LINK =\n<line_number-54>            \"https://www.mongodb.com/docs/atlas/data-federation/query/sql/drivers/odbc/connect\";\n<line_number-55>    private static final String PRODUCT_DOCS_NAME = \"Atlas SQL ODBC Driver\";\n<line_number-56>\n<line_number-57>    // OIDC response parameters\n<line_number-58>    private static final String CODE = \"code\";\n<line_number-59>    private static final String LOCATION = \"Location\";\n<line_number-60>    private static final String STATE = \"state\";\n<line_number-61>\n<line_number-62>    // template variables\n<line_number-63>    private static final String PRODUCT_DOCS_LINK_KEY = \"product_docs_link\";\n<line_number-64>    private static final String PRODUCT_DOCS_NAME_KEY = \"product_docs_name\";\n<line_number-65>    private static final String ERROR_URI_KEY = \"error_uri\";\n<line_number-66>    private static final String ERROR_KEY = \"error\";\n<line_number-67>    private static final String ERROR_DESCRIPTION_KEY = \"error_description\";\n<line_number-68>\n<line_number-69>    // server endpoints\n<line_number-70>    private static final String ACCEPTED_ENDPOINT = \"/accepted\";\n<line_number-71>    private static final String CALLBACK_ENDPOINT = \"/callback\";\n<line_number-72>    private static final String REDIRECT_ENDPOINT = \"/redirect\";\n<line_number-73>\n<line_number-74>    private HttpServer server;\n<line_number-75>    private final TemplateEngine templateEngine;\n<line_number-76>    private final BlockingQueue<OidcResponse> oidcResponseQueue;\n<line_number-77>\n<line_number-78>    public RFC8252HttpServer() {\n<line_number-79>        templateEngine = createTemplateEngine();\n<line_number-80>        oidcResponseQueue = new LinkedBlockingQueue<>();\n<line_number-81>    }\n<line_number-82>\n<line_number-83>    /**\n<line_number-84>     * Starts the HTTP server and sets up the necessary contexts and handlers.\n<line_number-85>     *\n<line_number-86>     * @throws IOException if an I/O error occurs while creating or starting the server\n<line_number-87>     */\n<line_number-88>    public void start() throws IOException {\n<line_number-89>        server = HttpServer.create(new InetSocketAddress(DEFAULT_REDIRECT_PORT), 0);\n<line_number-90>\n<line_number-91>        server.createContext(CALLBACK_ENDPOINT, new CallbackHandler());\n<line_number-92>        server.createContext(REDIRECT_ENDPOINT, new CallbackHandler());\n<line_number-93>        server.createContext(ACCEPTED_ENDPOINT, new AcceptedHandler());\n<line_number-94>        server.setExecutor(null);\n<line_number-95>        server.start();\n<line_number-96>    }\n<line_number-97>\n<line_number-98>    /**\n<line_number-99>     * Attempts to retrieve an OIDC response from the queue, waiting up to a default timeout of 300\n<line_number-100>     * seconds.\n<line_number-101>     *\n<line_number-102>     * @return the OIDC response, if available within the default timeout period\n<line_number-103>     * @throws InterruptedException if no response is available within the default timeout period\n<line_number-104>     */\n<line_number-105>    public OidcResponse getOidcResponse() throws InterruptedException, OidcTimeoutException {\n<line_number-106>        return getOidcResponse(Duration.ofSeconds(300));\n<line_number-107>    }\n<line_number-108>\n<line_number-109>    /**\n<line_number-110>     * Attempts to retrieve an OIDC response from the queue, waiting up to the specified timeout. If\n<line_number-111>     * no response is available within the timeout period, an InterruptedException is thrown.\n<line_number-112>     *\n<line_number-113>     * @param timeout the maximum time to wait for an OIDC response, in seconds\n<line_number-114>     * @return the OIDC response, if available within the timeout period\n<line_number-115>     * @throws InterruptedException if no response is available within the timeout period or if the\n<line_number-116>     *     current thread is interrupted while waiting\n<line_number-117>     */\n<line_number-118>    public OidcResponse getOidcResponse(Duration timeout)\n<line_number-119>            throws OidcTimeoutException, InterruptedException {\n<line_number-120>        if (timeout == null) {\n<line_number-121>            return getOidcResponse();\n<line_number-122>        }\n<line_number-123>        OidcResponse response = oidcResponseQueue.poll(timeout.getSeconds(), TimeUnit.SECONDS);\n<line_number-124>        if (response == null) {\n<line_number-125>            throw new OidcTimeoutException(\"Timeout waiting for OIDC response\");\n<line_number-126>        }\n<line_number-127>        return response;\n<line_number-128>    }\n<line_number-129>\n<line_number-130>    public void stop() {\n<line_number-131>        if (server != null) {\n<line_number-132>            server.stop(0);\n<line_number-133>        }\n<line_number-134>    }\n<line_number-135>\n<line_number-136>    /**\n<line_number-137>     * Creates and configures the template engine.\n<line_number-138>     *\n<line_number-139>     * @return the configured template engine\n<line_number-140>     */\n<line_number-141>    private TemplateEngine createTemplateEngine() {\n<line_number-142>        TemplateEngine templateEngine = new TemplateEngine();\n<line_number-143>        ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();\n<line_number-144>        templateResolver.setPrefix(\"/templates/\");\n<line_number-145>        templateResolver.setSuffix(\".html\");\n<line_number-146>        templateEngine.setTemplateResolver(templateResolver);\n<line_number-147>        return templateEngine;\n<line_number-148>    }\n<line_number-149>\n<line_number-150>    /** HTTP handler for handling the callback and redirect endpoints. */\n<line_number-151>    private class CallbackHandler implements HttpHandler {\n<line_number-152>\n<line_number-153>        @Override\n<line_number-154>        public void handle(HttpExchange exchange) throws IOException {\n<line_number-155>            Map<String, String> queryParams = parseQueryParams(exchange);\n<line_number-156>            OidcResponse oidcResponse = new OidcResponse();\n<line_number-157>\n<line_number-158>            if (queryParams.containsKey(CODE)) {\n<line_number-159>                oidcResponse.setCode(queryParams.get(CODE));\n<line_number-160>                oidcResponse.setState(queryParams.getOrDefault(STATE, \"\"));\n<line_number-161>                if (!putOidcResponse(exchange, oidcResponse)) {\n<line_number-162>                    return;\n<line_number-163>                }\n<line_number-164>                // This will hide the code and state from the URL bar by doing a redirect\n<line_number-165>                // to the /accepted page rather than rendering the accepted page directly\n<line_number-166>                exchange.getResponseHeaders().set(LOCATION, ACCEPTED_ENDPOINT);\n<line_number-167>                sendResponse(exchange, \"\", HttpURLConnection.HTTP_MOVED_TEMP);\n<line_number-168>            } else if (queryParams.containsKey(ERROR_KEY)) {\n<line_number-169>                oidcResponse.setError(queryParams.get(ERROR_KEY));\n<line_number-170>                oidcResponse.setErrorDescription(\n<line_number-171>                        queryParams.getOrDefault(ERROR_DESCRIPTION_KEY, \"Unknown error\"));\n<line_number-172>                if (!putOidcResponse(exchange, oidcResponse)) {\n<line_number-173>                    return;\n<line_number-174>                }\n<line_number-175>                Context context = new Context();\n<line_number-176>                context.setVariable(ERROR_URI_KEY, LOGIN_ERROR_URI);\n<line_number-177>                context.setVariable(PRODUCT_DOCS_LINK_KEY, PRODUCT_DOCS_LINK);\n<line_number-178>                context.setVariable(PRODUCT_DOCS_NAME_KEY, PRODUCT_DOCS_NAME);\n<line_number-179>                context.setVariable(ERROR_KEY, queryParams.get(ERROR_KEY));\n<line_number-180>                context.setVariable(\n<line_number-181>                        ERROR_DESCRIPTION_KEY,\n<line_number-182>                        queryParams.getOrDefault(ERROR_DESCRIPTION_KEY, \"Unknown error\"));\n<line_number-183>                String errorHtml = templateEngine.process(\"OIDCErrorTemplate\", context);\n<line_number-184>                sendResponse(exchange, errorHtml, HttpURLConnection.HTTP_BAD_REQUEST);\n<line_number-185>\n<line_number-186>            } else {\n<line_number-187>                oidcResponse.setError(\"Not found\");\n<line_number-188>                String allParams =\n<line_number-189>                        queryParams\n<line_number-190>                                .entrySet()\n<line_number-191>                                .stream()\n<line_number-192>                                .map(entry -> entry.getKey() + \"=\" + entry.getValue())\n<line_number-193>                                .reduce((param1, param2) -> param1 + \", \" + param2)\n<line_number-194>                                .orElse(\"No parameters\");\n<line_number-195>                oidcResponse.setErrorDescription(\"Not found. Parameters: \" + allParams);\n<line_number-196>                if (!putOidcResponse(exchange, oidcResponse)) {\n<line_number-197>                    return;\n<line_number-198>                }\n<line_number-199>                Context context = new Context();\n<line_number-200>                context.setVariable(PRODUCT_DOCS_LINK_KEY, PRODUCT_DOCS_LINK);\n<line_number-201>                context.setVariable(PRODUCT_DOCS_NAME_KEY, PRODUCT_DOCS_NAME);\n<line_number-202>                String notFoundHtml = templateEngine.process(\"OIDCNotFoundTemplate\", context);\n<line_number-203>                sendResponse(exchange, notFoundHtml, HttpURLConnection.HTTP_NOT_FOUND);\n<line_number-204>            }\n<line_number-205>        }\n<line_number-206>    }\n<line_number-207>\n<line_number-208>    /** HTTP handler for handling the accepted endpoint. */\n<line_number-209>    private class AcceptedHandler implements HttpHandler {\n<line_number-210>        @Override\n<line_number-211>        public void handle(HttpExchange exchange) throws IOException {\n<line_number-212>            Context context = new Context();\n<line_number-213>            context.setVariable(PRODUCT_DOCS_LINK_KEY, PRODUCT_DOCS_LINK);\n<line_number-214>            context.setVariable(PRODUCT_DOCS_NAME_KEY, PRODUCT_DOCS_NAME);\n<line_number-215>            String acceptedHtml = templateEngine.process(\"OIDCAcceptedTemplate\", context);\n<line_number-216>            sendResponse(exchange, acceptedHtml, HttpURLConnection.HTTP_OK);\n<line_number-217>        }\n<line_number-218>    }\n<line_number-219>\n<line_number-220>    /**\n<line_number-221>     * Parses the query parameters from the HTTP exchange.\n<line_number-222>     *\n<line_number-223>     * @param exchange the HTTP exchange\n<line_number-224>     * @return a map containing the parsed query parameters\n<line_number-225>     * @throws UnsupportedEncodingException if the encoding is not supported\n<line_number-226>     */\n<line_number-227>    private Map<String, String> parseQueryParams(HttpExchange exchange)\n<line_number-228>            throws UnsupportedEncodingException {\n<line_number-229>        Map<String, String> queryParams = new HashMap<>();\n<line_number-230>        String rawQuery = exchange.getRequestURI().getRawQuery();\n<line_number-231>\n<line_number-232>        if (rawQuery != null) {\n<line_number-233>            String[] params = rawQuery.split(\"&\");\n<line_number-234>            for (String param : params) {\n<line_number-235>                int equalsIndex = param.indexOf('=');\n<line_number-236>                if (equalsIndex > 0) {\n<line_number-237>                    String key = param.substring(0, equalsIndex);\n<line_number-238>                    String encodedValue = param.substring(equalsIndex + 1);\n<line_number-239>                    String value = URLDecoder.decode(encodedValue, \"UTF-8\");\n<line_number-240>                    queryParams.put(key, value);\n<line_number-241>                } else {\n<line_number-242>                    queryParams.put(param, \"\");\n<line_number-243>                }\n<line_number-244>            }\n<line_number-245>        }\n<line_number-246>        return queryParams;\n<line_number-247>    }\n<line_number-248>\n<line_number-249>    /**\n<line_number-250>     * Puts the OIDC response into the blocking queue. If the queue is full, an error response is\n<line_number-251>     * sent to the client and the HttpExchange is closed.\n<line_number-252>     *\n<line_number-253>     * @param exchange the HTTP exchange\n<line_number-254>     * @param oidcResponse the OIDC response to put into the queue\n<line_number-255>     * @return true if the response was successfully put into the queue, false otherwise\n<line_number-256>     * @throws IOException if an I/O error occurs while sending a response\n<line_number-257>     */\n<line_number-258>    private boolean putOidcResponse(HttpExchange exchange, OidcResponse oidcResponse)\n<line_number-259>            throws IOException {\n<line_number-260>        try {\n<line_number-261>            oidcResponseQueue.put(oidcResponse);\n<line_number-262>            return true;\n<line_number-263>        } catch (InterruptedException e) {\n<line_number-264>            Thread.currentThread().interrupt();\n<line_number-265>            // sendResponse will close the exchange\n<line_number-266>            sendResponse(exchange, \"<html><body><h1>Internal Server Error</h1></body></html>\", 500);\n<line_number-267>            return false;\n<line_number-268>        }\n<line_number-269>    }\n<line_number-270>\n<line_number-271>    /**\n<line_number-272>     * Sends an HTTP response with the specified content and status code.\n<line_number-273>     *\n<line_number-274>     * @param exchange the HTTP exchange\n<line_number-275>     * @param response the response content\n<line_number-276>     * @param statusCode the HTTP status code\n<line_number-277>     * @throws IOException if an I/O error occurs while sending the response\n<line_number-278>     */\n<line_number-279>    private void sendResponse(HttpExchange exchange, String response, int statusCode)\n<line_number-280>            throws IOException {\n<line_number-281>        exchange.getResponseHeaders().set(\"Content-Type\", \"text/html; charset=utf-8\");\n<line_number-282>        try {\n<line_number-283>            exchange.sendResponseHeaders(\n<line_number-284>                    statusCode, response.getBytes(StandardCharsets.UTF_8).length);\n<line_number-285>            try (OutputStream os = exchange.getResponseBody()) {\n<line_number-286>                os.write(response.getBytes(StandardCharsets.UTF_8));\n<line_number-287>            }\n<line_number-288>        } catch (IOException e) {\n<line_number-289>            Logger logger = Logger.getLogger(RFC8252HttpServer.class.getName());\n<line_number-290>            logger.log(Level.SEVERE, \"Error sending response\", e);\n<line_number-291>            throw e;\n<line_number-292>        } finally {\n<line_number-293>            exchange.close();\n<line_number-294>        }\n<line_number-295>    }\n<line_number-296>}\n",
        "comments": [
          {
            "comment_code_range": "41-44",
            "comment_linenumber": "40",
            "comment": "This class implements an OIDC server based on RFC 8252, handling authorization code flow and providing HTTP endpoints for callback and redirection.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "78-81",
            "comment_linenumber": "77",
            "comment": "Constructor initializes the template engine and the OIDC response queue.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "83-87",
            "comment_linenumber": "82",
            "comment": "Starts the HTTP server, sets up contexts for callback and redirect endpoints, and begins listening for requests.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "99-104",
            "comment_linenumber": "98",
            "comment": "Retrieves an OIDC response from the queue, waiting up to 300 seconds.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "110-116",
            "comment_linenumber": "109",
            "comment": "Retrieves an OIDC response from the queue with a specified timeout, throwing an exception if no response is available.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "130-134",
            "comment_linenumber": "129",
            "comment": "Stops the HTTP server if it is currently running.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "136-140",
            "comment_linenumber": "135",
            "comment": "Creates and configures the template engine for rendering HTML responses.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "150-150",
            "comment_linenumber": "149",
            "comment": "Handles HTTP requests for the callback and redirect endpoints.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "153-205",
            "comment_linenumber": "152",
            "comment": "Processes incoming HTTP exchanges, handling OIDC responses and errors, and sending appropriate HTML responses.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "208-208",
            "comment_linenumber": "207",
            "comment": "Handles HTTP requests for the accepted endpoint.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "211-216",
            "comment_linenumber": "210",
            "comment": "Processes the accepted endpoint request and sends an HTML response.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "220-226",
            "comment_linenumber": "219",
            "comment": "Parses query parameters from the HTTP exchange and returns them as a map.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "249-256",
            "comment_linenumber": "248",
            "comment": "Attempts to put an OIDC response into the queue, handling errors if the queue is full.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "271-278",
            "comment_linenumber": "270",
            "comment": "Sends an HTTP response with the specified content and status code, handling any I/O errors.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'RFC8252HttpServer.java' defines a class that implements an OpenID Connect (OIDC) server based on RFC 8252. It primarily serves to handle the OIDC authorization code flow by providing HTTP endpoints for callback and redirection. The server listens on a specified port (default is 27097) and processes incoming HTTP requests. The class contains several inner classes, specifically 'CallbackHandler' and 'AcceptedHandler', which implement the HttpHandler interface to manage HTTP requests for specific endpoints. The main class has methods to start and stop the server, retrieve OIDC responses from a blocking queue, and send HTTP responses. It also includes a method for parsing query parameters from HTTP exchanges. The class utilizes a template engine for rendering HTML responses based on the OIDC flow outcomes. The design follows a straightforward request-response model typical in web servers, with a focus on handling OIDC-specific logic and error management.",
        "file_summary": "This file implements an OIDC server that manages the authorization code flow as per RFC 8252. It provides endpoints for handling callbacks and redirections, processes incoming HTTP requests, and renders HTML responses based on the OIDC flow outcomes."
      }
    ]
  },
  "TestOidcAuthFlow.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcAuthFlow.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcAuthFlow.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcAuthFlow.java",
        "chunk_id": "TestOidcAuthFlow_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc.manualtests;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential.OidcCallbackContext;\n<line_number-20>import com.mongodb.jdbc.oidc.JdbcOidcCallbackContext;\n<line_number-21>import com.mongodb.jdbc.oidc.OidcAuthFlow;\n<line_number-22>import java.time.Duration;\n<line_number-23>\n<line_number-24>public class TestOidcAuthFlow {\n<line_number-25>    public static void main(String[] args) {\n<line_number-26>        OidcAuthFlow authFlow = new OidcAuthFlow();\n<line_number-27>\n<line_number-28>        Duration timeout = Duration.ofMinutes(5);\n<line_number-29>        OidcCallbackContext callbackContext =\n<line_number-30>                new JdbcOidcCallbackContext(timeout, 1, null, TestOidcUtils.IDP_INFO, null);\n<line_number-31>\n<line_number-32>        TestOidcUtils.testAuthCodeFlow(callbackContext, authFlow);\n<line_number-33>    }\n<line_number-34>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for the OIDC manual tests related to MongoDB JDBC.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "24-34",
            "comment_linenumber": "23",
            "comment": "Test class for demonstrating the OIDC authentication flow using JDBC. It initializes the authentication flow and executes a test for the authorization code flow.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "25-33",
            "comment_linenumber": "24",
            "comment": "Main method that serves as the entry point for the test. It sets up the OIDC authentication flow and initiates the test for the authorization code flow.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "26-26",
            "comment_linenumber": "25",
            "comment": "Creates an instance of OidcAuthFlow to manage the authentication process.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "28-30",
            "comment_linenumber": "27",
            "comment": "Sets a timeout duration for the authentication process and initializes the callback context with necessary parameters.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "32-32",
            "comment_linenumber": "31",
            "comment": "Calls the utility method to test the authorization code flow using the provided callback context and authentication flow.",
            "comment_kind": "other"
          }
        ],
        "structural_analysis": "The file 'TestOidcAuthFlow.java' is designed to test the OIDC authentication flow using JDBC. It follows a straightforward structure with a single public class, 'TestOidcAuthFlow', containing a main method that serves as the entry point for execution. The class imports necessary components from the MongoDB JDBC library, including 'OidcCallbackContext' and 'OidcAuthFlow', as well as Java's 'Duration' class for managing timeouts. The main method initializes an instance of 'OidcAuthFlow' and sets a timeout duration of 5 minutes. It then creates a 'JdbcOidcCallbackContext' with specific parameters, including an IDP information constant from 'TestOidcUtils'. Finally, it invokes a static method 'testAuthCodeFlow' from 'TestOidcUtils' to execute the authentication test. The file does not contain any complex control flows or external dependencies beyond the MongoDB JDBC library and standard Java libraries.",
        "file_summary": "This file contains a test class for the OIDC authentication flow using JDBC, demonstrating how to set up and execute an authorization code flow test."
      }
    ]
  },
  "TestOidcAuthFlowAndRefresh.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcAuthFlowAndRefresh.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcAuthFlowAndRefresh.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcAuthFlowAndRefresh.java",
        "chunk_id": "TestOidcAuthFlowAndRefresh_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc.manualtests;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential.OidcCallbackContext;\n<line_number-20>import com.mongodb.MongoCredential.OidcCallbackResult;\n<line_number-21>import com.mongodb.jdbc.oidc.JdbcOidcCallbackContext;\n<line_number-22>import com.mongodb.jdbc.oidc.OidcAuthFlow;\n<line_number-23>import java.time.Duration;\n<line_number-24>\n<line_number-25>public class TestOidcAuthFlowAndRefresh {\n<line_number-26>    public static void main(String[] args) {\n<line_number-27>        OidcAuthFlow authFlow = new OidcAuthFlow();\n<line_number-28>\n<line_number-29>        Duration timeout = Duration.ofMinutes(5);\n<line_number-30>        OidcCallbackContext callbackContext =\n<line_number-31>                new JdbcOidcCallbackContext(timeout, 1, null, TestOidcUtils.IDP_INFO, null);\n<line_number-32>\n<line_number-33>        OidcCallbackResult result = TestOidcUtils.testAuthCodeFlow(callbackContext, authFlow);\n<line_number-34>        if (result != null) {\n<line_number-35>            // get refresh token from the AuthCodeFLow result\n<line_number-36>            OidcCallbackContext refreshContext =\n<line_number-37>                    new JdbcOidcCallbackContext(\n<line_number-38>                            timeout, 1, result.getRefreshToken(), TestOidcUtils.IDP_INFO, null);\n<line_number-39>            try {\n<line_number-40>                OidcCallbackResult refreshResult = authFlow.doRefresh(refreshContext);\n<line_number-41>                if (refreshResult != null) {\n<line_number-42>                    System.out.println(\"Refreshed Access Token: \" + refreshResult.getAccessToken());\n<line_number-43>                    System.out.println(\n<line_number-44>                            \"Refreshed Refresh Token: \" + refreshResult.getRefreshToken());\n<line_number-45>                } else {\n<line_number-46>                    System.out.println(\"Refresh token flow failed.\");\n<line_number-47>                }\n<line_number-48>            } catch (Exception e) {\n<line_number-49>                System.err.println(\n<line_number-50>                        \"An error occurred while running the refresh token flow: \"\n<line_number-51>                                + e.getMessage());\n<line_number-52>                e.printStackTrace();\n<line_number-53>            }\n<line_number-54>        }\n<line_number-55>    }\n<line_number-56>}\n",
        "comments": [
          {
            "comment_code_range": "25-55",
            "comment_linenumber": "24",
            "comment": "This class contains the main method to test the OIDC authentication flow and refresh token functionality.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "26-55",
            "comment_linenumber": "25",
            "comment": "Main entry point for the application that initiates the OIDC authentication flow and handles token refresh.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "27-33",
            "comment_linenumber": "26",
            "comment": "Initializes the OIDC authentication flow and sets up the callback context with a timeout and IDP information.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "34-54",
            "comment_linenumber": "33",
            "comment": "Handles the result of the authentication flow, retrieves the refresh token, and attempts to refresh the access token.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "36-46",
            "comment_linenumber": "35",
            "comment": "Creates a new callback context for refreshing the token using the refresh token obtained from the initial flow.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "40-53",
            "comment_linenumber": "39",
            "comment": "Executes the refresh token flow and handles potential exceptions, printing results or errors to the console.",
            "comment_kind": "try"
          }
        ],
        "structural_analysis": "The file 'TestOidcAuthFlowAndRefresh.java' serves as a test harness for the OIDC authentication flow and refresh token mechanism within the MongoDB JDBC OIDC package. It follows a procedural design pattern, primarily focusing on the execution of authentication and token refresh logic. The top-level class 'TestOidcAuthFlowAndRefresh' contains a single static method 'main', which is the entry point of the application. \n\nThe class does not extend any other class and does not implement any interfaces. It is responsible for initializing the OIDC authentication flow, setting up the necessary context for the authentication process, and managing the refresh token flow. \n\nThe 'main' method initializes an instance of 'OidcAuthFlow' and creates a 'JdbcOidcCallbackContext' with a specified timeout and IDP information. It then calls 'TestOidcUtils.testAuthCodeFlow' to execute the authentication code flow, which returns an 'OidcCallbackResult'. If the result is not null, it retrieves the refresh token and attempts to refresh the access token using 'authFlow.doRefresh'. The method handles exceptions that may occur during the refresh process, logging any errors to the console. \n\nThe file imports several classes from the MongoDB library, including 'OidcCallbackContext', 'OidcCallbackResult', and 'OidcAuthFlow', indicating its reliance on these components for OIDC functionality. The use of 'Duration' from the Java time package allows for flexible timeout management during the authentication process. Overall, the file encapsulates the logic for testing OIDC authentication and token refresh, providing a clear structure for executing these operations.",
        "file_summary": "The 'TestOidcAuthFlowAndRefresh.java' file is designed to test the OIDC authentication flow and the refresh token mechanism within the MongoDB JDBC OIDC package. It initializes the authentication process, handles the retrieval of access and refresh tokens, and manages the refresh token flow, providing a console output of the results."
      }
    ]
  },
  "TestOidcCallback.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcCallback.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcCallback.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcCallback.java",
        "chunk_id": "TestOidcCallback_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc.manualtests;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential.OidcCallback;\n<line_number-20>import com.mongodb.MongoCredential.OidcCallbackContext;\n<line_number-21>import com.mongodb.MongoCredential.OidcCallbackResult;\n<line_number-22>import com.mongodb.jdbc.oidc.JdbcOidcCallback;\n<line_number-23>import com.mongodb.jdbc.oidc.JdbcOidcCallbackContext;\n<line_number-24>\n<line_number-25>public class TestOidcCallback {\n<line_number-26>\n<line_number-27>    public static void main(String[] args) {\n<line_number-28>        OidcCallback oidcCallback = new JdbcOidcCallback();\n<line_number-29>\n<line_number-30>        OidcCallbackContext initialContext =\n<line_number-31>                new JdbcOidcCallbackContext(null, 1, null, TestOidcUtils.IDP_INFO, null);\n<line_number-32>        try {\n<line_number-33>            OidcCallbackResult initialResult = oidcCallback.onRequest(initialContext);\n<line_number-34>            if (initialResult != null) {\n<line_number-35>                System.out.println(\"Access Token: \" + initialResult.getAccessToken());\n<line_number-36>                System.out.println(\"Refresh Token: \" + initialResult.getRefreshToken());\n<line_number-37>            } else {\n<line_number-38>                System.out.println(\"Authentication failed.\");\n<line_number-39>            }\n<line_number-40>            OidcCallbackContext refreshContext =\n<line_number-41>                    new JdbcOidcCallbackContext(\n<line_number-42>                            null, 1, initialResult.getRefreshToken(), TestOidcUtils.IDP_INFO, null);\n<line_number-43>            OidcCallbackResult refreshResult = oidcCallback.onRequest(refreshContext);\n<line_number-44>            if (refreshResult != null) {\n<line_number-45>                System.out.println(\"Refreshed Access Token: \" + refreshResult.getAccessToken());\n<line_number-46>                System.out.println(\"Refreshed Refresh Token: \" + refreshResult.getRefreshToken());\n<line_number-47>            } else {\n<line_number-48>                System.out.println(\"Refresh token flow failed.\");\n<line_number-49>            }\n<line_number-50>        } catch (Exception e) {\n<line_number-51>            System.err.println(\"Error during OIDC callback test: \" + e.getMessage());\n<line_number-52>        }\n<line_number-53>    }\n<line_number-54>}\n",
        "comments": [
          {
            "comment_code_range": "25-53",
            "comment_linenumber": "24",
            "comment": "This class serves as a test harness for the OIDC callback functionality, demonstrating the request and refresh token flows.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "27-53",
            "comment_linenumber": "26",
            "comment": "Main method that initiates the OIDC callback test, handling both initial authentication and token refresh.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "30-33",
            "comment_linenumber": "29",
            "comment": "Creates the initial context for the OIDC callback request, including necessary parameters for authentication.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "34-39",
            "comment_linenumber": "33",
            "comment": "Handles the result of the initial OIDC callback request, printing access and refresh tokens or an error message.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "40-43",
            "comment_linenumber": "39",
            "comment": "Creates a new context for refreshing the access token using the refresh token obtained from the initial request.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "44-48",
            "comment_linenumber": "43",
            "comment": "Handles the result of the refresh token request, printing the new tokens or an error message.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "50-52",
            "comment_linenumber": "49",
            "comment": "Catches and logs any exceptions that occur during the OIDC callback test.",
            "comment_kind": "try"
          }
        ],
        "structural_analysis": "The file 'TestOidcCallback.java' is part of the 'com.mongodb.jdbc.oidc.manualtests' package and serves as a test harness for OpenID Connect (OIDC) callback functionality. It primarily demonstrates the process of obtaining and refreshing access tokens using OIDC callbacks. The main class, 'TestOidcCallback', contains a single method, 'main', which orchestrates the testing of the OIDC callback. The class does not implement any interfaces or extend any other classes. The 'main' method initializes an instance of 'JdbcOidcCallback', which is a concrete implementation of the 'OidcCallback' interface. It creates an initial context for the OIDC request using 'JdbcOidcCallbackContext', passing necessary parameters including an IDP (Identity Provider) information. The method then invokes the 'onRequest' method of the 'oidcCallback' instance to handle the authentication request. The results are processed to print the access and refresh tokens or an error message if authentication fails. Subsequently, a new context is created for refreshing the access token using the refresh token obtained from the initial request. The refresh request is similarly handled, with results printed accordingly. The method includes exception handling to log any errors encountered during the process. Overall, the file encapsulates the logic for testing OIDC callbacks, focusing on token management and error handling.",
        "file_summary": "The 'TestOidcCallback.java' file is designed to test the OpenID Connect (OIDC) callback functionality, specifically focusing on the processes of obtaining and refreshing access tokens. It provides a simple command-line interface to demonstrate these flows and handle potential errors during the authentication process."
      }
    ]
  },
  "TestOidcCallbackWithBadRefreshToken.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcCallbackWithBadRefreshToken.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcCallbackWithBadRefreshToken.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcCallbackWithBadRefreshToken.java",
        "chunk_id": "TestOidcCallbackWithBadRefreshToken_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc.manualtests;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential.OidcCallback;\n<line_number-20>import com.mongodb.MongoCredential.OidcCallbackContext;\n<line_number-21>import com.mongodb.MongoCredential.OidcCallbackResult;\n<line_number-22>import com.mongodb.jdbc.oidc.JdbcOidcCallback;\n<line_number-23>import com.mongodb.jdbc.oidc.JdbcOidcCallbackContext;\n<line_number-24>import javax.security.auth.RefreshFailedException;\n<line_number-25>\n<line_number-26>public class TestOidcCallbackWithBadRefreshToken {\n<line_number-27>\n<line_number-28>    public static void main(String[] args) {\n<line_number-29>        OidcCallback oidcCallback = new JdbcOidcCallback();\n<line_number-30>\n<line_number-31>        String badRefreshToken = \"bad-refresh-token\";\n<line_number-32>        OidcCallbackContext context =\n<line_number-33>                new JdbcOidcCallbackContext(null, 1, badRefreshToken, TestOidcUtils.IDP_INFO, null);\n<line_number-34>\n<line_number-35>        try {\n<line_number-36>            OidcCallbackResult result = oidcCallback.onRequest(context);\n<line_number-37>            System.out.println(\"This should not print, bad refresh token expected to fail.\");\n<line_number-38>            System.out.println(result);\n<line_number-39>        } catch (Exception e) {\n<line_number-40>            if (e.getCause() instanceof RefreshFailedException) {\n<line_number-41>                System.err.println(\n<line_number-42>                        \"Expected RefreshFailedException occurred: \" + e.getCause().getMessage());\n<line_number-43>            } else {\n<line_number-44>                System.err.println(\"Unexpected error: \" + e.getMessage());\n<line_number-45>            }\n<line_number-46>        }\n<line_number-47>    }\n<line_number-48>}\n",
        "comments": [
          {
            "comment_code_range": "26-48",
            "comment_linenumber": "25",
            "comment": "This class tests the behavior of the OIDC callback when provided with a bad refresh token, expecting a RefreshFailedException.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "28-48",
            "comment_linenumber": "27",
            "comment": "Main method that initializes the OIDC callback and tests it with a bad refresh token, handling expected exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "35-46",
            "comment_linenumber": "34",
            "comment": "Try-catch block to handle the callback request and manage exceptions, specifically looking for RefreshFailedException.",
            "comment_kind": "try"
          },
          {
            "comment_code_range": "40-46",
            "comment_linenumber": "39",
            "comment": "Conditional block to differentiate between expected RefreshFailedException and unexpected errors.",
            "comment_kind": "conditional"
          }
        ],
        "structural_analysis": "File overview: The file 'TestOidcCallbackWithBadRefreshToken.java' is a test class designed to validate the behavior of the OIDC callback mechanism when an invalid refresh token is provided. It follows a straightforward procedural design pattern typical for unit tests. \n\nTop-level types: \n- Signature: TestOidcCallbackWithBadRefreshToken, class. \n  Role: This class is responsible for testing the OIDC callback functionality with a specific focus on handling bad refresh tokens. \n  Lifecycle notes: This class is not intended for instantiation; it serves solely as a test utility. \n\nMembers: \n- Fields: \n  - oidcCallback: OidcCallback, private, initialized to a new JdbcOidcCallback instance, used to invoke the OIDC callback. \n  - badRefreshToken: String, initialized to \"bad-refresh-token\", simulates an invalid token for testing purposes. \n  - context: OidcCallbackContext, initialized with parameters including the bad refresh token, encapsulates the context for the callback request. \n\nMethod deep-dive: \n- Signature: main, parameters: String[] args, return type: void. \n  Behaviour: Initializes the OIDC callback and context, invokes the callback with the bad token, and handles exceptions. \n  Internal calls: Calls onRequest method of oidcCallback. \n  External calls: Utilizes JdbcOidcCallback and JdbcOidcCallbackContext from the com.mongodb.jdbc.oidc package. \n  Key control flow: The method contains a try-catch block to manage the expected RefreshFailedException and any other unexpected errors. \n\nRelationships: The class directly interacts with the JdbcOidcCallback and JdbcOidcCallbackContext classes, which are part of the MongoDB JDBC OIDC package. \n\nExternal touchpoints: The class relies on the MongoDB JDBC OIDC library for its functionality. \n\nAlgorithms / domain logic: The primary logic revolves around testing the handling of invalid refresh tokens and ensuring that the appropriate exceptions are thrown. \n\nObservations & caveats: The test is designed to validate error handling, ensuring robustness in the OIDC callback implementation. There are no apparent performance hotspots or thread-safety concerns in this single-threaded test context.",
        "file_summary": "The 'TestOidcCallbackWithBadRefreshToken.java' file contains a test class that verifies the behavior of the OIDC callback when an invalid refresh token is provided. It aims to ensure that the system correctly raises a RefreshFailedException, thereby validating the error handling capabilities of the OIDC callback mechanism."
      }
    ]
  },
  "TestOidcCallbackWithShortTimeout.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcCallbackWithShortTimeout.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcCallbackWithShortTimeout.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcCallbackWithShortTimeout.java",
        "chunk_id": "TestOidcCallbackWithShortTimeout_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc.manualtests;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential.OidcCallback;\n<line_number-20>import com.mongodb.MongoCredential.OidcCallbackContext;\n<line_number-21>import com.mongodb.MongoCredential.OidcCallbackResult;\n<line_number-22>import com.mongodb.jdbc.oidc.JdbcOidcCallback;\n<line_number-23>import com.mongodb.jdbc.oidc.JdbcOidcCallbackContext;\n<line_number-24>import com.mongodb.jdbc.oidc.OidcTimeoutException;\n<line_number-25>import java.time.Duration;\n<line_number-26>\n<line_number-27>public class TestOidcCallbackWithShortTimeout {\n<line_number-28>\n<line_number-29>    public static void main(String[] args) {\n<line_number-30>        OidcCallback oidcCallback = new JdbcOidcCallback();\n<line_number-31>\n<line_number-32>        Duration shortTimeout = Duration.ofSeconds(2); // intentionally short to trigger timeout\n<line_number-33>        OidcCallbackContext context =\n<line_number-34>                new JdbcOidcCallbackContext(shortTimeout, 1, null, TestOidcUtils.IDP_INFO, null);\n<line_number-35>\n<line_number-36>        try {\n<line_number-37>            OidcCallbackResult result = oidcCallback.onRequest(context);\n<line_number-38>            // Timeout is expected when user input is required as it should take longer than 2 second.\n<line_number-39>            // It may pass if the user is already signed in and credentials are saved in the browser.\n<line_number-40>            System.out.println(\n<line_number-41>                    \"This should not print, timeout expected. Sign out of the IdP or clear the browser cache \"\n<line_number-42>                            + \"to trigger a timeout.\");\n<line_number-43>            System.out.println(result);\n<line_number-44>        } catch (Exception e) {\n<line_number-45>            if (e.getCause() instanceof OidcTimeoutException) {\n<line_number-46>                System.err.println(\n<line_number-47>                        \"Expected OidcTimeoutException occurred: \" + e.getCause().getMessage());\n<line_number-48>            } else {\n<line_number-49>                System.err.println(\"Unexpected error: \" + e.getMessage());\n<line_number-50>            }\n<line_number-51>        }\n<line_number-52>    }\n<line_number-53>}\n",
        "comments": [
          {
            "comment_code_range": "27-52",
            "comment_linenumber": "26",
            "comment": "This class tests the OIDC callback functionality with a deliberately short timeout to ensure that a timeout exception is triggered when user input is required.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "29-52",
            "comment_linenumber": "28",
            "comment": "Main method that initiates the OIDC callback test with a short timeout and handles the expected timeout exception.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "32-34",
            "comment_linenumber": "31",
            "comment": "Sets a short timeout duration of 2 seconds for the OIDC callback context, which is intentionally brief to trigger a timeout during the test.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "36-51",
            "comment_linenumber": "35",
            "comment": "Try-catch block that executes the OIDC callback and handles the expected OidcTimeoutException, logging appropriate messages based on the outcome.",
            "comment_kind": "try"
          },
          {
            "comment_code_range": "45-49",
            "comment_linenumber": "44",
            "comment": "Handles exceptions thrown during the OIDC callback execution, specifically checking for the OidcTimeoutException and logging the result.",
            "comment_kind": "conditional"
          }
        ],
        "structural_analysis": "The file 'TestOidcCallbackWithShortTimeout.java' is designed to test the OIDC callback functionality in a MongoDB JDBC context. It employs a straightforward structure with a single public class containing a main method. The class utilizes the JdbcOidcCallback to simulate a scenario where a timeout is expected due to a short duration set for user input. The main method initializes the OIDC callback and context, executes the callback, and handles exceptions, particularly focusing on the OidcTimeoutException. The class does not implement any interfaces or extend other classes, making it a standalone test utility. The primary external dependencies are the MongoDB OIDC-related classes, which are imported at the beginning of the file. The method's behavior is straightforward, with a clear focus on testing timeout scenarios, and it includes exception handling to differentiate between expected and unexpected errors.",
        "file_summary": "This file contains a test class for validating the behavior of OIDC callbacks with a short timeout in a MongoDB JDBC context. It aims to ensure that the system correctly handles timeout scenarios when user input is required."
      }
    ]
  },
  "TestOidcUtils.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcUtils.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcUtils.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestOidcUtils.java",
        "chunk_id": "TestOidcUtils_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc.manualtests;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoCredential.IdpInfo;\n<line_number-20>import com.mongodb.MongoCredential.OidcCallbackContext;\n<line_number-21>import com.mongodb.MongoCredential.OidcCallbackResult;\n<line_number-22>import com.mongodb.jdbc.oidc.JdbcIdpInfo;\n<line_number-23>import com.mongodb.jdbc.oidc.OidcAuthFlow;\n<line_number-24>import java.util.Collections;\n<line_number-25>import java.util.List;\n<line_number-26>\n<line_number-27>public class TestOidcUtils {\n<line_number-28>\n<line_number-29>    public static String OIDC_ISSUER = \"https://mongodb-dev.okta.com/oauth2/ausqrxbcr53xakaRR357\";\n<line_number-30>    public static String OIDC_CLIENT_ID = \"0oarvap2r7PmNIBsS357\";\n<line_number-31>    public static final List<String> OPENID_SCOPE = Collections.singletonList(\"openid\");\n<line_number-32>\n<line_number-33>    public static final IdpInfo IDP_INFO =\n<line_number-34>            new JdbcIdpInfo(OIDC_ISSUER, OIDC_CLIENT_ID, OPENID_SCOPE);\n<line_number-35>\n<line_number-36>    public static OidcCallbackResult testAuthCodeFlow(\n<line_number-37>            OidcCallbackContext callbackContext, OidcAuthFlow authFlow) {\n<line_number-38>\n<line_number-39>        try {\n<line_number-40>            OidcCallbackResult result = authFlow.doAuthCodeFlow(callbackContext);\n<line_number-41>            if (result != null) {\n<line_number-42>                System.out.println(\"Access Token: \" + result.getAccessToken());\n<line_number-43>                System.out.println(\"Refresh Token: \" + result.getRefreshToken());\n<line_number-44>                return result;\n<line_number-45>            } else {\n<line_number-46>                System.out.println(\"Authentication failed.\");\n<line_number-47>            }\n<line_number-48>        } catch (Exception e) {\n<line_number-49>            System.err.println(\n<line_number-50>                    \"An error occurred while running the OIDC authentication flow: \"\n<line_number-51>                            + e.getMessage());\n<line_number-52>            e.printStackTrace();\n<line_number-53>        }\n<line_number-54>        return null;\n<line_number-55>    }\n<line_number-56>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for OIDC manual tests related to MongoDB JDBC.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "27-55",
            "comment_linenumber": "26",
            "comment": "TestOidcUtils class provides utility methods for testing OIDC authentication flows, including constants for issuer and client ID.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "29-31",
            "comment_linenumber": "28",
            "comment": "OIDC issuer URL for authentication.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "30-31",
            "comment_linenumber": "28",
            "comment": "Client ID used for OIDC authentication.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "33-34",
            "comment_linenumber": "32",
            "comment": "IDP_INFO holds the configuration for the OIDC identity provider.",
            "comment_kind": "field"
          },
          {
            "comment_code_range": "36-55",
            "comment_linenumber": "35",
            "comment": "testAuthCodeFlow method executes the OIDC authentication code flow and returns the result, handling exceptions and logging output.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "39-54",
            "comment_linenumber": "38",
            "comment": "Try-catch block for handling exceptions during the authentication flow.",
            "comment_kind": "try"
          },
          {
            "comment_code_range": "41-46",
            "comment_linenumber": "40",
            "comment": "Checks if the authentication result is valid and logs the access and refresh tokens.",
            "comment_kind": "conditional"
          }
        ],
        "structural_analysis": "The file named TestOidcUtils.java serves as a utility class for testing OpenID Connect (OIDC) authentication flows specifically for MongoDB JDBC. It follows a straightforward structure with a single public class containing static fields and methods. The class is designed to facilitate the testing of OIDC authentication by providing necessary constants and a method to execute the authentication flow. The primary design pattern utilized here is the utility pattern, as the class contains static members and methods that do not require instantiation. \n\nTop-level types include:\n- **TestOidcUtils**: A public class responsible for OIDC testing utilities. It does not extend any other class and does not implement any interfaces. The class is not designed to be instantiated, as it contains only static members.\n\nMembers:\n- **Fields**:\n  - `OIDC_ISSUER`: A static string representing the OIDC issuer URL, public visibility.\n  - `OIDC_CLIENT_ID`: A static string representing the client ID for OIDC, public visibility.\n  - `OPENID_SCOPE`: A static final list containing the scope for OIDC, public visibility.\n  - `IDP_INFO`: A static final instance of `JdbcIdpInfo` initialized with the issuer, client ID, and scope, public visibility.\n\n- **Methods**:\n  - `testAuthCodeFlow(OidcCallbackContext callbackContext, OidcAuthFlow authFlow)`: A static method that executes the OIDC authentication code flow. It takes a callback context and an authentication flow as parameters and returns an `OidcCallbackResult`. The method handles exceptions and logs relevant information to the console. It internally calls the `doAuthCodeFlow` method of the `authFlow` parameter and checks the result for validity.\n\nRelationships include the use of external classes such as `OidcCallbackContext`, `OidcAuthFlow`, and `OidcCallbackResult` from the `com.mongodb.MongoCredential` package, indicating dependencies on MongoDB's OIDC implementation. The method also handles exceptions that may arise during the authentication process, ensuring robust error handling. \n\nOverall, the file encapsulates the necessary components for testing OIDC flows, providing a clear structure and functionality for developers working with MongoDB's JDBC OIDC integration.",
        "file_summary": "The TestOidcUtils.java file provides utility methods and constants for testing OpenID Connect (OIDC) authentication flows in the context of MongoDB JDBC. It includes a method to execute the authentication code flow and handle results, facilitating the testing process for developers."
      }
    ]
  },
  "TestRFC8252Server.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestRFC8252Server.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestRFC8252Server.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\oidc\\manualtests\\TestRFC8252Server.java",
        "chunk_id": "TestRFC8252Server_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc.manualtests;\n<line_number-18>\n<line_number-19>import com.mongodb.jdbc.oidc.OidcResponse;\n<line_number-20>import com.mongodb.jdbc.oidc.OidcTimeoutException;\n<line_number-21>import com.mongodb.jdbc.oidc.RFC8252HttpServer;\n<line_number-22>import java.io.IOException;\n<line_number-23>/**\n<line_number-24> * Main class to start the RFC8252HttpServer and wait for the OIDC response Used for testing the\n<line_number-25> * serving of the HTML pages and the OIDC response\n<line_number-26> */\n<line_number-27>public class TestRFC8252Server {\n<line_number-28>    public static void main(String[] args) {\n<line_number-29>        int port = RFC8252HttpServer.DEFAULT_REDIRECT_PORT;\n<line_number-30>        RFC8252HttpServer server = new RFC8252HttpServer();\n<line_number-31>        try {\n<line_number-32>            server.start();\n<line_number-33>            System.out.println(\"Server started on port \" + port);\n<line_number-34>\n<line_number-35>            // Wait for the OIDC response\n<line_number-36>            OidcResponse oidcResponse = server.getOidcResponse();\n<line_number-37>            System.out.println(\"Server Result:\\n\" + oidcResponse.toString());\n<line_number-38>\n<line_number-39>            Thread.sleep(2000);\n<line_number-40>        } catch (IOException | OidcTimeoutException | InterruptedException e) {\n<line_number-41>            e.printStackTrace();\n<line_number-42>        } finally {\n<line_number-43>            server.stop();\n<line_number-44>        }\n<line_number-45>    }\n<line_number-46>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Package declaration for the manual tests related to OIDC functionality.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "23-25",
            "comment_linenumber": "22",
            "comment": "Main class to start the RFC8252HttpServer and wait for the OIDC response. Used for testing the serving of the HTML pages and the OIDC response.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "28-45",
            "comment_linenumber": "27",
            "comment": "Main method that initializes and starts the RFC8252HttpServer, waits for an OIDC response, and handles exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "29-29",
            "comment_linenumber": "28",
            "comment": "Defines the port for the RFC8252HttpServer using the default redirect port.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "30-30",
            "comment_linenumber": "29",
            "comment": "Instantiates the RFC8252HttpServer to handle OIDC requests.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "31-32",
            "comment_linenumber": "30",
            "comment": "Starts the RFC8252HttpServer to begin listening for requests.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "35-37",
            "comment_linenumber": "34",
            "comment": "Retrieves the OIDC response from the server and prints the result to the console.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "39-39",
            "comment_linenumber": "38",
            "comment": "Pauses the main thread for 2 seconds to allow for processing.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "40-42",
            "comment_linenumber": "39",
            "comment": "Catches and handles IO, OIDC timeout, and interruption exceptions, printing the stack trace.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "43-43",
            "comment_linenumber": "42",
            "comment": "Stops the RFC8252HttpServer to clean up resources.",
            "comment_kind": "other"
          }
        ],
        "structural_analysis": "The file named TestRFC8252Server.java serves as a manual testing utility for the RFC8252HttpServer, which is part of the MongoDB OIDC implementation. It follows a straightforward structure with a single public class containing a main method. The main method is responsible for initializing the server, starting it, waiting for an OIDC response, and handling any exceptions that may arise during execution. The class imports necessary components from the OIDC package, including OidcResponse and OidcTimeoutException, as well as standard Java IO exceptions. The server is instantiated and started on a predefined port, and the program waits for a response before printing it to the console. Exception handling is implemented to ensure that the server stops gracefully in case of errors. Overall, the file encapsulates the testing logic for the OIDC server in a clear and concise manner.",
        "file_summary": "TestRFC8252Server.java is a utility for testing the RFC8252HttpServer's functionality in handling OIDC responses. It initializes the server, waits for a response, and manages exceptions, providing a simple way to verify the server's operation."
      }
    ]
  },
  "BsonUtils.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\utils\\BsonUtils.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\utils\\BsonUtils.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\utils\\BsonUtils.java",
        "chunk_id": "BsonUtils_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.utils;\n<line_number-18>\n<line_number-19>import com.mongodb.jdbc.MongoSerializationException;\n<line_number-20>import com.mongodb.jdbc.NoCheckStateJsonWriter;\n<line_number-21>import java.io.IOException;\n<line_number-22>import java.io.StringWriter;\n<line_number-23>import java.nio.ByteBuffer;\n<line_number-24>import org.bson.BsonBinaryReader;\n<line_number-25>import org.bson.BsonBinaryWriter;\n<line_number-26>import org.bson.BsonDocument;\n<line_number-27>import org.bson.BsonDocumentWriter;\n<line_number-28>import org.bson.codecs.*;\n<line_number-29>import org.bson.io.BasicOutputBuffer;\n<line_number-30>import org.bson.json.JsonMode;\n<line_number-31>import org.bson.json.JsonWriter;\n<line_number-32>import org.bson.json.JsonWriterSettings;\n<line_number-33>\n<line_number-34>/** Utility class for BSON serialization and deserialization. */\n<line_number-35>public class BsonUtils {\n<line_number-36>    public static final JsonWriterSettings JSON_WRITER_SETTINGS =\n<line_number-37>            JsonWriterSettings.builder().outputMode(JsonMode.RELAXED).indent(true).build();\n<line_number-38>\n<line_number-39>    public static final JsonWriterSettings JSON_WRITER_NO_INDENT_SETTINGS =\n<line_number-40>            JsonWriterSettings.builder().outputMode(JsonMode.RELAXED).indent(false).build();\n<line_number-41>\n<line_number-42>    /**\n<line_number-43>     * Serializes a BsonDocument into a BSON byte array.\n<line_number-44>     *\n<line_number-45>     * @param doc The BsonDocument to serialize.\n<line_number-46>     * @return BSON byte array.\n<line_number-47>     * @throws MongoSerializationException If serialization fails.\n<line_number-48>     */\n<line_number-49>    public static byte[] serialize(BsonDocument doc) throws MongoSerializationException {\n<line_number-50>        if (doc == null) {\n<line_number-51>            throw new MongoSerializationException(\"Cannot serialize a null BsonDocument.\");\n<line_number-52>        }\n<line_number-53>        try (BasicOutputBuffer buffer = new BasicOutputBuffer();\n<line_number-54>                BsonBinaryWriter writer = new BsonBinaryWriter(buffer)) {\n<line_number-55>            BsonDocumentCodec codec = new BsonDocumentCodec();\n<line_number-56>            codec.encode(writer, doc, EncoderContext.builder().build());\n<line_number-57>            writer.flush();\n<line_number-58>            return buffer.toByteArray();\n<line_number-59>        } catch (RuntimeException e) {\n<line_number-60>            throw new MongoSerializationException(\"Failed to serialize BSON.\", e);\n<line_number-61>        }\n<line_number-62>    }\n<line_number-63>\n<line_number-64>    /**\n<line_number-65>     * Deserializes a BSON byte array into a BsonDocument.\n<line_number-66>     *\n<line_number-67>     * @param bytes The BSON byte array.\n<line_number-68>     * @return The deserialized BsonDocument.\n<line_number-69>     * @throws MongoSerializationException If deserialization fails.\n<line_number-70>     */\n<line_number-71>    public static BsonDocument deserialize(byte[] bytes) throws MongoSerializationException {\n<line_number-72>        try (BsonBinaryReader reader = new BsonBinaryReader(ByteBuffer.wrap(bytes))) {\n<line_number-73>            BsonDocumentCodec codec = new BsonDocumentCodec();\n<line_number-74>            return codec.decode(reader, DecoderContext.builder().build());\n<line_number-75>        } catch (RuntimeException e) {\n<line_number-76>            throw new MongoSerializationException(\"Failed to deserialize BSON.\", e);\n<line_number-77>        }\n<line_number-78>    }\n<line_number-79>\n<line_number-80>    public static <T> String toString(Codec<T> codec, T val, JsonWriterSettings settings) {\n<line_number-81>        try (StringWriter writer = new StringWriter();\n<line_number-82>                JsonWriter jsonWriter = new NoCheckStateJsonWriter(writer, settings)) {\n<line_number-83>            codec.encode(jsonWriter, val, EncoderContext.builder().build());\n<line_number-84>            writer.flush();\n<line_number-85>\n<line_number-86>            return writer.toString();\n<line_number-87>        } catch (IOException e) {\n<line_number-88>            throw new RuntimeException(e);\n<line_number-89>        }\n<line_number-90>    }\n<line_number-91>\n<line_number-92>    public static <T> String toString(Codec<T> codec, T val) {\n<line_number-93>        return toString(codec, val, JSON_WRITER_SETTINGS);\n<line_number-94>    }\n<line_number-95>\n<line_number-96>    public static <T> BsonDocument toBsonDocument(Codec<T> codec, T val) {\n<line_number-97>        BsonDocument doc = new BsonDocument();\n<line_number-98>        try (BsonDocumentWriter writer = new BsonDocumentWriter(doc); ) {\n<line_number-99>            codec.encode(writer, val, EncoderContext.builder().build());\n<line_number-100>            writer.flush();\n<line_number-101>        }\n<line_number-102>        return doc;\n<line_number-103>    }\n<line_number-104>}\n",
        "comments": [
          {
            "comment_code_range": "34-35",
            "comment_linenumber": "33",
            "comment": "Utility class for BSON serialization and deserialization.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "42-62",
            "comment_linenumber": "41",
            "comment": "Serializes a BsonDocument into a BSON byte array, throwing an exception if serialization fails.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "64-78",
            "comment_linenumber": "63",
            "comment": "Deserializes a BSON byte array into a BsonDocument, throwing an exception if deserialization fails.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "80-90",
            "comment_linenumber": "79",
            "comment": "Converts an object to its string representation using the provided codec and JSON writer settings.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "92-93",
            "comment_linenumber": "91",
            "comment": "Converts an object to its string representation using the default JSON writer settings.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "96-102",
            "comment_linenumber": "95",
            "comment": "Converts an object to a BsonDocument using the provided codec.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'BsonUtils.java' serves as a utility class for BSON serialization and deserialization, primarily used in MongoDB-related applications. It employs a functional programming style, providing static methods for various operations related to BSON documents. The class does not extend any other class and does not implement any interfaces. It contains several static final fields for JSON writer settings, which dictate how BSON documents are serialized into JSON format. The main methods include 'serialize', which converts a BsonDocument into a byte array, and 'deserialize', which converts a byte array back into a BsonDocument. Both methods handle exceptions related to serialization failures. Additionally, there are methods for converting objects to string representations and for creating BsonDocuments from objects using specified codecs. The class is designed to be stateless and thread-safe, as it does not maintain any instance state. It relies on external libraries for BSON handling, specifically the BSON codec library from MongoDB. The methods utilize try-with-resources statements to ensure proper resource management, particularly for I/O operations.",
        "file_summary": "The 'BsonUtils.java' file provides utility functions for serializing and deserializing BSON documents, facilitating the conversion between BSON and byte arrays, as well as between BSON and JSON string representations. It is essential for applications that interact with MongoDB, ensuring efficient data handling."
      }
    ]
  },
  "NativeLoader.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\utils\\NativeLoader.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\utils\\NativeLoader.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\utils\\NativeLoader.java",
        "chunk_id": "NativeLoader_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.utils;\n<line_number-18>\n<line_number-19>import com.mongodb.MongoException;\n<line_number-20>import com.mongodb.jdbc.MongoDriver;\n<line_number-21>import java.io.File;\n<line_number-22>import java.io.FileNotFoundException;\n<line_number-23>import java.io.IOException;\n<line_number-24>import java.io.InputStream;\n<line_number-25>import java.net.URL;\n<line_number-26>import java.nio.file.*;\n<line_number-27>import java.util.HashSet;\n<line_number-28>import java.util.Set;\n<line_number-29>import java.util.regex.Pattern;\n<line_number-30>import org.apache.commons.lang3.SystemUtils;\n<line_number-31>\n<line_number-32>/**\n<line_number-33> * A helper based on the NativeUtils library of Adam Heinrich:\n<line_number-34> *\n<line_number-35> * <p>A simple library class which helps with loading dynamic libraries stored in the JAR archive.\n<line_number-36> * These libraries usualy contain implementation of some methods in native code (using JNI - Java\n<line_number-37> * Native Interface).\n<line_number-38> *\n<line_number-39> * @see \"http://adamheinrich.com/blog/2012/how-to-load-native-jni-library-from-jar\"\n<line_number-40> * @see \"https://github.com/adamheinrich/native-utils\"\n<line_number-41> */\n<line_number-42>public class NativeLoader {\n<line_number-43>\n<line_number-44>    private static final String NATIVE_FOLDER_PATH_PREFIX = \"mongosql_native\";\n<line_number-45>\n<line_number-46>    /** Temporary directory which will contain the DLLs. */\n<line_number-47>    private static File temporaryLibDir;\n<line_number-48>\n<line_number-49>    // List of libraries loaded using the loader.\n<line_number-50>    // A library can only be loaded once.\n<line_number-51>    private static Set<String> loadedLibs = new HashSet<String>();\n<line_number-52>\n<line_number-53>    // This pattern was constructed using OpenJDK platform keys logic.\n<line_number-54>    // See https://github.com/openjdk/jtreg/blob/master/make/Platform.gmk#L103\n<line_number-55>    private static final Pattern X86_64_ARCH_PATTERN =\n<line_number-56>            Pattern.compile(\"^(x86_64|amd64|ia32e|em64t|x64|x86-64|8664|intel64)$\");\n<line_number-57>    private static final Pattern ARM_ARCH_PATTERN = Pattern.compile(\"^(aarch64|arm64)$\");\n<line_number-58>\n<line_number-59>    private static final String ARM = \"arm\";\n<line_number-60>    private static final String X86_64 = \"x86_64\";\n<line_number-61>\n<line_number-62>    private static final String MACOS = \"macos\";\n<line_number-63>    private static final String LINUX = \"linux\";\n<line_number-64>    private static final String WINDOWS = \"win\";\n<line_number-65>\n<line_number-66>    /** Private constructor - this class will never be instanced. */\n<line_number-67>    private NativeLoader() {}\n<line_number-68>\n<line_number-69>    private static String normalizeOS() throws MongoException {\n<line_number-70>        if (SystemUtils.IS_OS_LINUX) {\n<line_number-71>            return LINUX;\n<line_number-72>        } else if (SystemUtils.IS_OS_WINDOWS) {\n<line_number-73>            return WINDOWS;\n<line_number-74>        } else if (SystemUtils.IS_OS_MAC) {\n<line_number-75>            return MACOS;\n<line_number-76>        }\n<line_number-77>\n<line_number-78>        // Unsupported OS\n<line_number-79>        throw new MongoException(\"Unsupported OS : \" + SystemUtils.OS_NAME);\n<line_number-80>    }\n<line_number-81>\n<line_number-82>    private static String normalizeArch() throws MongoException {\n<line_number-83>        String arch = SystemUtils.OS_ARCH.toLowerCase();\n<line_number-84>        if (X86_64_ARCH_PATTERN.matcher(arch).matches()) {\n<line_number-85>            return X86_64;\n<line_number-86>        } else if (ARM_ARCH_PATTERN.matcher(arch).matches()) {\n<line_number-87>            return ARM;\n<line_number-88>        }\n<line_number-89>\n<line_number-90>        // Unsupported architecture\n<line_number-91>        throw new MongoException(\"Unsupported architecture : \" + arch);\n<line_number-92>    }\n<line_number-93>\n<line_number-94>    /**\n<line_number-95>     * Loads library from current JAR archive.\n<line_number-96>     *\n<line_number-97>     * <p>The file from JAR is copied into system temporary directory and then loaded. The temporary\n<line_number-98>     * file is deleted after exiting. Method uses String as filename because the pathname is\n<line_number-99>     * \"abstract\", not system-dependent.\n<line_number-100>     *\n<line_number-101>     * @param libraryName The name of the library to load.\n<line_number-102>     * @return the path of the loaded library.\n<line_number-103>     * @throws IOException If temporary file creation or read/write operation fails\n<line_number-104>     * @throws IllegalArgumentException If source file (param libPath) does not exist\n<line_number-105>     * @throws IllegalArgumentException If the libPath is not absolute or if the filename is shorter\n<line_number-106>     *     than three characters (restriction of {@link File#createTempFile(java.lang.String,\n<line_number-107>     *     java.lang.String)}).\n<line_number-108>     * @throws FileNotFoundException If the file could not be found inside the JAR.\n<line_number-109>     */\n<line_number-110>    public static String loadLibraryFromJar(String libraryName)\n<line_number-111>            throws IOException, IllegalArgumentException, FileNotFoundException {\n<line_number-112>\n<line_number-113>        String libName = System.mapLibraryName(libraryName);\n<line_number-114>        if (loadedLibs.contains(libName)) {\n<line_number-115>            // Don't reload.\n<line_number-116>            return libName;\n<line_number-117>        }\n<line_number-118>\n<line_number-119>        // Build the library path using the os and arch information.\n<line_number-120>        String resourcePath =\n<line_number-121>                normalizeArch().toLowerCase() + \"/\" + normalizeOS().toLowerCase() + \"/\" + libName;\n<line_number-122>\n<line_number-123>        URL resource =\n<line_number-124>                MongoDriver.class.getProtectionDomain().getClassLoader().getResource(resourcePath);\n<line_number-125>\n<line_number-126>        if (resource != null) {\n<line_number-127>\n<line_number-128>            // Create a temporary directory to copy the library into.\n<line_number-129>            if (temporaryLibDir == null) {\n<line_number-130>                temporaryLibDir = createTempDirectory();\n<line_number-131>                temporaryLibDir.deleteOnExit();\n<line_number-132>            }\n<line_number-133>\n<line_number-134>            // Copy the library in the temporary directory.\n<line_number-135>            File libFile;\n<line_number-136>            libFile = new File(temporaryLibDir, libName);\n<line_number-137>\n<line_number-138>            try (InputStream is = resource.openStream()) {\n<line_number-139>                Files.copy(is, libFile.toPath());\n<line_number-140>            } catch (FileAlreadyExistsException e) {\n<line_number-141>                // Do nothing, the library is already there which means that the JVM already loaded it.\n<line_number-142>            } catch (IOException e) {\n<line_number-143>                libFile.delete();\n<line_number-144>                // Unexpected error.\n<line_number-145>                throw e;\n<line_number-146>            } catch (NullPointerException e) {\n<line_number-147>                libFile.delete();\n<line_number-148>                throw new FileNotFoundException(\n<line_number-149>                        \"Resource \" + resourcePath + \" was not found inside JAR.\");\n<line_number-150>            }\n<line_number-151>\n<line_number-152>            try {\n<line_number-153>                System.load(libFile.getAbsolutePath());\n<line_number-154>            } finally {\n<line_number-155>                if (isPosixCompliant()) {\n<line_number-156>                    // Assume POSIX compliant file system, can be deleted after loading\n<line_number-157>                    libFile.delete();\n<line_number-158>                } else {\n<line_number-159>                    // Assume non-POSIX, and don't delete until last file descriptor closed\n<line_number-160>                    libFile.deleteOnExit();\n<line_number-161>                }\n<line_number-162>            }\n<line_number-163>\n<line_number-164>            return libFile.getAbsolutePath();\n<line_number-165>        }\n<line_number-166>        throw new FileNotFoundException(\"Resource \" + resourcePath + \" was not found inside JAR.\");\n<line_number-167>    }\n<line_number-168>\n<line_number-169>    private static boolean isPosixCompliant() {\n<line_number-170>        try {\n<line_number-171>            return FileSystems.getDefault().supportedFileAttributeViews().contains(\"posix\");\n<line_number-172>        } catch (FileSystemNotFoundException | ProviderNotFoundException | SecurityException e) {\n<line_number-173>            e.printStackTrace();\n<line_number-174>            return false;\n<line_number-175>        }\n<line_number-176>    }\n<line_number-177>\n<line_number-178>    /**\n<line_number-179>     * Creates a temporary directory under the file system path of a temporary directory for use by\n<line_number-180>     * the java runtime. The path will look like {java.io.tmpdir}/{prefix}{nanoTime}\n<line_number-181>     *\n<line_number-182>     * @return The path to the created directory.\n<line_number-183>     * @throws IOException If an error occurs.\n<line_number-184>     */\n<line_number-185>    private static File createTempDirectory() throws IOException {\n<line_number-186>        String tempDir = System.getProperty(\"java.io.tmpdir\");\n<line_number-187>        File generatedDir = new File(tempDir, NATIVE_FOLDER_PATH_PREFIX + System.nanoTime());\n<line_number-188>\n<line_number-189>        if (!generatedDir.mkdir() && !Files.exists(generatedDir.toPath())) {\n<line_number-190>            throw new IOException(\"Failed to create temp directory \" + generatedDir.getName());\n<line_number-191>        }\n<line_number-192>        return generatedDir;\n<line_number-193>    }\n<line_number-194>}\n",
        "comments": [
          {
            "comment_code_range": "32-41",
            "comment_linenumber": "31",
            "comment": "Describes the NativeLoader class, which assists in loading dynamic libraries from JAR archives using JNI.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "66-67",
            "comment_linenumber": "65",
            "comment": "Private constructor to prevent instantiation of the NativeLoader class.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "69-80",
            "comment_linenumber": "68",
            "comment": "Normalizes the operating system name for library loading, throwing an exception for unsupported OS.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "82-91",
            "comment_linenumber": "81",
            "comment": "Normalizes the architecture type for library loading, throwing an exception for unsupported architectures.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "94-108",
            "comment_linenumber": "93",
            "comment": "Loads a library from the current JAR archive, handling temporary file creation and loading via JNI.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "169-175",
            "comment_linenumber": "168",
            "comment": "Checks if the file system is POSIX compliant, which affects how libraries are managed post-loading.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "178-184",
            "comment_linenumber": "177",
            "comment": "Creates a temporary directory for storing native libraries, ensuring it is unique and valid.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'NativeLoader.java' is part of the 'com.mongodb.jdbc.utils' package and serves as a utility class for loading native libraries from JAR files using Java Native Interface (JNI). It employs a singleton-like pattern with a private constructor to prevent instantiation. The class contains static methods and fields to manage the loading process, including handling different operating systems and architectures. Key members include a set to track loaded libraries, patterns for architecture matching, and methods for normalizing OS and architecture names. The primary method, 'loadLibraryFromJar', orchestrates the loading of the specified library, ensuring it is copied to a temporary directory before being loaded into the JVM. The class also includes error handling for unsupported OS and architecture types, as well as for file operations. The 'createTempDirectory' method ensures that a unique temporary directory is created for library storage, while 'isPosixCompliant' checks the file system's compliance with POSIX standards, affecting library management post-loading.",
        "file_summary": "The 'NativeLoader.java' file provides functionality for loading native libraries from JAR archives in a platform-independent manner, utilizing JNI. It manages library loading, temporary file creation, and ensures compatibility with various operating systems and architectures."
      }
    ]
  },
  "X509Authentication.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\utils\\X509Authentication.java",
    "chunks": [
      {
        "file_path": "src\\main\\java\\com\\mongodb\\jdbc\\utils\\X509Authentication.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\main\\java\\com\\mongodb\\jdbc\\utils\\X509Authentication.java",
        "chunk_id": "X509Authentication_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.utils;\n<line_number-18>\n<line_number-19>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-20>import java.io.FileReader;\n<line_number-21>import java.security.*;\n<line_number-22>import java.security.cert.Certificate;\n<line_number-23>import java.util.logging.Level;\n<line_number-24>import javax.net.ssl.KeyManagerFactory;\n<line_number-25>import javax.net.ssl.SSLContext;\n<line_number-26>import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;\n<line_number-27>import org.bouncycastle.cert.X509CertificateHolder;\n<line_number-28>import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;\n<line_number-29>import org.bouncycastle.jce.provider.BouncyCastleProvider;\n<line_number-30>import org.bouncycastle.openssl.PEMParser;\n<line_number-31>import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n<line_number-32>import org.bouncycastle.pkcs.PKCS8EncryptedPrivateKeyInfo;\n<line_number-33>import org.bouncycastle.pkcs.jcajce.JcePKCSPBEInputDecryptorProviderBuilder;\n<line_number-34>\n<line_number-35>public class X509Authentication {\n<line_number-36>    private static final BouncyCastleProvider BC_PROVIDER = new BouncyCastleProvider();\n<line_number-37>    private final MongoLogger logger;\n<line_number-38>\n<line_number-39>    public X509Authentication(MongoLogger logger) {\n<line_number-40>        this.logger = logger;\n<line_number-41>    }\n<line_number-42>\n<line_number-43>    public void configureX509Authentication(\n<line_number-44>            com.mongodb.MongoClientSettings.Builder settingsBuilder,\n<line_number-45>            String pemPath,\n<line_number-46>            char[] passphrase) {\n<line_number-47>\n<line_number-48>        logger.log(Level.FINE, \"Using client certificate for X509 authentication: \" + pemPath);\n<line_number-49>        if (passphrase != null && passphrase.length > 0) {\n<line_number-50>            logger.log(Level.FINE, \"Client certificate passphrase has been specified\");\n<line_number-51>        }\n<line_number-52>        try {\n<line_number-53>            SSLContext sslContext = createSSLContext(pemPath, passphrase);\n<line_number-54>\n<line_number-55>            settingsBuilder.applyToSslSettings(\n<line_number-56>                    sslSettings -> {\n<line_number-57>                        sslSettings.enabled(true);\n<line_number-58>                        sslSettings.context(sslContext);\n<line_number-59>                    });\n<line_number-60>        } catch (Exception e) {\n<line_number-61>            throw new RuntimeException(\"SSL setup failed\", e);\n<line_number-62>        }\n<line_number-63>    }\n<line_number-64>\n<line_number-65>    private SSLContext createSSLContext(String pemPath, char[] passphrase) throws Exception {\n<line_number-66>        PrivateKey privateKey = null;\n<line_number-67>        Certificate cert = null;\n<line_number-68>\n<line_number-69>        try (PEMParser pemParser = new PEMParser(new FileReader(pemPath))) {\n<line_number-70>            Object pemObj;\n<line_number-71>\n<line_number-72>            // Iterate through PEM objects found in the PEM file and process them based on type:\n<line_number-73>            //  - Encrypted/unencrypted private keys\n<line_number-74>            //  - X.509 certificates\n<line_number-75>            while ((pemObj = pemParser.readObject()) != null) {\n<line_number-76>                try {\n<line_number-77>                    if (passphrase != null\n<line_number-78>                            && passphrase.length > 0\n<line_number-79>                            && pemObj instanceof PKCS8EncryptedPrivateKeyInfo) {\n<line_number-80>                        privateKey =\n<line_number-81>                                new JcaPEMKeyConverter()\n<line_number-82>                                        .setProvider(BC_PROVIDER)\n<line_number-83>                                        .getPrivateKey(\n<line_number-84>                                                ((PKCS8EncryptedPrivateKeyInfo) pemObj)\n<line_number-85>                                                        .decryptPrivateKeyInfo(\n<line_number-86>                                                                new JcePKCSPBEInputDecryptorProviderBuilder()\n<line_number-87>                                                                        .setProvider(BC_PROVIDER)\n<line_number-88>                                                                        .build(passphrase)));\n<line_number-89>                    } else if (pemObj instanceof PrivateKeyInfo) {\n<line_number-90>                        privateKey =\n<line_number-91>                                new JcaPEMKeyConverter()\n<line_number-92>                                        .setProvider(BC_PROVIDER)\n<line_number-93>                                        .getPrivateKey((PrivateKeyInfo) pemObj);\n<line_number-94>                    }\n<line_number-95>                } catch (Exception e) {\n<line_number-96>                    throw new GeneralSecurityException(\n<line_number-97>                            \"Failed to process private key from PEM file\", e);\n<line_number-98>                }\n<line_number-99>\n<line_number-100>                if (pemObj instanceof X509CertificateHolder) {\n<line_number-101>                    cert =\n<line_number-102>                            new JcaX509CertificateConverter()\n<line_number-103>                                    .setProvider(BC_PROVIDER)\n<line_number-104>                                    .getCertificate((X509CertificateHolder) pemObj);\n<line_number-105>                }\n<line_number-106>            }\n<line_number-107>        }\n<line_number-108>\n<line_number-109>        if (privateKey == null) {\n<line_number-110>            throw new IllegalStateException(\n<line_number-111>                    \"Failed to read private key from PEM file (encrypted or unencrypted)\");\n<line_number-112>        }\n<line_number-113>        if (cert == null) {\n<line_number-114>            throw new IllegalStateException(\"Failed to read certificate from PEM file\");\n<line_number-115>        }\n<line_number-116>\n<line_number-117>        return createSSLContextFromKeyAndCert(privateKey, cert);\n<line_number-118>    }\n<line_number-119>\n<line_number-120>    private SSLContext createSSLContextFromKeyAndCert(PrivateKey privateKey, Certificate cert)\n<line_number-121>            throws Exception {\n<line_number-122>        KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n<line_number-123>        keyStore.load(null, null);\n<line_number-124>        keyStore.setKeyEntry(\"mongodb-cert\", privateKey, null, new Certificate[] {cert});\n<line_number-125>\n<line_number-126>        KeyManagerFactory kmf =\n<line_number-127>                KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n<line_number-128>\n<line_number-129>        // Passphrase not needed for in memory keystore\n<line_number-130>        kmf.init(keyStore, null);\n<line_number-131>\n<line_number-132>        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n<line_number-133>        // Initialize sslContext and use default trust managers\n<line_number-134>        sslContext.init(kmf.getKeyManagers(), null, new SecureRandom());\n<line_number-135>\n<line_number-136>        return sslContext;\n<line_number-137>    }\n<line_number-138>}\n",
        "comments": [
          {
            "comment_code_range": "35-41",
            "comment_linenumber": "34",
            "comment": "This class handles X.509 authentication for MongoDB connections, utilizing client certificates for secure communication.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "39-41",
            "comment_linenumber": "38",
            "comment": "Constructor that initializes the logger for logging authentication events.",
            "comment_kind": "constructor"
          },
          {
            "comment_code_range": "43-62",
            "comment_linenumber": "42",
            "comment": "Configures X.509 authentication by setting up SSL context using the provided PEM file and optional passphrase.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "65-117",
            "comment_linenumber": "64",
            "comment": "Creates an SSL context from the specified PEM file, extracting the private key and certificate.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "120-136",
            "comment_linenumber": "119",
            "comment": "Creates an SSL context from the provided private key and certificate, initializing the key manager factory.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "72-106",
            "comment_linenumber": "71",
            "comment": "Processes PEM objects to extract private keys and certificates, handling both encrypted and unencrypted formats.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "129-134",
            "comment_linenumber": "128",
            "comment": "Initializes the SSL context with default trust managers after setting up the key manager factory.",
            "comment_kind": "block"
          }
        ],
        "structural_analysis": "The file 'X509Authentication.java' is part of the 'com.mongodb.jdbc.utils' package and is responsible for managing X.509 authentication for MongoDB connections. It employs the Bouncy Castle library for cryptographic operations and SSL context creation. The primary class, 'X509Authentication', contains methods to configure authentication settings, create SSL contexts from PEM files, and handle private keys and certificates. The class is designed to be instantiated with a logger for logging purposes. It includes methods for configuring SSL settings in MongoDB client settings, creating SSL contexts from PEM files, and initializing key managers. The class uses several external libraries, including Bouncy Castle for cryptographic operations and Java's built-in security classes for SSL context management. Notably, the class ensures that both private keys and certificates are correctly extracted and validated from the provided PEM file, throwing exceptions if any required components are missing. The design follows a straightforward approach to SSL configuration, ensuring secure communication with MongoDB servers.",
        "file_summary": "The 'X509Authentication.java' file provides functionality for configuring X.509 authentication in MongoDB JDBC connections, enabling secure communication through client certificates. It handles the extraction of private keys and certificates from PEM files and sets up the necessary SSL context for secure connections."
      }
    ]
  },
  "BsonTypeInfoTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\BsonTypeInfoTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\BsonTypeInfoTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\BsonTypeInfoTest.java",
        "chunk_id": "BsonTypeInfoTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.BsonTypeInfo.BSON_ARRAY;\n<line_number-20>import static com.mongodb.jdbc.BsonTypeInfo.BSON_BINDATA;\n<line_number-21>import static com.mongodb.jdbc.BsonTypeInfo.BSON_BOOL;\n<line_number-22>import static com.mongodb.jdbc.BsonTypeInfo.BSON_DATE;\n<line_number-23>import static com.mongodb.jdbc.BsonTypeInfo.BSON_DBPOINTER;\n<line_number-24>import static com.mongodb.jdbc.BsonTypeInfo.BSON_DECIMAL;\n<line_number-25>import static com.mongodb.jdbc.BsonTypeInfo.BSON_DOUBLE;\n<line_number-26>import static com.mongodb.jdbc.BsonTypeInfo.BSON_INT;\n<line_number-27>import static com.mongodb.jdbc.BsonTypeInfo.BSON_JAVASCRIPT;\n<line_number-28>import static com.mongodb.jdbc.BsonTypeInfo.BSON_JAVASCRIPTWITHSCOPE;\n<line_number-29>import static com.mongodb.jdbc.BsonTypeInfo.BSON_LONG;\n<line_number-30>import static com.mongodb.jdbc.BsonTypeInfo.BSON_MAXKEY;\n<line_number-31>import static com.mongodb.jdbc.BsonTypeInfo.BSON_MINKEY;\n<line_number-32>import static com.mongodb.jdbc.BsonTypeInfo.BSON_NULL;\n<line_number-33>import static com.mongodb.jdbc.BsonTypeInfo.BSON_OBJECT;\n<line_number-34>import static com.mongodb.jdbc.BsonTypeInfo.BSON_OBJECTID;\n<line_number-35>import static com.mongodb.jdbc.BsonTypeInfo.BSON_REGEX;\n<line_number-36>import static com.mongodb.jdbc.BsonTypeInfo.BSON_STRING;\n<line_number-37>import static com.mongodb.jdbc.BsonTypeInfo.BSON_SYMBOL;\n<line_number-38>import static com.mongodb.jdbc.BsonTypeInfo.BSON_TIMESTAMP;\n<line_number-39>import static com.mongodb.jdbc.BsonTypeInfo.BSON_UNDEFINED;\n<line_number-40>import static com.mongodb.jdbc.BsonTypeInfo.getBsonTypeInfoByName;\n<line_number-41>import static com.mongodb.jdbc.BsonTypeInfo.getBsonTypeInfoFromBsonValue;\n<line_number-42>import static org.junit.jupiter.api.Assertions.assertEquals;\n<line_number-43>import static org.junit.jupiter.api.Assertions.assertThrows;\n<line_number-44>\n<line_number-45>import java.nio.charset.StandardCharsets;\n<line_number-46>import java.sql.SQLException;\n<line_number-47>import org.bson.BsonArray;\n<line_number-48>import org.bson.BsonBinary;\n<line_number-49>import org.bson.BsonBoolean;\n<line_number-50>import org.bson.BsonDateTime;\n<line_number-51>import org.bson.BsonDbPointer;\n<line_number-52>import org.bson.BsonDecimal128;\n<line_number-53>import org.bson.BsonDocument;\n<line_number-54>import org.bson.BsonDouble;\n<line_number-55>import org.bson.BsonInt32;\n<line_number-56>import org.bson.BsonInt64;\n<line_number-57>import org.bson.BsonJavaScript;\n<line_number-58>import org.bson.BsonJavaScriptWithScope;\n<line_number-59>import org.bson.BsonMaxKey;\n<line_number-60>import org.bson.BsonMinKey;\n<line_number-61>import org.bson.BsonNull;\n<line_number-62>import org.bson.BsonObjectId;\n<line_number-63>import org.bson.BsonRegularExpression;\n<line_number-64>import org.bson.BsonString;\n<line_number-65>import org.bson.BsonSymbol;\n<line_number-66>import org.bson.BsonTimestamp;\n<line_number-67>import org.bson.BsonUndefined;\n<line_number-68>import org.bson.types.Decimal128;\n<line_number-69>import org.bson.types.ObjectId;\n<line_number-70>import org.junit.jupiter.api.Test;\n<line_number-71>\n<line_number-72>public class BsonTypeInfoTest {\n<line_number-73>    @Test\n<line_number-74>    void testGetBsonTypeInfoByName() throws SQLException {\n<line_number-75>        assertEquals(BSON_ARRAY, getBsonTypeInfoByName(\"array\"));\n<line_number-76>        assertEquals(BSON_BOOL, getBsonTypeInfoByName(\"bool\"));\n<line_number-77>        assertEquals(BSON_BINDATA, getBsonTypeInfoByName(\"binData\"));\n<line_number-78>        assertEquals(BSON_DATE, getBsonTypeInfoByName(\"date\"));\n<line_number-79>        assertEquals(BSON_DBPOINTER, getBsonTypeInfoByName(\"dbPointer\"));\n<line_number-80>        assertEquals(BSON_DECIMAL, getBsonTypeInfoByName(\"decimal\"));\n<line_number-81>        assertEquals(BSON_DOUBLE, getBsonTypeInfoByName(\"double\"));\n<line_number-82>        assertEquals(BSON_INT, getBsonTypeInfoByName(\"int\"));\n<line_number-83>        assertEquals(BSON_JAVASCRIPT, getBsonTypeInfoByName(\"javascript\"));\n<line_number-84>        assertEquals(BSON_JAVASCRIPTWITHSCOPE, getBsonTypeInfoByName(\"javascriptWithScope\"));\n<line_number-85>        assertEquals(BSON_LONG, getBsonTypeInfoByName(\"long\"));\n<line_number-86>        assertEquals(BSON_MAXKEY, getBsonTypeInfoByName(\"maxKey\"));\n<line_number-87>        assertEquals(BSON_MINKEY, getBsonTypeInfoByName(\"minKey\"));\n<line_number-88>        assertEquals(BSON_NULL, getBsonTypeInfoByName(\"null\"));\n<line_number-89>        assertEquals(BSON_OBJECT, getBsonTypeInfoByName(\"object\"));\n<line_number-90>        assertEquals(BSON_OBJECTID, getBsonTypeInfoByName(\"objectId\"));\n<line_number-91>        assertEquals(BSON_REGEX, getBsonTypeInfoByName(\"regex\"));\n<line_number-92>        assertEquals(BSON_STRING, getBsonTypeInfoByName(\"string\"));\n<line_number-93>        assertEquals(BSON_SYMBOL, getBsonTypeInfoByName(\"symbol\"));\n<line_number-94>        assertEquals(BSON_TIMESTAMP, getBsonTypeInfoByName(\"timestamp\"));\n<line_number-95>        assertEquals(BSON_UNDEFINED, getBsonTypeInfoByName(\"undefined\"));\n<line_number-96>\n<line_number-97>        // Test invalid type name\n<line_number-98>        assertThrows(\n<line_number-99>                SQLException.class,\n<line_number-100>                () -> getBsonTypeInfoByName(\"invalid\"),\n<line_number-101>                \"invalid BSON type name expected to throw exception\");\n<line_number-102>    }\n<line_number-103>\n<line_number-104>    @Test\n<line_number-105>    void testGetBsonTypeInfoFromBsonValue() throws SQLException {\n<line_number-106>        assertEquals(BSON_ARRAY, getBsonTypeInfoFromBsonValue(new BsonArray()));\n<line_number-107>        assertEquals(BSON_BOOL, getBsonTypeInfoFromBsonValue(new BsonBoolean(true)));\n<line_number-108>        assertEquals(\n<line_number-109>                BSON_BINDATA,\n<line_number-110>                getBsonTypeInfoFromBsonValue(new BsonBinary(\"a\".getBytes(StandardCharsets.UTF_8))));\n<line_number-111>        assertEquals(BSON_DATE, getBsonTypeInfoFromBsonValue(new BsonDateTime(1)));\n<line_number-112>        assertEquals(\n<line_number-113>                BSON_DBPOINTER,\n<line_number-114>                getBsonTypeInfoFromBsonValue(new BsonDbPointer(\"test\", new ObjectId())));\n<line_number-115>        assertEquals(\n<line_number-116>                BSON_DECIMAL, getBsonTypeInfoFromBsonValue(new BsonDecimal128(new Decimal128(1))));\n<line_number-117>        assertEquals(BSON_DOUBLE, getBsonTypeInfoFromBsonValue(new BsonDouble(2.2)));\n<line_number-118>        assertEquals(BSON_INT, getBsonTypeInfoFromBsonValue(new BsonInt32(1)));\n<line_number-119>        assertEquals(BSON_JAVASCRIPT, getBsonTypeInfoFromBsonValue(new BsonJavaScript(\"\")));\n<line_number-120>        assertEquals(\n<line_number-121>                BSON_JAVASCRIPTWITHSCOPE,\n<line_number-122>                getBsonTypeInfoFromBsonValue(new BsonJavaScriptWithScope(\"\", new BsonDocument())));\n<line_number-123>        assertEquals(BSON_LONG, getBsonTypeInfoFromBsonValue(new BsonInt64(1)));\n<line_number-124>        assertEquals(BSON_MAXKEY, getBsonTypeInfoFromBsonValue(new BsonMaxKey()));\n<line_number-125>        assertEquals(BSON_MINKEY, getBsonTypeInfoFromBsonValue(new BsonMinKey()));\n<line_number-126>        assertEquals(BSON_NULL, getBsonTypeInfoFromBsonValue(new BsonNull()));\n<line_number-127>        assertEquals(BSON_OBJECTID, getBsonTypeInfoFromBsonValue(new BsonObjectId()));\n<line_number-128>        assertEquals(BSON_REGEX, getBsonTypeInfoFromBsonValue(new BsonRegularExpression(\"\")));\n<line_number-129>        assertEquals(BSON_STRING, getBsonTypeInfoFromBsonValue(new BsonString(\"\")));\n<line_number-130>        assertEquals(BSON_SYMBOL, getBsonTypeInfoFromBsonValue(new BsonSymbol(\"\")));\n<line_number-131>        assertEquals(BSON_TIMESTAMP, getBsonTypeInfoFromBsonValue(new BsonTimestamp()));\n<line_number-132>        assertEquals(BSON_UNDEFINED, getBsonTypeInfoFromBsonValue(new BsonUndefined()));\n<line_number-133>        assertEquals(BSON_OBJECT, getBsonTypeInfoFromBsonValue(new BsonDocument()));\n<line_number-134>    }\n<line_number-135>}\n",
        "comments": [
          {
            "comment_code_range": "72-135",
            "comment_linenumber": "71",
            "comment": "Test class for validating BSON type information retrieval methods.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "74-102",
            "comment_linenumber": "73",
            "comment": "Tests the retrieval of BSON type information by name, ensuring valid names return expected types and invalid names throw exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "105-134",
            "comment_linenumber": "104",
            "comment": "Tests the retrieval of BSON type information from BSON values, validating that each BSON type returns the correct type information.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'BsonTypeInfoTest.java' is a JUnit test class designed to validate the functionality of BSON type information retrieval methods from the 'BsonTypeInfo' class. It follows the standard structure of a JUnit test class, containing test methods annotated with '@Test'. The class does not extend any other class and does not implement any interfaces. It imports various BSON types from the 'org.bson' package and static methods from 'com.mongodb.jdbc.BsonTypeInfo'.\n\nThe class contains two primary test methods:\n1. **testGetBsonTypeInfoByName**: This method tests the 'getBsonTypeInfoByName' function, asserting that valid BSON type names return the correct type information and that an invalid name throws an SQLException.\n2. **testGetBsonTypeInfoFromBsonValue**: This method tests the 'getBsonTypeInfoFromBsonValue' function, asserting that various BSON value instances return the expected BSON type information.\n\nBoth methods utilize assertions from the JUnit framework to validate expected outcomes against actual results. The tests cover a comprehensive range of BSON types, ensuring robust validation of the BSON type information retrieval functionality.",
        "file_summary": "The 'BsonTypeInfoTest.java' file serves as a unit test suite for the BSON type information retrieval methods in the 'BsonTypeInfo' class. It ensures that the methods correctly map BSON type names and BSON values to their respective type information, validating both expected behavior and error handling."
      }
    ]
  },
  "BsonUtilsTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\BsonUtilsTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\BsonUtilsTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\BsonUtilsTest.java",
        "chunk_id": "BsonUtilsTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static org.junit.jupiter.api.Assertions.*;\n<line_number-20>\n<line_number-21>import com.mongodb.jdbc.utils.BsonUtils;\n<line_number-22>import org.bson.BsonDocument;\n<line_number-23>import org.bson.BsonInt32;\n<line_number-24>import org.bson.BsonString;\n<line_number-25>import org.junit.jupiter.api.Test;\n<line_number-26>\n<line_number-27>class BsonUtilsTest {\n<line_number-28>\n<line_number-29>    @Test\n<line_number-30>    void testSerializeDeserialize() throws MongoSerializationException {\n<line_number-31>        BsonDocument originalDoc =\n<line_number-32>                new BsonDocument(\"name\", new BsonString(\"Test\"))\n<line_number-33>                        .append(\"value\", new BsonInt32(123))\n<line_number-34>                        .append(\"nested\", new BsonDocument(\"key\", new BsonString(\"value\")));\n<line_number-35>\n<line_number-36>        byte[] serialized = BsonUtils.serialize(originalDoc);\n<line_number-37>        assertNotNull(serialized, \"Serialized byte array should not be null\");\n<line_number-38>        assertTrue(serialized.length > 0, \"Serialized byte array should have content\");\n<line_number-39>\n<line_number-40>        BsonDocument deserializedDoc = BsonUtils.deserialize(serialized);\n<line_number-41>        assertNotNull(deserializedDoc, \"Deserialized document should not be null\");\n<line_number-42>        assertEquals(\n<line_number-43>                originalDoc,\n<line_number-44>                deserializedDoc,\n<line_number-45>                \"Original and deserialized documents should be equal\");\n<line_number-46>    }\n<line_number-47>\n<line_number-48>    @Test\n<line_number-49>    void testSerializeNullDocument() {\n<line_number-50>        assertThrows(\n<line_number-51>                MongoSerializationException.class,\n<line_number-52>                () -> BsonUtils.serialize(null),\n<line_number-53>                \"Serializing a null document should throw MongoSerializationException\");\n<line_number-54>    }\n<line_number-55>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC utilities, specifically for BSON operations.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "27-55",
            "comment_linenumber": "26",
            "comment": "Test class for BsonUtils, containing unit tests for serialization and deserialization of BSON documents.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "29-46",
            "comment_linenumber": "28",
            "comment": "Tests the serialization and deserialization process of a BSON document, ensuring integrity of data.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "48-53",
            "comment_linenumber": "47",
            "comment": "Tests that serializing a null BSON document throws a MongoSerializationException as expected.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file is named BsonUtilsTest.java and serves as a unit test suite for the BsonUtils class, which is responsible for BSON serialization and deserialization. It follows the JUnit testing framework. The primary role of this file is to validate the functionality of BSON operations, ensuring that data integrity is maintained during serialization and deserialization processes. \n\nTop-level types include:\n- Class: BsonUtilsTest\n  - Role: Contains unit tests for the BsonUtils class, specifically testing serialization and deserialization of BSON documents.\n  - Lifecycle notes: This class is not instantiated; it is used solely for testing purposes.\n\nMembers:\n- Method: testSerializeDeserialize\n  - Signature: void testSerializeDeserialize() throws MongoSerializationException\n  - Behaviour: Tests the serialization of a BSON document and verifies that the deserialized document matches the original. It checks for null values and ensures the serialized byte array is not null or empty.\n  - Internal calls: Calls BsonUtils.serialize() and BsonUtils.deserialize().\n  - External calls: Uses assertions from the JUnit framework.\n  - Key control flow: Contains assertions to validate the expected outcomes of serialization and deserialization.\n\n- Method: testSerializeNullDocument\n  - Signature: void testSerializeNullDocument()\n  - Behaviour: Ensures that attempting to serialize a null BSON document throws a MongoSerializationException.\n  - Internal calls: Calls BsonUtils.serialize().\n  - External calls: Uses assertions from the JUnit framework.\n  - Key control flow: Contains an assertion to validate that the expected exception is thrown.\n\nRelationships: The BsonUtilsTest class directly interacts with the BsonUtils class for serialization and deserialization operations. It utilizes JUnit's assertion methods to validate outcomes.\n\nExternal touchpoints: The file relies on the JUnit testing framework for structuring tests and assertions. It also interacts with BSON-related classes from the MongoDB driver.\n\nObservations & caveats: The tests assume that the BsonUtils class is correctly implemented and that BSON serialization and deserialization are functioning as intended. There are no noted performance hotspots or thread-safety concerns within this test class.",
        "file_summary": "This file contains unit tests for the BsonUtils class, focusing on the serialization and deserialization of BSON documents. It ensures that BSON operations maintain data integrity and handle edge cases, such as null documents, correctly."
      }
    ]
  },
  "MongoConnectionTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoConnectionTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\MongoConnectionTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoConnectionTest.java",
        "chunk_id": "MongoConnectionTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static org.junit.jupiter.api.Assertions.*;\n<line_number-20>import static org.mockito.Mockito.*;\n<line_number-21>\n<line_number-22>import com.mongodb.ConnectionString;\n<line_number-23>import com.mongodb.MongoClientSettings;\n<line_number-24>import com.mongodb.client.internal.MongoClientImpl;\n<line_number-25>import java.sql.Connection;\n<line_number-26>import java.sql.SQLException;\n<line_number-27>import java.sql.Savepoint;\n<line_number-28>import java.sql.Statement;\n<line_number-29>import org.junit.jupiter.api.BeforeAll;\n<line_number-30>import org.junit.jupiter.api.BeforeEach;\n<line_number-31>import org.junit.jupiter.api.Test;\n<line_number-32>import org.junit.jupiter.api.TestInstance;\n<line_number-33>import org.junit.jupiter.api.extension.ExtendWith;\n<line_number-34>import org.mockito.Mock;\n<line_number-35>import org.mockito.MockitoAnnotations;\n<line_number-36>import org.mockito.junit.jupiter.MockitoExtension;\n<line_number-37>import org.mockito.junit.jupiter.MockitoSettings;\n<line_number-38>import org.mockito.quality.Strictness;\n<line_number-39>\n<line_number-40>@ExtendWith(MockitoExtension.class)\n<line_number-41>@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n<line_number-42>@MockitoSettings(strictness = Strictness.WARN)\n<line_number-43>class MongoConnectionTest extends MongoMock {\n<line_number-44>    static final String localhost = \"mongodb://localhost\";\n<line_number-45>    @Mock private MongoConnectionProperties mockConnectionProperties;\n<line_number-46>\n<line_number-47>    @BeforeAll\n<line_number-48>    protected void initMocks() {\n<line_number-49>        MockitoAnnotations.initMocks(this);\n<line_number-50>    }\n<line_number-51>\n<line_number-52>    // Since MongoConnection cannot be created with its constructor, we have to use InjectionMocks Annotation and\n<line_number-53>    // create it during initiation. In order to reuse the same object for each test, we need to reset it before each test case.\n<line_number-54>    @BeforeEach\n<line_number-55>    void setupTest() throws NoSuchFieldException {\n<line_number-56>        resetMockObjs();\n<line_number-57>    }\n<line_number-58>\n<line_number-59>    @BeforeEach\n<line_number-60>    void setUp() {\n<line_number-61>        when(mockConnectionProperties.getConnectionString())\n<line_number-62>                .thenReturn(new ConnectionString(localhost));\n<line_number-63>        when(mockConnectionProperties.getDatabase()).thenReturn(\"test\");\n<line_number-64>    }\n<line_number-65>\n<line_number-66>    private String getApplicationName(MongoConnection connection) {\n<line_number-67>        MongoClientImpl mongoClientImpl = (MongoClientImpl) connection.getMongoClient();\n<line_number-68>        MongoClientSettings mcs = mongoClientImpl.getSettings();\n<line_number-69>        return mcs.getApplicationName();\n<line_number-70>    }\n<line_number-71>\n<line_number-72>    @Test\n<line_number-73>    void testBuildAppNameWithoutClientInfo() {\n<line_number-74>        when(mockConnectionProperties.getClientInfo()).thenReturn(null);\n<line_number-75>\n<line_number-76>        mongoConnection = new MongoConnection(null, mockConnectionProperties);\n<line_number-77>\n<line_number-78>        String expectedAppName = MongoDriver.NAME + \"+\" + MongoDriver.getVersion();\n<line_number-79>        assertEquals(expectedAppName, getApplicationName(mongoConnection));\n<line_number-80>    }\n<line_number-81>\n<line_number-82>    @Test\n<line_number-83>    void testAppNameWithValidClientInfo() {\n<line_number-84>        String clientInfo = \"test-client+1.0.0\";\n<line_number-85>        when(mockConnectionProperties.getClientInfo()).thenReturn(clientInfo);\n<line_number-86>\n<line_number-87>        mongoConnection = new MongoConnection(null, mockConnectionProperties);\n<line_number-88>\n<line_number-89>        String expectedAppName =\n<line_number-90>                MongoDriver.NAME + \"+\" + MongoDriver.getVersion() + \"|\" + clientInfo;\n<line_number-91>        assertEquals(expectedAppName, getApplicationName(mongoConnection));\n<line_number-92>    }\n<line_number-93>\n<line_number-94>    @Test\n<line_number-95>    void testAppNameWithInvalidClientInfo() {\n<line_number-96>        // Client information has to be in the format 'name+version'\n<line_number-97>        when(mockConnectionProperties.getClientInfo()).thenReturn(\"invalid-client-info\");\n<line_number-98>\n<line_number-99>        mongoConnection = new MongoConnection(null, mockConnectionProperties);\n<line_number-100>\n<line_number-101>        String expectedAppName = MongoDriver.NAME + \"+\" + MongoDriver.getVersion();\n<line_number-102>        assertEquals(expectedAppName, getApplicationName(mongoConnection));\n<line_number-103>    }\n<line_number-104>\n<line_number-105>    // to replace lambda as input in the testExceptionAfterConnectionClosed\n<line_number-106>    interface TestInterface {\n<line_number-107>        void test() throws SQLException;\n<line_number-108>    }\n<line_number-109>\n<line_number-110>    void testExceptionAfterConnectionClosed(TestInterface ti) {\n<line_number-111>        // create statement after closed throws exception\n<line_number-112>        mongoConnection.close();\n<line_number-113>        assertThrows(SQLException.class, ti::test);\n<line_number-114>    }\n<line_number-115>\n<line_number-116>    void testNoop(TestInterface ti) {\n<line_number-117>        assertDoesNotThrow(ti::test);\n<line_number-118>        testExceptionAfterConnectionClosed(ti::test);\n<line_number-119>    }\n<line_number-120>\n<line_number-121>    @Test\n<line_number-122>    void testCheckConnection() {\n<line_number-123>        // When initiated\n<line_number-124>        assertFalse(mongoConnection.isClosed());\n<line_number-125>\n<line_number-126>        // after calling close()\n<line_number-127>        mongoConnection.close();\n<line_number-128>        assertTrue(mongoConnection.isClosed());\n<line_number-129>    }\n<line_number-130>\n<line_number-131>    @Test\n<line_number-132>    void testCreateStatement() throws SQLException {\n<line_number-133>        Statement statement = mongoConnection.createStatement();\n<line_number-134>\n<line_number-135>        // Should be able to create multiple statements.\n<line_number-136>        Statement statement2 = mongoConnection.createStatement();\n<line_number-137>        assertNotEquals(statement, statement2);\n<line_number-138>\n<line_number-139>        // create statement after closed throws exception\n<line_number-140>        mongoConnection.close();\n<line_number-141>        testExceptionAfterConnectionClosed(() -> mongoConnection.createStatement());\n<line_number-142>    }\n<line_number-143>\n<line_number-144>    @Test\n<line_number-145>    void testSetAutoCommitTrue() {\n<line_number-146>        testNoop(() -> mongoConnection.setAutoCommit(true));\n<line_number-147>    }\n<line_number-148>\n<line_number-149>    @Test\n<line_number-150>    void testSetAutoCommitFalse() {\n<line_number-151>        testNoop(() -> mongoConnection.setAutoCommit(false));\n<line_number-152>    }\n<line_number-153>\n<line_number-154>    @Test\n<line_number-155>    void testGetAutoCommit() throws SQLException {\n<line_number-156>        assertTrue(mongoConnection.getAutoCommit());\n<line_number-157>    }\n<line_number-158>\n<line_number-159>    @Test\n<line_number-160>    void testCommit() {\n<line_number-161>        testNoop(() -> mongoConnection.commit());\n<line_number-162>    }\n<line_number-163>\n<line_number-164>    @Test\n<line_number-165>    void testRollback() {\n<line_number-166>        testNoop(() -> mongoConnection.rollback());\n<line_number-167>    }\n<line_number-168>\n<line_number-169>    @Test\n<line_number-170>    void testCloseAndIsClosed() {\n<line_number-171>        assertFalse(mongoConnection.isClosed());\n<line_number-172>        mongoConnection.close();\n<line_number-173>        assertTrue(mongoConnection.isClosed());\n<line_number-174>\n<line_number-175>        // noop for second close()\n<line_number-176>        mongoConnection.close();\n<line_number-177>        assertTrue(mongoConnection.isClosed());\n<line_number-178>    }\n<line_number-179>\n<line_number-180>    @Test\n<line_number-181>    void testSetReadOnly() {\n<line_number-182>        testNoop(() -> mongoConnection.setReadOnly(true));\n<line_number-183>    }\n<line_number-184>\n<line_number-185>    @Test\n<line_number-186>    void testIsReadOnly() {\n<line_number-187>        testNoop(() -> mongoConnection.isReadOnly());\n<line_number-188>    }\n<line_number-189>\n<line_number-190>    @Test\n<line_number-191>    void testSetGetCatalog() throws SQLException {\n<line_number-192>        assertEquals(database, mongoConnection.getCatalog());\n<line_number-193>        mongoConnection.setCatalog(\"test1\");\n<line_number-194>        assertEquals(\"test1\", mongoConnection.getCatalog());\n<line_number-195>\n<line_number-196>        testExceptionAfterConnectionClosed(() -> mongoConnection.setCatalog(\"test\"));\n<line_number-197>        testExceptionAfterConnectionClosed(() -> mongoConnection.getCatalog());\n<line_number-198>    }\n<line_number-199>\n<line_number-200>    @Test\n<line_number-201>    void tesSetTransactionIsolation() {\n<line_number-202>        testNoop(\n<line_number-203>                () ->\n<line_number-204>                        mongoConnection.setTransactionIsolation(\n<line_number-205>                                Connection.TRANSACTION_READ_UNCOMMITTED));\n<line_number-206>    }\n<line_number-207>\n<line_number-208>    @Test\n<line_number-209>    void tesGetTransactionIsolation() throws SQLException {\n<line_number-210>        assertEquals(Connection.TRANSACTION_NONE, mongoConnection.getTransactionIsolation());\n<line_number-211>        testExceptionAfterConnectionClosed(() -> mongoConnection.getTransactionIsolation());\n<line_number-212>    }\n<line_number-213>\n<line_number-214>    @Test\n<line_number-215>    void testGetWarnings() throws SQLException {\n<line_number-216>        assertEquals(null, mongoConnection.getWarnings());\n<line_number-217>        testExceptionAfterConnectionClosed(() -> mongoConnection.getWarnings());\n<line_number-218>    }\n<line_number-219>\n<line_number-220>    @Test\n<line_number-221>    void testClearWarnings() {\n<line_number-222>        testNoop(() -> mongoConnection.clearWarnings());\n<line_number-223>    }\n<line_number-224>\n<line_number-225>    @Test\n<line_number-226>    void testRollbackJ3() {\n<line_number-227>        Savepoint sp = mock(Savepoint.class);\n<line_number-228>        testNoop(() -> mongoConnection.rollback(sp));\n<line_number-229>    }\n<line_number-230>}\n",
        "comments": [
          {
            "comment_code_range": "43-230",
            "comment_linenumber": "42",
            "comment": "Test class for MongoConnection, verifying its behavior and interactions with MongoDB. It uses Mockito for mocking dependencies and JUnit for testing.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "47-50",
            "comment_linenumber": "46",
            "comment": "Initializes mocks before all tests are run, ensuring that mock objects are ready for use.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "54-57",
            "comment_linenumber": "53",
            "comment": "Resets mock objects before each test to ensure a clean state for testing.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "59-64",
            "comment_linenumber": "58",
            "comment": "Sets up mock behaviors for connection properties before each test, defining expected return values.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "66-70",
            "comment_linenumber": "65",
            "comment": "Retrieves the application name from the MongoConnection instance, extracting it from the MongoClient settings.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "72-80",
            "comment_linenumber": "71",
            "comment": "Tests the application name generation when no client info is provided, expecting a default format.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "82-91",
            "comment_linenumber": "81",
            "comment": "Tests the application name generation with valid client info, ensuring it is appended correctly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "94-102",
            "comment_linenumber": "93",
            "comment": "Tests the application name generation with invalid client info, ensuring it defaults to the expected format.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "106-108",
            "comment_linenumber": "105",
            "comment": "Defines a functional interface for testing methods that throw SQLException, allowing for flexible testing.",
            "comment_kind": "interface"
          },
          {
            "comment_code_range": "110-113",
            "comment_linenumber": "109",
            "comment": "Tests that an exception is thrown when attempting to create a statement after the connection is closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "116-118",
            "comment_linenumber": "115",
            "comment": "Tests that no exception is thrown for valid operations and checks exception handling after closing the connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "121-128",
            "comment_linenumber": "120",
            "comment": "Tests the connection state before and after closing it, ensuring the isClosed method reflects the correct state.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "131-141",
            "comment_linenumber": "130",
            "comment": "Tests the creation of statements, ensuring multiple statements can be created and that exceptions are handled correctly after closing.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "144-152",
            "comment_linenumber": "143",
            "comment": "Tests setting auto-commit to true, ensuring no exceptions are thrown during the operation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "155-157",
            "comment_linenumber": "154",
            "comment": "Tests retrieval of the auto-commit state, ensuring it returns the expected value.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "160-162",
            "comment_linenumber": "159",
            "comment": "Tests the commit operation, ensuring it executes without exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "165-167",
            "comment_linenumber": "164",
            "comment": "Tests the rollback operation, ensuring it executes without exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "170-178",
            "comment_linenumber": "169",
            "comment": "Tests the close operation and verifies the connection state, ensuring that multiple close calls do not throw exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "181-183",
            "comment_linenumber": "180",
            "comment": "Tests setting the connection to read-only mode, ensuring no exceptions are thrown.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "186-188",
            "comment_linenumber": "185",
            "comment": "Tests the read-only state of the connection, ensuring it executes without exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "191-197",
            "comment_linenumber": "190",
            "comment": "Tests setting and getting the catalog, ensuring correct behavior and exception handling after closing the connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "201-205",
            "comment_linenumber": "200",
            "comment": "Tests setting the transaction isolation level, ensuring no exceptions are thrown.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "209-211",
            "comment_linenumber": "208",
            "comment": "Tests getting the transaction isolation level, ensuring it returns the expected value and handles exceptions correctly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "215-217",
            "comment_linenumber": "214",
            "comment": "Tests getting warnings from the connection, ensuring it returns null and handles exceptions correctly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "221-223",
            "comment_linenumber": "220",
            "comment": "Tests clearing warnings from the connection, ensuring no exceptions are thrown.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "226-228",
            "comment_linenumber": "225",
            "comment": "Tests the rollback operation with a specific savepoint, ensuring no exceptions are thrown.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoConnectionTest.java' serves as a unit test suite for the 'MongoConnection' class, which is part of the MongoDB JDBC driver. It employs the JUnit testing framework and Mockito for mocking dependencies. The test class extends 'MongoMock', indicating it may inherit setup or utility methods relevant to MongoDB testing. The class is annotated with testing configurations to manage mock behavior and lifecycle. \n\nThe primary focus of the tests is to validate the behavior of the 'MongoConnection' class, particularly its methods related to connection management, application name generation, and transaction handling. Each test method is designed to verify specific functionalities, ensuring that the connection behaves as expected under various scenarios, including valid and invalid inputs. \n\nThe class contains several private helper methods, such as 'getApplicationName', which encapsulate common logic used across multiple tests. The use of a functional interface 'TestInterface' allows for flexible testing of methods that may throw exceptions, enhancing the test coverage. \n\nOverall, the structure is organized to facilitate clear and maintainable tests, with a focus on ensuring that the 'MongoConnection' class adheres to expected behaviors and handles edge cases appropriately.",
        "file_summary": "This file contains unit tests for the 'MongoConnection' class in the MongoDB JDBC driver, validating its functionality and ensuring correct behavior in various scenarios. It utilizes JUnit and Mockito to create a robust testing environment, focusing on connection management, application name generation, and transaction handling."
      }
    ]
  },
  "MongoDatabaseMetaDataTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoDatabaseMetaDataTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\MongoDatabaseMetaDataTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoDatabaseMetaDataTest.java",
        "chunk_id": "MongoDatabaseMetaDataTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.MongoDatabaseMetaData.filterEmptiesAndInternalDBs;\n<line_number-20>import static org.junit.jupiter.api.Assertions.*;\n<line_number-21>\n<line_number-22>import com.mongodb.ConnectionString;\n<line_number-23>import java.sql.DatabaseMetaData;\n<line_number-24>import java.sql.ResultSet;\n<line_number-25>import java.sql.ResultSetMetaData;\n<line_number-26>import java.sql.SQLException;\n<line_number-27>import java.util.ArrayList;\n<line_number-28>import java.util.Arrays;\n<line_number-29>import java.util.stream.Collectors;\n<line_number-30>import org.junit.jupiter.api.Test;\n<line_number-31>import org.junit.jupiter.api.TestInstance;\n<line_number-32>\n<line_number-33>@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n<line_number-34>public class MongoDatabaseMetaDataTest {\n<line_number-35>    protected static final ConnectionString uri =\n<line_number-36>            new ConnectionString(\"mongodb://localhost:27017/admin\");\n<line_number-37>    protected static final String database = \"mock\";\n<line_number-38>\n<line_number-39>    protected DatabaseMetaData databaseMetaData =\n<line_number-40>            new MongoDatabaseMetaData(\n<line_number-41>                    new MongoConnection(\n<line_number-42>                            new MongoConnectionProperties(\n<line_number-43>                                    uri, database, null, null, null, false, null)));\n<line_number-44>\n<line_number-45>    protected int countRows(ResultSet rs) throws SQLException {\n<line_number-46>        for (int i = 0; ; ++i) {\n<line_number-47>            if (!rs.next()) {\n<line_number-48>                return i;\n<line_number-49>            }\n<line_number-50>        }\n<line_number-51>    }\n<line_number-52>\n<line_number-53>    /**\n<line_number-54>     * Calls the databaseMetaData.getFunctions with the given function name pattern and the expected\n<line_number-55>     * number of rows it should return and verifies that it matches the actual number of rows\n<line_number-56>     * returned.\n<line_number-57>     *\n<line_number-58>     * @param functionNamePattern The function name pattern used to narrow the search.\n<line_number-59>     * @param expectedNumRows The expected number of rows it should return.\n<line_number-60>     * @throws SQLException If an error occurs when calling getFunctions.\n<line_number-61>     */\n<line_number-62>    protected void testGetFunctionsHelper(String functionNamePattern, int expectedNumRows)\n<line_number-63>            throws SQLException {\n<line_number-64>        String[] getFunctionsColumns =\n<line_number-65>                new String[] {\n<line_number-66>                    \"FUNCTION_CAT\",\n<line_number-67>                    \"FUNCTION_SCHEM\",\n<line_number-68>                    \"FUNCTION_NAME\",\n<line_number-69>                    \"REMARKS\",\n<line_number-70>                    \"FUNCTION_TYPE\",\n<line_number-71>                    \"SPECIFIC_NAME\",\n<line_number-72>                };\n<line_number-73>        ResultSet rs = databaseMetaData.getFunctions(null, null, functionNamePattern);\n<line_number-74>        validateResultSet(rs, expectedNumRows, getFunctionsColumns);\n<line_number-75>    }\n<line_number-76>\n<line_number-77>    void validateResultSet(ResultSet rs, int expectedNumRows, String[] expectedColumns)\n<line_number-78>            throws SQLException {\n<line_number-79>        ResultSetMetaData rsmd = rs.getMetaData();\n<line_number-80>        for (int i = 0; i < expectedColumns.length; ++i) {\n<line_number-81>            assertEquals(expectedColumns[i], rsmd.getColumnName(i + 1));\n<line_number-82>            assertEquals(expectedColumns[i], rsmd.getColumnLabel(i + 1));\n<line_number-83>        }\n<line_number-84>        assertEquals(expectedNumRows, countRows(rs));\n<line_number-85>    }\n<line_number-86>\n<line_number-87>    @Test\n<line_number-88>    void testGetProcedures() throws SQLException {\n<line_number-89>        String[] columns =\n<line_number-90>                new String[] {\n<line_number-91>                    \"PROCEDURE_CAT\",\n<line_number-92>                    \"PROCEDURE_SCHEM\",\n<line_number-93>                    \"PROCEDURE_NAME\",\n<line_number-94>                    \"REMARKS\",\n<line_number-95>                    \"PROCEDURE_TYPE\",\n<line_number-96>                    \"SPECIFIC_NAME\",\n<line_number-97>                };\n<line_number-98>\n<line_number-99>        // we will never have procedures.\n<line_number-100>        ResultSet rs = databaseMetaData.getProcedures(null, null, \"%\");\n<line_number-101>        validateResultSet(rs, 0, columns);\n<line_number-102>    }\n<line_number-103>\n<line_number-104>    @Test\n<line_number-105>    void testGetProceduresColumns() throws SQLException {\n<line_number-106>        String[] columns =\n<line_number-107>                new String[] {\n<line_number-108>                    \"PROCEDURE_CAT\",\n<line_number-109>                    \"PROCEDURE_SCHEM\",\n<line_number-110>                    \"PROCEDURE_NAME\",\n<line_number-111>                    \"COLUMN_NAME\",\n<line_number-112>                    \"COLUMN_TYPE\",\n<line_number-113>                    \"DATA_TYPE\",\n<line_number-114>                    \"TYPE_NAME\",\n<line_number-115>                    \"PRECISION\",\n<line_number-116>                    \"LENGTH\",\n<line_number-117>                    \"SCALE\",\n<line_number-118>                    \"RADIX\",\n<line_number-119>                    \"NULLABLE\",\n<line_number-120>                    \"REMARKS\",\n<line_number-121>                    \"COLUMN_DEF\",\n<line_number-122>                    \"SQL_DATA_TYPE\",\n<line_number-123>                    \"SQL_DATETIME_SUB\",\n<line_number-124>                    \"CHAR_OCTET_LENGTH\",\n<line_number-125>                    \"ORDINAL_POSITION\",\n<line_number-126>                    \"IS_NULLABLE\",\n<line_number-127>                    \"SPECIFIC_NAME\",\n<line_number-128>                };\n<line_number-129>\n<line_number-130>        ResultSet rs = databaseMetaData.getProcedureColumns(null, null, \"%\", \"%\");\n<line_number-131>        validateResultSet(rs, 0, columns);\n<line_number-132>    }\n<line_number-133>\n<line_number-134>    @Test\n<line_number-135>    void testGetVersionColumns() throws SQLException {\n<line_number-136>        String[] columns =\n<line_number-137>                new String[] {\n<line_number-138>                    \"SCOPE\",\n<line_number-139>                    \"COLUMN_NAME\",\n<line_number-140>                    \"DATA_TYPE\",\n<line_number-141>                    \"TYPE_NAME\",\n<line_number-142>                    \"COLUMN_SIZE\",\n<line_number-143>                    \"BUFFER_LENGTH\",\n<line_number-144>                    \"DECIMAL_DIGITS\",\n<line_number-145>                    \"PSEUDO_COLUMN\",\n<line_number-146>                };\n<line_number-147>\n<line_number-148>        ResultSet rs = databaseMetaData.getVersionColumns(null, null, \"%\");\n<line_number-149>        validateResultSet(rs, 0, columns);\n<line_number-150>    }\n<line_number-151>\n<line_number-152>    @Test\n<line_number-153>    void testGetImportedKeys() throws SQLException {\n<line_number-154>        String[] columns =\n<line_number-155>                new String[] {\n<line_number-156>                    \"PKTABLE_CAT\",\n<line_number-157>                    \"PKTABLE_SCHEM\",\n<line_number-158>                    \"PKTABLE_NAME\",\n<line_number-159>                    \"PKCOLUMN_NAME\",\n<line_number-160>                    \"FKTABLE_CAT\",\n<line_number-161>                    \"FKTABLE_SCHEM\",\n<line_number-162>                    \"FKTABLE_NAME\",\n<line_number-163>                    \"FKCOLUMN_NAME\",\n<line_number-164>                    \"KEY_SEQ\",\n<line_number-165>                    \"UPDATE_RULE\",\n<line_number-166>                    \"DELETE_RULE\",\n<line_number-167>                    \"FK_NAME\",\n<line_number-168>                    \"PK_NAME\",\n<line_number-169>                    \"DEFERRABILITY\",\n<line_number-170>                };\n<line_number-171>\n<line_number-172>        ResultSet rs = databaseMetaData.getImportedKeys(null, null, \"%\");\n<line_number-173>        validateResultSet(rs, 0, columns);\n<line_number-174>    }\n<line_number-175>\n<line_number-176>    @Test\n<line_number-177>    void testGetExportedKeys() throws SQLException {\n<line_number-178>        String[] columns =\n<line_number-179>                new String[] {\n<line_number-180>                    \"PKTABLE_CAT\",\n<line_number-181>                    \"PKTABLE_SCHEM\",\n<line_number-182>                    \"PKTABLE_NAME\",\n<line_number-183>                    \"PKCOLUMN_NAME\",\n<line_number-184>                    \"FKTABLE_CAT\",\n<line_number-185>                    \"FKTABLE_SCHEM\",\n<line_number-186>                    \"FKTABLE_NAME\",\n<line_number-187>                    \"FKCOLUMN_NAME\",\n<line_number-188>                    \"KEY_SEQ\",\n<line_number-189>                    \"UPDATE_RULE\",\n<line_number-190>                    \"DELETE_RULE\",\n<line_number-191>                    \"FK_NAME\",\n<line_number-192>                    \"PK_NAME\",\n<line_number-193>                    \"DEFERRABILITY\",\n<line_number-194>                };\n<line_number-195>\n<line_number-196>        ResultSet rs = databaseMetaData.getExportedKeys(null, null, \"%\");\n<line_number-197>        validateResultSet(rs, 0, columns);\n<line_number-198>    }\n<line_number-199>\n<line_number-200>    @Test\n<line_number-201>    void testGetCrossReference() throws SQLException {\n<line_number-202>        String[] columns =\n<line_number-203>                new String[] {\n<line_number-204>                    \"PKTABLE_CAT\",\n<line_number-205>                    \"PKTABLE_SCHEM\",\n<line_number-206>                    \"PKTABLE_NAME\",\n<line_number-207>                    \"PKCOLUMN_NAME\",\n<line_number-208>                    \"FKTABLE_CAT\",\n<line_number-209>                    \"FKTABLE_SCHEM\",\n<line_number-210>                    \"FKTABLE_NAME\",\n<line_number-211>                    \"FKCOLUMN_NAME\",\n<line_number-212>                    \"KEY_SEQ\",\n<line_number-213>                    \"UPDATE_RULE\",\n<line_number-214>                    \"DELETE_RULE\",\n<line_number-215>                    \"FK_NAME\",\n<line_number-216>                    \"PK_NAME\",\n<line_number-217>                    \"DEFERRABILITY\",\n<line_number-218>                };\n<line_number-219>\n<line_number-220>        ResultSet rs = databaseMetaData.getCrossReference(null, null, \"%\", null, null, \"%\");\n<line_number-221>        validateResultSet(rs, 0, columns);\n<line_number-222>    }\n<line_number-223>\n<line_number-224>    @Test\n<line_number-225>    void testGetUDTs() throws SQLException {\n<line_number-226>        String[] columns =\n<line_number-227>                new String[] {\n<line_number-228>                    \"TYPE_CAT\",\n<line_number-229>                    \"TYPE_SCHEM\",\n<line_number-230>                    \"TYPE_NAME\",\n<line_number-231>                    \"CLASS_NAME\",\n<line_number-232>                    \"DATA_TYPE\",\n<line_number-233>                    \"REMARKS\",\n<line_number-234>                    \"BASE_TYPE\",\n<line_number-235>                };\n<line_number-236>\n<line_number-237>        ResultSet rs = databaseMetaData.getUDTs(null, null, \"%\", null);\n<line_number-238>        validateResultSet(rs, 0, columns);\n<line_number-239>    }\n<line_number-240>\n<line_number-241>    @Test\n<line_number-242>    void testGetSuperTypes() throws SQLException {\n<line_number-243>        String[] columns =\n<line_number-244>                new String[] {\n<line_number-245>                    \"TYPE_CAT\",\n<line_number-246>                    \"TYPE_SCHEM\",\n<line_number-247>                    \"TYPE_NAME\",\n<line_number-248>                    \"SUPERTYPE_CAT\",\n<line_number-249>                    \"SUPERTYPE_SCHEM\",\n<line_number-250>                    \"SUPERTYPE_NAME\",\n<line_number-251>                };\n<line_number-252>\n<line_number-253>        ResultSet rs = databaseMetaData.getSuperTypes(null, \"%\", \"%\");\n<line_number-254>        validateResultSet(rs, 0, columns);\n<line_number-255>    }\n<line_number-256>\n<line_number-257>    @Test\n<line_number-258>    void testGetSuperTables() throws SQLException {\n<line_number-259>        String[] columns =\n<line_number-260>                new String[] {\n<line_number-261>                    \"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"SUPERTABLE_NAME\",\n<line_number-262>                };\n<line_number-263>\n<line_number-264>        ResultSet rs = databaseMetaData.getSuperTables(null, \"%\", \"%\");\n<line_number-265>        validateResultSet(rs, 0, columns);\n<line_number-266>    }\n<line_number-267>\n<line_number-268>    @Test\n<line_number-269>    void testGetAttributes() throws SQLException {\n<line_number-270>        String[] columns =\n<line_number-271>                new String[] {\n<line_number-272>                    \"TYPE_CAT\",\n<line_number-273>                    \"TYPE_SCHEM\",\n<line_number-274>                    \"TYPE_NAME\",\n<line_number-275>                    \"ATTR_NAME\",\n<line_number-276>                    \"DATA_TYPE\",\n<line_number-277>                    \"ATTR_TYPE_NAME\",\n<line_number-278>                    \"ATTR_SIZE\",\n<line_number-279>                    \"DECIMAL_DIGITS\",\n<line_number-280>                    \"NUM_PREC_RADIX\",\n<line_number-281>                    \"NULLABLE\",\n<line_number-282>                    \"REMARKS\",\n<line_number-283>                    \"ATTR_DEF\",\n<line_number-284>                    \"SQL_DATA_TYPE\",\n<line_number-285>                    \"SQL_DATETIME_SUB\",\n<line_number-286>                    \"CHAR_OCTET_LENGTH\",\n<line_number-287>                    \"ORDINAL_POSITION\",\n<line_number-288>                    \"IS_NULLABLE\",\n<line_number-289>                    \"SCOPE_CATALOG\",\n<line_number-290>                    \"SCOPE_SCHEMA\",\n<line_number-291>                    \"SCOPE_TABLE\",\n<line_number-292>                    \"SOURCE_DATA_TYPE\",\n<line_number-293>                };\n<line_number-294>\n<line_number-295>        ResultSet rs = databaseMetaData.getAttributes(null, null, \"%\", \"%\");\n<line_number-296>        validateResultSet(rs, 0, columns);\n<line_number-297>    }\n<line_number-298>\n<line_number-299>    @Test\n<line_number-300>    void testGetPseudoColumns() throws SQLException {\n<line_number-301>        String[] columns =\n<line_number-302>                new String[] {\n<line_number-303>                    \"TABLE_CAT\",\n<line_number-304>                    \"TABLE_SCHEM\",\n<line_number-305>                    \"TABLE_NAME\",\n<line_number-306>                    \"COLUMN_NAME\",\n<line_number-307>                    \"DATA_TYPE\",\n<line_number-308>                    \"COLUMN_SIZE\",\n<line_number-309>                    \"DECIMAL_DIGITS\",\n<line_number-310>                    \"NUM_PREC_RADIX\",\n<line_number-311>                    \"COLUMN_USAGE\",\n<line_number-312>                    \"REMARKS\",\n<line_number-313>                    \"CHAR_OCTET_LENGTH\",\n<line_number-314>                    \"IS_NULLABLE\",\n<line_number-315>                };\n<line_number-316>\n<line_number-317>        ResultSet rs = databaseMetaData.getPseudoColumns(null, null, \"%\", \"%\");\n<line_number-318>        validateResultSet(rs, 0, columns);\n<line_number-319>    }\n<line_number-320>\n<line_number-321>    @Test\n<line_number-322>    void testGetSchemas() throws SQLException {\n<line_number-323>        String[] columns =\n<line_number-324>                new String[] {\n<line_number-325>                    \"TABLE_SCHEM\", \"TABLE_CATALOG\",\n<line_number-326>                };\n<line_number-327>\n<line_number-328>        // getSchemas()\n<line_number-329>        ResultSet rs = databaseMetaData.getSchemas();\n<line_number-330>        validateResultSet(rs, 0, columns);\n<line_number-331>\n<line_number-332>        // getSchemas(catalog, schemaPattern)\n<line_number-333>        rs = databaseMetaData.getSchemas(null, null);\n<line_number-334>        validateResultSet(rs, 0, columns);\n<line_number-335>    }\n<line_number-336>\n<line_number-337>    @Test\n<line_number-338>    /** Test the DatabaseMetadata.getFunctions method. */\n<line_number-339>    void testGetFunctions() throws SQLException {\n<line_number-340>        // All function(s)\n<line_number-341>        testGetFunctionsHelper(\"%\", 114);\n<line_number-342>        // All function(s) with a 'S'\n<line_number-343>        testGetFunctionsHelper(\"%S%\", 31);\n<line_number-344>        // All function(s) with a 's'\n<line_number-345>        testGetFunctionsHelper(\"%s%\", 0);\n<line_number-346>        // The 'SUBSTRING' function(s)\n<line_number-347>        testGetFunctionsHelper(\"SUBSTRING\", 2);\n<line_number-348>        // The 'SUBS(any character)RING' function(s)\n<line_number-349>        testGetFunctionsHelper(\"SUBS_RING\", 2);\n<line_number-350>    }\n<line_number-351>\n<line_number-352>    @Test\n<line_number-353>    void testGetSQLKeywords() throws SQLException {\n<line_number-354>        final String expectedKeywords =\n<line_number-355>                \"AGGREGATE,\"\n<line_number-356>                        + \"ASC,\"\n<line_number-357>                        + \"BINDATA,\"\n<line_number-358>                        + \"BIT,\"\n<line_number-359>                        + \"BOOL,\"\n<line_number-360>                        + \"BSON_DATE,\"\n<line_number-361>                        + \"BSON_TIMESTAMP,\"\n<line_number-362>                        + \"DBPOINTER,\"\n<line_number-363>                        + \"DESC,\"\n<line_number-364>                        + \"DOCUMENT,\"\n<line_number-365>                        + \"ERROR,\"\n<line_number-366>                        + \"EXTRACT,\"\n<line_number-367>                        + \"FIRST,\"\n<line_number-368>                        + \"JAVASCRIPT,\"\n<line_number-369>                        + \"JAVASCRIPTWITHSCOPE,\"\n<line_number-370>                        + \"LIMIT,\"\n<line_number-371>                        + \"LONG,\"\n<line_number-372>                        + \"MAXKEY,\"\n<line_number-373>                        + \"MINKEY,\"\n<line_number-374>                        + \"MISSING,\"\n<line_number-375>                        + \"NEXT,\"\n<line_number-376>                        + \"NUMBER,\"\n<line_number-377>                        + \"OBJECTID,\"\n<line_number-378>                        + \"OFFSET,\"\n<line_number-379>                        + \"POSITION,\"\n<line_number-380>                        + \"REGEX,\"\n<line_number-381>                        + \"SUBSTRING,\"\n<line_number-382>                        + \"SYMBOL,\"\n<line_number-383>                        + \"TRIM,\"\n<line_number-384>                        + \"UNDEFINED\";\n<line_number-385>\n<line_number-386>        assertEquals(expectedKeywords, databaseMetaData.getSQLKeywords());\n<line_number-387>    }\n<line_number-388>\n<line_number-389>    @Test\n<line_number-390>    void testGetNumericFunctions() throws SQLException {\n<line_number-391>        final String expectedFunctions =\n<line_number-392>                \"ABS,\"\n<line_number-393>                        + \"COS,\"\n<line_number-394>                        + \"DEGREES,\"\n<line_number-395>                        + \"FLOOR,\"\n<line_number-396>                        + \"MOD,\"\n<line_number-397>                        + \"RADIANS,\"\n<line_number-398>                        + \"ROUND,\"\n<line_number-399>                        + \"SIN,\"\n<line_number-400>                        + \"SQRT,\"\n<line_number-401>                        + \"TAN\";\n<line_number-402>\n<line_number-403>        assertEquals(expectedFunctions, databaseMetaData.getNumericFunctions());\n<line_number-404>    }\n<line_number-405>\n<line_number-406>    @Test\n<line_number-407>    void testGetStringFunctions() throws SQLException {\n<line_number-408>        final String expectedFunctions =\n<line_number-409>                \"CHAR_LENGTH,\" + \"OCTET_LENGTH,\" + \"POSITION,\" + \"SUBSTRING\";\n<line_number-410>\n<line_number-411>        assertEquals(expectedFunctions, databaseMetaData.getStringFunctions());\n<line_number-412>    }\n<line_number-413>\n<line_number-414>    @Test\n<line_number-415>    void testGetSystemFunctions() throws SQLException {\n<line_number-416>        final String expectedFunctions = \"\";\n<line_number-417>\n<line_number-418>        assertEquals(expectedFunctions, databaseMetaData.getSystemFunctions());\n<line_number-419>    }\n<line_number-420>\n<line_number-421>    @Test\n<line_number-422>    void testGetTimeDateFunctions() throws SQLException {\n<line_number-423>        final String expectedFunctions = \"CURRENT_TIMESTAMP,EXTRACT\";\n<line_number-424>\n<line_number-425>        assertEquals(expectedFunctions, databaseMetaData.getTimeDateFunctions());\n<line_number-426>    }\n<line_number-427>\n<line_number-428>    @Test\n<line_number-429>    void testToJavaPattern() throws SQLException {\n<line_number-430>        final String specialCharacters = \".^$*+?(){}|[]\\\\\";\n<line_number-431>        final String escapedSpecialCharacters = \"\\\\.\\\\^\\\\$\\\\*\\\\+\\\\?\\\\(\\\\)\\\\{\\\\}\\\\|\\\\[\\\\]\\\\\\\\\";\n<line_number-432>\n<line_number-433>        assertEquals(\n<line_number-434>                escapedSpecialCharacters,\n<line_number-435>                MongoDatabaseMetaData.toJavaPattern(specialCharacters).toString());\n<line_number-436>        assertEquals(\"\\\\\\\\%\", MongoDatabaseMetaData.toJavaPattern(\"\\\\%\").toString());\n<line_number-437>        assertEquals(\".*\", MongoDatabaseMetaData.toJavaPattern(\"%\").toString());\n<line_number-438>        assertEquals(\"\\\\\\\\_\", MongoDatabaseMetaData.toJavaPattern(\"\\\\_\").toString());\n<line_number-439>        assertEquals(\".\", MongoDatabaseMetaData.toJavaPattern(\"_\").toString());\n<line_number-440>        assertEquals(\n<line_number-441>                \"nothingToEscape\",\n<line_number-442>                MongoDatabaseMetaData.toJavaPattern(\"nothingToEscape\").toString());\n<line_number-443>        assertEquals(\n<line_number-444>                \"a\\\\\\\\_.b\\\\\\\\%.*\", MongoDatabaseMetaData.toJavaPattern(\"a\\\\__b\\\\%%\").toString());\n<line_number-445>    }\n<line_number-446>\n<line_number-447>    @Test\n<line_number-448>    void testFilterEmptiesAndAdmin() {\n<line_number-449>        final ArrayList<String> input = new ArrayList<>(Arrays.asList(\"foo\", \"bar\", \"\", \"admin\"));\n<line_number-450>        final ArrayList<String> expected = new ArrayList<>(Arrays.asList(\"foo\", \"bar\"));\n<line_number-451>        assertEquals(\n<line_number-452>                expected,\n<line_number-453>                input.stream()\n<line_number-454>                        .filter(dbName -> filterEmptiesAndInternalDBs(dbName))\n<line_number-455>                        .collect(Collectors.toList()));\n<line_number-456>    }\n<line_number-457>}\n",
        "comments": [
          {
            "comment_code_range": "34-44",
            "comment_linenumber": "33",
            "comment": "Test class for MongoDatabaseMetaData, responsible for validating database metadata retrieval methods.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "45-51",
            "comment_linenumber": "44",
            "comment": "Counts the number of rows in a ResultSet by iterating until no more rows are available.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "53-61",
            "comment_linenumber": "52",
            "comment": "Helper method to test databaseMetaData.getFunctions, verifying the number of returned rows matches expectations.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "77-84",
            "comment_linenumber": "76",
            "comment": "Validates the ResultSet against expected columns and the expected number of rows.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "87-102",
            "comment_linenumber": "86",
            "comment": "Tests the retrieval of procedures from the database, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "104-132",
            "comment_linenumber": "103",
            "comment": "Tests the retrieval of procedure columns, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "134-150",
            "comment_linenumber": "133",
            "comment": "Tests the retrieval of version columns, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "152-173",
            "comment_linenumber": "151",
            "comment": "Tests the retrieval of imported keys, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "176-197",
            "comment_linenumber": "175",
            "comment": "Tests the retrieval of exported keys, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "200-221",
            "comment_linenumber": "199",
            "comment": "Tests the retrieval of cross-references, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "224-239",
            "comment_linenumber": "223",
            "comment": "Tests the retrieval of user-defined types (UDTs), expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "241-255",
            "comment_linenumber": "240",
            "comment": "Tests the retrieval of super types, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "257-266",
            "comment_linenumber": "256",
            "comment": "Tests the retrieval of super tables, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "268-296",
            "comment_linenumber": "267",
            "comment": "Tests the retrieval of attributes, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "299-318",
            "comment_linenumber": "298",
            "comment": "Tests the retrieval of pseudo columns, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "321-335",
            "comment_linenumber": "320",
            "comment": "Tests the retrieval of schemas, expecting zero results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "337-350",
            "comment_linenumber": "336",
            "comment": "Tests the databaseMetaData.getFunctions method with various patterns and expected results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "352-386",
            "comment_linenumber": "351",
            "comment": "Tests the retrieval of SQL keywords from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "389-411",
            "comment_linenumber": "388",
            "comment": "Tests the retrieval of numeric functions from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "414-426",
            "comment_linenumber": "413",
            "comment": "Tests the retrieval of string functions from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "429-438",
            "comment_linenumber": "428",
            "comment": "Tests the retrieval of system functions from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "421-425",
            "comment_linenumber": "420",
            "comment": "Tests the retrieval of time/date functions from the database metadata.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "447-455",
            "comment_linenumber": "446",
            "comment": "Tests the filterEmptiesAndInternalDBs method to ensure it filters out empty and internal database names.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoDatabaseMetaDataTest.java' is a JUnit test class designed to validate the functionality of the MongoDatabaseMetaData class, specifically focusing on its methods for retrieving metadata from a MongoDB database. The class is annotated with @TestInstance, indicating that test instances are created per class rather than per method, which is useful for maintaining state across tests. The class contains a series of test methods that check various aspects of database metadata retrieval, including functions, procedures, attributes, and schemas. Each test method typically sets up expected results and calls the corresponding method from the MongoDatabaseMetaData class, asserting that the actual results match the expectations. The class also includes helper methods for counting rows in ResultSets and validating the structure of ResultSets against expected columns. The tests are structured to ensure that the MongoDB metadata retrieval methods behave correctly and return the expected results, particularly focusing on edge cases such as empty results.",
        "file_summary": "This file contains unit tests for the MongoDatabaseMetaData class, ensuring that various metadata retrieval methods function correctly and return expected results. It validates the behavior of methods related to functions, procedures, keys, and other database metadata aspects."
      }
    ]
  },
  "MongoDriverTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoDriverTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\MongoDriverTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoDriverTest.java",
        "chunk_id": "MongoDriverTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.MongoDriver.MongoJDBCProperty.*;\n<line_number-20>import static org.junit.jupiter.api.Assertions.*;\n<line_number-21>\n<line_number-22>import com.mongodb.AuthenticationMechanism;\n<line_number-23>import com.mongodb.client.MongoClient;\n<line_number-24>import java.io.File;\n<line_number-25>import java.io.IOException;\n<line_number-26>import java.lang.ref.WeakReference;\n<line_number-27>import java.lang.reflect.Field;\n<line_number-28>import java.nio.file.Files;\n<line_number-29>import java.nio.file.Paths;\n<line_number-30>import java.sql.Connection;\n<line_number-31>import java.sql.DriverPropertyInfo;\n<line_number-32>import java.sql.SQLException;\n<line_number-33>import java.sql.SQLFeatureNotSupportedException;\n<line_number-34>import java.util.Properties;\n<line_number-35>import java.util.concurrent.ConcurrentHashMap;\n<line_number-36>import java.util.concurrent.atomic.AtomicInteger;\n<line_number-37>import java.util.concurrent.locks.ReadWriteLock;\n<line_number-38>import java.util.logging.Level;\n<line_number-39>import org.junit.jupiter.api.BeforeAll;\n<line_number-40>import org.junit.jupiter.api.Test;\n<line_number-41>import org.junit.jupiter.api.TestInstance;\n<line_number-42>import org.junit.jupiter.api.extension.ExtendWith;\n<line_number-43>import org.mockito.MockitoAnnotations;\n<line_number-44>import org.mockito.junit.jupiter.MockitoExtension;\n<line_number-45>\n<line_number-46>@ExtendWith(MockitoExtension.class)\n<line_number-47>@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n<line_number-48>class MongoDriverTest {\n<line_number-49>\n<line_number-50>    static final String localhost = \"mongodb://localhost\";\n<line_number-51>    static final String USER = \"AzureDiamond\";\n<line_number-52>    static final String PWD = \"hunter2\";\n<line_number-53>    static final String DB = \"foo\";\n<line_number-54>    static final String basicURL = \"jdbc:mongodb://localhost\";\n<line_number-55>    static final String userNoPWDURL = \"jdbc:mongodb://foo@localhost/admin\";\n<line_number-56>    static final String userURL = \"jdbc:mongodb://foo:bar@localhost\";\n<line_number-57>    static final String jdbcUserURL = \"jdbc:mongodb://jdbc:bar@localhost\";\n<line_number-58>    static final String dbInURL = \"jdbc:mongodb://localhost/foo?authSource=admin\";\n<line_number-59>    static final String userOIDCURL =\n<line_number-60>            \"jdbc:mongodb://foo@localhost/admin?authMechanism=MONGODB-OIDC\";\n<line_number-61>    static final String oidcURL =\n<line_number-62>            \"jdbc:mongodb://localhost/foo?authMechanism=MONGODB-OIDC&authSource=admin\";\n<line_number-63>    static final String userPwdOIDCURL =\n<line_number-64>            \"jdbc:mongodb://foo:bar@localhost?authMechanism=MONGODB-OIDC\";\n<line_number-65>\n<line_number-66>    // Even though ADF does not support replSets, this tests that we handle these URLs properly\n<line_number-67>    // for the future.\n<line_number-68>    static final String replURL = \"jdbc:mongodb://foo:bar@localhost:27017,localhost:28910\";\n<line_number-69>\n<line_number-70>    private static final String CURRENT_DIR =\n<line_number-71>            Paths.get(\".\").toAbsolutePath().normalize().toString();\n<line_number-72>    private static final String NOT_LOGGING_TO_FILE_ERROR = \"Not logging to files.\";\n<line_number-73>\n<line_number-74>    // Using an atomicInteger in case Junit ran with parallel execution enabled\n<line_number-75>    private static AtomicInteger connectionCounter = new AtomicInteger();\n<line_number-76>\n<line_number-77>    private static final String USER_CONN_KEY = \"user\";\n<line_number-78>    private static final String PWD_CONN_KEY = \"password\";\n<line_number-79>    private static final String DB_CONN_KEY = \"database\";\n<line_number-80>\n<line_number-81>    private static final Properties mandatoryProperties = setProperties();\n<line_number-82>\n<line_number-83>    private static Properties setProperties() {\n<line_number-84>        Properties props = new Properties();\n<line_number-85>        props.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-86>\n<line_number-87>        return props;\n<line_number-88>    }\n<line_number-89>\n<line_number-90>    @BeforeAll\n<line_number-91>    void initMocks() {\n<line_number-92>        MockitoAnnotations.initMocks(this);\n<line_number-93>    }\n<line_number-94>\n<line_number-95>    @Test\n<line_number-96>    void testBasicURL() throws SQLException {\n<line_number-97>        MongoDriver d = new MongoDriver();\n<line_number-98>        // Missing mandatory 'DATABASE.getPropertyName()' property\n<line_number-99>        missingConnectionSettings(d, basicURL, null);\n<line_number-100>\n<line_number-101>        Properties p = new Properties();\n<line_number-102>        missingConnectionSettings(d, basicURL, p);\n<line_number-103>\n<line_number-104>        // user without password should throw.\n<line_number-105>        p = (Properties) mandatoryProperties.clone();\n<line_number-106>        p.setProperty(USER_CONN_KEY, \"user\");\n<line_number-107>        missingConnectionSettings(d, basicURL, p);\n<line_number-108>\n<line_number-109>        // once property is set, it should be fine.\n<line_number-110>        p.setProperty(PWD_CONN_KEY, \"pwd\");\n<line_number-111>        assertNotNull(d.getUnvalidatedConnection(basicURL, p));\n<line_number-112>    }\n<line_number-113>\n<line_number-114>    @Test\n<line_number-115>    void testURIDBURL() throws SQLException {\n<line_number-116>        MongoDriver d = new MongoDriver();\n<line_number-117>        Properties p = new Properties();\n<line_number-118>        p.setProperty(USER_CONN_KEY, \"AzureDiamond\");\n<line_number-119>        p.setProperty(PWD_CONN_KEY, \"hunter2\");\n<line_number-120>        assertNotNull(d.getUnvalidatedConnection(dbInURL, p));\n<line_number-121>    }\n<line_number-122>\n<line_number-123>    private void missingConnectionSettings(\n<line_number-124>            MongoDriver d, String connectionUrl, Properties properties) {\n<line_number-125>        // Should not return null or throw, even with null properties.\n<line_number-126>        try {\n<line_number-127>            d.getUnvalidatedConnection(connectionUrl, properties);\n<line_number-128>            fail(\"The connection should fail because a mandatory connection setting is missing.\");\n<line_number-129>        } catch (SQLException e) {\n<line_number-130>            // Expected failure\n<line_number-131>            assertEquals(\n<line_number-132>                    MongoDriver.CONNECTION_ERROR_SQLSTATE,\n<line_number-133>                    e.getSQLState(),\n<line_number-134>                    \"Expect SQL state \"\n<line_number-135>                            + MongoDriver.CONNECTION_ERROR_SQLSTATE\n<line_number-136>                            + \" but got \"\n<line_number-137>                            + e.getSQLState());\n<line_number-138>        }\n<line_number-139>    }\n<line_number-140>\n<line_number-141>    @Test\n<line_number-142>    void testuserNoPWDURL() throws SQLException {\n<line_number-143>        MongoDriver d = new MongoDriver();\n<line_number-144>\n<line_number-145>        // This will throw because the java driver will fail\n<line_number-146>        // to parse the URI.\n<line_number-147>        try {\n<line_number-148>            d.getUnvalidatedConnection(userNoPWDURL, mandatoryProperties);\n<line_number-149>            fail(\"The connection should fail because the URI is not valid.\");\n<line_number-150>        } catch (SQLException e) {\n<line_number-151>            // Expected failure\n<line_number-152>            assertEquals(java.lang.IllegalArgumentException.class, e.getCause().getClass());\n<line_number-153>        }\n<line_number-154>    }\n<line_number-155>\n<line_number-156>    @Test\n<line_number-157>    void testJDBCURL() throws SQLException {\n<line_number-158>        MongoDriver d = new MongoDriver();\n<line_number-159>\n<line_number-160>        assertNotNull(d.getUnvalidatedConnection(jdbcUserURL, mandatoryProperties));\n<line_number-161>\n<line_number-162>        // changing user name from `jdbc` should throw.\n<line_number-163>        Properties p = (Properties) mandatoryProperties.clone();\n<line_number-164>        p.setProperty(USER_CONN_KEY, \"jdbc2\");\n<line_number-165>        assertThrows(\n<line_number-166>                SQLException.class,\n<line_number-167>                () -> d.getUnvalidatedConnection(jdbcUserURL, p),\n<line_number-168>                \"The connection should fail because of a user mismatch between the URI and the properties\");\n<line_number-169>    }\n<line_number-170>\n<line_number-171>    @Test\n<line_number-172>    void testUserURL() throws SQLException {\n<line_number-173>        MongoDriver d = new MongoDriver();\n<line_number-174>        missingConnectionSettings(d, userURL, null);\n<line_number-175>\n<line_number-176>        Properties p = new Properties();\n<line_number-177>        missingConnectionSettings(d, userURL, p);\n<line_number-178>        p = (Properties) mandatoryProperties.clone();\n<line_number-179>        assertNotNull(d.getUnvalidatedConnection(userURL, p));\n<line_number-180>\n<line_number-181>        // This is not a mismatch, because we assume that if an auth DATABASE.getPropertyName() is missing\n<line_number-182>        // in the URI, even though default is admin, the user would prefer whatever is in\n<line_number-183>        // the passed Properties.\n<line_number-184>        p.setProperty(\"authDATABASE.getPropertyName()\", \"admin2\");\n<line_number-185>        assertNotNull(d.getUnvalidatedConnection(userURL, p));\n<line_number-186>\n<line_number-187>        Properties p2 = (Properties) mandatoryProperties.clone();\n<line_number-188>        p2.setProperty(USER_CONN_KEY, \"dfasdfds\");\n<line_number-189>        // user mismatch should throw.\n<line_number-190>        assertThrows(\n<line_number-191>                SQLException.class,\n<line_number-192>                () -> d.getUnvalidatedConnection(userURL, p2),\n<line_number-193>                \"The connection should fail because of a user mismatch between the URI and the properties\");\n<line_number-194>\n<line_number-195>        Properties p3 = (Properties) mandatoryProperties.clone();\n<line_number-196>        p3.setProperty(PWD_CONN_KEY, \"dfasdfds\");\n<line_number-197>        // pwd mismatch should throw.\n<line_number-198>        assertThrows(\n<line_number-199>                SQLException.class,\n<line_number-200>                () -> d.getUnvalidatedConnection(userURL, p3),\n<line_number-201>                \"The connection should fail because of a password mismatch between the URI and the properties\");\n<line_number-202>    }\n<line_number-203>\n<line_number-204>    @Test\n<line_number-205>    void testReplURL() throws SQLException {\n<line_number-206>        MongoDriver d = new MongoDriver();\n<line_number-207>        missingConnectionSettings(d, replURL, null);\n<line_number-208>\n<line_number-209>        Properties p = new Properties();\n<line_number-210>        missingConnectionSettings(d, replURL, p);\n<line_number-211>        p = (Properties) mandatoryProperties.clone();\n<line_number-212>        assertNotNull(d.getUnvalidatedConnection(replURL, p));\n<line_number-213>\n<line_number-214>        Properties p2 = (Properties) mandatoryProperties.clone();\n<line_number-215>        p2.setProperty(USER_CONN_KEY, \"dfasdfds\");\n<line_number-216>        // user mismatch should throw.\n<line_number-217>        assertThrows(\n<line_number-218>                SQLException.class,\n<line_number-219>                () -> d.getUnvalidatedConnection(replURL, p2),\n<line_number-220>                \"The connection should fail because of a user mismatch between the URI and the properties\");\n<line_number-221>\n<line_number-222>        Properties p3 = (Properties) mandatoryProperties.clone();\n<line_number-223>        p3.setProperty(PWD_CONN_KEY, \"dfasdfds\");\n<line_number-224>        // pwd mismatch should throw.\n<line_number-225>        assertThrows(\n<line_number-226>                SQLException.class,\n<line_number-227>                () -> d.getUnvalidatedConnection(replURL, p3),\n<line_number-228>                \"The connection should fail because of a password mismatch between the URI and the properties\");\n<line_number-229>    }\n<line_number-230>\n<line_number-231>    @Test\n<line_number-232>    void testMongoDBOIDCAuthMechanismWithUsername() throws SQLException {\n<line_number-233>        MongoDriver d = new MongoDriver();\n<line_number-234>        Properties p = new Properties();\n<line_number-235>\n<line_number-236>        assertNotNull(d.getUnvalidatedConnection(userOIDCURL, p));\n<line_number-237>    }\n<line_number-238>\n<line_number-239>    @Test\n<line_number-240>    void testMongoDBOIDCAuthMechanismWithoutUsername() throws SQLException {\n<line_number-241>        MongoDriver d = new MongoDriver();\n<line_number-242>        Properties p = new Properties();\n<line_number-243>\n<line_number-244>        assertNotNull(d.getUnvalidatedConnection(oidcURL, p));\n<line_number-245>    }\n<line_number-246>\n<line_number-247>    @Test\n<line_number-248>    void testMongoDBOIDCAuthMechanismWithPassword() throws SQLException {\n<line_number-249>        MongoDriver d = new MongoDriver();\n<line_number-250>        Properties p = new Properties();\n<line_number-251>\n<line_number-252>        assertThrows(\n<line_number-253>                SQLException.class,\n<line_number-254>                () -> d.getUnvalidatedConnection(userPwdOIDCURL, p),\n<line_number-255>                \"The connection should fail because password is not allowed with MONGODB-OIDC authentication.\");\n<line_number-256>    }\n<line_number-257>\n<line_number-258>    @Test\n<line_number-259>    void testGetPropertyInfo() throws SQLException {\n<line_number-260>        MongoDriver d = new MongoDriver();\n<line_number-261>\n<line_number-262>        // Should not throw, even with null for Properties.\n<line_number-263>        DriverPropertyInfo[] res = d.getPropertyInfo(basicURL, null);\n<line_number-264>        assertEquals(1, res.length);\n<line_number-265>        assertEquals(DATABASE.getPropertyName(), res[0].name);\n<line_number-266>\n<line_number-267>        Properties p = new Properties();\n<line_number-268>        res = d.getPropertyInfo(basicURL, p);\n<line_number-269>        assertEquals(1, res.length);\n<line_number-270>        assertEquals(DATABASE.getPropertyName(), res[0].name);\n<line_number-271>\n<line_number-272>        p.setProperty(USER_CONN_KEY, \"hello\");\n<line_number-273>        res = d.getPropertyInfo(basicURL, p);\n<line_number-274>        assertEquals(2, res.length);\n<line_number-275>        assertEquals(DATABASE.getPropertyName(), res[0].name);\n<line_number-276>        assertEquals(\"password\", res[1].name);\n<line_number-277>\n<line_number-278>        p = (Properties) mandatoryProperties.clone();\n<line_number-279>        p.setProperty(USER_CONN_KEY, \"hello\");\n<line_number-280>        res = d.getPropertyInfo(basicURL, p);\n<line_number-281>        assertEquals(1, res.length);\n<line_number-282>        assertEquals(\"password\", res[0].name);\n<line_number-283>\n<line_number-284>        p = new Properties();\n<line_number-285>        p.setProperty(PWD_CONN_KEY, \"hello\");\n<line_number-286>        res = d.getPropertyInfo(basicURL, p);\n<line_number-287>        assertEquals(2, res.length);\n<line_number-288>        assertEquals(DATABASE.getPropertyName(), res[0].name);\n<line_number-289>        assertEquals(\"user\", res[1].name);\n<line_number-290>\n<line_number-291>        p = (Properties) mandatoryProperties.clone();\n<line_number-292>        p.setProperty(PWD_CONN_KEY, \"hello\");\n<line_number-293>        res = d.getPropertyInfo(basicURL, p);\n<line_number-294>        assertEquals(1, res.length);\n<line_number-295>        assertEquals(\"user\", res[0].name);\n<line_number-296>    }\n<line_number-297>\n<line_number-298>    @Test\n<line_number-299>    void testInvalidLoggingLevel() throws Exception {\n<line_number-300>        // Default connection settings.\n<line_number-301>        // No logging. No files are created, nothing is logged.\n<line_number-302>        Properties props = new Properties();\n<line_number-303>        props.setProperty(LOG_LEVEL.getPropertyName(), \"NOT_A_LOG_LEVEL.getPropertyName()\");\n<line_number-304>        assertThrows(\n<line_number-305>                SQLException.class,\n<line_number-306>                () -> createConnectionAndVerifyLogFileExists(props),\n<line_number-307>                \"Expected connection to fail because log level is invalid.\");\n<line_number-308>    }\n<line_number-309>\n<line_number-310>    @Test\n<line_number-311>    void testLoggingOff() throws Exception {\n<line_number-312>        // Default connection settings.\n<line_number-313>        // No logging. No files are created, nothing is logged.\n<line_number-314>        Properties props = new Properties();\n<line_number-315>        setLogDir(props);\n<line_number-316>        MongoConnection conn = createConnectionAndVerifyLogFileExists(props);\n<line_number-317>\n<line_number-318>        // Clean-up\n<line_number-319>        cleanupLoggingTest(conn, props);\n<line_number-320>    }\n<line_number-321>\n<line_number-322>    @Test\n<line_number-323>    void testLoggingSevere() throws Exception {\n<line_number-324>        // Creates a log file for the connection. Only logs error.\n<line_number-325>        // Connection is successful, the log file will be empty.\n<line_number-326>        Properties props = new Properties();\n<line_number-327>        setLogDir(props);\n<line_number-328>        props.setProperty(LOG_LEVEL.getPropertyName(), Level.SEVERE.getName());\n<line_number-329>        MongoConnection conn = createConnectionAndVerifyLogFileExists(props);\n<line_number-330>        File logFile = getLogFile(props);\n<line_number-331>        conn.getMetaData();\n<line_number-332>        // The file is still empty because no exception was thrown.\n<line_number-333>        assertTrue(logFile.length() == 0);\n<line_number-334>        // Clean-up\n<line_number-335>        cleanupLoggingTest(conn, props);\n<line_number-336>    }\n<line_number-337>\n<line_number-338>    @Test\n<line_number-339>    void testLoggingSevereWithError() throws Exception {\n<line_number-340>        // Creates a log file for the connection. Only logs error.\n<line_number-341>        // Connection is successful, the log file will be empty.\n<line_number-342>        Properties props = new Properties();\n<line_number-343>        setLogDir(props);\n<line_number-344>        props.setProperty(LOG_LEVEL.getPropertyName(), Level.SEVERE.getName());\n<line_number-345>        MongoConnection conn = createConnectionAndVerifyLogFileExists(props);\n<line_number-346>        try {\n<line_number-347>            conn.getTypeMap(); // Call will fail with a SQLFeatureNotSupportedException\n<line_number-348>            fail(\n<line_number-349>                    \"A SQLFeatureNotSupportedException was expected, but the call to getTypeMap() succeeded.\");\n<line_number-350>        } catch (SQLFeatureNotSupportedException e) {\n<line_number-351>            // Expected. Keep going.\n<line_number-352>        }\n<line_number-353>        File logFile = getLogFile(props);\n<line_number-354>        // The file now contains the log entry for the exception\n<line_number-355>        assertTrue(logFile.length() > 0);\n<line_number-356>        checkLogContent(\n<line_number-357>                logFile,\n<line_number-358>                \"[SEVERE] [c-\"\n<line_number-359>                        + conn.connectionId\n<line_number-360>                        + \"] com.mongodb.jdbc.MongoConnection: Error in MongoConnection.getTypeMap()\",\n<line_number-361>                1);\n<line_number-362>        // Clean-up\n<line_number-363>        cleanupLoggingTest(conn, props);\n<line_number-364>    }\n<line_number-365>\n<line_number-366>    @Test\n<line_number-367>    void testLoggingFiner() throws Exception {\n<line_number-368>        // Creates a log file for the connection. Log public method entries.\n<line_number-369>        // Connection is successful, the log file will contain logs.\n<line_number-370>        Properties props = new Properties();\n<line_number-371>        setLogDir(props);\n<line_number-372>        props.setProperty(LOG_LEVEL.getPropertyName(), Level.FINER.getName());\n<line_number-373>        MongoConnection conn = createConnectionAndVerifyLogFileExists(props);\n<line_number-374>        File logFile = getLogFile(props);\n<line_number-375>        conn.getMetaData();\n<line_number-376>        checkLogContent(\n<line_number-377>                logFile,\n<line_number-378>                \"[FINER] [c-\"\n<line_number-379>                        + conn.connectionId\n<line_number-380>                        + \"] com.mongodb.jdbc.MongoConnection: >> getMetaData()\",\n<line_number-381>                1);\n<line_number-382>\n<line_number-383>        // Clean-up\n<line_number-384>        cleanupLoggingTest(conn, props);\n<line_number-385>    }\n<line_number-386>\n<line_number-387>    @Test\n<line_number-388>    void testCustomLogDir() throws Exception {\n<line_number-389>        // Creates a log file for the connection in the custom directory.\n<line_number-390>        // Log public method entries.\n<line_number-391>        // Connection is successful, the log file will contain logs.\n<line_number-392>        Properties props = new Properties();\n<line_number-393>        props.setProperty(LOG_LEVEL.getPropertyName(), Level.FINER.getName());\n<line_number-394>        File specialLogDir = new File(new File(\".\").getAbsolutePath(), \"customLogDir\");\n<line_number-395>        if (!specialLogDir.exists()) {\n<line_number-396>            specialLogDir.mkdir();\n<line_number-397>        }\n<line_number-398>        props.setProperty(LOG_DIR.getPropertyName(), specialLogDir.getAbsolutePath());\n<line_number-399>\n<line_number-400>        MongoConnection conn = createConnectionAndVerifyLogFileExists(props);\n<line_number-401>        File logFile = getLogFile(props);\n<line_number-402>        conn.getMetaData();\n<line_number-403>        checkLogContent(\n<line_number-404>                logFile,\n<line_number-405>                \"[FINER] [c-\"\n<line_number-406>                        + conn.connectionId\n<line_number-407>                        + \"] com.mongodb.jdbc.MongoConnection: >> getMetaData()\",\n<line_number-408>                1);\n<line_number-409>        // Clean-up\n<line_number-410>        cleanupLoggingTest((MongoConnection) conn, props);\n<line_number-411>    }\n<line_number-412>\n<line_number-413>    @Test\n<line_number-414>    void testInvalidCustomLogDir() throws Exception {\n<line_number-415>        // Set the custom log dir to an invalid path\n<line_number-416>        // Connection is not successful.\n<line_number-417>        Properties props = new Properties();\n<line_number-418>        File specialLogDir = new File(new File(\".\"), \"ThisIsNotAValidPath\");\n<line_number-419>        props.setProperty(LOG_DIR.getPropertyName(), specialLogDir.getAbsolutePath());\n<line_number-420>        assertThrows(\n<line_number-421>                SQLException.class,\n<line_number-422>                () -> createConnectionAndVerifyLogFileExists(props),\n<line_number-423>                \"Expected to fail because the logging directory does not exist.\");\n<line_number-424>    }\n<line_number-425>\n<line_number-426>    @Test\n<line_number-427>    void testLogDirIsConsole() throws Exception {\n<line_number-428>\n<line_number-429>        Properties props = new Properties();\n<line_number-430>        props.setProperty(LOG_DIR.getPropertyName(), MongoDriver.LOG_TO_CONSOLE);\n<line_number-431>        props.setProperty(LOG_LEVEL.getPropertyName(), Level.FINER.getName());\n<line_number-432>        MongoConnection conn = createConnectionAndVerifyLogFileExists(props);\n<line_number-433>        try {\n<line_number-434>            getLogFile(props);\n<line_number-435>            fail(\"There should be no log file since we are logging to console.\");\n<line_number-436>        } catch (Exception e) {\n<line_number-437>            assertEquals(NOT_LOGGING_TO_FILE_ERROR, e.getMessage());\n<line_number-438>        }\n<line_number-439>\n<line_number-440>        // Clean-up\n<line_number-441>        cleanupLoggingTest(conn, props);\n<line_number-442>    }\n<line_number-443>\n<line_number-444>    @Test\n<line_number-445>    void testMultipleConnectionSameLogDir() throws Exception {\n<line_number-446>        // Set the custom log dir to an invalid path\n<line_number-447>        // Connection is not successful.\n<line_number-448>        Properties props = new Properties();\n<line_number-449>        setLogDir(props);\n<line_number-450>        // Create a first connection with level FINER\n<line_number-451>        props.setProperty(LOG_LEVEL.getPropertyName(), Level.FINER.getName());\n<line_number-452>        MongoConnection conn = createConnectionAndVerifyLogFileExists(props);\n<line_number-453>\n<line_number-454>        // Create a first connection with level FINER\n<line_number-455>        Properties props2 = new Properties(props);\n<line_number-456>        props2.setProperty(LOG_LEVEL.getPropertyName(), Level.INFO.getName());\n<line_number-457>        MongoConnection conn2 = createConnectionAndVerifyLogFileExists(props2);\n<line_number-458>\n<line_number-459>        // Validate log content\n<line_number-460>        File logFile = getLogFile(props);\n<line_number-461>        File logFile2 = getLogFile(props2);\n<line_number-462>        assertEquals(logFile.getAbsolutePath(), logFile2.getAbsolutePath());\n<line_number-463>        String connInitPattern =\n<line_number-464>                \"[INFO] [c-{connectionId}] com.mongodb.jdbc.MongoConnection initConnectionLogger: Connecting using MongoDB Atlas SQL interface JDBC Driver\";\n<line_number-465>        checkLogContent(\n<line_number-466>                logFile,\n<line_number-467>                connInitPattern.replace(\"{connectionId}\", String.valueOf(conn.connectionId)),\n<line_number-468>                1);\n<line_number-469>\n<line_number-470>        checkLogContent(\n<line_number-471>                logFile,\n<line_number-472>                connInitPattern.replace(\"{connectionId}\", String.valueOf(conn2.connectionId)),\n<line_number-473>                1);\n<line_number-474>\n<line_number-475>        conn.getMetaData();\n<line_number-476>        String connGetMetadataPattern =\n<line_number-477>                \"[FINER] [c-{connectionId}] com.mongodb.jdbc.MongoConnection: >> getMetaData()\";\n<line_number-478>\n<line_number-479>        checkLogContent(\n<line_number-480>                logFile,\n<line_number-481>                connGetMetadataPattern.replace(\"{connectionId}\", String.valueOf(conn.connectionId)),\n<line_number-482>                1);\n<line_number-483>        checkLogContent(\n<line_number-484>                logFile,\n<line_number-485>                connGetMetadataPattern.replace(\n<line_number-486>                        \"{connectionId}\", String.valueOf(conn2.connectionId)),\n<line_number-487>                0);\n<line_number-488>\n<line_number-489>        try {\n<line_number-490>            conn2.getTypeMap(); // Call will fail with a SQLFeatureNotSupportedException\n<line_number-491>            fail();\n<line_number-492>        } catch (SQLFeatureNotSupportedException e) {\n<line_number-493>            // Expected. Keep going.\n<line_number-494>        }\n<line_number-495>\n<line_number-496>        String errPattern =\n<line_number-497>                \"[SEVERE] [c-{connectionId}] com.mongodb.jdbc.MongoConnection: Error in MongoConnection.getTypeMap()\";\n<line_number-498>        checkLogContent(\n<line_number-499>                logFile,\n<line_number-500>                errPattern.replace(\"{connectionId}\", String.valueOf(conn.connectionId)),\n<line_number-501>                0);\n<line_number-502>\n<line_number-503>        checkLogContent(\n<line_number-504>                logFile,\n<line_number-505>                errPattern.replace(\"{connectionId}\", String.valueOf(conn2.connectionId)),\n<line_number-506>                1);\n<line_number-507>\n<line_number-508>        // Clean-up\n<line_number-509>        cleanupLoggingTest(conn, props);\n<line_number-510>        cleanupLoggingTest(conn2, props2);\n<line_number-511>    }\n<line_number-512>\n<line_number-513>    /**\n<line_number-514>     * Set the LogDir property.\n<line_number-515>     *\n<line_number-516>     * @param props The properties to add LogDir to.\n<line_number-517>     */\n<line_number-518>    private void setLogDir(Properties props) {\n<line_number-519>        String logDirPath = CURRENT_DIR + File.separator + connectionCounter.incrementAndGet();\n<line_number-520>        File logDir = new File(logDirPath);\n<line_number-521>        logDir.mkdir();\n<line_number-522>        props.setProperty(LOG_DIR.getPropertyName(), logDirPath);\n<line_number-523>    }\n<line_number-524>\n<line_number-525>    /**\n<line_number-526>     * Check that the log file contains the expect number of lines and the filtered line.\n<line_number-527>     *\n<line_number-528>     * @param logFile The log file to verify.\n<line_number-529>     * @param filter The filter to apply on the log file to filter log lines.\n<line_number-530>     * @param expectedFilteredLineCount The expected number of filtered log lines.\n<line_number-531>     * @throws IOException If an error occurs reading the log files.\n<line_number-532>     */\n<line_number-533>    private void checkLogContent(File logFile, String filter, int expectedFilteredLineCount)\n<line_number-534>            throws IOException {\n<line_number-535>        // The file now contains the log entry for getMetadata\n<line_number-536>        assertTrue(logFile.length() > 0);\n<line_number-537>        long logLinesCount =\n<line_number-538>                Files.lines(Paths.get(logFile.getAbsolutePath()))\n<line_number-539>                        .filter(s -> s.contains(filter))\n<line_number-540>                        .count();\n<line_number-541>        assertEquals(expectedFilteredLineCount, logLinesCount);\n<line_number-542>    }\n<line_number-543>\n<line_number-544>    /**\n<line_number-545>     * Creates a new Connection and check if the related log file exist if it should.\n<line_number-546>     *\n<line_number-547>     * @param loggingTestProps The logging properties.\n<line_number-548>     * @throws Exception If an error occurs.\n<line_number-549>     */\n<line_number-550>    private MongoConnection createConnectionAndVerifyLogFileExists(Properties loggingTestProps)\n<line_number-551>            throws Exception {\n<line_number-552>        MongoDriver d = new MongoDriver();\n<line_number-553>        loggingTestProps.setProperty(DATABASE.getPropertyName(), \"admin\");\n<line_number-554>\n<line_number-555>        MongoConnection connection = d.getUnvalidatedConnection(userURL, loggingTestProps);\n<line_number-556>        assertNotNull(connection);\n<line_number-557>\n<line_number-558>        if (null != loggingTestProps.getProperty(LOG_LEVEL.getPropertyName())\n<line_number-559>                && !loggingTestProps\n<line_number-560>                        .getProperty(LOG_LEVEL.getPropertyName())\n<line_number-561>                        .equals(Level.OFF.getName())\n<line_number-562>                && !logToConsole(loggingTestProps)) {\n<line_number-563>            assertTrue(getLogFile(loggingTestProps).exists());\n<line_number-564>        }\n<line_number-565>        return connection;\n<line_number-566>    }\n<line_number-567>\n<line_number-568>    /**\n<line_number-569>     * Get the log file which will be associated with the connection when/if logging is turned on.\n<line_number-570>     *\n<line_number-571>     * @param loggingTestProps The connection settings related to logging.\n<line_number-572>     * @return The log file.\n<line_number-573>     * @throws Exception If the connection is not logging to files (either console or no logging).\n<line_number-574>     */\n<line_number-575>    private File getLogFile(Properties loggingTestProps) throws Exception {\n<line_number-576>        if (loggingTestProps == null || logToConsole(loggingTestProps)) {\n<line_number-577>            throw new Exception(NOT_LOGGING_TO_FILE_ERROR);\n<line_number-578>        }\n<line_number-579>\n<line_number-580>        File logFile =\n<line_number-581>                new File(\n<line_number-582>                        loggingTestProps.getProperty(LOG_DIR.getPropertyName())\n<line_number-583>                                + File.separator\n<line_number-584>                                + \"connection.log\");\n<line_number-585>        return logFile;\n<line_number-586>    }\n<line_number-587>\n<line_number-588>    /**\n<line_number-589>     * Check if the connection is going to log to Console or a file.\n<line_number-590>     *\n<line_number-591>     * @param loggingTestProps The connection settings related to logging.\n<line_number-592>     * @return True if logging to console, false if logging to a file.\n<line_number-593>     * @throws Exception If the connection is not logging.\n<line_number-594>     */\n<line_number-595>    private boolean logToConsole(Properties loggingTestProps) throws Exception {\n<line_number-596>        if (loggingTestProps == null) {\n<line_number-597>            throw new Exception(\"Logging not enabled.\");\n<line_number-598>        } else {\n<line_number-599>            return loggingTestProps.getProperty(LOG_DIR.getPropertyName()) == null\n<line_number-600>                    || loggingTestProps\n<line_number-601>                            .getProperty(LOG_DIR.getPropertyName())\n<line_number-602>                            .equalsIgnoreCase(MongoDriver.LOG_TO_CONSOLE);\n<line_number-603>        }\n<line_number-604>    }\n<line_number-605>\n<line_number-606>    /**\n<line_number-607>     * Close the connection and remove the log file if it exists.\n<line_number-608>     *\n<line_number-609>     * @param conn The connection.\n<line_number-610>     * @param props The connection settings.\n<line_number-611>     */\n<line_number-612>    private void cleanupLoggingTest(MongoConnection conn, Properties props) {\n<line_number-613>        try {\n<line_number-614>            conn.close();\n<line_number-615>            File logDir = new File(props.getProperty(LOG_DIR.getPropertyName()));\n<line_number-616>            if (logDir.exists()) {\n<line_number-617>                for (File file : logDir.listFiles()) {\n<line_number-618>                    // Delete log file before delete directory because\n<line_number-619>                    // the directory must be empty for delete to work\n<line_number-620>                    file.delete();\n<line_number-621>                }\n<line_number-622>                logDir.delete();\n<line_number-623>            }\n<line_number-624>        } catch (Exception e) {\n<line_number-625>            e.printStackTrace();\n<line_number-626>            // Ignore clean-up error if any\n<line_number-627>        }\n<line_number-628>    }\n<line_number-629>\n<line_number-630>    @Test\n<line_number-631>    void testClientInfoProperty() throws Exception {\n<line_number-632>        MongoDriver d = new MongoDriver();\n<line_number-633>        Properties p = new Properties();\n<line_number-634>        Connection c;\n<line_number-635>        p.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-636>\n<line_number-637>        // ClientInfo not set succeeds\n<line_number-638>        c = d.getUnvalidatedConnection(basicURL, p);\n<line_number-639>        assertNotNull(c);\n<line_number-640>\n<line_number-641>        // Invalid ClientInfo property results in Exception\n<line_number-642>        p.setProperty(CLIENT_INFO.getPropertyName(), \"InvalidFormat\");\n<line_number-643>        assertThrows(\n<line_number-644>                SQLException.class,\n<line_number-645>                () -> d.getUnvalidatedConnection(basicURL, p),\n<line_number-646>                \"The connection should fail because expected format is <name>+<version>.\");\n<line_number-647>\n<line_number-648>        p.setProperty(CLIENT_INFO.getPropertyName(), \"name+version\");\n<line_number-649>        c = d.getUnvalidatedConnection(basicURL, p);\n<line_number-650>        assertNotNull(c);\n<line_number-651>    }\n<line_number-652>\n<line_number-653>    @Test\n<line_number-654>    void testExtJsonModeProperty() throws Exception {\n<line_number-655>        MongoDriver d = new MongoDriver();\n<line_number-656>        Properties p = new Properties();\n<line_number-657>        Connection c;\n<line_number-658>        p.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-659>\n<line_number-660>        // ExtJsonMode not set succeeds\n<line_number-661>        c = d.getUnvalidatedConnection(basicURL, p);\n<line_number-662>        assertNotNull(c);\n<line_number-663>\n<line_number-664>        // Invalid ExtJsonMode property results in Exception\n<line_number-665>        p.setProperty(EXT_JSON_MODE.getPropertyName(), \"InvalidMode\");\n<line_number-666>        assertThrows(\n<line_number-667>                SQLException.class,\n<line_number-668>                () -> d.getUnvalidatedConnection(basicURL, p),\n<line_number-669>                \"The connection should fail because expected input is RELAXED or EXTENDED.\");\n<line_number-670>\n<line_number-671>        p.setProperty(EXT_JSON_MODE.getPropertyName(), \"EXTENDED\");\n<line_number-672>        c = d.getUnvalidatedConnection(basicURL, p);\n<line_number-673>        assertNotNull(c);\n<line_number-674>\n<line_number-675>        p.setProperty(EXT_JSON_MODE.getPropertyName(), \"RELAXED\");\n<line_number-676>        c = d.getUnvalidatedConnection(basicURL, p);\n<line_number-677>        assertNotNull(c);\n<line_number-678>    }\n<line_number-679>\n<line_number-680>    @Test\n<line_number-681>    void testClientCaching() throws Exception {\n<line_number-682>        MongoDriver d = new MongoDriver();\n<line_number-683>        Properties p = new Properties();\n<line_number-684>        p.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-685>\n<line_number-686>        // Create three connections with the same properties\n<line_number-687>        MongoConnection conn1 = d.getUnvalidatedConnection(basicURL, p);\n<line_number-688>        MongoConnection conn2 = d.getUnvalidatedConnection(basicURL, p);\n<line_number-689>        MongoConnection conn3 = d.getUnvalidatedConnection(basicURL, p);\n<line_number-690>\n<line_number-691>        // Verify that the connections share the same MongoClient instance\n<line_number-692>        assertSame(conn1.getMongoClient(), conn2.getMongoClient());\n<line_number-693>        assertSame(conn1.getMongoClient(), conn3.getMongoClient());\n<line_number-694>    }\n<line_number-695>\n<line_number-696>    @Test\n<line_number-697>    void testClientCachingWithDifferentKeyedProperties() throws Exception {\n<line_number-698>        MongoDriver d = new MongoDriver();\n<line_number-699>\n<line_number-700>        Properties p1 = new Properties();\n<line_number-701>        p1.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-702>        p1.setProperty(CLIENT_INFO.getPropertyName(), \"app1+1.0\");\n<line_number-703>        MongoConnection conn1 = d.getUnvalidatedConnection(basicURL, p1);\n<line_number-704>\n<line_number-705>        Properties p2 = new Properties();\n<line_number-706>        p2.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-707>        p2.setProperty(CLIENT_INFO.getPropertyName(), \"app2+1.0\");\n<line_number-708>        // Create connection with different client info\n<line_number-709>        MongoConnection conn2 = d.getUnvalidatedConnection(basicURL, p2);\n<line_number-710>\n<line_number-711>        assertNotSame(conn1.getMongoClient(), conn2.getMongoClient());\n<line_number-712>    }\n<line_number-713>\n<line_number-714>    @Test\n<line_number-715>    void testClientCachingWithDifferentUnkeyedProperties() throws Exception {\n<line_number-716>        // Testing with different JSON modes, a property that is not part of the unique key used\n<line_number-717>        // for caching.\n<line_number-718>        MongoDriver d = new MongoDriver();\n<line_number-719>\n<line_number-720>        // Create connections with different extended JSON mode\n<line_number-721>        Properties p1 = new Properties();\n<line_number-722>        p1.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-723>        p1.setProperty(EXT_JSON_MODE.getPropertyName(), \"RELAXED\");\n<line_number-724>\n<line_number-725>        Properties p2 = new Properties();\n<line_number-726>        p2.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-727>        p2.setProperty(EXT_JSON_MODE.getPropertyName(), \"EXTENDED\");\n<line_number-728>\n<line_number-729>        MongoConnection conn1 = d.getUnvalidatedConnection(basicURL, p1);\n<line_number-730>        MongoConnection conn2 = d.getUnvalidatedConnection(basicURL, p2);\n<line_number-731>\n<line_number-732>        assertSame(conn1.getMongoClient(), conn2.getMongoClient());\n<line_number-733>    }\n<line_number-734>\n<line_number-735>    @Test\n<line_number-736>    void testMongoDBX509AuthMechanismWithoutPassphrase() throws SQLException {\n<line_number-737>        MongoDriver d = new MongoDriver();\n<line_number-738>        Properties p = new Properties();\n<line_number-739>        p.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-740>\n<line_number-741>        String x509URL = \"jdbc:mongodb://localhost/test?authMechanism=MONGODB-X509\";\n<line_number-742>        assertThrows(\n<line_number-743>                IllegalStateException.class,\n<line_number-744>                () -> d.getUnvalidatedConnection(x509URL, p),\n<line_number-745>                \"Expected to fail because x509Passphrase is missing.\");\n<line_number-746>    }\n<line_number-747>\n<line_number-748>    @Test\n<line_number-749>    void testMongoDBX509WithPemPathAndPassphrase() throws SQLException {\n<line_number-750>        String passphrase = \"passphrase\";\n<line_number-751>\n<line_number-752>        MongoDriver d = new MongoDriver();\n<line_number-753>        Properties p = new Properties();\n<line_number-754>        p.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-755>        p.setProperty(\n<line_number-756>                MongoDriver.MongoJDBCProperty.X509_PEM_PATH.getPropertyName(), \"valid-path.pem\");\n<line_number-757>        p.setProperty(\"password\", passphrase);\n<line_number-758>\n<line_number-759>        String x509URL = \"jdbc:mongodb://localhost/test?authMechanism=MONGODB-X509\";\n<line_number-760>\n<line_number-761>        MongoDriver.MongoConnectionConfig config = d.getConnectionSettings(x509URL, p);\n<line_number-762>\n<line_number-763>        assertNotNull(config.connectionString, \"Connection string should be created.\");\n<line_number-764>        assertNull(config.connectionString.getUsername(), \"Username should be null.\");\n<line_number-765>        assertNull(config.connectionString.getPassword(), \"Password should be null.\");\n<line_number-766>        assertEquals(\n<line_number-767>                AuthenticationMechanism.MONGODB_X509,\n<line_number-768>                config.connectionString.getCredential().getAuthenticationMechanism(),\n<line_number-769>                \"Authentication mechanism should be MONGODB_X509.\");\n<line_number-770>        assertArrayEquals(\n<line_number-771>                passphrase.toCharArray(),\n<line_number-772>                config.x509Passphrase,\n<line_number-773>                \"x509Passphrase should match the provided value.\");\n<line_number-774>    }\n<line_number-775>\n<line_number-776>    private int getClientCacheSize() throws NoSuchFieldException, IllegalAccessException {\n<line_number-777>        Field cacheField = MongoDriver.class.getDeclaredField(\"mongoClientCache\");\n<line_number-778>        cacheField.setAccessible(true);\n<line_number-779>        ConcurrentHashMap<Integer, WeakReference<MongoClient>> cache =\n<line_number-780>                (ConcurrentHashMap<Integer, WeakReference<MongoClient>>) cacheField.get(null);\n<line_number-781>\n<line_number-782>        Field lockField = MongoDriver.class.getDeclaredField(\"mongoClientCacheLock\");\n<line_number-783>        lockField.setAccessible(true);\n<line_number-784>        ReadWriteLock lock = (ReadWriteLock) lockField.get(null);\n<line_number-785>\n<line_number-786>        lock.readLock().lock();\n<line_number-787>        try {\n<line_number-788>            return cache.size();\n<line_number-789>        } finally {\n<line_number-790>            lock.readLock().unlock();\n<line_number-791>        }\n<line_number-792>    }\n<line_number-793>\n<line_number-794>    private void clearClientCache() throws NoSuchFieldException, IllegalAccessException {\n<line_number-795>        Field cacheField = MongoDriver.class.getDeclaredField(\"mongoClientCache\");\n<line_number-796>        cacheField.setAccessible(true);\n<line_number-797>        ConcurrentHashMap<Integer, WeakReference<MongoClient>> cache =\n<line_number-798>                (ConcurrentHashMap<Integer, WeakReference<MongoClient>>) cacheField.get(null);\n<line_number-799>\n<line_number-800>        Field lockField = MongoDriver.class.getDeclaredField(\"mongoClientCacheLock\");\n<line_number-801>        lockField.setAccessible(true);\n<line_number-802>        ReadWriteLock lock = (ReadWriteLock) lockField.get(null);\n<line_number-803>\n<line_number-804>        lock.writeLock().lock();\n<line_number-805>        try {\n<line_number-806>            cache.clear();\n<line_number-807>        } finally {\n<line_number-808>            lock.writeLock().unlock();\n<line_number-809>        }\n<line_number-810>    }\n<line_number-811>\n<line_number-812>    void testDisableClientCacheAux(String value)\n<line_number-813>            throws SQLException, NoSuchFieldException, IllegalAccessException {\n<line_number-814>        MongoDriver d = new MongoDriver();\n<line_number-815>        clearClientCache();\n<line_number-816>        Properties p = new Properties();\n<line_number-817>        p.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-818>        p.setProperty(MongoDriver.MongoJDBCProperty.DISABLE_CLIENT_CACHE.getPropertyName(), value);\n<line_number-819>\n<line_number-820>        // Create two connections with the same properties\n<line_number-821>        MongoConnection conn1 = d.getUnvalidatedConnection(basicURL, p);\n<line_number-822>        MongoConnection conn2 = d.getUnvalidatedConnection(basicURL, p);\n<line_number-823>\n<line_number-824>        assertEquals(\n<line_number-825>                0,\n<line_number-826>                getClientCacheSize(),\n<line_number-827>                \"Client cache should be empty when DISABLE_CLIENT_CACHE is set to true.\");\n<line_number-828>        // Verify that the connections do not share the same MongoClient instance\n<line_number-829>        assertNotSame(conn1.getMongoClient(), conn2.getMongoClient());\n<line_number-830>    }\n<line_number-831>\n<line_number-832>    void testNoDisableClientCacheAux(String value)\n<line_number-833>            throws SQLException, NoSuchFieldException, IllegalAccessException {\n<line_number-834>        MongoDriver d = new MongoDriver();\n<line_number-835>        clearClientCache();\n<line_number-836>        Properties p = new Properties();\n<line_number-837>        p.setProperty(DATABASE.getPropertyName(), \"test\");\n<line_number-838>        p.setProperty(MongoDriver.MongoJDBCProperty.DISABLE_CLIENT_CACHE.getPropertyName(), value);\n<line_number-839>\n<line_number-840>        // Create two connections with the same properties\n<line_number-841>        MongoConnection conn1 = d.getUnvalidatedConnection(basicURL, p);\n<line_number-842>        MongoConnection conn2 = d.getUnvalidatedConnection(basicURL, p);\n<line_number-843>\n<line_number-844>        // Verify that the connections do not share the same MongoClient instance\n<line_number-845>        assertEquals(\n<line_number-846>                getClientCacheSize(),\n<line_number-847>                1,\n<line_number-848>                \"Client cache should be empty when DISABLE_CLIENT_CACHE is set to true.\");\n<line_number-849>        assertEquals(conn1.getMongoClient(), conn2.getMongoClient());\n<line_number-850>    }\n<line_number-851>\n<line_number-852>    @Test\n<line_number-853>    void testDisableClientCache()\n<line_number-854>            throws SQLException, NoSuchFieldException, IllegalAccessException {\n<line_number-855>        testDisableClientCacheAux(\"true\");\n<line_number-856>        testDisableClientCacheAux(\"TRUE\");\n<line_number-857>        testDisableClientCacheAux(\"TrUe\");\n<line_number-858>        testDisableClientCacheAux(\"1\");\n<line_number-859>        testDisableClientCacheAux(\"YeS\");\n<line_number-860>\n<line_number-861>        testNoDisableClientCacheAux(\"false\");\n<line_number-862>        testNoDisableClientCacheAux(\"FALSE\");\n<line_number-863>        testNoDisableClientCacheAux(\"0\");\n<line_number-864>    }\n<line_number-865>\n<line_number-866>    @Test\n<line_number-867>    void testNullPropValue() throws Exception {\n<line_number-868>        // Create a new Properties object.\n<line_number-869>        Properties p = new Properties();\n<line_number-870>        MongoDriver d = new MongoDriver();\n<line_number-871>        // Put a key-value pair into the Properties object, with the value being an object.\n<line_number-872>        p.put(USER_CONN_KEY, new Pair<Double, Boolean>(6.0, true));\n<line_number-873>        p.setProperty(PWD_CONN_KEY, PWD);\n<line_number-874>        p.setProperty(DB_CONN_KEY, DB);\n<line_number-875>\n<line_number-876>        assertThrows(SQLException.class, () -> d.connect(\"jdbc:\" + localhost, p));\n<line_number-877>\n<line_number-878>        try {\n<line_number-879>            d.connect(\"jdbc:\" + localhost, p);\n<line_number-880>        } catch (Exception e) {\n<line_number-881>            e.printStackTrace();\n<line_number-882>        }\n<line_number-883>    }\n<line_number-884>\n<line_number-885>    @Test\n<line_number-886>    void testNullPropKey() throws Exception {\n<line_number-887>        // Create a new Properties object.\n<line_number-888>        Properties p = new Properties();\n<line_number-889>        MongoDriver d = new MongoDriver();\n<line_number-890>        // Put a key-value pair into the Properties object, with the value being an object.\n<line_number-891>        p.put(new Pair<Double, Boolean>(6.0, true), USER);\n<line_number-892>        p.setProperty(PWD_CONN_KEY, PWD);\n<line_number-893>        p.setProperty(DB_CONN_KEY, DB);\n<line_number-894>\n<line_number-895>        assertThrows(SQLException.class, () -> d.connect(\"jdbc:\" + localhost, p));\n<line_number-896>\n<line_number-897>        try {\n<line_number-898>            d.connect(\"jdbc:\" + localhost, p);\n<line_number-899>        } catch (Exception e) {\n<line_number-900>            e.printStackTrace();\n<line_number-901>        }\n<line_number-902>    }\n<line_number-903>}\n",
        "comments": [
          {
            "comment_code_range": "46-48",
            "comment_linenumber": "45",
            "comment": "This class contains unit tests for the MongoDriver, validating various connection scenarios and properties.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "81-88",
            "comment_linenumber": "80",
            "comment": "Sets mandatory properties for the MongoDriver connection, specifically the database name.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "90-93",
            "comment_linenumber": "89",
            "comment": "Initializes Mockito mocks before all tests are run.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "95-111",
            "comment_linenumber": "94",
            "comment": "Tests the basic connection URL handling, ensuring mandatory properties are validated correctly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "114-120",
            "comment_linenumber": "113",
            "comment": "Validates the connection using a URI that includes the database name.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "123-139",
            "comment_linenumber": "122",
            "comment": "Checks that missing connection settings do not throw exceptions but return null.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "141-150",
            "comment_linenumber": "140",
            "comment": "Tests the connection URL without a password, expecting an SQLException due to invalid URI.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "156-168",
            "comment_linenumber": "155",
            "comment": "Tests the JDBC connection URL, ensuring user mismatch throws an exception.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "171-201",
            "comment_linenumber": "170",
            "comment": "Validates user connection URL handling, ensuring proper exception handling for mismatched credentials.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "204-228",
            "comment_linenumber": "203",
            "comment": "Tests the replication connection URL, ensuring it handles user mismatches correctly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "231-236",
            "comment_linenumber": "230",
            "comment": "Tests MongoDB OIDC authentication mechanism with a username.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "240-245",
            "comment_linenumber": "239",
            "comment": "Tests MongoDB OIDC authentication mechanism without a username.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "248-256",
            "comment_linenumber": "247",
            "comment": "Tests MongoDB OIDC authentication mechanism with a password, expecting an exception.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "259-295",
            "comment_linenumber": "258",
            "comment": "Tests the retrieval of property information from the MongoDriver, ensuring correct properties are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "298-307",
            "comment_linenumber": "296",
            "comment": "Tests invalid logging level handling, expecting an SQLException.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "310-320",
            "comment_linenumber": "309",
            "comment": "Tests logging off scenario, ensuring no log files are created.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "323-335",
            "comment_linenumber": "322",
            "comment": "Tests severe logging level, ensuring log file remains empty on successful connection.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "338-355",
            "comment_linenumber": "336",
            "comment": "Tests severe logging with an error, ensuring log file captures the exception.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "367-410",
            "comment_linenumber": "366",
            "comment": "Tests logging with a custom directory, ensuring logs are created correctly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "413-424",
            "comment_linenumber": "412",
            "comment": "Tests invalid custom log directory handling, expecting an SQLException.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "426-441",
            "comment_linenumber": "425",
            "comment": "Tests logging to console, ensuring no log file is created.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "444-510",
            "comment_linenumber": "443",
            "comment": "Tests multiple connections to the same log directory, ensuring log content is validated correctly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "513-523",
            "comment_linenumber": "512",
            "comment": "Sets the log directory property in the provided properties object.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "525-541",
            "comment_linenumber": "524",
            "comment": "Checks the log content for expected entries and counts.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "544-566",
            "comment_linenumber": "543",
            "comment": "Creates a new connection and verifies the associated log file exists if logging is enabled.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "568-586",
            "comment_linenumber": "567",
            "comment": "Retrieves the log file associated with the connection, throwing an exception if not logging to files.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "588-604",
            "comment_linenumber": "587",
            "comment": "Checks if the connection is logging to console or a file.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "606-628",
            "comment_linenumber": "605",
            "comment": "Cleans up the logging test by closing the connection and deleting log files.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "630-650",
            "comment_linenumber": "629",
            "comment": "Tests the client info property handling, ensuring valid and invalid formats are processed correctly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "653-678",
            "comment_linenumber": "652",
            "comment": "Tests the extended JSON mode property handling, ensuring valid and invalid formats are processed correctly.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "680-694",
            "comment_linenumber": "679",
            "comment": "Tests client caching behavior, ensuring multiple connections share the same MongoClient instance.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "696-711",
            "comment_linenumber": "695",
            "comment": "Tests client caching with different keyed properties, ensuring separate MongoClient instances are created.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "714-732",
            "comment_linenumber": "713",
            "comment": "Tests client caching with different unkeyed properties, ensuring shared MongoClient instances are used.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "735-746",
            "comment_linenumber": "734",
            "comment": "Tests MongoDB X.509 authentication mechanism without a passphrase, expecting an exception.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "748-773",
            "comment_linenumber": "747",
            "comment": "Tests MongoDB X.509 authentication with a PEM path and passphrase, ensuring correct configuration.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "776-791",
            "comment_linenumber": "775",
            "comment": "Retrieves the size of the client cache using reflection to access private fields.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "794-808",
            "comment_linenumber": "793",
            "comment": "Clears the client cache using reflection to access private fields.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "812-830",
            "comment_linenumber": "811",
            "comment": "Tests disabling the client cache, ensuring separate MongoClient instances are created.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "832-850",
            "comment_linenumber": "831",
            "comment": "Tests not disabling the client cache, ensuring shared MongoClient instances are used.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "852-864",
            "comment_linenumber": "851",
            "comment": "Tests various scenarios for disabling the client cache, ensuring correct behavior.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "866-895",
            "comment_linenumber": "865",
            "comment": "Tests handling of null property values in connection properties, expecting an SQLException.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "886-895",
            "comment_linenumber": "885",
            "comment": "Tests handling of null property keys in connection properties, expecting an SQLException.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoDriverTest.java' is a JUnit test class designed to validate the functionality of the MongoDriver class in the com.mongodb.jdbc package. It employs the Mockito framework for mocking dependencies and follows a structured approach to test various connection scenarios, including handling of different authentication mechanisms, connection URLs, and logging configurations. The class is annotated with @ExtendWith(MockitoExtension.class) to enable Mockito support and @TestInstance(TestInstance.Lifecycle.PER_CLASS) to allow instance-level lifecycle methods. \n\nThe class contains multiple test methods, each focusing on specific aspects of the MongoDriver's behavior. It initializes properties for database connections and validates expected outcomes, such as successful connections or thrown exceptions. The tests cover a wide range of scenarios, including basic URL validation, user authentication, logging behavior, and client caching. \n\nKey methods include 'setProperties' for initializing mandatory properties, 'initMocks' for setting up mocks, and various test methods that assert the expected behavior of the MongoDriver under different conditions. The class also includes private utility methods for managing logging directories and verifying log content. Overall, the structure is organized to facilitate clear and maintainable test cases, ensuring comprehensive coverage of the MongoDriver's functionality.",
        "file_summary": "The 'MongoDriverTest.java' file contains unit tests for the MongoDriver class, validating its connection handling, authentication mechanisms, and logging configurations. It ensures that the driver behaves correctly under various scenarios, including error handling and property validation, using the JUnit and Mockito frameworks."
      }
    ]
  },
  "MongoJsonSchemaTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoJsonSchemaTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\MongoJsonSchemaTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoJsonSchemaTest.java",
        "chunk_id": "MongoJsonSchemaTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static org.bson.codecs.configuration.CodecRegistries.fromProviders;\n<line_number-20>import static org.junit.jupiter.api.Assertions.assertEquals;\n<line_number-21>import static org.junit.jupiter.api.Assertions.assertTrue;\n<line_number-22>\n<line_number-23>import java.io.File;\n<line_number-24>import java.io.FileNotFoundException;\n<line_number-25>import java.io.FileReader;\n<line_number-26>import java.io.StringReader;\n<line_number-27>import java.sql.SQLException;\n<line_number-28>import java.util.ArrayList;\n<line_number-29>import java.util.Collection;\n<line_number-30>import java.util.List;\n<line_number-31>import org.bson.BsonDocument;\n<line_number-32>import org.bson.BsonDocumentWriter;\n<line_number-33>import org.bson.BsonWriter;\n<line_number-34>import org.bson.codecs.BsonValueCodecProvider;\n<line_number-35>import org.bson.codecs.Codec;\n<line_number-36>import org.bson.codecs.DecoderContext;\n<line_number-37>import org.bson.codecs.EncoderContext;\n<line_number-38>import org.bson.codecs.ValueCodecProvider;\n<line_number-39>import org.bson.codecs.configuration.CodecRegistry;\n<line_number-40>import org.bson.codecs.pojo.PojoCodecProvider;\n<line_number-41>import org.bson.json.JsonReader;\n<line_number-42>import org.bson.json.JsonWriterSettings;\n<line_number-43>import org.junit.jupiter.api.DynamicTest;\n<line_number-44>import org.junit.jupiter.api.Test;\n<line_number-45>import org.junit.jupiter.api.TestFactory;\n<line_number-46>\n<line_number-47>/** Test the deserialization and simplifacation of JsonSchema returned by a sqlgetschema command. */\n<line_number-48>public class MongoJsonSchemaTest {\n<line_number-49>    static final CodecRegistry REGISTRY =\n<line_number-50>            fromProviders(\n<line_number-51>                    new BsonValueCodecProvider(),\n<line_number-52>                    new ValueCodecProvider(),\n<line_number-53>                    PojoCodecProvider.builder().automatic(true).build());\n<line_number-54>    static final Codec<MongoJsonSchema> MONGO_JSON_SCHEMA_CODEC =\n<line_number-55>            REGISTRY.get(MongoJsonSchema.class);\n<line_number-56>    static final Codec<MongoVersionedJsonSchema> MONGO_VERSIONED_JSON_SCHEMA_CODEC =\n<line_number-57>            REGISTRY.get(MongoVersionedJsonSchema.class);\n<line_number-58>    static final Codec<JsonSchema> JSON_SCHEMA_CODEC = REGISTRY.get(JsonSchema.class);\n<line_number-59>\n<line_number-60>    @TestFactory\n<line_number-61>    Collection<DynamicTest> runIntegrationTests() throws SQLException {\n<line_number-62>        ClassLoader classLoader = getClass().getClassLoader();\n<line_number-63>        File input = new File(classLoader.getResource(\"mongoJsonSchemaTest/input\").getFile());\n<line_number-64>        assertTrue(input.isDirectory(), input.getPath() + \" is not a directory.\");\n<line_number-65>        File expectedOutput =\n<line_number-66>                new File(classLoader.getResource(\"mongoJsonSchemaTest/expectedOutput\").getFile());\n<line_number-67>        assertTrue(expectedOutput.isDirectory(), expectedOutput.getPath() + \" is not a directory.\");\n<line_number-68>        List<DynamicTest> dynamicTests = new ArrayList<>();\n<line_number-69>        for (File testEntry : input.listFiles()) {\n<line_number-70>            File output = new File(expectedOutput.getAbsoluteFile() + \"/\" + testEntry.getName());\n<line_number-71>            dynamicTests.add(\n<line_number-72>                    DynamicTest.dynamicTest(\n<line_number-73>                            testEntry.getName(),\n<line_number-74>                            () -> {\n<line_number-75>                                System.out.println(\n<line_number-76>                                        \"Comparing \"\n<line_number-77>                                                + testEntry.getName()\n<line_number-78>                                                + \" with \"\n<line_number-79>                                                + output.getName());\n<line_number-80>                                testDeserializeAndSimplifySchema(testEntry, output);\n<line_number-81>                            }));\n<line_number-82>        }\n<line_number-83>        return dynamicTests;\n<line_number-84>    }\n<line_number-85>\n<line_number-86>    @Test\n<line_number-87>    public void testEmptySchema() throws Exception {\n<line_number-88>        JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build();\n<line_number-89>\n<line_number-90>        // Deserializes empty documents\n<line_number-91>        Codec[] schemaCodecs = {\n<line_number-92>            JSON_SCHEMA_CODEC, MONGO_JSON_SCHEMA_CODEC, MONGO_VERSIONED_JSON_SCHEMA_CODEC\n<line_number-93>        };\n<line_number-94>        for (Codec codec : schemaCodecs) {\n<line_number-95>            Class encoderClass = codec.getEncoderClass();\n<line_number-96>            // Encode an \"emtpy\" object using the default constructor with no arguments for the class associated to the codec\n<line_number-97>            BsonDocument docFromEmptyObj = new BsonDocument();\n<line_number-98>            BsonWriter writer = new BsonDocumentWriter(docFromEmptyObj);\n<line_number-99>            codec.encode(\n<line_number-100>                    writer,\n<line_number-101>                    encoderClass.getConstructor().newInstance(),\n<line_number-102>                    EncoderContext.builder().build());\n<line_number-103>            writer.flush();\n<line_number-104>\n<line_number-105>            try (JsonReader reader = new JsonReader(new StringReader(\"{}\"))) {\n<line_number-106>                // Decode the empty document\n<line_number-107>                Object encodedObj = codec.decode(reader, DecoderContext.builder().build());\n<line_number-108>                assertEquals(encoderClass, encodedObj.getClass());\n<line_number-109>\n<line_number-110>                // Re-encode the decoded schema and check its content, verify that it matches a new \"empty\" instance\n<line_number-111>                BsonDocument docFromDecodedEmptyJson = new BsonDocument();\n<line_number-112>                writer = new BsonDocumentWriter(docFromDecodedEmptyJson);\n<line_number-113>                codec.encode(writer, encodedObj, EncoderContext.builder().build());\n<line_number-114>                writer.flush();\n<line_number-115>\n<line_number-116>                assertEquals(\n<line_number-117>                        docFromEmptyObj.toJson(settings), docFromDecodedEmptyJson.toJson(settings));\n<line_number-118>            }\n<line_number-119>        }\n<line_number-120>    }\n<line_number-121>\n<line_number-122>    private void testDeserializeAndSimplifySchema(File input, File output)\n<line_number-123>            throws FileNotFoundException {\n<line_number-124>        JsonSchema in_schema = null;\n<line_number-125>        MongoJsonSchema out_schema = null;\n<line_number-126>        // Decode the input\n<line_number-127>        try (JsonReader reader = new JsonReader(new FileReader(input))) {\n<line_number-128>            in_schema = JSON_SCHEMA_CODEC.decode(reader, DecoderContext.builder().build());\n<line_number-129>        }\n<line_number-130>        // Decode the expected out as jsonSchema to make sure that no simplification is happening\n<line_number-131>        // except the transformation from String to Set<String> if necessary for bsonType.\n<line_number-132>        try (JsonReader reader = new JsonReader(new FileReader(output))) {\n<line_number-133>            out_schema = MONGO_JSON_SCHEMA_CODEC.decode(reader, DecoderContext.builder().build());\n<line_number-134>        }\n<line_number-135>\n<line_number-136>        // Transform the mongoJsonSchema to a JsonSchema for comparing each other\n<line_number-137>        MongoJsonSchema simplifiedSchema = MongoJsonSchema.toSimplifiedMongoJsonSchema(in_schema);\n<line_number-138>\n<line_number-139>        assertEquals(simplifiedSchema, out_schema);\n<line_number-140>    }\n<line_number-141>}\n",
        "comments": [
          {
            "comment_code_range": "47-48",
            "comment_linenumber": "46",
            "comment": "Test the deserialization and simplification of JsonSchema returned by a sqlgetschema command.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "60-84",
            "comment_linenumber": "59",
            "comment": "Runs integration tests by comparing generated schemas against expected output from files in specified directories.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "86-120",
            "comment_linenumber": "85",
            "comment": "Tests the deserialization of empty schemas and verifies that encoding and decoding produce consistent results.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "122-140",
            "comment_linenumber": "121",
            "comment": "Deserializes input and output schemas from files, transforms the input schema, and asserts equality with the expected output schema.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "90-90",
            "comment_linenumber": "89",
            "comment": "Deserializes empty documents.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "96-96",
            "comment_linenumber": "95",
            "comment": "Encode an 'empty' object using the default constructor with no arguments for the class associated to the codec.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "106-106",
            "comment_linenumber": "105",
            "comment": "Decode the empty document.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "130-130",
            "comment_linenumber": "129",
            "comment": "Decode the expected output as JsonSchema to ensure no simplification occurs except necessary transformations.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "136-136",
            "comment_linenumber": "135",
            "comment": "Transform the MongoJsonSchema to a JsonSchema for comparison.",
            "comment_kind": "block"
          }
        ],
        "structural_analysis": "The file 'MongoJsonSchemaTest.java' is a JUnit test class designed to validate the deserialization and simplification of JSON schemas returned by a SQL command. It employs the Strategy design pattern by utilizing various codecs for encoding and decoding BSON documents. The primary class, 'MongoJsonSchemaTest', contains static codec registry fields for handling different schema types. The class includes integration tests that dynamically generate tests based on input files, ensuring that the output matches expected results. The 'runIntegrationTests' method orchestrates the loading of input and expected output directories, iterating through files to create dynamic tests. The 'testEmptySchema' method checks the behavior of the codecs when handling empty schemas, ensuring that encoding and decoding processes are consistent. The private method 'testDeserializeAndSimplifySchema' handles the deserialization of input and output schemas, transforming the input schema for comparison. The class relies on external libraries such as BSON and JUnit for its functionality, and it is structured to ensure that all tests are executed in a controlled manner, with assertions verifying expected outcomes.",
        "file_summary": "This file contains unit tests for the deserialization and simplification of JSON schemas in the MongoDB JDBC context. It validates that schemas returned from SQL commands are correctly processed and that empty schemas are handled appropriately."
      }
    ]
  },
  "MongoMock.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoMock.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\MongoMock.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoMock.java",
        "chunk_id": "MongoMock_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static org.mockito.ArgumentMatchers.*;\n<line_number-20>import static org.mockito.Mockito.doNothing;\n<line_number-21>import static org.mockito.Mockito.when;\n<line_number-22>\n<line_number-23>import com.mongodb.ConnectionString;\n<line_number-24>import com.mongodb.client.AggregateIterable;\n<line_number-25>import com.mongodb.client.MongoClient;\n<line_number-26>import com.mongodb.client.MongoCursor;\n<line_number-27>import com.mongodb.client.MongoDatabase;\n<line_number-28>import java.lang.reflect.Field;\n<line_number-29>import java.sql.SQLException;\n<line_number-30>import java.util.Base64;\n<line_number-31>import java.util.HashSet;\n<line_number-32>import java.util.LinkedHashMap;\n<line_number-33>import java.util.UUID;\n<line_number-34>import org.bson.*;\n<line_number-35>import org.bson.codecs.BsonDocumentCodec;\n<line_number-36>import org.bson.codecs.DecoderContext;\n<line_number-37>import org.bson.internal.UuidHelper;\n<line_number-38>import org.bson.json.JsonReader;\n<line_number-39>import org.mockito.InjectMocks;\n<line_number-40>import org.mockito.Mock;\n<line_number-41>import org.mockito.internal.util.reflection.FieldSetter;\n<line_number-42>\n<line_number-43>public abstract class MongoMock {\n<line_number-44>    static ConnectionString uri = new ConnectionString(\"mongodb://localhost:27017/admin\");\n<line_number-45>    protected static String database = \"test\";\n<line_number-46>    // __bot.a\n<line_number-47>    protected static int DOUBLE_COL = 1;\n<line_number-48>    // __bot.binary\n<line_number-49>    protected static int BINARY_COL = 2;\n<line_number-50>    // __bot.dup\n<line_number-51>    protected static int BOT_DUP_COL = 3;\n<line_number-52>    // __bot.str\n<line_number-53>    protected static int STRING_COL = 4;\n<line_number-54>    // foo.a\n<line_number-55>    protected static int ANY_OF_INT_STRING_COL = 5;\n<line_number-56>    // foo.b\n<line_number-57>    protected static int INT_OR_NULL_COL = 6;\n<line_number-58>    // foo.c\n<line_number-59>    protected static int INT_COL = 7;\n<line_number-60>    // foo.d\n<line_number-61>    protected static int ANY_COL = 8;\n<line_number-62>    // foo.doc\n<line_number-63>    protected static int DOC_COL = 9;\n<line_number-64>    // foo.dup\n<line_number-65>    protected static int FOO_DUP_COL = 10;\n<line_number-66>    // foo.null\n<line_number-67>    protected static int NULL_COL = 11;\n<line_number-68>    // foo.vec\n<line_number-69>    protected static int ARRAY_COL = 12;\n<line_number-70>\n<line_number-71>    // __bot fields\n<line_number-72>    protected static String DOUBLE_COL_LABEL = \"a\";\n<line_number-73>    protected static String BINARY_COL_LABEL = \"binary\";\n<line_number-74>    protected static String STRING_COL_LABEL = \"str\";\n<line_number-75>\n<line_number-76>    protected static String BOT_DUP_COL_LABEL = \"dup\";\n<line_number-77>\n<line_number-78>    // foo fields\n<line_number-79>    protected static String ANY_OF_INT_STRING_COL_LABEL = \"anyOfStrOrInt\";\n<line_number-80>    protected static String INT_NULLABLE_COL_LABEL = \"b\";\n<line_number-81>    protected static String INT_COL_LABEL = \"c\";\n<line_number-82>    protected static String ANY_COL_LABEL = \"d\";\n<line_number-83>    protected static String DOC_COL_LABEL = \"doc\";\n<line_number-84>    protected static String NULL_COL_LABEL = \"null\";\n<line_number-85>    protected static String ARRAY_COL_LABEL = \"vec\";\n<line_number-86>\n<line_number-87>    protected static String FOO_DUP_COL_LABEL = \"dup\";\n<line_number-88>\n<line_number-89>    // all.double\n<line_number-90>    protected static String ALL_DOUBLE_COL_LABEL = \"double\";\n<line_number-91>    // all.string\n<line_number-92>    protected static String ALL_STRING_COL_LABEL = \"string\";\n<line_number-93>    // all.object\n<line_number-94>    protected static String ALL_OBJECT_COL_LABEL = \"object\";\n<line_number-95>    // all.array\n<line_number-96>    protected static String ALL_ARRAY_COL_LABEL = \"array\";\n<line_number-97>    // all.binary\n<line_number-98>    protected static String ALL_BINARY_COL_LABEL = \"binData\";\n<line_number-99>    // all.undefined\n<line_number-100>    protected static String ALL_UNDEFINED_COL_LABEL = \"undefined\";\n<line_number-101>    // all.objectId\n<line_number-102>    protected static String ALL_OBJECT_ID_COL_LABEL = \"objectId\";\n<line_number-103>    // all.bool\n<line_number-104>    protected static String ALL_BOOL_COL_LABEL = \"bool\";\n<line_number-105>    // all.date\n<line_number-106>    protected static String ALL_DATE_COL_LABEL = \"date\";\n<line_number-107>    // all.null\n<line_number-108>    protected static String ALL_NULL_COL_LABEL = \"null\";\n<line_number-109>    // all.regex\n<line_number-110>    protected static String ALL_REGEX_COL_LABEL = \"regex\";\n<line_number-111>    // all.dbPointer\n<line_number-112>    protected static String ALL_DB_POINTER_COL_LABEL = \"dbPointer\";\n<line_number-113>    // all.javascript\n<line_number-114>    protected static String ALL_JAVASCRIPT_COL_LABEL = \"javascript\";\n<line_number-115>    // all.symbol\n<line_number-116>    protected static String ALL_SYMBOL_COL_LABEL = \"symbol\";\n<line_number-117>    // all.javascriptWithScope\n<line_number-118>    protected static String ALL_JAVASCRIPT_WITH_SCOPE_COL_LABEL = \"javascriptWithScope\";\n<line_number-119>    // all.int\n<line_number-120>    protected static String ALL_INT_COL_LABEL = \"int\";\n<line_number-121>    // all.timestamp\n<line_number-122>    protected static String ALL_TIMESTAMP_COL_LABEL = \"timestamp\";\n<line_number-123>    // all.long\n<line_number-124>    protected static String ALL_LONG_COL_LABEL = \"long\";\n<line_number-125>    // all.decimal\n<line_number-126>    protected static String ALL_DECIMAL_COL_LABEL = \"decimal\";\n<line_number-127>    // all.minKey\n<line_number-128>    protected static String ALL_MIN_KEY_COL_LABEL = \"minKey\";\n<line_number-129>    // all.maxKey\n<line_number-130>    protected static String ALL_MAX_KEY_COL_LABEL = \"maxKey\";\n<line_number-131>    // all.standardUuid\n<line_number-132>    protected static String ALL_STANDARD_UUID_COL_LABEL = \"standardUuid\";\n<line_number-133>    // all.legacyUuid\n<line_number-134>    protected static String ALL_LEGACY_UUID_COL_LABEL = \"legacyUuid\";\n<line_number-135>\n<line_number-136>    protected static String ALL_DOUBLE_COL_VAL = \"1.0\";\n<line_number-137>    protected static String ALL_STRING_COL_VAL = \"\\\"str\\\"\";\n<line_number-138>    protected static String ALL_OBJECT_ID_COL_VAL = \"{\\\"$oid\\\": \\\"57e193d7a9cc81b4027498b5\\\"}\";\n<line_number-139>    protected static String ALL_OBJECT_COL_VAL =\n<line_number-140>            \"{\\\"x\\\": 10, \\\"y\\\": \" + ALL_OBJECT_ID_COL_VAL + \"}\";\n<line_number-141>    protected static String ALL_ARRAY_COL_VAL = \"[7, 8, 9]\";\n<line_number-142>    protected static String ALL_BINARY_COL_VAL =\n<line_number-143>            \"{\\\"$binary\\\": {\\\"base64\\\": \\\"\\\", \\\"subType\\\": \\\"00\\\"}}\";\n<line_number-144>    protected static String ALL_UNDEFINED_COL_VAL = \"{\\\"$undefined\\\": true}\";\n<line_number-145>    protected static String ALL_BOOL_COL_VAL = \"true\";\n<line_number-146>    protected static String ALL_DATE_COL_VAL = \"{\\\"$date\\\": \\\"2020-12-25T17:13:14Z\\\"}\";\n<line_number-147>    protected static String ALL_NULL_COL_VAL = \"null\";\n<line_number-148>    protected static String ALL_REGEX_COL_VAL =\n<line_number-149>            \"{\\\"$regularExpression\\\": {\\\"pattern\\\": \\\"abc\\\", \\\"options\\\": \\\"i\\\"}}\";\n<line_number-150>    protected static String ALL_DB_POINTER_COL_VAL =\n<line_number-151>            \"{\\\"$dbPointer\\\": {\\\"$ref\\\": \\\"db2\\\", \\\"$id\\\": \" + ALL_OBJECT_ID_COL_VAL + \"}}\";\n<line_number-152>    protected static String ALL_JAVASCRIPT_COL_VAL = \"{\\\"$code\\\": \\\"javascript\\\"}\";\n<line_number-153>    protected static String ALL_SYMBOL_COL_VAL = \"{\\\"$symbol\\\": \\\"sym\\\"}\";\n<line_number-154>    protected static String ALL_JAVASCRIPT_WITH_SCOPE_COL_VAL =\n<line_number-155>            \"{\\\"$code\\\": \\\"code\\\", \\\"$scope\\\": {\\\"x\\\": 1}}\";\n<line_number-156>    protected static String ALL_INT_COL_VAL = \"3\";\n<line_number-157>    protected static String ALL_TIMESTAMP_COL_VAL =\n<line_number-158>            \"{\\\"$timestamp\\\": {\\\"t\\\": 1412180887, \\\"i\\\": 1}}\";\n<line_number-159>    protected static String ALL_LONG_COL_VAL = \"2147483648\";\n<line_number-160>    protected static String ALL_DECIMAL_COL_VAL = \"{\\\"$numberDecimal\\\": \\\"21.2\\\"}\";\n<line_number-161>    protected static String ALL_MIN_KEY_COL_VAL = \"{\\\"$minKey\\\": 1}\";\n<line_number-162>    protected static String ALL_MAX_KEY_COL_VAL = \"{\\\"$maxKey\\\": 1}\";\n<line_number-163>\n<line_number-164>    protected static String ALL_UUID_STRING_VAL = \"00112233-4455-6677-8899-aabbccddeeff\";\n<line_number-165>    protected static UUID ALL_UUID_VAL = UUID.fromString(ALL_UUID_STRING_VAL);\n<line_number-166>    protected static String ALL_UUID_STRING_EXT_VAL = \"{\\\"$uuid\\\":\\\"\" + ALL_UUID_STRING_VAL + \"\\\"}\";\n<line_number-167>\n<line_number-168>    protected static String ALL_STANDARD_UUID_COL_VAL =\n<line_number-169>            String.format(\n<line_number-170>                    \"{\\\"$binary\\\": {\\\"base64\\\": \\\"%s\\\", \\\"subType\\\": \\\"04\\\"}}\",\n<line_number-171>                    Base64.getEncoder()\n<line_number-172>                            .encodeToString(\n<line_number-173>                                    UuidHelper.encodeUuidToBinary(\n<line_number-174>                                            ALL_UUID_VAL, UuidRepresentation.STANDARD)));\n<line_number-175>\n<line_number-176>    protected static String ALL_LEGACY_UUID_COL_VAL =\n<line_number-177>            String.format(\n<line_number-178>                    \"{\\\"$binary\\\": {\\\"base64\\\": \\\"%s\\\", \\\"subType\\\": \\\"03\\\"}}\",\n<line_number-179>                    Base64.getEncoder()\n<line_number-180>                            .encodeToString(\n<line_number-181>                                    UuidHelper.encodeUuidToBinary(\n<line_number-182>                                            ALL_UUID_VAL, UuidRepresentation.JAVA_LEGACY)));\n<line_number-183>\n<line_number-184>    @Mock protected static MongoClient mongoClient;\n<line_number-185>    @Mock protected static MongoDatabase mongoDatabase;\n<line_number-186>    @Mock protected static AggregateIterable<BsonDocument> aggregateIterable;\n<line_number-187>    @Mock protected static MongoCursor<BsonDocument> mongoCursor;\n<line_number-188>\n<line_number-189>    @InjectMocks\n<line_number-190>    protected static MongoConnection mongoConnection =\n<line_number-191>            new MongoConnection(\n<line_number-192>                    new MongoConnectionProperties(uri, database, null, null, null, false, null));\n<line_number-193>\n<line_number-194>    private static Field getDeclaredFieldFromClassOrSuperClass(Class c, String fieldName)\n<line_number-195>            throws NoSuchFieldException {\n<line_number-196>        try {\n<line_number-197>            return c.getDeclaredField(fieldName);\n<line_number-198>        } catch (NoSuchFieldException e) {\n<line_number-199>            Class superClass = c.getSuperclass();\n<line_number-200>            if (superClass != null) {\n<line_number-201>                return getDeclaredFieldFromClassOrSuperClass(superClass, fieldName);\n<line_number-202>            }\n<line_number-203>        }\n<line_number-204>        throw new NoSuchFieldException(fieldName);\n<line_number-205>    }\n<line_number-206>\n<line_number-207>    // reset the mock objects before every test case\n<line_number-208>    protected static void resetMockObjs() throws NoSuchFieldException {\n<line_number-209>        FieldSetter.setField(\n<line_number-210>                mongoConnection,\n<line_number-211>                getDeclaredFieldFromClassOrSuperClass(mongoConnection.getClass(), \"mongoClient\"),\n<line_number-212>                mongoClient);\n<line_number-213>        FieldSetter.setField(\n<line_number-214>                mongoConnection,\n<line_number-215>                getDeclaredFieldFromClassOrSuperClass(mongoConnection.getClass(), \"isClosed\"),\n<line_number-216>                false);\n<line_number-217>        FieldSetter.setField(\n<line_number-218>                mongoConnection,\n<line_number-219>                getDeclaredFieldFromClassOrSuperClass(mongoConnection.getClass(), \"currentDB\"),\n<line_number-220>                database);\n<line_number-221>\n<line_number-222>        doNothing().when(mongoClient).close();\n<line_number-223>        // Mock mongoDatabase\n<line_number-224>        when(mongoConnection.getDatabase(anyString())).thenReturn(mongoDatabase);\n<line_number-225>        when(mongoDatabase.withCodecRegistry(any())).thenReturn(mongoDatabase);\n<line_number-226>        when(mongoDatabase.aggregate(any(), eq(BsonDocument.class))).thenReturn(aggregateIterable);\n<line_number-227>        // Mock aggregateIterable\n<line_number-228>        when(aggregateIterable.batchSize(anyInt())).thenReturn(aggregateIterable);\n<line_number-229>        when(aggregateIterable.maxTime(anyLong(), any())).thenReturn(aggregateIterable);\n<line_number-230>        when(aggregateIterable.cursor()).thenReturn(mongoCursor);\n<line_number-231>\n<line_number-232>        // Mock MongoCursor\n<line_number-233>        when(mongoCursor.hasNext()).thenReturn(false);\n<line_number-234>    }\n<line_number-235>\n<line_number-236>    // to replace lambda as input in the testExceptionAfterConnectionClosed\n<line_number-237>    interface TestInterface {\n<line_number-238>        void test() throws SQLException;\n<line_number-239>    }\n<line_number-240>\n<line_number-241>    protected static MongoJsonSchema generateMongoJsonSchema() {\n<line_number-242>        /*\n<line_number-243>        {\n<line_number-244>            bsonType: object,\n<line_number-245>            properties: {\n<line_number-246>                foo: {\n<line_number-247>                    bsonType: object,\n<line_number-248>                    properties: {\n<line_number-249>                        c: {\n<line_number-250>                            bsonType: int\n<line_number-251>                        },\n<line_number-252>                        anyOfStrOrInt: {\n<line_number-253>                            anyOf: [\n<line_number-254>                                {bsonType: int},\n<line_number-255>                                {bsonType: string},\n<line_number-256>                            ],\n<line_number-257>                        },\n<line_number-258>                        d: {},\n<line_number-259>                        b: {\n<line_number-260>                            anyOf: [\n<line_number-261>                               {bsonType: int},\n<line_number-262>                               {bsonType: null},\n<line_number-263>                            ],\n<line_number-264>                        },\n<line_number-265>                        vec: {\n<line_number-266>                           bsonType: array,\n<line_number-267>                           items: {\n<line_number-268>                               bsonType: int,\n<line_number-269>                           }\n<line_number-270>                        },\n<line_number-271>                        null: {\n<line_number-272>                           bsonType: NULL\n<line_number-273>                        },\n<line_number-274>                        doc: {\n<line_number-275>                           bsonType: object,\n<line_number-276>                           properties: {\n<line_number-277>                              c: {\n<line_number-278>                                 bsonType: int\n<line_number-279>                              }\n<line_number-280>                           },\n<line_number-281>                           required: [c]\n<line_number-282>                        },\n<line_number-283>                        dup: {\n<line_number-284>                            bsonType: int\n<line_number-285>                       }\n<line_number-286>                    },\n<line_number-287>                    required: [anyOfStrOrInt, b, vec, doc, dup],\n<line_number-288>                },\n<line_number-289>                \"\": {\n<line_number-290>                   bsonType: object,\n<line_number-291>                   properties: {\n<line_number-292>                       a: {\n<line_number-293>                           bsonType: double\n<line_number-294>                       },\n<line_number-295>                       binary: {\n<line_number-296>                           bsonType: binary\n<line_number-297>                       }\n<line_number-298>                       str: {\n<line_number-299>                           bsonType: string\n<line_number-300>                       }\n<line_number-301>                       dup: {\n<line_number-302>                            bsonType: string\n<line_number-303>                       },\n<line_number-304>                      standardUuid: {\n<line_number-305>                           bsonType: binData\n<line_number-306>                       },\n<line_number-307>                       legacyUuid: {\n<line_number-308>                           bsonType: binData\n<line_number-309>                       }\n<line_number-310>                   }\n<line_number-311>                },\n<line_number-312>            },\n<line_number-313>            required: [foo, \"\"]\n<line_number-314>        }\n<line_number-315>        */\n<line_number-316>        MongoJsonSchema schema = new MongoJsonSchema();\n<line_number-317>        schema.bsonType = \"object\";\n<line_number-318>        schema.required = new HashSet<String>();\n<line_number-319>        schema.required.add(\"foo\");\n<line_number-320>\n<line_number-321>        MongoJsonSchema fooSchema = new MongoJsonSchema();\n<line_number-322>        fooSchema.bsonType = \"object\";\n<line_number-323>        fooSchema.required = new HashSet<String>();\n<line_number-324>        fooSchema.required.add(ANY_OF_INT_STRING_COL_LABEL);\n<line_number-325>        fooSchema.required.add(INT_NULLABLE_COL_LABEL);\n<line_number-326>        fooSchema.required.add(ARRAY_COL_LABEL);\n<line_number-327>        fooSchema.required.add(DOC_COL_LABEL);\n<line_number-328>        fooSchema.required.add(FOO_DUP_COL_LABEL);\n<line_number-329>\n<line_number-330>        MongoJsonSchema aSchema = new MongoJsonSchema();\n<line_number-331>        aSchema.anyOf = new HashSet<MongoJsonSchema>();\n<line_number-332>        MongoJsonSchema anyOf1Schema = new MongoJsonSchema();\n<line_number-333>        anyOf1Schema.bsonType = \"int\";\n<line_number-334>        MongoJsonSchema anyOf2Schema = new MongoJsonSchema();\n<line_number-335>        anyOf2Schema.bsonType = \"string\";\n<line_number-336>        aSchema.anyOf.add(anyOf1Schema);\n<line_number-337>        aSchema.anyOf.add(anyOf2Schema);\n<line_number-338>\n<line_number-339>        MongoJsonSchema bSchema = new MongoJsonSchema();\n<line_number-340>        bSchema.anyOf = new HashSet<MongoJsonSchema>();\n<line_number-341>        anyOf1Schema = new MongoJsonSchema();\n<line_number-342>        anyOf1Schema.bsonType = \"int\";\n<line_number-343>        anyOf2Schema = new MongoJsonSchema();\n<line_number-344>        anyOf2Schema.bsonType = \"null\";\n<line_number-345>        bSchema.anyOf.add(anyOf1Schema);\n<line_number-346>        bSchema.anyOf.add(anyOf2Schema);\n<line_number-347>\n<line_number-348>        MongoJsonSchema cSchema = new MongoJsonSchema();\n<line_number-349>        cSchema.bsonType = \"int\";\n<line_number-350>\n<line_number-351>        MongoJsonSchema vecSchema = new MongoJsonSchema();\n<line_number-352>        vecSchema.bsonType = \"array\";\n<line_number-353>        vecSchema.items = new MongoJsonSchema();\n<line_number-354>        vecSchema.items.bsonType = \"int\";\n<line_number-355>\n<line_number-356>        MongoJsonSchema nullSchema = new MongoJsonSchema();\n<line_number-357>        nullSchema.bsonType = \"null\";\n<line_number-358>\n<line_number-359>        MongoJsonSchema fooDupSchema = new MongoJsonSchema();\n<line_number-360>        fooDupSchema.bsonType = \"int\";\n<line_number-361>\n<line_number-362>        // For the doc schema, we reuse the foo.c INT field variables\n<line_number-363>        MongoJsonSchema docSchema = MongoJsonSchema.createEmptyObjectSchema();\n<line_number-364>        docSchema.required.add(INT_COL_LABEL);\n<line_number-365>        docSchema.properties.put(INT_COL_LABEL, cSchema);\n<line_number-366>\n<line_number-367>        fooSchema.properties = new LinkedHashMap<String, MongoJsonSchema>();\n<line_number-368>        fooSchema.properties.put(INT_COL_LABEL, cSchema);\n<line_number-369>        fooSchema.properties.put(ANY_OF_INT_STRING_COL_LABEL, aSchema);\n<line_number-370>        // new MongoJsonSchema() is the ANY schema\n<line_number-371>        fooSchema.properties.put(ANY_COL_LABEL, new MongoJsonSchema());\n<line_number-372>        fooSchema.properties.put(INT_NULLABLE_COL_LABEL, bSchema);\n<line_number-373>        fooSchema.properties.put(ARRAY_COL_LABEL, vecSchema);\n<line_number-374>        fooSchema.properties.put(NULL_COL_LABEL, nullSchema);\n<line_number-375>        fooSchema.properties.put(DOC_COL_LABEL, docSchema);\n<line_number-376>        fooSchema.properties.put(FOO_DUP_COL_LABEL, fooDupSchema);\n<line_number-377>\n<line_number-378>        MongoJsonSchema botSchema = new MongoJsonSchema();\n<line_number-379>        botSchema.bsonType = \"object\";\n<line_number-380>        botSchema.properties = new LinkedHashMap<String, MongoJsonSchema>();\n<line_number-381>        aSchema = new MongoJsonSchema();\n<line_number-382>        aSchema.bsonType = \"double\";\n<line_number-383>        botSchema.properties.put(DOUBLE_COL_LABEL, aSchema);\n<line_number-384>        MongoJsonSchema binarySchema = new MongoJsonSchema();\n<line_number-385>        binarySchema.bsonType = \"binData\";\n<line_number-386>        botSchema.properties.put(\"binary\", binarySchema);\n<line_number-387>        MongoJsonSchema strSchema = new MongoJsonSchema();\n<line_number-388>        strSchema.bsonType = \"string\";\n<line_number-389>        botSchema.properties.put(\"str\", strSchema);\n<line_number-390>        MongoJsonSchema botDupSchema = new MongoJsonSchema();\n<line_number-391>        botDupSchema.bsonType = \"string\";\n<line_number-392>        botSchema.properties.put(BOT_DUP_COL_LABEL, botDupSchema);\n<line_number-393>\n<line_number-394>        schema.properties = new LinkedHashMap<String, MongoJsonSchema>();\n<line_number-395>        schema.properties.put(\"foo\", fooSchema);\n<line_number-396>        schema.properties.put(\"\", botSchema);\n<line_number-397>        return schema;\n<line_number-398>    }\n<line_number-399>\n<line_number-400>    BsonDocument generateRow() {\n<line_number-401>        /*\n<line_number-402>        {\n<line_number-403>            \"foo.a\": 1,\n<line_number-404>            \"foo.b\": null,\n<line_number-405>            \"foo.c\": 2,\n<line_number-406>            \"foo.d\": {\n<line_number-407>                \"$undefined\":true\n<line_number-408>            },\n<line_number-409>            \"foo.null\": null\n<line_number-410>            \"foo.vec\": [\n<line_number-411>                1,\n<line_number-412>                2,\n<line_number-413>                3\n<line_number-414>            ],\n<line_number-415>            \"foo.doc\": {\n<line_number-416>                \"c\": 5\n<line_number-417>            }\n<line_number-418>            \"__bot.a\": 1.2,\n<line_number-419>            \"__bot.binary\": <binary data>\n<line_number-420>            \"__bot.str\": \"a\"\n<line_number-421>        }\n<line_number-422>        */\n<line_number-423>        BsonDocument document = new BsonDocument();\n<line_number-424>        BsonDocument bot = new BsonDocument();\n<line_number-425>        BsonDocument foo = new BsonDocument();\n<line_number-426>\n<line_number-427>        foo.put(ANY_OF_INT_STRING_COL_LABEL, new BsonInt32(1));\n<line_number-428>        foo.put(INT_NULLABLE_COL_LABEL, new BsonNull());\n<line_number-429>        foo.put(INT_COL_LABEL, new BsonInt32(2));\n<line_number-430>        foo.put(ANY_COL_LABEL, new BsonUndefined());\n<line_number-431>        foo.put(NULL_COL_LABEL, new BsonNull());\n<line_number-432>        foo.put(FOO_DUP_COL_LABEL, new BsonInt32(8));\n<line_number-433>\n<line_number-434>        BsonArray array = new BsonArray();\n<line_number-435>        array.add(new BsonInt32(1));\n<line_number-436>        array.add(new BsonInt32(2));\n<line_number-437>        array.add(new BsonInt32(3));\n<line_number-438>        foo.put(ARRAY_COL_LABEL, array);\n<line_number-439>\n<line_number-440>        BsonDocument fooSubDoc = new BsonDocument();\n<line_number-441>        fooSubDoc.put(INT_COL_LABEL, new BsonInt32(5));\n<line_number-442>        foo.put(DOC_COL_LABEL, fooSubDoc);\n<line_number-443>\n<line_number-444>        bot.put(DOUBLE_COL_LABEL, new BsonDouble(1.2));\n<line_number-445>        byte binary[] = {10, 20, 30};\n<line_number-446>        bot.put(BINARY_COL_LABEL, new BsonBinary(binary));\n<line_number-447>        bot.put(STRING_COL_LABEL, new BsonString(\"a\"));\n<line_number-448>        bot.put(BOT_DUP_COL_LABEL, new BsonString(\"dupCol\"));\n<line_number-449>        document.put(\"\", bot);\n<line_number-450>        document.put(\"foo\", foo);\n<line_number-451>\n<line_number-452>        return document;\n<line_number-453>    }\n<line_number-454>\n<line_number-455>    MongoJsonSchemaResult generateSchema() {\n<line_number-456>        MongoJsonSchemaResult schemaResult = new MongoJsonSchemaResult();\n<line_number-457>        schemaResult.ok = 1;\n<line_number-458>        schemaResult.schema = new MongoVersionedJsonSchema();\n<line_number-459>        schemaResult.schema.mongoJsonSchema = generateMongoJsonSchema();\n<line_number-460>        return schemaResult;\n<line_number-461>    }\n<line_number-462>\n<line_number-463>    protected static MongoJsonSchema generateMongoJsonSchemaAllTypes() {\n<line_number-464>        String schema =\n<line_number-465>                \"{\"\n<line_number-466>                        + \"    \\\"bsonType\\\": \\\"object\\\",\"\n<line_number-467>                        + \"    \\\"properties\\\": {\"\n<line_number-468>                        + \"        \\\"all\\\": {\"\n<line_number-469>                        + \"            \\\"bsonType\\\": \\\"object\\\",\"\n<line_number-470>                        + \"            \\\"properties\\\": {\"\n<line_number-471>                        + \"                \\\"double\\\": {\"\n<line_number-472>                        + \"                    \\\"bsonType\\\": \\\"double\\\"\"\n<line_number-473>                        + \"                },\"\n<line_number-474>                        + \"                \\\"string\\\": {\"\n<line_number-475>                        + \"                    \\\"bsonType\\\": \\\"string\\\"\"\n<line_number-476>                        + \"                },\"\n<line_number-477>                        + \"                \\\"object\\\": {\"\n<line_number-478>                        + \"                    \\\"bsonType\\\": \\\"object\\\",\"\n<line_number-479>                        + \"                    \\\"properties\\\": {\"\n<line_number-480>                        + \"                        \\\"x\\\": {\"\n<line_number-481>                        + \"                            \\\"bsonType\\\": \\\"int\\\"\"\n<line_number-482>                        + \"                        },\"\n<line_number-483>                        + \"                        \\\"y\\\": {\"\n<line_number-484>                        + \"                            \\\"bsonType\\\": \\\"objectId\\\"\"\n<line_number-485>                        + \"                        }\"\n<line_number-486>                        + \"                    }\"\n<line_number-487>                        + \"                },\"\n<line_number-488>                        + \"                \\\"array\\\": {\"\n<line_number-489>                        + \"                    \\\"bsonType\\\": \\\"array\\\",\"\n<line_number-490>                        + \"                    \\\"items\\\": {\"\n<line_number-491>                        + \"                        \\\"bsonType\\\": \\\"int\\\"\"\n<line_number-492>                        + \"                    }\"\n<line_number-493>                        + \"                },\"\n<line_number-494>                        + \"                \\\"binData\\\": {\"\n<line_number-495>                        + \"                    \\\"bsonType\\\": \\\"binData\\\"\"\n<line_number-496>                        + \"                },\"\n<line_number-497>                        + \"                \\\"legacyUuid\\\": {\"\n<line_number-498>                        + \"                    \\\"bsonType\\\": \\\"binData\\\"\"\n<line_number-499>                        + \"                },\"\n<line_number-500>                        + \"                \\\"standardUuid\\\": {\"\n<line_number-501>                        + \"                    \\\"bsonType\\\": \\\"binData\\\"\"\n<line_number-502>                        + \"                },\"\n<line_number-503>                        + \"                \\\"undefined\\\": {\"\n<line_number-504>                        + \"                    \\\"bsonType\\\": \\\"undefined\\\"\"\n<line_number-505>                        + \"                },\"\n<line_number-506>                        + \"                \\\"objectId\\\": {\"\n<line_number-507>                        + \"                    \\\"bsonType\\\": \\\"objectId\\\"\"\n<line_number-508>                        + \"                },\"\n<line_number-509>                        + \"                \\\"bool\\\": {\"\n<line_number-510>                        + \"                    \\\"bsonType\\\": \\\"bool\\\"\"\n<line_number-511>                        + \"                },\"\n<line_number-512>                        + \"                \\\"date\\\": {\"\n<line_number-513>                        + \"                    \\\"bsonType\\\": \\\"date\\\"\"\n<line_number-514>                        + \"                },\"\n<line_number-515>                        + \"                \\\"null\\\": {\"\n<line_number-516>                        + \"                    \\\"bsonType\\\": \\\"null\\\"\"\n<line_number-517>                        + \"                },\"\n<line_number-518>                        + \"                \\\"regex\\\": {\"\n<line_number-519>                        + \"                    \\\"bsonType\\\": \\\"regex\\\"\"\n<line_number-520>                        + \"                },\"\n<line_number-521>                        + \"                \\\"dbPointer\\\": {\"\n<line_number-522>                        + \"                    \\\"bsonType\\\": \\\"dbPointer\\\"\"\n<line_number-523>                        + \"                },\"\n<line_number-524>                        + \"                \\\"javascript\\\": {\"\n<line_number-525>                        + \"                    \\\"bsonType\\\": \\\"javascript\\\"\"\n<line_number-526>                        + \"                },\"\n<line_number-527>                        + \"                \\\"symbol\\\": {\"\n<line_number-528>                        + \"                    \\\"bsonType\\\": \\\"symbol\\\"\"\n<line_number-529>                        + \"                },\"\n<line_number-530>                        + \"                \\\"javascriptWithScope\\\": {\"\n<line_number-531>                        + \"                    \\\"bsonType\\\": \\\"javascriptWithScope\\\"\"\n<line_number-532>                        + \"                },\"\n<line_number-533>                        + \"                \\\"int\\\": {\"\n<line_number-534>                        + \"                    \\\"bsonType\\\": \\\"int\\\"\"\n<line_number-535>                        + \"                },\"\n<line_number-536>                        + \"                \\\"timestamp\\\": {\"\n<line_number-537>                        + \"                    \\\"bsonType\\\": \\\"timestamp\\\"\"\n<line_number-538>                        + \"                },\"\n<line_number-539>                        + \"                \\\"long\\\": {\"\n<line_number-540>                        + \"                    \\\"bsonType\\\": \\\"long\\\"\"\n<line_number-541>                        + \"                },\"\n<line_number-542>                        + \"                \\\"decimal\\\": {\"\n<line_number-543>                        + \"                    \\\"bsonType\\\": \\\"decimal\\\"\"\n<line_number-544>                        + \"                },\"\n<line_number-545>                        + \"                \\\"minKey\\\": {\"\n<line_number-546>                        + \"                    \\\"bsonType\\\": \\\"minKey\\\"\"\n<line_number-547>                        + \"                },\"\n<line_number-548>                        + \"                \\\"maxKey\\\": {\"\n<line_number-549>                        + \"                    \\\"bsonType\\\": \\\"maxKey\\\"\"\n<line_number-550>                        + \"                }\"\n<line_number-551>                        + \"            },\"\n<line_number-552>                        + \"            \\\"required\\\": [\"\n<line_number-553>                        + \"                \\\"double\\\", \\\"string\\\", \\\"object\\\", \\\"array\\\", \\\"binData\\\", \\\"legacyUuid\\\", \\\"standardUuid\\\", \\\"undefined\\\",\"\n<line_number-554>                        + \"                \\\"objectId\\\", \\\"bool\\\", \\\"date\\\", \\\"null\\\", \\\"regex\\\", \\\"dbPointer\\\",\"\n<line_number-555>                        + \"                \\\"javascript\\\", \\\"symbol\\\", \\\"javascriptWithScope\\\", \\\"int\\\",\"\n<line_number-556>                        + \"                \\\"timestamp\\\", \\\"long\\\", \\\"decimal\\\", \\\"minKey\\\", \\\"maxKey\\\"\"\n<line_number-557>                        + \"            ]\"\n<line_number-558>                        + \"        }\"\n<line_number-559>                        + \"    },\"\n<line_number-560>                        + \"    \\\"required\\\": [\\\"all\\\"]\"\n<line_number-561>                        + \"}\";\n<line_number-562>\n<line_number-563>        return MongoDriver.REGISTRY\n<line_number-564>                .get(MongoJsonSchema.class)\n<line_number-565>                .decode(new JsonReader(schema), DecoderContext.builder().build());\n<line_number-566>    }\n<line_number-567>\n<line_number-568>    static BsonDocument generateRowAllTypes() {\n<line_number-569>        String doc =\n<line_number-570>                \"{\\\"all\\\": {\"\n<line_number-571>                        + \"\\\"\"\n<line_number-572>                        + ALL_DOUBLE_COL_LABEL\n<line_number-573>                        + \"\\\": \"\n<line_number-574>                        + ALL_DOUBLE_COL_VAL\n<line_number-575>                        + \",\"\n<line_number-576>                        + \"\\\"\"\n<line_number-577>                        + ALL_STRING_COL_LABEL\n<line_number-578>                        + \"\\\": \"\n<line_number-579>                        + ALL_STRING_COL_VAL\n<line_number-580>                        + \",\"\n<line_number-581>                        + \"\\\"\"\n<line_number-582>                        + ALL_OBJECT_COL_LABEL\n<line_number-583>                        + \"\\\": \"\n<line_number-584>                        + ALL_OBJECT_COL_VAL\n<line_number-585>                        + \",\"\n<line_number-586>                        + \"\\\"\"\n<line_number-587>                        + ALL_ARRAY_COL_LABEL\n<line_number-588>                        + \"\\\": \"\n<line_number-589>                        + ALL_ARRAY_COL_VAL\n<line_number-590>                        + \",\"\n<line_number-591>                        + \"\\\"\"\n<line_number-592>                        + ALL_BINARY_COL_LABEL\n<line_number-593>                        + \"\\\": \"\n<line_number-594>                        + ALL_BINARY_COL_VAL\n<line_number-595>                        + \",\"\n<line_number-596>                        + \"\\\"\"\n<line_number-597>                        + ALL_LEGACY_UUID_COL_LABEL\n<line_number-598>                        + \"\\\": \"\n<line_number-599>                        + ALL_LEGACY_UUID_COL_VAL\n<line_number-600>                        + \",\"\n<line_number-601>                        + \"\\\"\"\n<line_number-602>                        + ALL_STANDARD_UUID_COL_LABEL\n<line_number-603>                        + \"\\\": \"\n<line_number-604>                        + ALL_STANDARD_UUID_COL_VAL\n<line_number-605>                        + \",\"\n<line_number-606>                        + \"\\\"\"\n<line_number-607>                        + ALL_UNDEFINED_COL_LABEL\n<line_number-608>                        + \"\\\": \"\n<line_number-609>                        + ALL_UNDEFINED_COL_VAL\n<line_number-610>                        + \",\"\n<line_number-611>                        + \"\\\"\"\n<line_number-612>                        + ALL_OBJECT_ID_COL_LABEL\n<line_number-613>                        + \"\\\": \"\n<line_number-614>                        + ALL_OBJECT_ID_COL_VAL\n<line_number-615>                        + \",\"\n<line_number-616>                        + \"\\\"\"\n<line_number-617>                        + ALL_BOOL_COL_LABEL\n<line_number-618>                        + \"\\\": \"\n<line_number-619>                        + ALL_BOOL_COL_VAL\n<line_number-620>                        + \",\"\n<line_number-621>                        + \"\\\"\"\n<line_number-622>                        + ALL_DATE_COL_LABEL\n<line_number-623>                        + \"\\\": \"\n<line_number-624>                        + ALL_DATE_COL_VAL\n<line_number-625>                        + \",\"\n<line_number-626>                        + \"\\\"\"\n<line_number-627>                        + ALL_NULL_COL_LABEL\n<line_number-628>                        + \"\\\": \"\n<line_number-629>                        + ALL_NULL_COL_VAL\n<line_number-630>                        + \",\"\n<line_number-631>                        + \"\\\"\"\n<line_number-632>                        + ALL_REGEX_COL_LABEL\n<line_number-633>                        + \"\\\": \"\n<line_number-634>                        + ALL_REGEX_COL_VAL\n<line_number-635>                        + \",\"\n<line_number-636>                        + \"\\\"\"\n<line_number-637>                        + ALL_DB_POINTER_COL_LABEL\n<line_number-638>                        + \"\\\": \"\n<line_number-639>                        + ALL_DB_POINTER_COL_VAL\n<line_number-640>                        + \",\"\n<line_number-641>                        + \"\\\"\"\n<line_number-642>                        + ALL_JAVASCRIPT_COL_LABEL\n<line_number-643>                        + \"\\\": \"\n<line_number-644>                        + ALL_JAVASCRIPT_COL_VAL\n<line_number-645>                        + \",\"\n<line_number-646>                        + \"\\\"\"\n<line_number-647>                        + ALL_SYMBOL_COL_LABEL\n<line_number-648>                        + \"\\\": \"\n<line_number-649>                        + ALL_SYMBOL_COL_VAL\n<line_number-650>                        + \",\"\n<line_number-651>                        + \"\\\"\"\n<line_number-652>                        + ALL_JAVASCRIPT_WITH_SCOPE_COL_LABEL\n<line_number-653>                        + \"\\\": \"\n<line_number-654>                        + ALL_JAVASCRIPT_WITH_SCOPE_COL_VAL\n<line_number-655>                        + \",\"\n<line_number-656>                        + \"\\\"\"\n<line_number-657>                        + ALL_INT_COL_LABEL\n<line_number-658>                        + \"\\\": \"\n<line_number-659>                        + ALL_INT_COL_VAL\n<line_number-660>                        + \",\"\n<line_number-661>                        + \"\\\"\"\n<line_number-662>                        + ALL_TIMESTAMP_COL_LABEL\n<line_number-663>                        + \"\\\": \"\n<line_number-664>                        + ALL_TIMESTAMP_COL_VAL\n<line_number-665>                        + \",\"\n<line_number-666>                        + \"\\\"\"\n<line_number-667>                        + ALL_LONG_COL_LABEL\n<line_number-668>                        + \"\\\": \"\n<line_number-669>                        + ALL_LONG_COL_VAL\n<line_number-670>                        + \",\"\n<line_number-671>                        + \"\\\"\"\n<line_number-672>                        + ALL_DECIMAL_COL_LABEL\n<line_number-673>                        + \"\\\": \"\n<line_number-674>                        + ALL_DECIMAL_COL_VAL\n<line_number-675>                        + \",\"\n<line_number-676>                        + \"\\\"\"\n<line_number-677>                        + ALL_MIN_KEY_COL_LABEL\n<line_number-678>                        + \"\\\": \"\n<line_number-679>                        + ALL_MIN_KEY_COL_VAL\n<line_number-680>                        + \",\"\n<line_number-681>                        + \"\\\"\"\n<line_number-682>                        + ALL_MAX_KEY_COL_LABEL\n<line_number-683>                        + \"\\\": \"\n<line_number-684>                        + ALL_MAX_KEY_COL_VAL\n<line_number-685>                        + \"}}\";\n<line_number-686>\n<line_number-687>        return new BsonDocumentCodec()\n<line_number-688>                .decode(new JsonReader(doc), DecoderContext.builder().build());\n<line_number-689>    }\n<line_number-690>}\n",
        "comments": [
          {
            "comment_code_range": "43-400",
            "comment_linenumber": "42",
            "comment": "Abstract class providing mock implementations for MongoDB interactions, including mock client and database setup for testing.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "184-234",
            "comment_linenumber": "183",
            "comment": "Resets mock objects before each test case, ensuring a clean state for MongoDB interactions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "241-397",
            "comment_linenumber": "240",
            "comment": "Generates a MongoDB JSON schema for validation, defining the structure and required fields of documents.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "400-452",
            "comment_linenumber": "399",
            "comment": "Creates a sample BSON document representing a row in the database, including various field types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "455-460",
            "comment_linenumber": "454",
            "comment": "Generates a MongoDB JSON schema result, encapsulating the schema and its validation status.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "463-688",
            "comment_linenumber": "462",
            "comment": "Generates a BSON document representing all possible types supported by MongoDB, useful for comprehensive testing.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoMock.java' serves as an abstract base class for mocking MongoDB interactions in unit tests. It utilizes Mockito for creating mock objects and provides methods to reset these mocks before each test case. The class defines various static fields representing MongoDB column labels and values, which are used in the mock documents. Key methods include 'resetMockObjs', which sets up the mock MongoDB client and database, 'generateMongoJsonSchema', which constructs a JSON schema for document validation, and 'generateRow', which creates a sample BSON document. The class also includes methods for generating schemas for all types supported by MongoDB, ensuring comprehensive coverage for testing. The use of static fields and methods indicates that this class is designed to be a utility for test cases rather than an instance-based object. The class does not implement any interfaces or extend other classes, making it a standalone utility for MongoDB testing.",
        "file_summary": "The 'MongoMock.java' file provides an abstract class for mocking MongoDB interactions in unit tests, facilitating the creation of mock clients, databases, and BSON documents for comprehensive testing of MongoDB-related functionality."
      }
    ]
  },
  "MongoResultSetMetaDataTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoResultSetMetaDataTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\MongoResultSetMetaDataTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoResultSetMetaDataTest.java",
        "chunk_id": "MongoResultSetMetaDataTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static org.junit.jupiter.api.Assertions.*;\n<line_number-20>\n<line_number-21>import java.sql.ResultSetMetaData;\n<line_number-22>import java.sql.SQLException;\n<line_number-23>import java.sql.Types;\n<line_number-24>import java.util.ArrayList;\n<line_number-25>import java.util.Arrays;\n<line_number-26>import java.util.List;\n<line_number-27>import org.bson.BsonValue;\n<line_number-28>import org.junit.jupiter.api.BeforeAll;\n<line_number-29>import org.junit.jupiter.api.Test;\n<line_number-30>import org.junit.jupiter.api.TestInstance;\n<line_number-31>import org.junit.jupiter.api.extension.ExtendWith;\n<line_number-32>import org.mockito.MockitoAnnotations;\n<line_number-33>import org.mockito.junit.jupiter.MockitoExtension;\n<line_number-34>\n<line_number-35>@ExtendWith(MockitoExtension.class)\n<line_number-36>@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n<line_number-37>class MongoResultSetMetaDataTest extends MongoMock {\n<line_number-38>    private static MongoResultSetMetaData resultSetMetaData;\n<line_number-39>\n<line_number-40>    static {\n<line_number-41>        try {\n<line_number-42>            resultSetMetaData =\n<line_number-43>                    new MongoResultSetMetaData(\n<line_number-44>                            generateMongoJsonSchema(),\n<line_number-45>                            null,\n<line_number-46>                            true,\n<line_number-47>                            mongoConnection.getLogger(),\n<line_number-48>                            0,\n<line_number-49>                            null);\n<line_number-50>        } catch (Exception e) {\n<line_number-51>            throw new RuntimeException(e);\n<line_number-52>        }\n<line_number-53>    }\n<line_number-54>\n<line_number-55>    @BeforeAll\n<line_number-56>    void initMocks() {\n<line_number-57>        MockitoAnnotations.initMocks(this);\n<line_number-58>    }\n<line_number-59>\n<line_number-60>    @Test\n<line_number-61>    void testGetColumnCount() throws SQLException {\n<line_number-62>        assertEquals(12, MongoResultSetMetaDataTest.resultSetMetaData.getColumnCount());\n<line_number-63>    }\n<line_number-64>\n<line_number-65>    @Test\n<line_number-66>    void testMetadataFieldsOrder() throws SQLException {\n<line_number-67>\n<line_number-68>        // Verify that the columns are sorted alphabetically when the sortFieldsAlphabetically is true and that the original order is kept when it's false.\n<line_number-69>        String[] expected_sorted_columns =\n<line_number-70>                new String[] {\n<line_number-71>                    \"a\",\n<line_number-72>                    \"binary\",\n<line_number-73>                    \"dup\",\n<line_number-74>                    \"str\",\n<line_number-75>                    \"anyOfStrOrInt\",\n<line_number-76>                    \"b\",\n<line_number-77>                    \"c\",\n<line_number-78>                    \"d\",\n<line_number-79>                    \"doc\",\n<line_number-80>                    \"dup\",\n<line_number-81>                    \"null\",\n<line_number-82>                    \"vec\"\n<line_number-83>                };\n<line_number-84>        String[] expected_original_columns =\n<line_number-85>                new String[] {\n<line_number-86>                    \"a\",\n<line_number-87>                    \"binary\",\n<line_number-88>                    \"str\",\n<line_number-89>                    \"dup\",\n<line_number-90>                    \"c\",\n<line_number-91>                    \"anyOfStrOrInt\",\n<line_number-92>                    \"d\",\n<line_number-93>                    \"b\",\n<line_number-94>                    \"vec\",\n<line_number-95>                    \"null\",\n<line_number-96>                    \"doc\",\n<line_number-97>                    \"dup\"\n<line_number-98>                };\n<line_number-99>        String[] expected_select_order_columns =\n<line_number-100>                new String[] {\n<line_number-101>                    \"binary\",\n<line_number-102>                    \"anyOfStrOrInt\",\n<line_number-103>                    \"b\",\n<line_number-104>                    \"dup\",\n<line_number-105>                    \"c\",\n<line_number-106>                    \"d\",\n<line_number-107>                    \"doc\",\n<line_number-108>                    \"null\",\n<line_number-109>                    \"vec\",\n<line_number-110>                    \"a\",\n<line_number-111>                    \"dup\",\n<line_number-112>                    \"str\"\n<line_number-113>                };\n<line_number-114>        List<List<String>> selectOrder =\n<line_number-115>                Arrays.asList(\n<line_number-116>                        Arrays.asList(\"\", \"binary\"),\n<line_number-117>                        Arrays.asList(\"foo\", \"anyOfStrOrInt\"),\n<line_number-118>                        Arrays.asList(\"foo\", \"b\"),\n<line_number-119>                        Arrays.asList(\"foo\", \"dup\"),\n<line_number-120>                        Arrays.asList(\"foo\", \"c\"),\n<line_number-121>                        Arrays.asList(\"foo\", \"d\"),\n<line_number-122>                        Arrays.asList(\"foo\", \"doc\"),\n<line_number-123>                        Arrays.asList(\"foo\", \"null\"),\n<line_number-124>                        Arrays.asList(\"foo\", \"vec\"),\n<line_number-125>                        Arrays.asList(\"\", \"a\"),\n<line_number-126>                        Arrays.asList(\"\", \"dup\"),\n<line_number-127>                        Arrays.asList(\"\", \"str\"));\n<line_number-128>\n<line_number-129>        MongoJsonSchema schema = generateMongoJsonSchema();\n<line_number-130>        MongoResultSetMetaData unsortedMedata =\n<line_number-131>                new MongoResultSetMetaData(\n<line_number-132>                        schema, null, false, mongoConnection.getLogger(), 0, null);\n<line_number-133>        MongoResultSetMetaData sortedMedata =\n<line_number-134>                new MongoResultSetMetaData(\n<line_number-135>                        schema, null, true, mongoConnection.getLogger(), 0, null);\n<line_number-136>        MongoResultSetMetaData selectOrderedMetadata =\n<line_number-137>                new MongoResultSetMetaData(\n<line_number-138>                        schema, selectOrder, false, mongoConnection.getLogger(), 0, null);\n<line_number-139>\n<line_number-140>        assertEquals(\n<line_number-141>                expected_original_columns.length,\n<line_number-142>                unsortedMedata.getColumnCount(),\n<line_number-143>                \"The number of expected columns doesn't match the actual number of columns\");\n<line_number-144>        for (int i = 0; i < unsortedMedata.getColumnCount(); i++) {\n<line_number-145>            assertEquals(expected_original_columns[i], unsortedMedata.getColumnName(i + 1));\n<line_number-146>        }\n<line_number-147>\n<line_number-148>        assertEquals(\n<line_number-149>                expected_sorted_columns.length,\n<line_number-150>                sortedMedata.getColumnCount(),\n<line_number-151>                \"The number of expected columns doesn't match the actual number of columns\");\n<line_number-152>        for (int i = 0; i < sortedMedata.getColumnCount(); i++) {\n<line_number-153>            assertEquals(expected_sorted_columns[i], sortedMedata.getColumnName(i + 1));\n<line_number-154>        }\n<line_number-155>\n<line_number-156>        assertEquals(\n<line_number-157>                expected_select_order_columns.length,\n<line_number-158>                selectOrderedMetadata.getColumnCount(),\n<line_number-159>                \"The number of expected columns doesn't match the actual number of columns\");\n<line_number-160>        for (int i = 0; i < selectOrderedMetadata.getColumnCount(); i++) {\n<line_number-161>            assertEquals(\n<line_number-162>                    expected_select_order_columns[i], selectOrderedMetadata.getColumnName(i + 1));\n<line_number-163>        }\n<line_number-164>    }\n<line_number-165>\n<line_number-166>    @Test\n<line_number-167>    void testGetCatalogAndSchemaName() throws SQLException {\n<line_number-168>        assertEquals(\"\", resultSetMetaData.getCatalogName(DOUBLE_COL));\n<line_number-169>        assertEquals(\"\", resultSetMetaData.getSchemaName(DOUBLE_COL));\n<line_number-170>    }\n<line_number-171>\n<line_number-172>    @Test\n<line_number-173>    void testGetColumnName() throws SQLException {\n<line_number-174>        assertEquals(DOUBLE_COL_LABEL, resultSetMetaData.getColumnName(DOUBLE_COL));\n<line_number-175>        assertEquals(STRING_COL_LABEL, resultSetMetaData.getColumnName(STRING_COL));\n<line_number-176>        assertEquals(\n<line_number-177>                ANY_OF_INT_STRING_COL_LABEL,\n<line_number-178>                resultSetMetaData.getColumnName(ANY_OF_INT_STRING_COL));\n<line_number-179>        assertEquals(INT_NULLABLE_COL_LABEL, resultSetMetaData.getColumnName(INT_OR_NULL_COL));\n<line_number-180>        assertEquals(INT_COL_LABEL, resultSetMetaData.getColumnName(INT_COL));\n<line_number-181>        assertEquals(ANY_COL_LABEL, resultSetMetaData.getColumnName(ANY_COL));\n<line_number-182>        assertEquals(NULL_COL_LABEL, resultSetMetaData.getColumnName(NULL_COL));\n<line_number-183>        assertEquals(ARRAY_COL_LABEL, resultSetMetaData.getColumnName(ARRAY_COL));\n<line_number-184>        assertEquals(DOC_COL_LABEL, resultSetMetaData.getColumnName(DOC_COL));\n<line_number-185>        assertEquals(BOT_DUP_COL_LABEL, resultSetMetaData.getColumnName(BOT_DUP_COL));\n<line_number-186>        assertEquals(FOO_DUP_COL_LABEL, resultSetMetaData.getColumnName(FOO_DUP_COL));\n<line_number-187>    }\n<line_number-188>\n<line_number-189>    @Test\n<line_number-190>    void testGetColumnLabel() throws SQLException {\n<line_number-191>        assertEquals(DOUBLE_COL_LABEL, resultSetMetaData.getColumnLabel(DOUBLE_COL));\n<line_number-192>        assertEquals(STRING_COL_LABEL, resultSetMetaData.getColumnLabel(STRING_COL));\n<line_number-193>        assertEquals(\n<line_number-194>                ANY_OF_INT_STRING_COL_LABEL,\n<line_number-195>                resultSetMetaData.getColumnLabel(ANY_OF_INT_STRING_COL));\n<line_number-196>        assertEquals(INT_NULLABLE_COL_LABEL, resultSetMetaData.getColumnLabel(INT_OR_NULL_COL));\n<line_number-197>        assertEquals(INT_COL_LABEL, resultSetMetaData.getColumnLabel(INT_COL));\n<line_number-198>        assertEquals(ANY_COL_LABEL, resultSetMetaData.getColumnLabel(ANY_COL));\n<line_number-199>        assertEquals(NULL_COL_LABEL, resultSetMetaData.getColumnName(NULL_COL));\n<line_number-200>        assertEquals(ARRAY_COL_LABEL, resultSetMetaData.getColumnLabel(ARRAY_COL));\n<line_number-201>        assertEquals(DOC_COL_LABEL, resultSetMetaData.getColumnLabel(DOC_COL));\n<line_number-202>        assertEquals(BOT_DUP_COL_LABEL, resultSetMetaData.getColumnName(BOT_DUP_COL));\n<line_number-203>        assertEquals(FOO_DUP_COL_LABEL, resultSetMetaData.getColumnName(FOO_DUP_COL));\n<line_number-204>    }\n<line_number-205>\n<line_number-206>    @Test\n<line_number-207>    void testGetTableName() throws SQLException {\n<line_number-208>        assertEquals(\"\", resultSetMetaData.getTableName(DOUBLE_COL));\n<line_number-209>        assertEquals(\"\", resultSetMetaData.getTableName(STRING_COL));\n<line_number-210>        assertEquals(\"\", resultSetMetaData.getTableName(BOT_DUP_COL));\n<line_number-211>        assertEquals(\"foo\", resultSetMetaData.getTableName(ANY_OF_INT_STRING_COL));\n<line_number-212>        assertEquals(\"foo\", resultSetMetaData.getTableName(INT_OR_NULL_COL));\n<line_number-213>        assertEquals(\"foo\", resultSetMetaData.getTableName(INT_COL));\n<line_number-214>        assertEquals(\"foo\", resultSetMetaData.getTableName(ANY_COL));\n<line_number-215>        assertEquals(\"foo\", resultSetMetaData.getTableName(NULL_COL));\n<line_number-216>        assertEquals(\"foo\", resultSetMetaData.getTableName(ARRAY_COL));\n<line_number-217>        assertEquals(\"foo\", resultSetMetaData.getTableName(DOC_COL));\n<line_number-218>        assertEquals(\"foo\", resultSetMetaData.getTableName(FOO_DUP_COL));\n<line_number-219>    }\n<line_number-220>\n<line_number-221>    @Test\n<line_number-222>    void testIsCaseSensitive() throws SQLException {\n<line_number-223>        assertEquals(false, resultSetMetaData.isCaseSensitive(DOUBLE_COL));\n<line_number-224>        assertEquals(true, resultSetMetaData.isCaseSensitive(STRING_COL));\n<line_number-225>        assertEquals(true, resultSetMetaData.isCaseSensitive(ANY_OF_INT_STRING_COL));\n<line_number-226>        assertEquals(false, resultSetMetaData.isCaseSensitive(INT_OR_NULL_COL));\n<line_number-227>        assertEquals(false, resultSetMetaData.isCaseSensitive(INT_COL));\n<line_number-228>        assertEquals(true, resultSetMetaData.isCaseSensitive(ANY_COL));\n<line_number-229>        assertEquals(false, resultSetMetaData.isCaseSensitive(NULL_COL));\n<line_number-230>        assertEquals(false, resultSetMetaData.isCaseSensitive(ARRAY_COL));\n<line_number-231>        assertEquals(false, resultSetMetaData.isCaseSensitive(DOC_COL));\n<line_number-232>        assertEquals(true, resultSetMetaData.isCaseSensitive(BOT_DUP_COL));\n<line_number-233>        assertEquals(false, resultSetMetaData.isCaseSensitive(FOO_DUP_COL));\n<line_number-234>    }\n<line_number-235>\n<line_number-236>    @Test\n<line_number-237>    void testIsNullable() throws SQLException {\n<line_number-238>        assertEquals(ResultSetMetaData.columnNullable, resultSetMetaData.isNullable(DOUBLE_COL));\n<line_number-239>        assertEquals(ResultSetMetaData.columnNullable, resultSetMetaData.isNullable(STRING_COL));\n<line_number-240>        assertEquals(\n<line_number-241>                ResultSetMetaData.columnNoNulls,\n<line_number-242>                resultSetMetaData.isNullable(ANY_OF_INT_STRING_COL));\n<line_number-243>        assertEquals(\n<line_number-244>                ResultSetMetaData.columnNullable, resultSetMetaData.isNullable(INT_OR_NULL_COL));\n<line_number-245>        assertEquals(ResultSetMetaData.columnNullable, resultSetMetaData.isNullable(INT_COL));\n<line_number-246>        assertEquals(ResultSetMetaData.columnNullable, resultSetMetaData.isNullable(ANY_COL));\n<line_number-247>        assertEquals(ResultSetMetaData.columnNullable, resultSetMetaData.isNullable(NULL_COL));\n<line_number-248>        assertEquals(ResultSetMetaData.columnNoNulls, resultSetMetaData.isNullable(ARRAY_COL));\n<line_number-249>        assertEquals(ResultSetMetaData.columnNoNulls, resultSetMetaData.isNullable(DOC_COL));\n<line_number-250>        assertEquals(ResultSetMetaData.columnNullable, resultSetMetaData.isNullable(BOT_DUP_COL));\n<line_number-251>        assertEquals(ResultSetMetaData.columnNoNulls, resultSetMetaData.isNullable(FOO_DUP_COL));\n<line_number-252>    }\n<line_number-253>\n<line_number-254>    @Test\n<line_number-255>    void testIsSigned() throws SQLException {\n<line_number-256>        assertEquals(true, resultSetMetaData.isSigned(DOUBLE_COL));\n<line_number-257>        assertEquals(false, resultSetMetaData.isSigned(STRING_COL));\n<line_number-258>        assertEquals(true, resultSetMetaData.isSigned(ANY_OF_INT_STRING_COL));\n<line_number-259>        assertEquals(true, resultSetMetaData.isSigned(INT_OR_NULL_COL));\n<line_number-260>        assertEquals(true, resultSetMetaData.isSigned(INT_COL));\n<line_number-261>        assertEquals(true, resultSetMetaData.isSigned(ANY_COL));\n<line_number-262>        assertEquals(false, resultSetMetaData.isSigned(NULL_COL));\n<line_number-263>        assertEquals(false, resultSetMetaData.isSigned(ARRAY_COL));\n<line_number-264>        assertEquals(false, resultSetMetaData.isSigned(DOC_COL));\n<line_number-265>        assertEquals(false, resultSetMetaData.isSigned(BOT_DUP_COL));\n<line_number-266>        assertEquals(true, resultSetMetaData.isSigned(FOO_DUP_COL));\n<line_number-267>    }\n<line_number-268>\n<line_number-269>    @Test\n<line_number-270>    void testGetColumnDisplaySize() throws SQLException {\n<line_number-271>        assertEquals(15, resultSetMetaData.getColumnDisplaySize(DOUBLE_COL));\n<line_number-272>        assertEquals(0, resultSetMetaData.getColumnDisplaySize(STRING_COL));\n<line_number-273>        assertEquals(0, resultSetMetaData.getColumnDisplaySize(ANY_OF_INT_STRING_COL));\n<line_number-274>        assertEquals(10, resultSetMetaData.getColumnDisplaySize(INT_OR_NULL_COL));\n<line_number-275>        assertEquals(10, resultSetMetaData.getColumnDisplaySize(INT_COL));\n<line_number-276>        assertEquals(0, resultSetMetaData.getColumnDisplaySize(ANY_COL));\n<line_number-277>        assertEquals(0, resultSetMetaData.getColumnDisplaySize(NULL_COL));\n<line_number-278>        assertEquals(0, resultSetMetaData.getColumnDisplaySize(ARRAY_COL));\n<line_number-279>        assertEquals(0, resultSetMetaData.getColumnDisplaySize(DOC_COL));\n<line_number-280>        assertEquals(0, resultSetMetaData.getColumnDisplaySize(BOT_DUP_COL));\n<line_number-281>        assertEquals(10, resultSetMetaData.getColumnDisplaySize(FOO_DUP_COL));\n<line_number-282>    }\n<line_number-283>\n<line_number-284>    @Test\n<line_number-285>    void testGetPrecision() throws SQLException {\n<line_number-286>        assertEquals(15, resultSetMetaData.getPrecision(DOUBLE_COL));\n<line_number-287>        assertEquals(0, resultSetMetaData.getPrecision(STRING_COL));\n<line_number-288>        assertEquals(0, resultSetMetaData.getPrecision(ANY_OF_INT_STRING_COL));\n<line_number-289>        assertEquals(10, resultSetMetaData.getPrecision(INT_OR_NULL_COL));\n<line_number-290>        assertEquals(10, resultSetMetaData.getPrecision(INT_COL));\n<line_number-291>        assertEquals(0, resultSetMetaData.getPrecision(ANY_COL));\n<line_number-292>        assertEquals(0, resultSetMetaData.getPrecision(NULL_COL));\n<line_number-293>        assertEquals(0, resultSetMetaData.getPrecision(ARRAY_COL));\n<line_number-294>        assertEquals(0, resultSetMetaData.getPrecision(DOC_COL));\n<line_number-295>        assertEquals(0, resultSetMetaData.getPrecision(BOT_DUP_COL));\n<line_number-296>        assertEquals(10, resultSetMetaData.getPrecision(FOO_DUP_COL));\n<line_number-297>    }\n<line_number-298>\n<line_number-299>    @Test\n<line_number-300>    void testGetScale() throws SQLException {\n<line_number-301>        assertEquals(15, resultSetMetaData.getScale(DOUBLE_COL));\n<line_number-302>        assertEquals(0, resultSetMetaData.getScale(STRING_COL));\n<line_number-303>        assertEquals(0, resultSetMetaData.getScale(ANY_OF_INT_STRING_COL));\n<line_number-304>        assertEquals(0, resultSetMetaData.getScale(INT_OR_NULL_COL));\n<line_number-305>        assertEquals(0, resultSetMetaData.getScale(INT_COL));\n<line_number-306>        assertEquals(0, resultSetMetaData.getScale(ANY_COL));\n<line_number-307>        assertEquals(0, resultSetMetaData.getScale(NULL_COL));\n<line_number-308>        assertEquals(0, resultSetMetaData.getScale(ARRAY_COL));\n<line_number-309>        assertEquals(0, resultSetMetaData.getScale(DOC_COL));\n<line_number-310>        assertEquals(0, resultSetMetaData.getScale(BOT_DUP_COL));\n<line_number-311>        assertEquals(0, resultSetMetaData.getScale(FOO_DUP_COL));\n<line_number-312>    }\n<line_number-313>\n<line_number-314>    @Test\n<line_number-315>    void testGetColumnType() throws SQLException {\n<line_number-316>        assertEquals(Types.DOUBLE, resultSetMetaData.getColumnType(DOUBLE_COL));\n<line_number-317>        assertEquals(Types.LONGVARCHAR, resultSetMetaData.getColumnType(STRING_COL));\n<line_number-318>        assertEquals(Types.OTHER, resultSetMetaData.getColumnType(ANY_OF_INT_STRING_COL));\n<line_number-319>        assertEquals(Types.INTEGER, resultSetMetaData.getColumnType(INT_OR_NULL_COL));\n<line_number-320>        assertEquals(Types.INTEGER, resultSetMetaData.getColumnType(INT_COL));\n<line_number-321>        assertEquals(Types.OTHER, resultSetMetaData.getColumnType(ANY_COL));\n<line_number-322>        assertEquals(Types.NULL, resultSetMetaData.getColumnType(NULL_COL));\n<line_number-323>        assertEquals(Types.OTHER, resultSetMetaData.getColumnType(ARRAY_COL));\n<line_number-324>        assertEquals(Types.OTHER, resultSetMetaData.getColumnType(DOC_COL));\n<line_number-325>        assertEquals(Types.LONGVARCHAR, resultSetMetaData.getColumnType(BOT_DUP_COL));\n<line_number-326>        assertEquals(Types.INTEGER, resultSetMetaData.getColumnType(FOO_DUP_COL));\n<line_number-327>    }\n<line_number-328>\n<line_number-329>    @Test\n<line_number-330>    void testGetColumnTypeClassName() throws SQLException {\n<line_number-331>        assertEquals(double.class.getName(), resultSetMetaData.getColumnClassName(DOUBLE_COL));\n<line_number-332>        assertEquals(String.class.getName(), resultSetMetaData.getColumnClassName(STRING_COL));\n<line_number-333>        assertEquals(\n<line_number-334>                BsonValue.class.getName(),\n<line_number-335>                resultSetMetaData.getColumnClassName(ANY_OF_INT_STRING_COL));\n<line_number-336>        assertEquals(int.class.getName(), resultSetMetaData.getColumnClassName(INT_OR_NULL_COL));\n<line_number-337>        assertEquals(int.class.getName(), resultSetMetaData.getColumnClassName(INT_COL));\n<line_number-338>        assertEquals(BsonValue.class.getName(), resultSetMetaData.getColumnClassName(ANY_COL));\n<line_number-339>        assertEquals(null, resultSetMetaData.getColumnClassName(NULL_COL));\n<line_number-340>        assertEquals(BsonValue.class.getName(), resultSetMetaData.getColumnClassName(ARRAY_COL));\n<line_number-341>        assertEquals(BsonValue.class.getName(), resultSetMetaData.getColumnClassName(DOC_COL));\n<line_number-342>        assertEquals(String.class.getName(), resultSetMetaData.getColumnClassName(BOT_DUP_COL));\n<line_number-343>        assertEquals(int.class.getName(), resultSetMetaData.getColumnClassName(FOO_DUP_COL));\n<line_number-344>    }\n<line_number-345>\n<line_number-346>    @Test\n<line_number-347>    void testGetColumnTypeName() throws SQLException {\n<line_number-348>        assertEquals(\"double\", resultSetMetaData.getColumnTypeName(DOUBLE_COL));\n<line_number-349>        assertEquals(\"string\", resultSetMetaData.getColumnTypeName(STRING_COL));\n<line_number-350>        assertEquals(\"bson\", resultSetMetaData.getColumnTypeName(ANY_OF_INT_STRING_COL));\n<line_number-351>        assertEquals(\"int\", resultSetMetaData.getColumnTypeName(INT_OR_NULL_COL));\n<line_number-352>        assertEquals(\"int\", resultSetMetaData.getColumnTypeName(INT_COL));\n<line_number-353>        assertEquals(\"bson\", resultSetMetaData.getColumnTypeName(ANY_COL));\n<line_number-354>        assertEquals(\"null\", resultSetMetaData.getColumnTypeName(NULL_COL));\n<line_number-355>        assertEquals(\"array\", resultSetMetaData.getColumnTypeName(ARRAY_COL));\n<line_number-356>        assertEquals(\"object\", resultSetMetaData.getColumnTypeName(DOC_COL));\n<line_number-357>        assertEquals(\"string\", resultSetMetaData.getColumnTypeName(BOT_DUP_COL));\n<line_number-358>        assertEquals(\"int\", resultSetMetaData.getColumnTypeName(FOO_DUP_COL));\n<line_number-359>    }\n<line_number-360>\n<line_number-361>    @Test\n<line_number-362>    void testGetDatasource() throws Exception {\n<line_number-363>        assertEquals(\"\", resultSetMetaData.getDatasource(DOUBLE_COL_LABEL));\n<line_number-364>        assertEquals(\"\", resultSetMetaData.getDatasource(STRING_COL_LABEL));\n<line_number-365>        assertEquals(\"foo\", resultSetMetaData.getDatasource(INT_NULLABLE_COL_LABEL));\n<line_number-366>        assertEquals(\"foo\", resultSetMetaData.getDatasource(INT_COL_LABEL));\n<line_number-367>        assertEquals(\"foo\", resultSetMetaData.getDatasource(ANY_COL_LABEL));\n<line_number-368>        assertEquals(\"foo\", resultSetMetaData.getDatasource(NULL_COL_LABEL));\n<line_number-369>        assertEquals(\"foo\", resultSetMetaData.getDatasource(ARRAY_COL_LABEL));\n<line_number-370>        assertEquals(\"foo\", resultSetMetaData.getDatasource(DOC_COL_LABEL));\n<line_number-371>        // Duplicated column names fail\n<line_number-372>        assertThrows(Exception.class, () -> resultSetMetaData.getDatasource(FOO_DUP_COL_LABEL));\n<line_number-373>        assertThrows(Exception.class, () -> resultSetMetaData.getDatasource(BOT_DUP_COL_LABEL));\n<line_number-374>    }\n<line_number-375>\n<line_number-376>    @Test\n<line_number-377>    void testEmptySelectOrder() throws SQLException {\n<line_number-378>        MongoJsonSchema schema = generateMongoJsonSchema();\n<line_number-379>\n<line_number-380>        MongoResultSetMetaData nullSelectOrderMetadata =\n<line_number-381>                new MongoResultSetMetaData(\n<line_number-382>                        schema, null, true, mongoConnection.getLogger(), 0, null);\n<line_number-383>\n<line_number-384>        List<List<String>> emptySelectOrder = new ArrayList<>();\n<line_number-385>        MongoResultSetMetaData emptySelectOrderMetadata =\n<line_number-386>                new MongoResultSetMetaData(\n<line_number-387>                        schema, emptySelectOrder, true, mongoConnection.getLogger(), 0, null);\n<line_number-388>\n<line_number-389>        assertEquals(12, nullSelectOrderMetadata.getColumnCount());\n<line_number-390>        assertEquals(12, emptySelectOrderMetadata.getColumnCount());\n<line_number-391>    }\n<line_number-392>}\n",
        "comments": [
          {
            "comment_code_range": "17-37",
            "comment_linenumber": "16",
            "comment": "This class tests the functionality of MongoResultSetMetaData, ensuring it behaves correctly with various metadata operations.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "40-53",
            "comment_linenumber": "39",
            "comment": "Static block initializes the MongoResultSetMetaData instance with a generated schema and other parameters for testing.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "55-58",
            "comment_linenumber": "54",
            "comment": "Initializes mocks before all tests are run, ensuring proper setup for Mockito.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "60-62",
            "comment_linenumber": "59",
            "comment": "Tests the getColumnCount method to verify it returns the correct number of columns.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "65-164",
            "comment_linenumber": "64",
            "comment": "Tests the order of metadata fields, verifying sorting behavior based on the sortFieldsAlphabetically flag.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "166-170",
            "comment_linenumber": "165",
            "comment": "Tests retrieval of catalog and schema names, ensuring they return empty strings for specified columns.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "172-186",
            "comment_linenumber": "171",
            "comment": "Tests the getColumnName method for various columns to ensure correct names are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "189-203",
            "comment_linenumber": "188",
            "comment": "Tests the getColumnLabel method for various columns to ensure correct labels are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "206-219",
            "comment_linenumber": "205",
            "comment": "Tests the getTableName method for various columns to ensure correct table names are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "221-233",
            "comment_linenumber": "220",
            "comment": "Tests the isCaseSensitive method for various columns to verify case sensitivity behavior.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "236-251",
            "comment_linenumber": "235",
            "comment": "Tests the isNullable method for various columns to ensure correct nullability is reported.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "254-266",
            "comment_linenumber": "253",
            "comment": "Tests the isSigned method for various columns to verify if they are signed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "269-281",
            "comment_linenumber": "268",
            "comment": "Tests the getColumnDisplaySize method for various columns to ensure correct display sizes are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "284-296",
            "comment_linenumber": "283",
            "comment": "Tests the getPrecision method for various columns to ensure correct precision values are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "299-311",
            "comment_linenumber": "298",
            "comment": "Tests the getScale method for various columns to ensure correct scale values are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "314-326",
            "comment_linenumber": "313",
            "comment": "Tests the getColumnType method for various columns to ensure correct SQL types are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "329-341",
            "comment_linenumber": "328",
            "comment": "Tests the getColumnTypeClassName method for various columns to ensure correct class names are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "346-358",
            "comment_linenumber": "345",
            "comment": "Tests the getColumnTypeName method for various columns to ensure correct type names are returned.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "361-373",
            "comment_linenumber": "360",
            "comment": "Tests the getDatasource method for various columns, including checks for exceptions on duplicated column names.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "376-391",
            "comment_linenumber": "375",
            "comment": "Tests behavior when the select order is empty, ensuring correct column counts are returned.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoResultSetMetaDataTest.java' is a JUnit test class designed to validate the functionality of the 'MongoResultSetMetaData' class. It employs the Mockito framework for mocking dependencies and is structured to ensure comprehensive coverage of the methods within 'MongoResultSetMetaData'. The class is annotated with '@ExtendWith(MockitoExtension.class)' to enable Mockito's features and '@TestInstance(TestInstance.Lifecycle.PER_CLASS)' to allow instance methods to be used for tests. The tests cover various aspects of metadata retrieval, including column count, names, labels, types, and properties such as nullability and case sensitivity. Each test method is self-contained, asserting expected outcomes against actual results, and utilizes static initialization for setting up the test environment. The class extends 'MongoMock', indicating it may inherit mock configurations or utilities relevant to MongoDB testing. Overall, the structure promotes clarity and maintainability, ensuring that each test is focused on a specific behavior of the 'MongoResultSetMetaData' class.",
        "file_summary": "This file contains unit tests for the 'MongoResultSetMetaData' class, validating its behavior and ensuring it correctly handles various metadata operations related to MongoDB. The tests cover aspects such as column count, names, labels, types, and properties, ensuring the integrity and reliability of the metadata handling functionality."
      }
    ]
  },
  "MongoResultSetTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoResultSetTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\MongoResultSetTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoResultSetTest.java",
        "chunk_id": "MongoResultSetTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static org.junit.jupiter.api.Assertions.*;\n<line_number-20>import static org.mockito.Mockito.when;\n<line_number-21>\n<line_number-22>import com.mongodb.client.MongoCursor;\n<line_number-23>import java.math.BigDecimal;\n<line_number-24>import java.sql.ResultSetMetaData;\n<line_number-25>import java.sql.SQLException;\n<line_number-26>import java.sql.Time;\n<line_number-27>import java.sql.Timestamp;\n<line_number-28>import java.sql.Types;\n<line_number-29>import java.util.ArrayList;\n<line_number-30>import java.util.Arrays;\n<line_number-31>import java.util.HashMap;\n<line_number-32>import java.util.HashSet;\n<line_number-33>import java.util.Iterator;\n<line_number-34>import java.util.List;\n<line_number-35>import java.util.concurrent.atomic.AtomicBoolean;\n<line_number-36>import org.bson.BsonArray;\n<line_number-37>import org.bson.BsonBinary;\n<line_number-38>import org.bson.BsonDateTime;\n<line_number-39>import org.bson.BsonDocument;\n<line_number-40>import org.bson.BsonDouble;\n<line_number-41>import org.bson.BsonInt32;\n<line_number-42>import org.bson.BsonNull;\n<line_number-43>import org.bson.BsonString;\n<line_number-44>import org.bson.BsonUndefined;\n<line_number-45>import org.bson.UuidRepresentation;\n<line_number-46>import org.bson.codecs.BsonDateTimeCodec;\n<line_number-47>import org.bson.codecs.Codec;\n<line_number-48>import org.bson.codecs.DecoderContext;\n<line_number-49>import org.bson.json.JsonReader;\n<line_number-50>import org.junit.jupiter.api.BeforeAll;\n<line_number-51>import org.junit.jupiter.api.BeforeEach;\n<line_number-52>import org.junit.jupiter.api.Test;\n<line_number-53>import org.junit.jupiter.api.TestInstance;\n<line_number-54>import org.junit.jupiter.api.extension.ExtendWith;\n<line_number-55>import org.mockito.Mock;\n<line_number-56>import org.mockito.MockitoAnnotations;\n<line_number-57>import org.mockito.junit.jupiter.MockitoExtension;\n<line_number-58>import org.mockito.junit.jupiter.MockitoSettings;\n<line_number-59>import org.mockito.quality.Strictness;\n<line_number-60>\n<line_number-61>@ExtendWith(MockitoExtension.class)\n<line_number-62>@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n<line_number-63>@MockitoSettings(strictness = Strictness.WARN)\n<line_number-64>class MongoResultSetTest extends MongoMock {\n<line_number-65>    @Mock MongoCursor<BsonDocument> cursor;\n<line_number-66>    MongoResultSet mockResultSet;\n<line_number-67>    static MongoResultSet mongoResultSet;\n<line_number-68>    static MongoResultSet mongoResultSetAllTypes;\n<line_number-69>    static MongoResultSet mongoResultSetAllTypesLegacyUUID;\n<line_number-70>    static MongoResultSet mongoResultSetAllTypesExtJson;\n<line_number-71>    static MongoResultSet closedMongoResultSet;\n<line_number-72>    static MongoResultSet mongoResultSetExtended;\n<line_number-73>\n<line_number-74>    private static MongoResultSetMetaData resultSetMetaData;\n<line_number-75>    private static MongoStatement mongoStatement;\n<line_number-76>    private static MongoJsonSchema schema;\n<line_number-77>\n<line_number-78>    static {\n<line_number-79>        try {\n<line_number-80>            schema = generateMongoJsonSchema();\n<line_number-81>            resultSetMetaData =\n<line_number-82>                    new MongoResultSetMetaData(\n<line_number-83>                            schema, null, true, mongoConnection.getLogger(), 0, null);\n<line_number-84>            mongoStatement = new MongoStatement(mongoConnection, \"test\");\n<line_number-85>        } catch (SQLException e) {\n<line_number-86>            throw new RuntimeException(e);\n<line_number-87>        }\n<line_number-88>\n<line_number-89>        BsonDocument document = new BsonDocument();\n<line_number-90>\n<line_number-91>        BsonDocument bot = new BsonDocument();\n<line_number-92>        BsonDocument foo = new BsonDocument();\n<line_number-93>        document.put(\"\", bot);\n<line_number-94>        document.put(\"foo\", foo);\n<line_number-95>\n<line_number-96>        bot.put(DOUBLE_COL_LABEL, new BsonDouble(2.4));\n<line_number-97>        byte binary[] = {10, 20, 30};\n<line_number-98>        bot.put(BINARY_COL_LABEL, new BsonBinary(binary));\n<line_number-99>        bot.put(STRING_COL_LABEL, new BsonString(\"b\"));\n<line_number-100>\n<line_number-101>        foo.put(ANY_OF_INT_STRING_COL_LABEL, new BsonInt32(3));\n<line_number-102>        foo.put(INT_NULLABLE_COL_LABEL, new BsonNull());\n<line_number-103>        foo.put(INT_COL_LABEL, new BsonInt32(4));\n<line_number-104>        foo.put(ANY_COL_LABEL, new BsonUndefined());\n<line_number-105>        foo.put(NULL_COL_LABEL, new BsonNull());\n<line_number-106>\n<line_number-107>        BsonArray array = new BsonArray();\n<line_number-108>        array.add(new BsonInt32(5));\n<line_number-109>        array.add(new BsonInt32(6));\n<line_number-110>        array.add(new BsonInt32(7));\n<line_number-111>        foo.put(ARRAY_COL_LABEL, array);\n<line_number-112>\n<line_number-113>        BsonDocument fooSubDoc = new BsonDocument();\n<line_number-114>        fooSubDoc.put(INT_COL_LABEL, new BsonInt32(5));\n<line_number-115>        foo.put(DOC_COL_LABEL, fooSubDoc);\n<line_number-116>\n<line_number-117>        List<BsonDocument> mongoResultDocs = new ArrayList<BsonDocument>();\n<line_number-118>        mongoResultDocs.add(document);\n<line_number-119>\n<line_number-120>        // All types result set\n<line_number-121>        BsonDocument docAllTypes = generateRowAllTypes();\n<line_number-122>        List<BsonDocument> mongoResultDocsAllTypes = new ArrayList<BsonDocument>();\n<line_number-123>        mongoResultDocsAllTypes.add(docAllTypes);\n<line_number-124>\n<line_number-125>        MongoJsonSchema schemaAllTypes = generateMongoJsonSchemaAllTypes();\n<line_number-126>\n<line_number-127>        try {\n<line_number-128>            mongoResultSet =\n<line_number-129>                    new MongoResultSet(\n<line_number-130>                            mongoStatement,\n<line_number-131>                            new BsonExplicitCursor(mongoResultDocs),\n<line_number-132>                            schema,\n<line_number-133>                            null,\n<line_number-134>                            false,\n<line_number-135>                            UuidRepresentation.STANDARD);\n<line_number-136>            mongoResultSetAllTypes =\n<line_number-137>                    new MongoResultSet(\n<line_number-138>                            mongoStatement,\n<line_number-139>                            new BsonExplicitCursor(mongoResultDocsAllTypes),\n<line_number-140>                            schemaAllTypes,\n<line_number-141>                            null,\n<line_number-142>                            false,\n<line_number-143>                            UuidRepresentation.STANDARD);\n<line_number-144>            mongoResultSetAllTypesLegacyUUID =\n<line_number-145>                    new MongoResultSet(\n<line_number-146>                            mongoStatement,\n<line_number-147>                            new BsonExplicitCursor(mongoResultDocsAllTypes),\n<line_number-148>                            schemaAllTypes,\n<line_number-149>                            null,\n<line_number-150>                            false,\n<line_number-151>                            UuidRepresentation.JAVA_LEGACY);\n<line_number-152>            mongoResultSetAllTypesExtJson =\n<line_number-153>                    new MongoResultSet(\n<line_number-154>                            mongoStatement,\n<line_number-155>                            new BsonExplicitCursor(mongoResultDocsAllTypes),\n<line_number-156>                            schemaAllTypes,\n<line_number-157>                            null,\n<line_number-158>                            true,\n<line_number-159>                            UuidRepresentation.STANDARD);\n<line_number-160>            closedMongoResultSet =\n<line_number-161>                    new MongoResultSet(\n<line_number-162>                            mongoStatement,\n<line_number-163>                            new BsonExplicitCursor(mongoResultDocs),\n<line_number-164>                            schema,\n<line_number-165>                            null,\n<line_number-166>                            false,\n<line_number-167>                            UuidRepresentation.STANDARD);\n<line_number-168>            mongoResultSetExtended =\n<line_number-169>                    new MongoResultSet(\n<line_number-170>                            mongoStatement,\n<line_number-171>                            new BsonExplicitCursor(mongoResultDocs),\n<line_number-172>                            schema,\n<line_number-173>                            null,\n<line_number-174>                            true,\n<line_number-175>                            UuidRepresentation.STANDARD);\n<line_number-176>            mongoResultSet.next();\n<line_number-177>            mongoResultSetAllTypes.next();\n<line_number-178>            mongoResultSetAllTypesLegacyUUID.next();\n<line_number-179>            mongoResultSetAllTypesExtJson.next();\n<line_number-180>            closedMongoResultSet.next();\n<line_number-181>            mongoResultSetExtended.next();\n<line_number-182>        } catch (Exception e) {\n<line_number-183>            throw new RuntimeException(e);\n<line_number-184>        }\n<line_number-185>    }\n<line_number-186>\n<line_number-187>    @BeforeAll\n<line_number-188>    void initMocks() {\n<line_number-189>        MockitoAnnotations.initMocks(this);\n<line_number-190>    }\n<line_number-191>\n<line_number-192>    @BeforeEach\n<line_number-193>    void setup() throws NoSuchFieldException {\n<line_number-194>        MongoMock.resetMockObjs();\n<line_number-195>    }\n<line_number-196>\n<line_number-197>    @Test\n<line_number-198>    void testBinaryGetters() throws Exception {\n<line_number-199>        // Binary cannot be gotten through anything other than getString, getBlob, and getBinaryStream, currently.\n<line_number-200>        assertThrows(\n<line_number-201>                SQLException.class,\n<line_number-202>                () -> {\n<line_number-203>                    mongoResultSet.getBoolean(BINARY_COL);\n<line_number-204>                });\n<line_number-205>        assertThrows(\n<line_number-206>                SQLException.class,\n<line_number-207>                () -> {\n<line_number-208>                    mongoResultSet.getLong(BINARY_COL);\n<line_number-209>                });\n<line_number-210>        assertThrows(\n<line_number-211>                SQLException.class,\n<line_number-212>                () -> {\n<line_number-213>                    mongoResultSet.getDouble(BINARY_COL);\n<line_number-214>                });\n<line_number-215>        assertThrows(\n<line_number-216>                SQLException.class,\n<line_number-217>                () -> {\n<line_number-218>                    mongoResultSet.getBigDecimal(BINARY_COL);\n<line_number-219>                });\n<line_number-220>        assertThrows(\n<line_number-221>                SQLException.class,\n<line_number-222>                () -> {\n<line_number-223>                    mongoResultSet.getTimestamp(BINARY_COL);\n<line_number-224>                });\n<line_number-225>\n<line_number-226>        // Test wasNull.\n<line_number-227>        mongoResultSet.getString(INT_OR_NULL_COL);\n<line_number-228>        assertTrue(mongoResultSet.wasNull());\n<line_number-229>        mongoResultSet.getString(DOUBLE_COL);\n<line_number-230>        assertFalse(mongoResultSet.wasNull());\n<line_number-231>\n<line_number-232>        mongoResultSet.getString(ANY_COL);\n<line_number-233>        assertTrue(mongoResultSet.wasNull());\n<line_number-234>\n<line_number-235>        // Only Binary and null values can be gotten from getBlob\n<line_number-236>        assertNotNull(mongoResultSet.getBlob(BINARY_COL_LABEL));\n<line_number-237>        assertThrows(\n<line_number-238>                SQLException.class,\n<line_number-239>                () -> {\n<line_number-240>                    mongoResultSet.getBlob(STRING_COL_LABEL);\n<line_number-241>                });\n<line_number-242>        assertNull(mongoResultSet.getBlob(NULL_COL));\n<line_number-243>        assertThrows(\n<line_number-244>                SQLException.class,\n<line_number-245>                () -> {\n<line_number-246>                    mongoResultSet.getBlob(DOUBLE_COL);\n<line_number-247>                });\n<line_number-248>        assertThrows(\n<line_number-249>                SQLException.class,\n<line_number-250>                () -> {\n<line_number-251>                    mongoResultSet.getBlob(ARRAY_COL);\n<line_number-252>                });\n<line_number-253>        assertThrows(\n<line_number-254>                SQLException.class,\n<line_number-255>                () -> {\n<line_number-256>                    mongoResultSet.getBlob(DOC_COL);\n<line_number-257>                });\n<line_number-258>        assertThrows(\n<line_number-259>                SQLException.class,\n<line_number-260>                () -> {\n<line_number-261>                    mongoResultSet.getBlob(INT_COL);\n<line_number-262>                });\n<line_number-263>\n<line_number-264>        // Only Binary and null values can be gotten from getBinaryStream\n<line_number-265>        assertNotNull(mongoResultSet.getBinaryStream(BINARY_COL_LABEL));\n<line_number-266>        assertThrows(\n<line_number-267>                SQLException.class,\n<line_number-268>                () -> {\n<line_number-269>                    mongoResultSet.getBinaryStream(STRING_COL_LABEL);\n<line_number-270>                });\n<line_number-271>\n<line_number-272>        assertNull(mongoResultSet.getBinaryStream(NULL_COL));\n<line_number-273>        assertThrows(\n<line_number-274>                SQLException.class,\n<line_number-275>                () -> {\n<line_number-276>                    mongoResultSet.getBinaryStream(DOUBLE_COL);\n<line_number-277>                });\n<line_number-278>        assertThrows(\n<line_number-279>                SQLException.class,\n<line_number-280>                () -> {\n<line_number-281>                    mongoResultSet.getBinaryStream(STRING_COL);\n<line_number-282>                });\n<line_number-283>        assertThrows(\n<line_number-284>                SQLException.class,\n<line_number-285>                () -> {\n<line_number-286>                    mongoResultSet.getBinaryStream(INT_COL);\n<line_number-287>                });\n<line_number-288>        assertThrows(\n<line_number-289>                SQLException.class,\n<line_number-290>                () -> {\n<line_number-291>                    mongoResultSet.getBinaryStream(ARRAY_COL);\n<line_number-292>                });\n<line_number-293>        assertThrows(\n<line_number-294>                SQLException.class,\n<line_number-295>                () -> {\n<line_number-296>                    mongoResultSet.getBinaryStream(DOC_COL);\n<line_number-297>                });\n<line_number-298>\n<line_number-299>        // Only Binary and null values can be gotten from getBytes\n<line_number-300>        assertNotNull(mongoResultSet.getBinaryStream(BINARY_COL_LABEL));\n<line_number-301>        assertThrows(\n<line_number-302>                SQLException.class,\n<line_number-303>                () -> {\n<line_number-304>                    mongoResultSet.getBytes(STRING_COL_LABEL);\n<line_number-305>                });\n<line_number-306>        assertNull(mongoResultSet.getBytes(NULL_COL));\n<line_number-307>        assertThrows(\n<line_number-308>                SQLException.class,\n<line_number-309>                () -> {\n<line_number-310>                    mongoResultSet.getBytes(DOUBLE_COL);\n<line_number-311>                });\n<line_number-312>        assertThrows(\n<line_number-313>                SQLException.class,\n<line_number-314>                () -> {\n<line_number-315>                    mongoResultSet.getBytes(INT_COL);\n<line_number-316>                });\n<line_number-317>    }\n<line_number-318>\n<line_number-319>    @Test\n<line_number-320>    void testGetUuidValues() throws Exception {\n<line_number-321>        // Test standard UUID\n<line_number-322>        Object actualStandardUuid = mongoResultSetAllTypes.getObject(ALL_STANDARD_UUID_COL_LABEL);\n<line_number-323>        assertEquals(ALL_UUID_VAL, actualStandardUuid);\n<line_number-324>\n<line_number-325>        // Test legacy UUID\n<line_number-326>        Object actualLegacyUuid =\n<line_number-327>                mongoResultSetAllTypesLegacyUUID.getObject(ALL_LEGACY_UUID_COL_LABEL);\n<line_number-328>        assertEquals(ALL_UUID_VAL, actualLegacyUuid);\n<line_number-329>\n<line_number-330>        // Test UUID as string\n<line_number-331>        assertEquals(\n<line_number-332>                ALL_UUID_STRING_EXT_VAL,\n<line_number-333>                mongoResultSetAllTypes.getString(ALL_STANDARD_UUID_COL_LABEL));\n<line_number-334>        assertEquals(\n<line_number-335>                ALL_UUID_STRING_EXT_VAL,\n<line_number-336>                mongoResultSetAllTypesLegacyUUID.getString(ALL_LEGACY_UUID_COL_LABEL));\n<line_number-337>        assertEquals(\n<line_number-338>                ALL_UUID_STRING_EXT_VAL,\n<line_number-339>                mongoResultSetAllTypesExtJson.getString(ALL_STANDARD_UUID_COL_LABEL));\n<line_number-340>    }\n<line_number-341>\n<line_number-342>    @Test\n<line_number-343>    void testGetColumnByIdAndName() throws Exception {\n<line_number-344>        assertEquals(DOUBLE_COL, mongoResultSet.findColumn(DOUBLE_COL_LABEL));\n<line_number-345>        assertEquals(STRING_COL, mongoResultSet.findColumn(STRING_COL_LABEL));\n<line_number-346>        assertEquals(INT_OR_NULL_COL, mongoResultSet.findColumn(INT_NULLABLE_COL_LABEL));\n<line_number-347>        assertEquals(INT_COL, mongoResultSet.findColumn(INT_COL_LABEL));\n<line_number-348>        assertEquals(ANY_COL, mongoResultSet.findColumn(ANY_COL_LABEL));\n<line_number-349>        assertEquals(ARRAY_COL, mongoResultSet.findColumn(ARRAY_COL_LABEL));\n<line_number-350>        assertEquals(DOC_COL, mongoResultSet.findColumn(DOC_COL_LABEL));\n<line_number-351>        assertThrows(SQLException.class, () -> mongoResultSet.findColumn(BOT_DUP_COL_LABEL));\n<line_number-352>        assertThrows(SQLException.class, () -> mongoResultSet.findColumn(FOO_DUP_COL_LABEL));\n<line_number-353>\n<line_number-354>        // Test that the IDX and LABELS are working together correctly.\n<line_number-355>        assertEquals(\n<line_number-356>                mongoResultSet.getString(DOUBLE_COL), mongoResultSet.getString(DOUBLE_COL_LABEL));\n<line_number-357>        assertEquals(\n<line_number-358>                mongoResultSet.getString(STRING_COL), mongoResultSet.getString(STRING_COL_LABEL));\n<line_number-359>        assertEquals(\n<line_number-360>                mongoResultSet.getString(INT_OR_NULL_COL),\n<line_number-361>                mongoResultSet.getString(INT_NULLABLE_COL_LABEL));\n<line_number-362>        assertEquals(mongoResultSet.getString(INT_COL), mongoResultSet.getString(INT_COL_LABEL));\n<line_number-363>        assertEquals(mongoResultSet.getString(ANY_COL), mongoResultSet.getString(ANY_COL_LABEL));\n<line_number-364>        assertEquals(\n<line_number-365>                mongoResultSet.getBytes(BINARY_COL), mongoResultSet.getBytes(BINARY_COL_LABEL));\n<line_number-366>    }\n<line_number-367>\n<line_number-368>    @Test\n<line_number-369>    void testGetStringValues() throws Exception {\n<line_number-370>        // DOUBLE_COL              2.4\n<line_number-371>        // STRING_COL              \"b\"\n<line_number-372>        // BINARY_COL              [10, 20, 30]\n<line_number-373>        // ANY_OF_INT_STRING_COL   3\n<line_number-374>        // INT_OR_NULL_COL         null\n<line_number-375>        // NULL_COL                null\n<line_number-376>        // INT_COL                 4\n<line_number-377>        // ANY_COL                 \"{}\"\n<line_number-378>        // ARRAY_COL               [5, 6, 7]\n<line_number-379>        // DOC_COL                 {\"c\": 5}\n<line_number-380>\n<line_number-381>        //Test String values are as expected\n<line_number-382>        assertEquals(\"2.4\", mongoResultSet.getString(DOUBLE_COL_LABEL));\n<line_number-383>        assertEquals(\"b\", mongoResultSet.getString(STRING_COL_LABEL));\n<line_number-384>        assertNull(mongoResultSet.getString(INT_NULLABLE_COL_LABEL));\n<line_number-385>        assertNull(mongoResultSet.getString(NULL_COL));\n<line_number-386>        assertEquals(\"4\", mongoResultSet.getString(INT_COL_LABEL));\n<line_number-387>        assertNull(mongoResultSet.getString(ANY_COL_LABEL));\n<line_number-388>        assertEquals(\"[5, 6, 7]\", mongoResultSet.getString(ARRAY_COL_LABEL));\n<line_number-389>        assertEquals(\"{\\\"c\\\": 5}\", mongoResultSet.getString(DOC_COL_LABEL));\n<line_number-390>\n<line_number-391>        // Check getAsciiStream and getUnicodeStream output are non-null.\n<line_number-392>        assertNotNull(mongoResultSet.getAsciiStream(STRING_COL_LABEL));\n<line_number-393>        assertNotNull(mongoResultSet.getUnicodeStream(STRING_COL_LABEL));\n<line_number-394>\n<line_number-395>        // Actually check getAsciiStream and getUnicodeStream output. We just check\n<line_number-396>        // that the length is what is expected.\n<line_number-397>        assertEquals(\n<line_number-398>                1, mongoResultSet.getAsciiStream(STRING_COL_LABEL).read(new byte[100], 0, 100));\n<line_number-399>        assertEquals(\n<line_number-400>                1, mongoResultSet.getUnicodeStream(STRING_COL_LABEL).read(new byte[100], 0, 100));\n<line_number-401>    }\n<line_number-402>\n<line_number-403>    @Test\n<line_number-404>    public void testGetStringAllTypes() throws Exception {\n<line_number-405>        // non-null types\n<line_number-406>        assertEquals(ALL_DOUBLE_COL_VAL, mongoResultSetAllTypes.getString(ALL_DOUBLE_COL_LABEL));\n<line_number-407>        assertEquals(ALL_OBJECT_COL_VAL, mongoResultSetAllTypes.getString(ALL_OBJECT_COL_LABEL));\n<line_number-408>        assertEquals(ALL_ARRAY_COL_VAL, mongoResultSetAllTypes.getString(ALL_ARRAY_COL_LABEL));\n<line_number-409>        assertEquals(ALL_BINARY_COL_VAL, mongoResultSetAllTypes.getString(ALL_BINARY_COL_LABEL));\n<line_number-410>        assertEquals(\n<line_number-411>                ALL_OBJECT_ID_COL_VAL, mongoResultSetAllTypes.getString(ALL_OBJECT_ID_COL_LABEL));\n<line_number-412>        assertEquals(ALL_BOOL_COL_VAL, mongoResultSetAllTypes.getString(ALL_BOOL_COL_LABEL));\n<line_number-413>        assertEquals(ALL_DATE_COL_VAL, mongoResultSetAllTypes.getString(ALL_DATE_COL_LABEL));\n<line_number-414>        assertEquals(ALL_REGEX_COL_VAL, mongoResultSetAllTypes.getString(ALL_REGEX_COL_LABEL));\n<line_number-415>        assertEquals(\n<line_number-416>                ALL_JAVASCRIPT_COL_VAL, mongoResultSetAllTypes.getString(ALL_JAVASCRIPT_COL_LABEL));\n<line_number-417>        assertEquals(ALL_SYMBOL_COL_VAL, mongoResultSetAllTypes.getString(ALL_SYMBOL_COL_LABEL));\n<line_number-418>        assertEquals(\n<line_number-419>                ALL_JAVASCRIPT_WITH_SCOPE_COL_VAL,\n<line_number-420>                mongoResultSetAllTypes.getString(ALL_JAVASCRIPT_WITH_SCOPE_COL_LABEL));\n<line_number-421>        assertEquals(ALL_INT_COL_VAL, mongoResultSetAllTypes.getString(ALL_INT_COL_LABEL));\n<line_number-422>        assertEquals(\n<line_number-423>                ALL_TIMESTAMP_COL_VAL, mongoResultSetAllTypes.getString(ALL_TIMESTAMP_COL_LABEL));\n<line_number-424>        assertEquals(ALL_LONG_COL_VAL, mongoResultSetAllTypes.getString(ALL_LONG_COL_LABEL));\n<line_number-425>        assertEquals(ALL_DECIMAL_COL_VAL, mongoResultSetAllTypes.getString(ALL_DECIMAL_COL_LABEL));\n<line_number-426>        assertEquals(ALL_MIN_KEY_COL_VAL, mongoResultSetAllTypes.getString(ALL_MIN_KEY_COL_LABEL));\n<line_number-427>        assertEquals(ALL_MAX_KEY_COL_VAL, mongoResultSetAllTypes.getString(ALL_MAX_KEY_COL_LABEL));\n<line_number-428>\n<line_number-429>        // Note that the extended JSON representation of a string value is double quote delimited,\n<line_number-430>        // but we do not want to return quotes as part of the String.\n<line_number-431>        assertEquals(\"str\", mongoResultSetAllTypes.getString(ALL_STRING_COL_LABEL));\n<line_number-432>\n<line_number-433>        // Note that the Java driver still outputs the legacy representation for DBPointer, as\n<line_number-434>        // opposed to the new standard representation: { $dbPointer: { $ref: <namespace>, $id: <oid> } }.\n<line_number-435>        // This is sufficient for our purposes, though.\n<line_number-436>        assertEquals(\n<line_number-437>                \"{\\\"$ref\\\": \\\"db2\\\", \\\"$id\\\": \" + ALL_OBJECT_ID_COL_VAL + \"}\",\n<line_number-438>                mongoResultSetAllTypes.getString(ALL_DB_POINTER_COL_LABEL));\n<line_number-439>\n<line_number-440>        // Note that getString() returns null for NULL and UNDEFINED BSON values\n<line_number-441>        assertNull(mongoResultSetAllTypes.getString(ALL_UNDEFINED_COL_LABEL));\n<line_number-442>        assertNull(mongoResultSetAllTypes.getString(ALL_NULL_COL_LABEL));\n<line_number-443>    }\n<line_number-444>\n<line_number-445>    @Test\n<line_number-446>    public void testGetObjectToStringAllTypes() throws Exception {\n<line_number-447>        // Test getObject().toString() result for each BSON type.\n<line_number-448>        assertEquals(\n<line_number-449>                ALL_DOUBLE_COL_VAL,\n<line_number-450>                mongoResultSetAllTypes.getObject(ALL_DOUBLE_COL_LABEL).toString());\n<line_number-451>        assertEquals(\n<line_number-452>                ALL_OBJECT_COL_VAL,\n<line_number-453>                mongoResultSetAllTypes.getObject(ALL_OBJECT_COL_LABEL).toString());\n<line_number-454>        assertEquals(\n<line_number-455>                ALL_ARRAY_COL_VAL,\n<line_number-456>                mongoResultSetAllTypes.getObject(ALL_ARRAY_COL_LABEL).toString());\n<line_number-457>        assertEquals(\n<line_number-458>                ALL_OBJECT_ID_COL_VAL,\n<line_number-459>                mongoResultSetAllTypes.getObject(ALL_OBJECT_ID_COL_LABEL).toString());\n<line_number-460>        assertEquals(\n<line_number-461>                ALL_BOOL_COL_VAL, mongoResultSetAllTypes.getObject(ALL_BOOL_COL_LABEL).toString());\n<line_number-462>        assertEquals(\n<line_number-463>                ALL_REGEX_COL_VAL,\n<line_number-464>                mongoResultSetAllTypes.getObject(ALL_REGEX_COL_LABEL).toString());\n<line_number-465>        assertEquals(\n<line_number-466>                ALL_JAVASCRIPT_COL_VAL,\n<line_number-467>                mongoResultSetAllTypes.getObject(ALL_JAVASCRIPT_COL_LABEL).toString());\n<line_number-468>        assertEquals(\n<line_number-469>                ALL_SYMBOL_COL_VAL,\n<line_number-470>                mongoResultSetAllTypes.getObject(ALL_SYMBOL_COL_LABEL).toString());\n<line_number-471>        assertEquals(\n<line_number-472>                ALL_JAVASCRIPT_WITH_SCOPE_COL_VAL,\n<line_number-473>                mongoResultSetAllTypes.getObject(ALL_JAVASCRIPT_WITH_SCOPE_COL_LABEL).toString());\n<line_number-474>        assertEquals(\n<line_number-475>                ALL_INT_COL_VAL, mongoResultSetAllTypes.getObject(ALL_INT_COL_LABEL).toString());\n<line_number-476>        assertEquals(\n<line_number-477>                ALL_TIMESTAMP_COL_VAL,\n<line_number-478>                mongoResultSetAllTypes.getObject(ALL_TIMESTAMP_COL_LABEL).toString());\n<line_number-479>        assertEquals(\n<line_number-480>                ALL_MIN_KEY_COL_VAL,\n<line_number-481>                mongoResultSetAllTypes.getObject(ALL_MIN_KEY_COL_LABEL).toString());\n<line_number-482>        assertEquals(\n<line_number-483>                ALL_MAX_KEY_COL_VAL,\n<line_number-484>                mongoResultSetAllTypes.getObject(ALL_MAX_KEY_COL_LABEL).toString());\n<line_number-485>\n<line_number-486>        // Note that the extended JSON representation of a string value is double quote delimited,\n<line_number-487>        // but we do not want to return quotes as part of the String.\n<line_number-488>        assertEquals(\"str\", mongoResultSetAllTypes.getObject(ALL_STRING_COL_LABEL).toString());\n<line_number-489>\n<line_number-490>        // Note that the Java driver still outputs the legacy representation for DBPointer, as\n<line_number-491>        // opposed to the new standard representation: { $dbPointer: { $ref: <namespace>, $id: <oid> } }.\n<line_number-492>        // This is sufficient for our purposes, though.\n<line_number-493>        assertEquals(\n<line_number-494>                \"{\\\"$ref\\\": \\\"db2\\\", \\\"$id\\\": \" + ALL_OBJECT_ID_COL_VAL + \"}\",\n<line_number-495>                mongoResultSetAllTypes.getObject(ALL_DB_POINTER_COL_LABEL).toString());\n<line_number-496>\n<line_number-497>        // Note that getObject() returns null for NULL and UNDEFINED BSON values, so we check\n<line_number-498>        // manually that their stringification returns what is expected.\n<line_number-499>        assertNull(mongoResultSetAllTypes.getObject(ALL_UNDEFINED_COL_LABEL));\n<line_number-500>        assertNull(\n<line_number-501>                new MongoBsonValue(new BsonUndefined(), false, UuidRepresentation.STANDARD)\n<line_number-502>                        .toString());\n<line_number-503>        assertNull(mongoResultSetAllTypes.getObject(ALL_NULL_COL_LABEL));\n<line_number-504>        assertNull(\n<line_number-505>                new MongoBsonValue(new BsonNull(), false, UuidRepresentation.STANDARD).toString());\n<line_number-506>\n<line_number-507>        // Note that getObject() must return the following classes for the following types:\n<line_number-508>        //   - Types.BIGINT    => long\n<line_number-509>        //   - Types.DECIMAL   => java.math.BigDecimal\n<line_number-510>        //   - Types.BINARY    => byte[]\n<line_number-511>        //   - Types.TIMESTAMP => java.sql.Timestamp\n<line_number-512>        // Therefore, the getObject().toString() representations are not extended JSON.\n<line_number-513>        // Since Types.BINARY maps to an array, we omit its getObject().toString() test.\n<line_number-514>        assertEquals(\"2147483648\", mongoResultSetAllTypes.getObject(ALL_LONG_COL_LABEL).toString());\n<line_number-515>        assertEquals(\"21.2\", mongoResultSetAllTypes.getObject(ALL_DECIMAL_COL_LABEL).toString());\n<line_number-516>\n<line_number-517>        Codec<BsonDateTime> c = new BsonDateTimeCodec();\n<line_number-518>        BsonDateTime d =\n<line_number-519>                c.decode(new JsonReader(ALL_DATE_COL_VAL), DecoderContext.builder().build());\n<line_number-520>        Timestamp t = new Timestamp(d.getValue());\n<line_number-521>\n<line_number-522>        assertEquals(t.toString(), mongoResultSetAllTypes.getObject(ALL_DATE_COL_LABEL).toString());\n<line_number-523>\n<line_number-524>        // test that the string values match for the objects with EXTENDED and RELAXED json modes\n<line_number-525>        assertEquals(\n<line_number-526>                new MongoBsonValue(new BsonInt32(3), true, UuidRepresentation.STANDARD).toString(),\n<line_number-527>                mongoResultSetExtended.getObject(ANY_OF_INT_STRING_COL).toString());\n<line_number-528>        assertEquals(\n<line_number-529>                new MongoBsonValue(new BsonInt32(3), false, UuidRepresentation.STANDARD).toString(),\n<line_number-530>                mongoResultSet.getObject(ANY_OF_INT_STRING_COL).toString());\n<line_number-531>\n<line_number-532>        BsonDocument doc = new BsonDocument();\n<line_number-533>        doc.put(INT_COL_LABEL, new BsonInt32(5));\n<line_number-534>        assertEquals(\n<line_number-535>                new MongoBsonValue(doc, true, UuidRepresentation.STANDARD).toString(),\n<line_number-536>                mongoResultSetExtended.getObject(DOC_COL_LABEL).toString());\n<line_number-537>        assertEquals(\n<line_number-538>                new MongoBsonValue(doc, false, UuidRepresentation.STANDARD).toString(),\n<line_number-539>                mongoResultSet.getObject(DOC_COL_LABEL).toString());\n<line_number-540>\n<line_number-541>        BsonArray array = new BsonArray();\n<line_number-542>        array.add(new BsonInt32(5));\n<line_number-543>        array.add(new BsonInt32(6));\n<line_number-544>        array.add(new BsonInt32(7));\n<line_number-545>        assertEquals(\n<line_number-546>                (new MongoBsonValue(array, true, UuidRepresentation.STANDARD)).toString(),\n<line_number-547>                mongoResultSetExtended.getObject(ARRAY_COL_LABEL).toString());\n<line_number-548>        assertEquals(\n<line_number-549>                (new MongoBsonValue(array, false, UuidRepresentation.STANDARD)).toString(),\n<line_number-550>                mongoResultSet.getObject(ARRAY_COL_LABEL).toString());\n<line_number-551>    }\n<line_number-552>\n<line_number-553>    @Test\n<line_number-554>    public void testGetObjectToStringMatchesGetString() throws Exception {\n<line_number-555>        // Assert that getObject().toString() matches getString() for BSON types\n<line_number-556>        // that map to JDBC Types.OTHER.\n<line_number-557>        assertEquals(\n<line_number-558>                mongoResultSetAllTypes.getString(ALL_OBJECT_COL_LABEL),\n<line_number-559>                mongoResultSetAllTypes.getObject(ALL_OBJECT_COL_LABEL).toString());\n<line_number-560>        assertEquals(\n<line_number-561>                mongoResultSetAllTypes.getString(ALL_ARRAY_COL_LABEL),\n<line_number-562>                mongoResultSetAllTypes.getObject(ALL_ARRAY_COL_LABEL).toString());\n<line_number-563>        assertEquals(\n<line_number-564>                mongoResultSetAllTypes.getString(ALL_OBJECT_ID_COL_LABEL),\n<line_number-565>                mongoResultSetAllTypes.getObject(ALL_OBJECT_ID_COL_LABEL).toString());\n<line_number-566>        assertEquals(\n<line_number-567>                mongoResultSetAllTypes.getString(ALL_REGEX_COL_LABEL),\n<line_number-568>                mongoResultSetAllTypes.getObject(ALL_REGEX_COL_LABEL).toString());\n<line_number-569>        assertEquals(\n<line_number-570>                mongoResultSetAllTypes.getString(ALL_DB_POINTER_COL_LABEL),\n<line_number-571>                mongoResultSetAllTypes.getObject(ALL_DB_POINTER_COL_LABEL).toString());\n<line_number-572>        assertEquals(\n<line_number-573>                mongoResultSetAllTypes.getString(ALL_JAVASCRIPT_COL_LABEL),\n<line_number-574>                mongoResultSetAllTypes.getObject(ALL_JAVASCRIPT_COL_LABEL).toString());\n<line_number-575>        assertEquals(\n<line_number-576>                mongoResultSetAllTypes.getString(ALL_SYMBOL_COL_LABEL),\n<line_number-577>                mongoResultSetAllTypes.getObject(ALL_SYMBOL_COL_LABEL).toString());\n<line_number-578>        assertEquals(\n<line_number-579>                mongoResultSetAllTypes.getString(ALL_JAVASCRIPT_WITH_SCOPE_COL_LABEL),\n<line_number-580>                mongoResultSetAllTypes.getObject(ALL_JAVASCRIPT_WITH_SCOPE_COL_LABEL).toString());\n<line_number-581>        assertEquals(\n<line_number-582>                mongoResultSetAllTypes.getString(ALL_TIMESTAMP_COL_LABEL),\n<line_number-583>                mongoResultSetAllTypes.getObject(ALL_TIMESTAMP_COL_LABEL).toString());\n<line_number-584>        assertEquals(\n<line_number-585>                mongoResultSetAllTypes.getString(ALL_MIN_KEY_COL_LABEL),\n<line_number-586>                mongoResultSetAllTypes.getObject(ALL_MIN_KEY_COL_LABEL).toString());\n<line_number-587>        assertEquals(\n<line_number-588>                mongoResultSetAllTypes.getString(ALL_MAX_KEY_COL_LABEL),\n<line_number-589>                mongoResultSetAllTypes.getObject(ALL_MAX_KEY_COL_LABEL).toString());\n<line_number-590>    }\n<line_number-591>\n<line_number-592>    @Test\n<line_number-593>    void testGetCursorName() throws Exception {\n<line_number-594>        mongoStatement.setCursorName(\"test\");\n<line_number-595>        assertEquals(\"test\", mongoResultSet.getCursorName());\n<line_number-596>    }\n<line_number-597>\n<line_number-598>    @Test\n<line_number-599>    void testGetArithmeticValues() throws Exception {\n<line_number-600>        // Test Double values are as expected\n<line_number-601>        assertEquals(0.0, mongoResultSet.getDouble(INT_NULLABLE_COL_LABEL));\n<line_number-602>        assertEquals(2.4, mongoResultSet.getDouble(DOUBLE_COL_LABEL));\n<line_number-603>        assertThrows(\n<line_number-604>                SQLException.class,\n<line_number-605>                () -> {\n<line_number-606>                    mongoResultSet.getDouble(STRING_COL_LABEL);\n<line_number-607>                });\n<line_number-608>        assertEquals(4.0, mongoResultSet.getDouble(INT_COL_LABEL));\n<line_number-609>        assertEquals(3.0, mongoResultSet.getDouble(ANY_OF_INT_STRING_COL));\n<line_number-610>\n<line_number-611>        // Test BigDecimal values are as expected\n<line_number-612>        assertEquals(BigDecimal.ZERO, mongoResultSet.getBigDecimal(INT_NULLABLE_COL_LABEL));\n<line_number-613>        assertEquals(new BigDecimal(2.4), mongoResultSet.getBigDecimal(DOUBLE_COL_LABEL));\n<line_number-614>        assertThrows(\n<line_number-615>                SQLException.class,\n<line_number-616>                () -> {\n<line_number-617>                    mongoResultSet.getBigDecimal(STRING_COL_LABEL);\n<line_number-618>                });\n<line_number-619>        assertEquals(new BigDecimal(4.0), mongoResultSet.getBigDecimal(INT_COL_LABEL));\n<line_number-620>        assertEquals(new BigDecimal(3.0), mongoResultSet.getBigDecimal(ANY_OF_INT_STRING_COL));\n<line_number-621>\n<line_number-622>        // Test Long values are as expected\n<line_number-623>        assertEquals(0L, mongoResultSet.getLong(INT_NULLABLE_COL_LABEL));\n<line_number-624>        assertEquals(2, mongoResultSet.getLong(DOUBLE_COL_LABEL));\n<line_number-625>        assertThrows(\n<line_number-626>                SQLException.class,\n<line_number-627>                () -> {\n<line_number-628>                    mongoResultSet.getLong(STRING_COL_LABEL);\n<line_number-629>                });\n<line_number-630>        assertEquals(4L, mongoResultSet.getLong(INT_COL_LABEL));\n<line_number-631>        assertEquals(3L, mongoResultSet.getLong(ANY_OF_INT_STRING_COL));\n<line_number-632>\n<line_number-633>        // Test Int values are as expected\n<line_number-634>        assertEquals(0, mongoResultSet.getInt(INT_NULLABLE_COL_LABEL));\n<line_number-635>        assertEquals(2, mongoResultSet.getInt(DOUBLE_COL_LABEL));\n<line_number-636>        assertThrows(\n<line_number-637>                SQLException.class,\n<line_number-638>                () -> {\n<line_number-639>                    mongoResultSet.getInt(STRING_COL_LABEL);\n<line_number-640>                });\n<line_number-641>        assertEquals(4, mongoResultSet.getInt(INT_COL_LABEL));\n<line_number-642>        assertEquals(3, mongoResultSet.getInt(ANY_OF_INT_STRING_COL));\n<line_number-643>    }\n<line_number-644>\n<line_number-645>    @Test\n<line_number-646>    void testGetByteValues() throws Exception {\n<line_number-647>        // Test Byte values are as expected\n<line_number-648>        assertEquals(0, mongoResultSet.getByte(INT_NULLABLE_COL_LABEL));\n<line_number-649>        assertEquals(2, mongoResultSet.getByte(DOUBLE_COL_LABEL));\n<line_number-650>        assertThrows(\n<line_number-651>                SQLException.class,\n<line_number-652>                () -> {\n<line_number-653>                    mongoResultSet.getByte(STRING_COL_LABEL);\n<line_number-654>                });\n<line_number-655>\n<line_number-656>        assertEquals(4, mongoResultSet.getByte(INT_COL_LABEL));\n<line_number-657>        assertEquals(3, mongoResultSet.getByte(ANY_OF_INT_STRING_COL));\n<line_number-658>    }\n<line_number-659>\n<line_number-660>    @Test\n<line_number-661>    void testGetBooleanValues() throws Exception {\n<line_number-662>        // Test Boolean values are as expected\n<line_number-663>        assertEquals(false, mongoResultSet.getBoolean(INT_NULLABLE_COL_LABEL));\n<line_number-664>        assertEquals(true, mongoResultSet.getBoolean(DOUBLE_COL_LABEL));\n<line_number-665>        // MongoDB converts all strings to true, even \"\"\n<line_number-666>        assertEquals(true, mongoResultSet.getBoolean(STRING_COL_LABEL));\n<line_number-667>        assertEquals(true, mongoResultSet.getBoolean(INT_COL_LABEL));\n<line_number-668>        assertEquals(true, mongoResultSet.getBoolean(ANY_OF_INT_STRING_COL));\n<line_number-669>    }\n<line_number-670>\n<line_number-671>    @Test\n<line_number-672>    void testGetTimestampValues() throws Exception {\n<line_number-673>\n<line_number-674>        assertNull(mongoResultSet.getTimestamp(NULL_COL_LABEL));\n<line_number-675>        assertEquals(new Timestamp(2), mongoResultSet.getTimestamp(DOUBLE_COL_LABEL));\n<line_number-676>        assertThrows(\n<line_number-677>                SQLException.class,\n<line_number-678>                () -> {\n<line_number-679>                    mongoResultSet.getTimestamp(STRING_COL_LABEL);\n<line_number-680>                });\n<line_number-681>        assertEquals(new Timestamp(4L), mongoResultSet.getTimestamp(INT_COL_LABEL));\n<line_number-682>        assertEquals(new Timestamp(3L), mongoResultSet.getTimestamp(ANY_OF_INT_STRING_COL));\n<line_number-683>\n<line_number-684>        assertNull(mongoResultSet.getTime(NULL_COL_LABEL));\n<line_number-685>        assertEquals(new Time(2), mongoResultSet.getTime(DOUBLE_COL_LABEL));\n<line_number-686>        assertThrows(\n<line_number-687>                SQLException.class,\n<line_number-688>                () -> {\n<line_number-689>                    mongoResultSet.getTime(STRING_COL_LABEL);\n<line_number-690>                });\n<line_number-691>        assertEquals(new Time(4L), mongoResultSet.getTime(INT_COL_LABEL));\n<line_number-692>        assertEquals(new Time(3L), mongoResultSet.getTime(ANY_OF_INT_STRING_COL));\n<line_number-693>\n<line_number-694>        assertNull(mongoResultSet.getTimestamp(NULL_COL_LABEL));\n<line_number-695>        assertEquals(new Timestamp(2), mongoResultSet.getTimestamp(DOUBLE_COL_LABEL));\n<line_number-696>        assertThrows(\n<line_number-697>                SQLException.class,\n<line_number-698>                () -> {\n<line_number-699>                    mongoResultSet.getTimestamp(STRING_COL_LABEL);\n<line_number-700>                });\n<line_number-701>        assertEquals(new Timestamp(4L), mongoResultSet.getTimestamp(INT_COL_LABEL));\n<line_number-702>        assertEquals(new Timestamp(3L), mongoResultSet.getTimestamp(ANY_OF_INT_STRING_COL));\n<line_number-703>    }\n<line_number-704>\n<line_number-705>    @Test\n<line_number-706>    void testGetObject() throws Exception {\n<line_number-707>        // test that the index and label versions of getObject have matching results\n<line_number-708>        assertEquals(\n<line_number-709>                mongoResultSet.getObject(DOUBLE_COL), mongoResultSet.getObject(DOUBLE_COL_LABEL));\n<line_number-710>        assertEquals(\n<line_number-711>                mongoResultSet.getObject(STRING_COL), mongoResultSet.getObject(STRING_COL_LABEL));\n<line_number-712>        assertEquals(\n<line_number-713>                mongoResultSet.getObject(INT_OR_NULL_COL),\n<line_number-714>                mongoResultSet.getObject(INT_NULLABLE_COL_LABEL));\n<line_number-715>        assertEquals(mongoResultSet.getObject(INT_COL), mongoResultSet.getObject(INT_COL_LABEL));\n<line_number-716>        assertEquals(mongoResultSet.getObject(ANY_COL), mongoResultSet.getObject(ANY_COL_LABEL));\n<line_number-717>        assertEquals(\n<line_number-718>                mongoResultSet.getObject(ARRAY_COL), mongoResultSet.getObject(ARRAY_COL_LABEL));\n<line_number-719>        assertEquals(mongoResultSet.getObject(DOC_COL), mongoResultSet.getObject(DOC_COL_LABEL));\n<line_number-720>\n<line_number-721>        // test that getObject returns the expected java object for each bson type\n<line_number-722>        assertNull(mongoResultSet.getObject(NULL_COL_LABEL));\n<line_number-723>        assertEquals(2.4, mongoResultSet.getObject(DOUBLE_COL_LABEL));\n<line_number-724>        assertEquals(\"b\", mongoResultSet.getObject(STRING_COL_LABEL));\n<line_number-725>        assertEquals(\n<line_number-726>                new MongoBsonValue(new BsonInt32(3), false, UuidRepresentation.STANDARD),\n<line_number-727>                mongoResultSet.getObject(ANY_OF_INT_STRING_COL));\n<line_number-728>\n<line_number-729>        assertNull(mongoResultSet.getObject(NULL_COL));\n<line_number-730>        assertEquals(4, mongoResultSet.getObject(INT_COL_LABEL));\n<line_number-731>\n<line_number-732>        assertNull(mongoResultSet.getObject(ANY_COL_LABEL));\n<line_number-733>\n<line_number-734>        BsonArray array = new BsonArray();\n<line_number-735>        array.add(new BsonInt32(5));\n<line_number-736>        array.add(new BsonInt32(6));\n<line_number-737>        array.add(new BsonInt32(7));\n<line_number-738>        assertEquals(\n<line_number-739>                new MongoBsonValue(array, false, UuidRepresentation.STANDARD),\n<line_number-740>                mongoResultSet.getObject(ARRAY_COL_LABEL));\n<line_number-741>\n<line_number-742>        BsonDocument doc = new BsonDocument();\n<line_number-743>        doc.put(INT_COL_LABEL, new BsonInt32(5));\n<line_number-744>        assertEquals(\n<line_number-745>                new MongoBsonValue(doc, false, UuidRepresentation.STANDARD),\n<line_number-746>                mongoResultSet.getObject(DOC_COL_LABEL));\n<line_number-747>\n<line_number-748>        byte[] binary = {10, 20, 30};\n<line_number-749>        assertArrayEquals(binary, (byte[]) mongoResultSet.getObject(BINARY_COL_LABEL));\n<line_number-750>    }\n<line_number-751>\n<line_number-752>    @SuppressWarnings(\"deprecation\")\n<line_number-753>    @Test\n<line_number-754>    void closedResultSets() throws Exception {\n<line_number-755>        try {\n<line_number-756>            closedMongoResultSet.close();\n<line_number-757>        } catch (SQLException e) {\n<line_number-758>            throw new RuntimeException(e);\n<line_number-759>        }\n<line_number-760>\n<line_number-761>        assertTrue(closedMongoResultSet.isClosed());\n<line_number-762>\n<line_number-763>        assertThrows(\n<line_number-764>                SQLException.class,\n<line_number-765>                () -> {\n<line_number-766>                    closedMongoResultSet.next();\n<line_number-767>                });\n<line_number-768>        assertThrows(\n<line_number-769>                SQLException.class,\n<line_number-770>                () -> {\n<line_number-771>                    closedMongoResultSet.wasNull();\n<line_number-772>                });\n<line_number-773>        assertThrows(\n<line_number-774>                SQLException.class,\n<line_number-775>                () -> {\n<line_number-776>                    closedMongoResultSet.getBigDecimal(0);\n<line_number-777>                });\n<line_number-778>        assertThrows(\n<line_number-779>                SQLException.class,\n<line_number-780>                () -> {\n<line_number-781>                    closedMongoResultSet.getBytes(0);\n<line_number-782>                });\n<line_number-783>        assertThrows(\n<line_number-784>                SQLException.class,\n<line_number-785>                () -> {\n<line_number-786>                    closedMongoResultSet.getBytes(\"f\");\n<line_number-787>                });\n<line_number-788>        assertThrows(\n<line_number-789>                SQLException.class,\n<line_number-790>                () -> {\n<line_number-791>                    closedMongoResultSet.getAsciiStream(0);\n<line_number-792>                });\n<line_number-793>        assertThrows(\n<line_number-794>                SQLException.class,\n<line_number-795>                () -> {\n<line_number-796>                    closedMongoResultSet.getAsciiStream(\"f\");\n<line_number-797>                });\n<line_number-798>        assertThrows(\n<line_number-799>                SQLException.class,\n<line_number-800>                () -> {\n<line_number-801>                    closedMongoResultSet.getUnicodeStream(0);\n<line_number-802>                });\n<line_number-803>        assertThrows(\n<line_number-804>                SQLException.class,\n<line_number-805>                () -> {\n<line_number-806>                    closedMongoResultSet.getUnicodeStream(\"f\");\n<line_number-807>                });\n<line_number-808>        assertThrows(\n<line_number-809>                SQLException.class,\n<line_number-810>                () -> {\n<line_number-811>                    closedMongoResultSet.getBinaryStream(0);\n<line_number-812>                });\n<line_number-813>        assertThrows(\n<line_number-814>                SQLException.class,\n<line_number-815>                () -> {\n<line_number-816>                    closedMongoResultSet.getBinaryStream(\"f\");\n<line_number-817>                });\n<line_number-818>        assertThrows(\n<line_number-819>                SQLException.class,\n<line_number-820>                () -> {\n<line_number-821>                    closedMongoResultSet.getString(0);\n<line_number-822>                });\n<line_number-823>        assertThrows(\n<line_number-824>                SQLException.class,\n<line_number-825>                () -> {\n<line_number-826>                    closedMongoResultSet.getString(\"f\");\n<line_number-827>                });\n<line_number-828>        assertThrows(\n<line_number-829>                SQLException.class,\n<line_number-830>                () -> {\n<line_number-831>                    closedMongoResultSet.getBoolean(0);\n<line_number-832>                });\n<line_number-833>        assertThrows(\n<line_number-834>                SQLException.class,\n<line_number-835>                () -> {\n<line_number-836>                    closedMongoResultSet.getBoolean(\"f\");\n<line_number-837>                });\n<line_number-838>        assertThrows(\n<line_number-839>                SQLException.class,\n<line_number-840>                () -> {\n<line_number-841>                    closedMongoResultSet.getByte(0);\n<line_number-842>                });\n<line_number-843>        assertThrows(\n<line_number-844>                SQLException.class,\n<line_number-845>                () -> {\n<line_number-846>                    closedMongoResultSet.getByte(\"f\");\n<line_number-847>                });\n<line_number-848>        assertThrows(\n<line_number-849>                SQLException.class,\n<line_number-850>                () -> {\n<line_number-851>                    closedMongoResultSet.getShort(0);\n<line_number-852>                });\n<line_number-853>        assertThrows(\n<line_number-854>                SQLException.class,\n<line_number-855>                () -> {\n<line_number-856>                    closedMongoResultSet.getShort(\"f\");\n<line_number-857>                });\n<line_number-858>        assertThrows(\n<line_number-859>                SQLException.class,\n<line_number-860>                () -> {\n<line_number-861>                    closedMongoResultSet.getInt(0);\n<line_number-862>                });\n<line_number-863>        assertThrows(\n<line_number-864>                SQLException.class,\n<line_number-865>                () -> {\n<line_number-866>                    closedMongoResultSet.getInt(\"f\");\n<line_number-867>                });\n<line_number-868>        assertThrows(\n<line_number-869>                SQLException.class,\n<line_number-870>                () -> {\n<line_number-871>                    closedMongoResultSet.getLong(0);\n<line_number-872>                });\n<line_number-873>        assertThrows(\n<line_number-874>                SQLException.class,\n<line_number-875>                () -> {\n<line_number-876>                    closedMongoResultSet.getLong(\"f\");\n<line_number-877>                });\n<line_number-878>        assertThrows(\n<line_number-879>                SQLException.class,\n<line_number-880>                () -> {\n<line_number-881>                    closedMongoResultSet.getFloat(0);\n<line_number-882>                });\n<line_number-883>        assertThrows(\n<line_number-884>                SQLException.class,\n<line_number-885>                () -> {\n<line_number-886>                    closedMongoResultSet.getFloat(\"f\");\n<line_number-887>                });\n<line_number-888>        assertThrows(\n<line_number-889>                SQLException.class,\n<line_number-890>                () -> {\n<line_number-891>                    closedMongoResultSet.getDouble(0);\n<line_number-892>                });\n<line_number-893>        assertThrows(\n<line_number-894>                SQLException.class,\n<line_number-895>                () -> {\n<line_number-896>                    closedMongoResultSet.getDouble(\"f\");\n<line_number-897>                });\n<line_number-898>        assertThrows(\n<line_number-899>                SQLException.class,\n<line_number-900>                () -> {\n<line_number-901>                    closedMongoResultSet.getBigDecimal(0);\n<line_number-902>                });\n<line_number-903>        assertThrows(\n<line_number-904>                SQLException.class,\n<line_number-905>                () -> {\n<line_number-906>                    closedMongoResultSet.getBigDecimal(\"f\");\n<line_number-907>                });\n<line_number-908>        assertThrows(\n<line_number-909>                SQLException.class,\n<line_number-910>                () -> {\n<line_number-911>                    closedMongoResultSet.getWarnings();\n<line_number-912>                });\n<line_number-913>        assertThrows(\n<line_number-914>                SQLException.class,\n<line_number-915>                () -> {\n<line_number-916>                    closedMongoResultSet.clearWarnings();\n<line_number-917>                });\n<line_number-918>        assertThrows(\n<line_number-919>                SQLException.class,\n<line_number-920>                () -> {\n<line_number-921>                    closedMongoResultSet.getMetaData();\n<line_number-922>                });\n<line_number-923>        assertThrows(\n<line_number-924>                SQLException.class,\n<line_number-925>                () -> {\n<line_number-926>                    closedMongoResultSet.findColumn(\"f\");\n<line_number-927>                });\n<line_number-928>        assertThrows(\n<line_number-929>                SQLException.class,\n<line_number-930>                () -> {\n<line_number-931>                    closedMongoResultSet.getCharacterStream(0);\n<line_number-932>                });\n<line_number-933>        assertThrows(\n<line_number-934>                SQLException.class,\n<line_number-935>                () -> {\n<line_number-936>                    closedMongoResultSet.getCharacterStream(\"f\");\n<line_number-937>                });\n<line_number-938>        assertThrows(\n<line_number-939>                SQLException.class,\n<line_number-940>                () -> {\n<line_number-941>                    closedMongoResultSet.isFirst();\n<line_number-942>                });\n<line_number-943>        assertThrows(\n<line_number-944>                SQLException.class,\n<line_number-945>                () -> {\n<line_number-946>                    closedMongoResultSet.isLast();\n<line_number-947>                });\n<line_number-948>        assertThrows(\n<line_number-949>                SQLException.class,\n<line_number-950>                () -> {\n<line_number-951>                    closedMongoResultSet.getRow();\n<line_number-952>                });\n<line_number-953>        assertThrows(\n<line_number-954>                SQLException.class,\n<line_number-955>                () -> {\n<line_number-956>                    closedMongoResultSet.previous();\n<line_number-957>                });\n<line_number-958>        assertThrows(\n<line_number-959>                SQLException.class,\n<line_number-960>                () -> {\n<line_number-961>                    closedMongoResultSet.getFetchDirection();\n<line_number-962>                });\n<line_number-963>        assertThrows(\n<line_number-964>                SQLException.class,\n<line_number-965>                () -> {\n<line_number-966>                    closedMongoResultSet.getType();\n<line_number-967>                });\n<line_number-968>        assertThrows(\n<line_number-969>                SQLException.class,\n<line_number-970>                () -> {\n<line_number-971>                    closedMongoResultSet.getConcurrency();\n<line_number-972>                });\n<line_number-973>        assertThrows(\n<line_number-974>                SQLException.class,\n<line_number-975>                () -> {\n<line_number-976>                    closedMongoResultSet.rowUpdated();\n<line_number-977>                });\n<line_number-978>        assertThrows(\n<line_number-979>                SQLException.class,\n<line_number-980>                () -> {\n<line_number-981>                    closedMongoResultSet.rowInserted();\n<line_number-982>                });\n<line_number-983>        assertThrows(\n<line_number-984>                SQLException.class,\n<line_number-985>                () -> {\n<line_number-986>                    closedMongoResultSet.rowDeleted();\n<line_number-987>                });\n<line_number-988>        assertThrows(\n<line_number-989>                SQLException.class,\n<line_number-990>                () -> {\n<line_number-991>                    closedMongoResultSet.insertRow();\n<line_number-992>                });\n<line_number-993>        assertThrows(\n<line_number-994>                SQLException.class,\n<line_number-995>                () -> {\n<line_number-996>                    closedMongoResultSet.deleteRow();\n<line_number-997>                });\n<line_number-998>        assertThrows(\n<line_number-999>                SQLException.class,\n<line_number-1000>                () -> {\n<line_number-1001>                    closedMongoResultSet.refreshRow();\n<line_number-1002>                });\n<line_number-1003>        assertThrows(\n<line_number-1004>                SQLException.class,\n<line_number-1005>                () -> {\n<line_number-1006>                    closedMongoResultSet.getStatement();\n<line_number-1007>                });\n<line_number-1008>        assertThrows(\n<line_number-1009>                SQLException.class,\n<line_number-1010>                () -> {\n<line_number-1011>                    closedMongoResultSet.getBlob(0);\n<line_number-1012>                });\n<line_number-1013>        assertThrows(\n<line_number-1014>                SQLException.class,\n<line_number-1015>                () -> {\n<line_number-1016>                    closedMongoResultSet.getBlob(\"f\");\n<line_number-1017>                });\n<line_number-1018>        assertThrows(\n<line_number-1019>                SQLException.class,\n<line_number-1020>                () -> {\n<line_number-1021>                    closedMongoResultSet.getClob(0);\n<line_number-1022>                });\n<line_number-1023>        assertThrows(\n<line_number-1024>                SQLException.class,\n<line_number-1025>                () -> {\n<line_number-1026>                    closedMongoResultSet.getClob(\"f\");\n<line_number-1027>                });\n<line_number-1028>        assertThrows(\n<line_number-1029>                SQLException.class,\n<line_number-1030>                () -> {\n<line_number-1031>                    closedMongoResultSet.getDate(0);\n<line_number-1032>                });\n<line_number-1033>        assertThrows(\n<line_number-1034>                SQLException.class,\n<line_number-1035>                () -> {\n<line_number-1036>                    closedMongoResultSet.getDate(\"f\");\n<line_number-1037>                });\n<line_number-1038>        assertThrows(\n<line_number-1039>                SQLException.class,\n<line_number-1040>                () -> {\n<line_number-1041>                    closedMongoResultSet.getDate(0);\n<line_number-1042>                });\n<line_number-1043>        assertThrows(\n<line_number-1044>                SQLException.class,\n<line_number-1045>                () -> {\n<line_number-1046>                    closedMongoResultSet.getDate(\"f\");\n<line_number-1047>                });\n<line_number-1048>        assertThrows(\n<line_number-1049>                SQLException.class,\n<line_number-1050>                () -> {\n<line_number-1051>                    closedMongoResultSet.getTime(0);\n<line_number-1052>                });\n<line_number-1053>        assertThrows(\n<line_number-1054>                SQLException.class,\n<line_number-1055>                () -> {\n<line_number-1056>                    closedMongoResultSet.getTime(\"f\");\n<line_number-1057>                });\n<line_number-1058>        assertThrows(\n<line_number-1059>                SQLException.class,\n<line_number-1060>                () -> {\n<line_number-1061>                    closedMongoResultSet.getTimestamp(0);\n<line_number-1062>                });\n<line_number-1063>        assertThrows(\n<line_number-1064>                SQLException.class,\n<line_number-1065>                () -> {\n<line_number-1066>                    closedMongoResultSet.getTimestamp(\"f\");\n<line_number-1067>                });\n<line_number-1068>        assertThrows(\n<line_number-1069>                SQLException.class,\n<line_number-1070>                () -> {\n<line_number-1071>                    closedMongoResultSet.getHoldability();\n<line_number-1072>                });\n<line_number-1073>        assertThrows(\n<line_number-1074>                SQLException.class,\n<line_number-1075>                () -> {\n<line_number-1076>                    closedMongoResultSet.getNClob(0);\n<line_number-1077>                });\n<line_number-1078>        assertThrows(\n<line_number-1079>                SQLException.class,\n<line_number-1080>                () -> {\n<line_number-1081>                    closedMongoResultSet.getNClob(\"f\");\n<line_number-1082>                });\n<line_number-1083>        assertThrows(\n<line_number-1084>                SQLException.class,\n<line_number-1085>                () -> {\n<line_number-1086>                    closedMongoResultSet.getNString(0);\n<line_number-1087>                });\n<line_number-1088>        assertThrows(\n<line_number-1089>                SQLException.class,\n<line_number-1090>                () -> {\n<line_number-1091>                    closedMongoResultSet.getNString(\"f\");\n<line_number-1092>                });\n<line_number-1093>        assertThrows(\n<line_number-1094>                SQLException.class,\n<line_number-1095>                () -> {\n<line_number-1096>                    closedMongoResultSet.getNCharacterStream(0);\n<line_number-1097>                });\n<line_number-1098>        assertThrows(\n<line_number-1099>                SQLException.class,\n<line_number-1100>                () -> {\n<line_number-1101>                    closedMongoResultSet.getNCharacterStream(\"f\");\n<line_number-1102>                });\n<line_number-1103>    }\n<line_number-1104>\n<line_number-1105>    @Test\n<line_number-1106>    void throwExceptionWhenNotAvailable() throws Exception {\n<line_number-1107>\n<line_number-1108>        AtomicBoolean nextCalledOnCursor = new AtomicBoolean(true);\n<line_number-1109>        when(cursor.hasNext()).thenAnswer(invocation -> !nextCalledOnCursor.get());\n<line_number-1110>        when(cursor.next())\n<line_number-1111>                .thenAnswer(\n<line_number-1112>                        invocation -> {\n<line_number-1113>                            if (nextCalledOnCursor.get()) {\n<line_number-1114>                                return generateRow();\n<line_number-1115>                            }\n<line_number-1116>                            nextCalledOnCursor.set(true);\n<line_number-1117>                            return generateRow();\n<line_number-1118>                        });\n<line_number-1119>\n<line_number-1120>        mockResultSet =\n<line_number-1121>                new MongoResultSet(\n<line_number-1122>                        mongoStatement, cursor, schema, null, false, UuidRepresentation.STANDARD);\n<line_number-1123>\n<line_number-1124>        boolean hasNext = mockResultSet.next();\n<line_number-1125>        assertFalse(hasNext);\n<line_number-1126>        assertNull(mockResultSet.getCurrent());\n<line_number-1127>        assertThrows(\n<line_number-1128>                SQLException.class,\n<line_number-1129>                () -> {\n<line_number-1130>                    mockResultSet.getString(\"label\");\n<line_number-1131>                });\n<line_number-1132>    }\n<line_number-1133>\n<line_number-1134>    @Test\n<line_number-1135>    void returnNextRowWhenAvailable() throws Exception {\n<line_number-1136>        BsonDocument valuesDoc = new BsonDocument();\n<line_number-1137>        BsonDocument valuesDoc2 = new BsonDocument();\n<line_number-1138>        BsonDocument valuesDoc3 = new BsonDocument();\n<line_number-1139>\n<line_number-1140>        BsonExplicitCursor cursor =\n<line_number-1141>                new BsonExplicitCursor(Arrays.asList(valuesDoc, valuesDoc2, valuesDoc3));\n<line_number-1142>        mockResultSet =\n<line_number-1143>                new MongoResultSet(\n<line_number-1144>                        mongoStatement, cursor, schema, null, false, UuidRepresentation.STANDARD);\n<line_number-1145>\n<line_number-1146>        assertFalse(mockResultSet.isFirst());\n<line_number-1147>        assertFalse(mockResultSet.isLast());\n<line_number-1148>\n<line_number-1149>        boolean hasNext = mockResultSet.next();\n<line_number-1150>        assertTrue(hasNext);\n<line_number-1151>        assertNotNull(mockResultSet.getCurrent());\n<line_number-1152>        // This still throws because \"label\" is unknown.\n<line_number-1153>        assertThrows(\n<line_number-1154>                SQLException.class,\n<line_number-1155>                () -> {\n<line_number-1156>                    mockResultSet.getString(\"label\");\n<line_number-1157>                });\n<line_number-1158>        assertTrue(mockResultSet.isFirst());\n<line_number-1159>        assertFalse(mockResultSet.isLast());\n<line_number-1160>    }\n<line_number-1161>\n<line_number-1162>    @Test\n<line_number-1163>    void testEmptyResultSet() throws SQLException {\n<line_number-1164>\n<line_number-1165>        String colName = \"a\";\n<line_number-1166>\n<line_number-1167>        BsonDocument emptyResultDoc = new BsonDocument();\n<line_number-1168>\n<line_number-1169>        AtomicBoolean nextCalledOnCursor = new AtomicBoolean(true);\n<line_number-1170>        when(cursor.hasNext()).thenAnswer(invocation -> !nextCalledOnCursor.get());\n<line_number-1171>        when(cursor.next())\n<line_number-1172>                .thenAnswer(\n<line_number-1173>                        invocation -> {\n<line_number-1174>                            if (nextCalledOnCursor.get()) {\n<line_number-1175>                                return false;\n<line_number-1176>                            }\n<line_number-1177>                            nextCalledOnCursor.set(true);\n<line_number-1178>                            return emptyResultDoc;\n<line_number-1179>                        });\n<line_number-1180>\n<line_number-1181>        mockResultSet =\n<line_number-1182>                new MongoResultSet(\n<line_number-1183>                        mongoStatement, cursor, schema, null, false, UuidRepresentation.STANDARD);\n<line_number-1184>\n<line_number-1185>        assertFalse(mockResultSet.isFirst());\n<line_number-1186>        // For empty result set, isLast should always be true\n<line_number-1187>        assertTrue(mockResultSet.isLast());\n<line_number-1188>        assertFalse(mockResultSet.next());\n<line_number-1189>        // For empty result set, isFirst should always be false\n<line_number-1190>        assertFalse(mockResultSet.isFirst());\n<line_number-1191>        assertTrue(mockResultSet.isLast());\n<line_number-1192>        assertEquals(12, mockResultSet.getMetaData().getColumnCount());\n<line_number-1193>        assertFalse(mockResultSet.next());\n<line_number-1194>        // query value for existing column in empty result should result to exception\n<line_number-1195>        assertThrows(\n<line_number-1196>                SQLException.class,\n<line_number-1197>                () -> {\n<line_number-1198>                    mockResultSet.getString(colName);\n<line_number-1199>                });\n<line_number-1200>    }\n<line_number-1201>\n<line_number-1202>    @Test\n<line_number-1203>    void testEmptyResultSetWhenGetMetadataCalledFirst() throws SQLException {\n<line_number-1204>        String colName = \"a\";\n<line_number-1205>\n<line_number-1206>        BsonDocument emptyResultDoc = new BsonDocument();\n<line_number-1207>\n<line_number-1208>        AtomicBoolean nextCalledOnCursor = new AtomicBoolean(true);\n<line_number-1209>        when(cursor.hasNext()).thenAnswer(invocation -> !nextCalledOnCursor.get());\n<line_number-1210>        when(cursor.next())\n<line_number-1211>                .thenAnswer(\n<line_number-1212>                        invocation -> {\n<line_number-1213>                            nextCalledOnCursor.set(true);\n<line_number-1214>                            return emptyResultDoc;\n<line_number-1215>                        });\n<line_number-1216>\n<line_number-1217>        mockResultSet =\n<line_number-1218>                new MongoResultSet(\n<line_number-1219>                        mongoStatement, cursor, schema, null, false, UuidRepresentation.STANDARD);\n<line_number-1220>\n<line_number-1221>        assertEquals(12, mockResultSet.getMetaData().getColumnCount());\n<line_number-1222>        assertFalse(mockResultSet.isFirst());\n<line_number-1223>        assertTrue(mockResultSet.isLast());\n<line_number-1224>        assertFalse(mockResultSet.next());\n<line_number-1225>        // For empty resultset, isFirst should always be false\n<line_number-1226>        assertFalse(mockResultSet.isFirst());\n<line_number-1227>        assertTrue(mockResultSet.isLast());\n<line_number-1228>        assertFalse(mockResultSet.next());\n<line_number-1229>        // query value for existing column in empty result should result to exception\n<line_number-1230>        assertThrows(\n<line_number-1231>                SQLException.class,\n<line_number-1232>                () -> {\n<line_number-1233>                    mockResultSet.getString(colName);\n<line_number-1234>                });\n<line_number-1235>    }\n<line_number-1236>\n<line_number-1237>    @Test\n<line_number-1238>    void sameMetaDataOnDifferentRowsEvenWithDifferentBsonTypes() throws SQLException {\n<line_number-1239>        AtomicBoolean nextCalledOnCursor = new AtomicBoolean(false);\n<line_number-1240>\n<line_number-1241>        MongoJsonSchema sameMetadataSchema = new MongoJsonSchema();\n<line_number-1242>        sameMetadataSchema.bsonType = \"object\";\n<line_number-1243>        sameMetadataSchema.required = new HashSet<String>();\n<line_number-1244>        sameMetadataSchema.required.add(\"foo\");\n<line_number-1245>\n<line_number-1246>        MongoJsonSchema fooSchema = new MongoJsonSchema();\n<line_number-1247>        fooSchema.bsonType = \"object\";\n<line_number-1248>        fooSchema.required = new HashSet<String>();\n<line_number-1249>        fooSchema.required.add(\"a\");\n<line_number-1250>\n<line_number-1251>        MongoJsonSchema aSchema = new MongoJsonSchema();\n<line_number-1252>        aSchema.bsonType = \"int\";\n<line_number-1253>\n<line_number-1254>        fooSchema.properties = new HashMap<String, MongoJsonSchema>();\n<line_number-1255>        fooSchema.properties.put(\"a\", aSchema);\n<line_number-1256>\n<line_number-1257>        sameMetadataSchema.properties = new HashMap<String, MongoJsonSchema>();\n<line_number-1258>        sameMetadataSchema.properties.put(\"foo\", fooSchema);\n<line_number-1259>\n<line_number-1260>        BsonDocument row1 = new BsonDocument();\n<line_number-1261>        row1.append(\"foo.a\", new BsonInt32(1));\n<line_number-1262>\n<line_number-1263>        BsonDocument row2 = new BsonDocument();\n<line_number-1264>        row1.append(\"foo.a\", new BsonString(\"test\"));\n<line_number-1265>\n<line_number-1266>        List<BsonDocument> rows = new ArrayList<>();\n<line_number-1267>        rows.add(row1);\n<line_number-1268>        rows.add(row2);\n<line_number-1269>\n<line_number-1270>        Iterator<BsonDocument> iter = rows.iterator();\n<line_number-1271>        when(cursor.hasNext()).thenAnswer(invocation -> iter.hasNext());\n<line_number-1272>        when(cursor.next())\n<line_number-1273>                .thenAnswer(\n<line_number-1274>                        invocation -> {\n<line_number-1275>                            BsonDocument doc = iter.next();\n<line_number-1276>                            return doc;\n<line_number-1277>                        });\n<line_number-1278>\n<line_number-1279>        mockResultSet =\n<line_number-1280>                new MongoResultSet(\n<line_number-1281>                        mongoStatement,\n<line_number-1282>                        cursor,\n<line_number-1283>                        sameMetadataSchema,\n<line_number-1284>                        null,\n<line_number-1285>                        false,\n<line_number-1286>                        UuidRepresentation.STANDARD);\n<line_number-1287>\n<line_number-1288>        ResultSetMetaData metaData = mockResultSet.getMetaData();\n<line_number-1289>        assertEquals(1, metaData.getColumnCount());\n<line_number-1290>        assertEquals(Types.INTEGER, metaData.getColumnType(1));\n<line_number-1291>\n<line_number-1292>        mockResultSet.next();\n<line_number-1293>        // This is still the first row\n<line_number-1294>        metaData = mockResultSet.getMetaData();\n<line_number-1295>        assertEquals(1, metaData.getColumnCount());\n<line_number-1296>        assertEquals(Types.INTEGER, metaData.getColumnType(1));\n<line_number-1297>\n<line_number-1298>        mockResultSet.next();\n<line_number-1299>        // Second row\n<line_number-1300>        metaData = mockResultSet.getMetaData();\n<line_number-1301>        assertEquals(1, metaData.getColumnCount());\n<line_number-1302>        assertEquals(Types.INTEGER, metaData.getColumnType(1));\n<line_number-1303>    }\n<line_number-1304>}\n",
        "comments": [
          {
            "comment_code_range": "64-1304",
            "comment_linenumber": "63",
            "comment": "Test class for MongoResultSet, extending MongoMock, to validate the behavior of MongoDB result sets in various scenarios.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "78-185",
            "comment_linenumber": "77",
            "comment": "Static initialization block to set up various MongoResultSet instances and their associated metadata for testing.",
            "comment_kind": "block"
          },
          {
            "comment_code_range": "187-190",
            "comment_linenumber": "186",
            "comment": "Initializes mocks before all tests are run.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "192-195",
            "comment_linenumber": "191",
            "comment": "Resets mock objects before each test to ensure a clean state.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "197-317",
            "comment_linenumber": "196",
            "comment": "Tests the behavior of binary getters in MongoResultSet, ensuring correct exceptions are thrown for unsupported types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "319-340",
            "comment_linenumber": "318",
            "comment": "Tests retrieval of UUID values from the MongoResultSet, validating standard and legacy UUID formats.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "342-366",
            "comment_linenumber": "341",
            "comment": "Tests the findColumn method of MongoResultSet, ensuring correct column indices are returned for given labels.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "368-401",
            "comment_linenumber": "367",
            "comment": "Tests retrieval of string values from MongoResultSet, validating expected outputs for various BSON types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "403-442",
            "comment_linenumber": "402",
            "comment": "Tests retrieval of string values for all BSON types, ensuring correct handling of extended JSON representations.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "446-486",
            "comment_linenumber": "445",
            "comment": "Tests the toString representation of objects retrieved from MongoResultSet for various BSON types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "492-532",
            "comment_linenumber": "491",
            "comment": "Tests that the getObject method returns the expected Java object for each BSON type.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "553-603",
            "comment_linenumber": "552",
            "comment": "Tests the retrieval of arithmetic values from MongoResultSet, ensuring correct handling of various numeric types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "605-668",
            "comment_linenumber": "604",
            "comment": "Tests retrieval of boolean values from MongoResultSet, validating expected outputs for different BSON types.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "671-703",
            "comment_linenumber": "670",
            "comment": "Tests retrieval of timestamp values from MongoResultSet, ensuring correct handling of various scenarios.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "705-750",
            "comment_linenumber": "704",
            "comment": "Tests the getObject method for various BSON types, ensuring correct behavior for both index and label versions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "752-1033",
            "comment_linenumber": "751",
            "comment": "Tests the behavior of closed result sets, ensuring appropriate exceptions are thrown when accessing closed result sets.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1105-1132",
            "comment_linenumber": "1104",
            "comment": "Tests the behavior of MongoResultSet when no rows are available, ensuring correct exception handling.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1134-1160",
            "comment_linenumber": "1133",
            "comment": "Tests the behavior of MongoResultSet when rows are available, ensuring correct retrieval of data.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1162-1200",
            "comment_linenumber": "1161",
            "comment": "Tests the behavior of MongoResultSet when it is empty, ensuring correct handling of metadata and exceptions.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1202-1235",
            "comment_linenumber": "1201",
            "comment": "Tests the behavior of MongoResultSet when metadata is called first on an empty result set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "1237-1303",
            "comment_linenumber": "1236",
            "comment": "Tests that the metadata remains consistent across different rows with varying BSON types.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoResultSetTest.java' is a JUnit test class designed to validate the functionality of the MongoResultSet class, which is part of the MongoDB JDBC driver. It extends the MongoMock class to leverage mock behavior for testing. The class contains a series of test methods that cover various aspects of the MongoResultSet, including initialization, data retrieval, exception handling, and behavior with empty result sets. The tests utilize Mockito for mocking dependencies and JUnit assertions for validating expected outcomes. The static initialization block sets up multiple instances of MongoResultSet with different configurations for comprehensive testing. Each test method is annotated with @Test, indicating that it is a test case to be executed by the JUnit framework. The methods are organized to ensure clarity and maintainability, with clear separation of concerns for each test case.",
        "file_summary": "This file contains unit tests for the MongoResultSet class, ensuring its correct behavior in handling various data types and scenarios when interacting with MongoDB. It validates the functionality of data retrieval methods, exception handling, and the behavior of result sets under different conditions."
      }
    ]
  },
  "MongoSQLTranslateLibTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoSQLTranslateLibTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\MongoSQLTranslateLibTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoSQLTranslateLibTest.java",
        "chunk_id": "MongoSQLTranslateLibTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static org.junit.jupiter.api.Assertions.*;\n<line_number-20>\n<line_number-21>import com.mongodb.jdbc.logging.MongoLogger;\n<line_number-22>import com.mongodb.jdbc.mongosql.GetMongosqlTranslateVersionResult;\n<line_number-23>import com.mongodb.jdbc.mongosql.MongoSQLException;\n<line_number-24>import com.mongodb.jdbc.mongosql.MongoSQLTranslate;\n<line_number-25>import java.lang.reflect.Field;\n<line_number-26>import java.lang.reflect.Method;\n<line_number-27>import java.util.logging.Logger;\n<line_number-28>import org.junit.jupiter.api.BeforeEach;\n<line_number-29>import org.junit.jupiter.api.Test;\n<line_number-30>\n<line_number-31>public class MongoSQLTranslateLibTest {\n<line_number-32>\n<line_number-33>    /** Helper function to call the runCommand endpoint of the translation library. */\n<line_number-34>    private static void testRunCommand() throws MongoSQLException, MongoSerializationException {\n<line_number-35>        MongoLogger mongoLogger = new MongoLogger(Logger.getLogger(\"Logger\"), 1);\n<line_number-36>        MongoSQLTranslate mongosqlTranslate = new MongoSQLTranslate(mongoLogger);\n<line_number-37>\n<line_number-38>        GetMongosqlTranslateVersionResult result = mongosqlTranslate.getMongosqlTranslateVersion();\n<line_number-39>\n<line_number-40>        assertNotNull(result);\n<line_number-41>        assertNotNull(result.version);\n<line_number-42>    }\n<line_number-43>\n<line_number-44>    @BeforeEach\n<line_number-45>    void setup() throws Exception {\n<line_number-46>        // Reset the mongoSqlTranslateLibraryLoaded flag to false before each test case.\n<line_number-47>        // This ensures that the flag starts with a known value at the start of the test\n<line_number-48>        // as it can be set during the static initialization or test interference.\n<line_number-49>        Field mongoSqlTranslateLibraryLoadedField =\n<line_number-50>                MongoDriver.class.getDeclaredField(\"mongoSqlTranslateLibraryLoaded\");\n<line_number-51>        mongoSqlTranslateLibraryLoadedField.setAccessible(true);\n<line_number-52>        mongoSqlTranslateLibraryLoadedField.set(null, false);\n<line_number-53>\n<line_number-54>        Field mongoSqlTranslateLibraryPathField =\n<line_number-55>                MongoDriver.class.getDeclaredField(\"mongoSqlTranslateLibraryPath\");\n<line_number-56>        mongoSqlTranslateLibraryPathField.setAccessible(true);\n<line_number-57>        mongoSqlTranslateLibraryPathField.set(null, null);\n<line_number-58>\n<line_number-59>        Field mongoSqlTranslateLibraryLoadingError =\n<line_number-60>                MongoDriver.class.getDeclaredField(\"mongoSqlTranslateLibraryLoadingError\");\n<line_number-61>        mongoSqlTranslateLibraryPathField.setAccessible(true);\n<line_number-62>        mongoSqlTranslateLibraryPathField.set(null, null);\n<line_number-63>    }\n<line_number-64>\n<line_number-65>    @Test\n<line_number-66>    void testLibraryLoadingFromDriverPath() throws Exception {\n<line_number-67>        assertNull(\n<line_number-68>                System.getenv(MongoDriver.MONGOSQL_TRANSLATE_PATH),\n<line_number-69>                \"MONGOSQL_TRANSLATE_PATH should not be set\");\n<line_number-70>\n<line_number-71>        Method initMethod = MongoDriver.class.getDeclaredMethod(\"loadMongoSqlTranslateLibrary\");\n<line_number-72>        initMethod.setAccessible(true);\n<line_number-73>        initMethod.invoke(null);\n<line_number-74>\n<line_number-75>        assertTrue(\n<line_number-76>                MongoDriver.isMongoSqlTranslateLibraryLoaded(),\n<line_number-77>                \"Library should be loaded successfully from the driver directory\");\n<line_number-78>        String tempDir = System.getProperty(\"java.io.tmpdir\");\n<line_number-79>        assertTrue(\n<line_number-80>                MongoDriver.getMongoSqlTranslateLibraryPath().contains(tempDir),\n<line_number-81>                \"Expected library path to contain '\"\n<line_number-82>                        + tempDir\n<line_number-83>                        + \"' but didn't. Actual path is \"\n<line_number-84>                        + MongoDriver.getMongoSqlTranslateLibraryPath());\n<line_number-85>\n<line_number-86>        // The library was loaded successfully. Now, let's make sure that we can call the runCommand endpoint.\n<line_number-87>        testRunCommand();\n<line_number-88>    }\n<line_number-89>\n<line_number-90>    @Test\n<line_number-91>    void testLibraryLoadingWithEnvironmentVariable() throws Exception {\n<line_number-92>        String envPath = System.getenv(MongoDriver.MONGOSQL_TRANSLATE_PATH);\n<line_number-93>        assertNotNull(envPath, \"MONGOSQL_TRANSLATE_PATH should be set\");\n<line_number-94>\n<line_number-95>        // Test loadMongoSqlTranslateLibrary, with Environment variable set it should find the library\n<line_number-96>        Method initMethod = MongoDriver.class.getDeclaredMethod(\"loadMongoSqlTranslateLibrary\");\n<line_number-97>        initMethod.setAccessible(true);\n<line_number-98>        initMethod.invoke(null);\n<line_number-99>\n<line_number-100>        assertNull(MongoDriver.getMongoSqlTranslateLibraryLoadError());\n<line_number-101>\n<line_number-102>        assertTrue(\n<line_number-103>                MongoDriver.isMongoSqlTranslateLibraryLoaded(),\n<line_number-104>                \"Library should be loaded when MONGOSQL_TRANSLATE_PATH is set\");\n<line_number-105>\n<line_number-106>        assertTrue(\n<line_number-107>                MongoDriver.getMongoSqlTranslateLibraryPath()\n<line_number-108>                        .contains(\"resources/MongoSqlLibraryTest\"),\n<line_number-109>                \"Expected library path to contain 'resources/MongoSqlLibraryTest' but didn't. Actual path is \"\n<line_number-110>                        + MongoDriver.getMongoSqlTranslateLibraryPath());\n<line_number-111>\n<line_number-112>        // The library was loaded successfully. Now, let's make sure that we can call the runCommand endpoint.\n<line_number-113>        testRunCommand();\n<line_number-114>    }\n<line_number-115>\n<line_number-116>    @Test\n<line_number-117>    void testLibraryLoadingWithInvalidEnvironmentVariableFallback() throws Exception {\n<line_number-118>        String envPath = System.getenv(MongoDriver.MONGOSQL_TRANSLATE_PATH);\n<line_number-119>        assertNotNull(envPath, \"MONGOSQL_TRANSLATE_PATH should be set\");\n<line_number-120>\n<line_number-121>        // Test loadMongoSqlTranslateLibrary, with invalid Environment variable set should fallback to driver directory\n<line_number-122>        Method initMethod = MongoDriver.class.getDeclaredMethod(\"loadMongoSqlTranslateLibrary\");\n<line_number-123>        initMethod.setAccessible(true);\n<line_number-124>        initMethod.invoke(null);\n<line_number-125>\n<line_number-126>        assertNotNull(MongoDriver.getMongoSqlTranslateLibraryLoadError());\n<line_number-127>\n<line_number-128>        assertTrue(\n<line_number-129>                MongoDriver.getMongoSqlTranslateLibraryLoadError()\n<line_number-130>                        .getMessage()\n<line_number-131>                        .contains(\"java.lang.UnsatisfiedLinkError: Can't load library\"),\n<line_number-132>                \"Expected error to be a loading error but is \"\n<line_number-133>                        + MongoDriver.getMongoSqlTranslateLibraryLoadError().getMessage());\n<line_number-134>\n<line_number-135>        // The library must be loaded and it should be the one from inside the driver.\n<line_number-136>        assertTrue(\n<line_number-137>                MongoDriver.isMongoSqlTranslateLibraryLoaded(),\n<line_number-138>                \"Library should be loaded successfully from the driver directory\");\n<line_number-139>        String tempDir = System.getProperty(\"java.io.tmpdir\");\n<line_number-140>        assertTrue(\n<line_number-141>                MongoDriver.getMongoSqlTranslateLibraryPath().contains(tempDir),\n<line_number-142>                \"Expected library path to contain '\"\n<line_number-143>                        + tempDir\n<line_number-144>                        + \"' but didn't. Actual path is \"\n<line_number-145>                        + MongoDriver.getMongoSqlTranslateLibraryPath());\n<line_number-146>\n<line_number-147>        // The library was loaded successfully. Now, let's make sure that we can call the runCommand endpoint.\n<line_number-148>        testRunCommand();\n<line_number-149>    }\n<line_number-150>}\n",
        "comments": [
          {
            "comment_code_range": "31-150",
            "comment_linenumber": "30",
            "comment": "Test suite for the MongoSQLTranslate library, ensuring proper loading and functionality of the translation library.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "33-42",
            "comment_linenumber": "32",
            "comment": "Helper function to call the runCommand endpoint of the translation library, verifying that the version is not null.",
            "comment_kind": "function"
          },
          {
            "comment_code_range": "44-63",
            "comment_linenumber": "43",
            "comment": "Setup method that resets the mongoSqlTranslateLibraryLoaded flag and related fields before each test case to ensure a clean state.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "65-87",
            "comment_linenumber": "64",
            "comment": "Test to verify that the library loads correctly from the driver path when the MONGOSQL_TRANSLATE_PATH environment variable is not set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "90-113",
            "comment_linenumber": "89",
            "comment": "Test to verify that the library loads correctly when the MONGOSQL_TRANSLATE_PATH environment variable is set.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "116-148",
            "comment_linenumber": "115",
            "comment": "Test to verify that the library falls back to the driver directory when an invalid MONGOSQL_TRANSLATE_PATH is provided.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoSQLTranslateLibTest.java' serves as a unit test suite for the MongoSQLTranslate library, primarily focusing on the loading mechanisms of the library. It employs the JUnit testing framework, indicated by the use of annotations such as @Test and @BeforeEach. The main class, MongoSQLTranslateLibTest, contains several test methods that validate the behavior of the MongoSQLTranslate library under different conditions. The class utilizes reflection to access private fields and methods of the MongoDriver class, which is responsible for loading the translation library. The test methods include setup procedures to ensure a clean state before each test, and they assert various conditions to verify the expected outcomes of library loading. The tests cover scenarios where the library is loaded from the driver path, when an environment variable is set, and when an invalid environment variable is provided, ensuring comprehensive coverage of the library's loading logic.",
        "file_summary": "This file contains unit tests for the MongoSQLTranslate library, ensuring that the library loads correctly under various conditions and that its functionality can be verified through the runCommand endpoint."
      }
    ]
  },
  "MongoStatementTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoStatementTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\MongoStatementTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\MongoStatementTest.java",
        "chunk_id": "MongoStatementTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2022-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static java.sql.Statement.CLOSE_CURRENT_RESULT;\n<line_number-20>import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n<line_number-21>import static org.junit.jupiter.api.Assertions.assertEquals;\n<line_number-22>import static org.junit.jupiter.api.Assertions.assertFalse;\n<line_number-23>import static org.junit.jupiter.api.Assertions.assertNull;\n<line_number-24>import static org.junit.jupiter.api.Assertions.assertThrows;\n<line_number-25>import static org.junit.jupiter.api.Assertions.assertTrue;\n<line_number-26>import static org.mockito.ArgumentMatchers.any;\n<line_number-27>import static org.mockito.ArgumentMatchers.eq;\n<line_number-28>import static org.mockito.Mockito.when;\n<line_number-29>\n<line_number-30>import java.sql.ResultSet;\n<line_number-31>import java.sql.ResultSetMetaData;\n<line_number-32>import java.sql.SQLException;\n<line_number-33>import java.util.concurrent.atomic.AtomicInteger;\n<line_number-34>import org.junit.jupiter.api.BeforeAll;\n<line_number-35>import org.junit.jupiter.api.BeforeEach;\n<line_number-36>import org.junit.jupiter.api.Test;\n<line_number-37>import org.junit.jupiter.api.TestInstance;\n<line_number-38>import org.junit.jupiter.api.extension.ExtendWith;\n<line_number-39>import org.mockito.MockitoAnnotations;\n<line_number-40>import org.mockito.junit.jupiter.MockitoExtension;\n<line_number-41>import org.mockito.junit.jupiter.MockitoSettings;\n<line_number-42>import org.mockito.quality.Strictness;\n<line_number-43>\n<line_number-44>@ExtendWith(MockitoExtension.class)\n<line_number-45>@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n<line_number-46>@MockitoSettings(strictness = Strictness.WARN)\n<line_number-47>class MongoStatementTest extends MongoMock {\n<line_number-48>    private static MongoStatement mongoStatement;\n<line_number-49>\n<line_number-50>    static {\n<line_number-51>        try {\n<line_number-52>            mongoStatement = new MongoStatement(mongoConnection, database);\n<line_number-53>        } catch (SQLException e) {\n<line_number-54>            e.printStackTrace();\n<line_number-55>        }\n<line_number-56>    }\n<line_number-57>\n<line_number-58>    @BeforeAll\n<line_number-59>    protected void initMocks() {\n<line_number-60>        MockitoAnnotations.initMocks(this);\n<line_number-61>    }\n<line_number-62>\n<line_number-63>    // Since MongoConnection cannot be created with its constructor, we have to use InjectionMocks Annotation and\n<line_number-64>    // create it during initiation. In order to reuse the same object for each test, we need to reset it before each test case.\n<line_number-65>    @BeforeEach\n<line_number-66>    void setupTest() throws NoSuchFieldException, SQLException {\n<line_number-67>        resetMockObjs();\n<line_number-68>        mongoConnection.clusterType = MongoConnection.MongoClusterType.AtlasDataFederation;\n<line_number-69>        mongoStatement = new MongoStatement(mongoConnection, database);\n<line_number-70>    }\n<line_number-71>\n<line_number-72>    void testExceptionAfterConnectionClosed(MongoConnectionTest.TestInterface ti)\n<line_number-73>            throws SQLException {\n<line_number-74>        // create statement after closed throws exception\n<line_number-75>        mongoStatement.close();\n<line_number-76>        assertThrows(SQLException.class, ti::test);\n<line_number-77>    }\n<line_number-78>\n<line_number-79>    void testNoop(MongoConnectionTest.TestInterface ti) throws SQLException {\n<line_number-80>        assertDoesNotThrow(ti::test);\n<line_number-81>        testExceptionAfterConnectionClosed(ti::test);\n<line_number-82>    }\n<line_number-83>\n<line_number-84>    // to replace lambda as input in the testExceptionAfterConnectionClosed\n<line_number-85>    interface TestInterface {\n<line_number-86>        void test() throws SQLException;\n<line_number-87>    }\n<line_number-88>\n<line_number-89>    @Test\n<line_number-90>    void testExecuteQueryEmptyResult() throws SQLException {\n<line_number-91>        AtomicInteger rowCnt = new AtomicInteger();\n<line_number-92>\n<line_number-93>        when(mongoCursor.hasNext()).thenAnswer(invocation -> rowCnt.get() < 0);\n<line_number-94>\n<line_number-95>        when(mongoCursor.next())\n<line_number-96>                .thenAnswer(\n<line_number-97>                        invocation -> {\n<line_number-98>                            rowCnt.incrementAndGet();\n<line_number-99>                            return generateRow();\n<line_number-100>                        });\n<line_number-101>\n<line_number-102>        when(mongoDatabase.runCommand(any(), eq(MongoJsonSchemaResult.class)))\n<line_number-103>                .thenReturn(generateSchema());\n<line_number-104>\n<line_number-105>        ResultSet rs = mongoStatement.executeQuery(\"select * from foo\");\n<line_number-106>        ResultSetMetaData metaData = rs.getMetaData();\n<line_number-107>        assertEquals(12, metaData.getColumnCount());\n<line_number-108>\n<line_number-109>        rs.next();\n<line_number-110>        assertThrows(\n<line_number-111>                SQLException.class,\n<line_number-112>                () -> {\n<line_number-113>                    rs.getInt(1);\n<line_number-114>                });\n<line_number-115>        assertFalse(rs.next());\n<line_number-116>        assertThrows(\n<line_number-117>                SQLException.class,\n<line_number-118>                () -> {\n<line_number-119>                    rs.getInt(1);\n<line_number-120>                });\n<line_number-121>\n<line_number-122>        assertTrue(rs.isLast());\n<line_number-123>    }\n<line_number-124>\n<line_number-125>    @Test\n<line_number-126>    void testExecuteQuery() throws SQLException {\n<line_number-127>        AtomicInteger rowCnt = new AtomicInteger();\n<line_number-128>        when(mongoDatabase.runCommand(any(), eq(MongoJsonSchemaResult.class)))\n<line_number-129>                .thenReturn(generateSchema());\n<line_number-130>        when(mongoCursor.hasNext()).thenAnswer(invocation -> rowCnt.get() < 1);\n<line_number-131>\n<line_number-132>        when(mongoCursor.next())\n<line_number-133>                .thenAnswer(\n<line_number-134>                        invocation -> {\n<line_number-135>                            rowCnt.incrementAndGet();\n<line_number-136>                            return generateRow();\n<line_number-137>                        });\n<line_number-138>\n<line_number-139>        ResultSet rs = mongoStatement.executeQuery(\"select * from foo\");\n<line_number-140>        ResultSetMetaData metaData = rs.getMetaData();\n<line_number-141>        assertEquals(12, metaData.getColumnCount());\n<line_number-142>        // need to call next() first\n<line_number-143>        assertThrows(\n<line_number-144>                SQLException.class,\n<line_number-145>                () -> {\n<line_number-146>                    rs.getInt(1);\n<line_number-147>                });\n<line_number-148>\n<line_number-149>        assertTrue(rs.next());\n<line_number-150>        assertEquals(1, rs.getInt(1));\n<line_number-151>        assertEquals(\"a\", rs.getString(4));\n<line_number-152>        assertFalse(rs.next());\n<line_number-153>        assertTrue(rs.isLast());\n<line_number-154>    }\n<line_number-155>\n<line_number-156>    @Test\n<line_number-157>    void testCloseForEmptyStatement() throws SQLException {\n<line_number-158>        assertFalse(mongoStatement.isClosed());\n<line_number-159>        mongoStatement.close();\n<line_number-160>        assertTrue(mongoStatement.isClosed());\n<line_number-161>\n<line_number-162>        // noop for second close()\n<line_number-163>        mongoStatement.close();\n<line_number-164>        assertTrue(mongoStatement.isClosed());\n<line_number-165>    }\n<line_number-166>\n<line_number-167>    @Test\n<line_number-168>    void testCloseForExecutedStatement() throws SQLException {\n<line_number-169>        when(mongoCursor.hasNext()).thenReturn(true);\n<line_number-170>        when(mongoCursor.next()).thenReturn(generateRow());\n<line_number-171>        when(mongoDatabase.runCommand(any(), eq(MongoJsonSchemaResult.class)))\n<line_number-172>                .thenReturn(generateSchema());\n<line_number-173>\n<line_number-174>        assertFalse(mongoStatement.isClosed());\n<line_number-175>        ResultSet rs = mongoStatement.executeQuery(\"select * from test\");\n<line_number-176>        mongoStatement.close();\n<line_number-177>        assertTrue(mongoStatement.isClosed());\n<line_number-178>        assertTrue(rs.isClosed());\n<line_number-179>\n<line_number-180>        // noop for second close()\n<line_number-181>        mongoStatement.close();\n<line_number-182>        assertTrue(mongoStatement.isClosed());\n<line_number-183>    }\n<line_number-184>\n<line_number-185>    @Test\n<line_number-186>    void testCloseOnCompletion() throws SQLException {\n<line_number-187>        when(mongoCursor.hasNext()).thenReturn(true);\n<line_number-188>        when(mongoCursor.next()).thenReturn(generateRow());\n<line_number-189>        when(mongoDatabase.runCommand(any(), eq(MongoJsonSchemaResult.class)))\n<line_number-190>                .thenReturn(generateSchema());\n<line_number-191>\n<line_number-192>        assertFalse(mongoStatement.isClosed());\n<line_number-193>        mongoStatement.closeOnCompletion = true;\n<line_number-194>        ResultSet rs = mongoStatement.executeQuery(\"select * from test\");\n<line_number-195>        rs.close();\n<line_number-196>        assertTrue(rs.isClosed());\n<line_number-197>        assertTrue(mongoStatement.isClosed());\n<line_number-198>\n<line_number-199>        // No-op since the statement has been closed\n<line_number-200>        // automatically when closing the resutlset\n<line_number-201>        mongoStatement.close();\n<line_number-202>        assertTrue(mongoStatement.isClosed());\n<line_number-203>    }\n<line_number-204>\n<line_number-205>    @Test\n<line_number-206>    void testGetMaxFieldSize() throws SQLException {\n<line_number-207>        assertEquals(0, mongoStatement.getMaxFieldSize());\n<line_number-208>        testExceptionAfterConnectionClosed(() -> mongoStatement.setMaxFieldSize(0));\n<line_number-209>    }\n<line_number-210>\n<line_number-211>    @Test\n<line_number-212>    void testSetMaxFieldoSize() throws SQLException {\n<line_number-213>        testNoop(() -> mongoStatement.setMaxFieldSize(0));\n<line_number-214>    }\n<line_number-215>\n<line_number-216>    @Test\n<line_number-217>    void testgetMaxRows() throws SQLException {\n<line_number-218>        assertEquals(0, mongoStatement.getMaxRows());\n<line_number-219>        testExceptionAfterConnectionClosed(() -> mongoStatement.getMaxRows());\n<line_number-220>    }\n<line_number-221>\n<line_number-222>    @Test\n<line_number-223>    void testSetMaxRows() throws SQLException {\n<line_number-224>        testNoop(() -> mongoStatement.setMaxRows(0));\n<line_number-225>    }\n<line_number-226>\n<line_number-227>    @Test\n<line_number-228>    void testSetEscapeProcessing() throws SQLException {\n<line_number-229>        testNoop(() -> mongoStatement.setEscapeProcessing(true));\n<line_number-230>    }\n<line_number-231>\n<line_number-232>    @Test\n<line_number-233>    void testSetGetQueryTimeout() throws SQLException {\n<line_number-234>        int timeout = 123;\n<line_number-235>        mongoStatement.setQueryTimeout(timeout);\n<line_number-236>        assertEquals(timeout, mongoStatement.getQueryTimeout());\n<line_number-237>\n<line_number-238>        testExceptionAfterConnectionClosed(() -> mongoStatement.setQueryTimeout(timeout));\n<line_number-239>        testExceptionAfterConnectionClosed(() -> mongoStatement.getQueryTimeout());\n<line_number-240>    }\n<line_number-241>\n<line_number-242>    @Test\n<line_number-243>    void testGetWarnings() throws SQLException {\n<line_number-244>        assertEquals(null, mongoStatement.getWarnings());\n<line_number-245>        testExceptionAfterConnectionClosed(() -> mongoStatement.getWarnings());\n<line_number-246>    }\n<line_number-247>\n<line_number-248>    @Test\n<line_number-249>    void testClearWarnings() throws SQLException {\n<line_number-250>        testNoop(() -> mongoStatement.clearWarnings());\n<line_number-251>    }\n<line_number-252>\n<line_number-253>    @Test\n<line_number-254>    void testSetCursorName() throws SQLException {\n<line_number-255>        testNoop(() -> mongoStatement.setCursorName(\"\"));\n<line_number-256>    }\n<line_number-257>\n<line_number-258>    @Test\n<line_number-259>    void testGetResultSet() throws SQLException {\n<line_number-260>        when(mongoCursor.hasNext()).thenReturn(true);\n<line_number-261>        when(mongoCursor.next()).thenReturn(generateRow());\n<line_number-262>        when(mongoDatabase.runCommand(any(), eq(MongoJsonSchemaResult.class)))\n<line_number-263>                .thenReturn(generateSchema());\n<line_number-264>\n<line_number-265>        assertNull(mongoStatement.getResultSet());\n<line_number-266>        ResultSet rs = mongoStatement.executeQuery(\"select * from foo\");\n<line_number-267>        assertEquals(rs, mongoStatement.getResultSet());\n<line_number-268>        testExceptionAfterConnectionClosed(() -> mongoStatement.getResultSet());\n<line_number-269>    }\n<line_number-270>\n<line_number-271>    @Test\n<line_number-272>    void testGetUpdateCount() throws SQLException {\n<line_number-273>        assertEquals(-1, mongoStatement.getUpdateCount());\n<line_number-274>        testExceptionAfterConnectionClosed(() -> mongoStatement.getUpdateCount());\n<line_number-275>    }\n<line_number-276>\n<line_number-277>    @Test\n<line_number-278>    void testGetMoreResults() throws SQLException {\n<line_number-279>        assertEquals(false, mongoStatement.getMoreResults());\n<line_number-280>        testExceptionAfterConnectionClosed(() -> mongoStatement.getMoreResults());\n<line_number-281>    }\n<line_number-282>\n<line_number-283>    @Test\n<line_number-284>    void testSetGetFetchSize() throws SQLException {\n<line_number-285>        assertThrows(SQLException.class, () -> mongoStatement.setFetchSize(-1));\n<line_number-286>\n<line_number-287>        int fetchSize = 10;\n<line_number-288>        mongoStatement.setFetchSize(fetchSize);\n<line_number-289>        assertEquals(fetchSize, mongoStatement.getFetchSize());\n<line_number-290>\n<line_number-291>        testExceptionAfterConnectionClosed(() -> mongoStatement.setFetchSize(0));\n<line_number-292>        testExceptionAfterConnectionClosed(() -> mongoStatement.getFetchSize());\n<line_number-293>    }\n<line_number-294>\n<line_number-295>    @Test\n<line_number-296>    void testGetResultSetConcurrency() throws SQLException {\n<line_number-297>        assertEquals(ResultSet.CONCUR_READ_ONLY, mongoStatement.getResultSetConcurrency());\n<line_number-298>        testExceptionAfterConnectionClosed(() -> mongoStatement.getResultSetConcurrency());\n<line_number-299>    }\n<line_number-300>\n<line_number-301>    @Test\n<line_number-302>    void testGetResultSetType() throws SQLException {\n<line_number-303>        assertEquals(ResultSet.TYPE_FORWARD_ONLY, mongoStatement.getResultSetType());\n<line_number-304>        testExceptionAfterConnectionClosed(() -> mongoStatement.getResultSetType());\n<line_number-305>    }\n<line_number-306>\n<line_number-307>    @Test\n<line_number-308>    void testGetConnection() throws SQLException {\n<line_number-309>        assertEquals(mongoConnection, mongoStatement.getConnection());\n<line_number-310>        testExceptionAfterConnectionClosed(() -> mongoStatement.getConnection());\n<line_number-311>    }\n<line_number-312>\n<line_number-313>    @Test\n<line_number-314>    void testGetMoreResultsWithInstructions() throws SQLException {\n<line_number-315>        when(mongoCursor.hasNext()).thenReturn(true);\n<line_number-316>        when(mongoCursor.next()).thenReturn(generateRow());\n<line_number-317>        when(mongoDatabase.runCommand(any(), eq(MongoJsonSchemaResult.class)))\n<line_number-318>                .thenReturn(generateSchema());\n<line_number-319>\n<line_number-320>        ResultSet rs = mongoStatement.executeQuery(\"select * from foo\");\n<line_number-321>        assertFalse(rs.isClosed());\n<line_number-322>        mongoStatement.getMoreResults(CLOSE_CURRENT_RESULT);\n<line_number-323>        assertTrue(rs.isClosed());\n<line_number-324>\n<line_number-325>        testExceptionAfterConnectionClosed(\n<line_number-326>                () -> mongoStatement.getMoreResults(CLOSE_CURRENT_RESULT));\n<line_number-327>    }\n<line_number-328>\n<line_number-329>    @Test\n<line_number-330>    void testSetPoolable() throws SQLException {\n<line_number-331>        testNoop(() -> mongoStatement.setPoolable(true));\n<line_number-332>    }\n<line_number-333>\n<line_number-334>    @Test\n<line_number-335>    void testIsPoolable() throws SQLException {\n<line_number-336>        assertEquals(false, mongoStatement.isPoolable());\n<line_number-337>        testExceptionAfterConnectionClosed(() -> mongoStatement.isPoolable());\n<line_number-338>    }\n<line_number-339>\n<line_number-340>    @Test\n<line_number-341>    void testSetGetCloseOnComplete() throws SQLException {\n<line_number-342>        when(mongoCursor.hasNext()).thenReturn(true);\n<line_number-343>        when(mongoCursor.next()).thenReturn(generateRow());\n<line_number-344>        when(mongoDatabase.runCommand(any(), eq(MongoJsonSchemaResult.class)))\n<line_number-345>                .thenReturn(generateSchema());\n<line_number-346>\n<line_number-347>        // When not close on complete\n<line_number-348>        assertFalse(mongoStatement.isCloseOnCompletion());\n<line_number-349>        ResultSet rs = mongoStatement.executeQuery(\"select * from foo\");\n<line_number-350>        assertFalse(mongoStatement.isClosed());\n<line_number-351>        rs.close();\n<line_number-352>        assertFalse(mongoStatement.isClosed());\n<line_number-353>\n<line_number-354>        // close on complete\n<line_number-355>        mongoStatement.closeOnCompletion();\n<line_number-356>        assertTrue(mongoStatement.isCloseOnCompletion());\n<line_number-357>        rs = mongoStatement.executeQuery(\"select * from foo\");\n<line_number-358>        assertFalse(mongoStatement.isClosed());\n<line_number-359>        rs.close();\n<line_number-360>        assertTrue(mongoStatement.isClosed());\n<line_number-361>\n<line_number-362>        testExceptionAfterConnectionClosed(() -> mongoStatement.setFetchSize(0));\n<line_number-363>        testExceptionAfterConnectionClosed(() -> mongoStatement.getFetchSize());\n<line_number-364>    }\n<line_number-365>\n<line_number-366>    @Test\n<line_number-367>    void testGetLargeMaxRows() throws SQLException {\n<line_number-368>        assertEquals(0, mongoStatement.getLargeMaxRows());\n<line_number-369>        testExceptionAfterConnectionClosed(() -> mongoStatement.getLargeMaxRows());\n<line_number-370>    }\n<line_number-371>}\n",
        "comments": [
          {
            "comment_code_range": "17-17",
            "comment_linenumber": "16",
            "comment": "Defines the package for MongoDB JDBC integration tests.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "44-47",
            "comment_linenumber": "43",
            "comment": "Test class for MongoStatement, extending MongoMock to utilize mock objects for testing database interactions.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "50-56",
            "comment_linenumber": "49",
            "comment": "Static block to initialize MongoStatement with a mock connection and database, handling potential SQL exceptions.",
            "comment_kind": "other"
          },
          {
            "comment_code_range": "58-61",
            "comment_linenumber": "57",
            "comment": "Initializes mock objects before all tests are run.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "63-70",
            "comment_linenumber": "62",
            "comment": "Sets up the test environment before each test, resetting mock objects and initializing MongoStatement.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "72-76",
            "comment_linenumber": "71",
            "comment": "Tests that an exception is thrown when attempting to create a statement after the connection is closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "79-81",
            "comment_linenumber": "78",
            "comment": "Tests that no exception is thrown for a valid operation and verifies exception handling after connection closure.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "84-87",
            "comment_linenumber": "83",
            "comment": "Interface to facilitate testing with a lambda expression for SQL operations.",
            "comment_kind": "interface"
          },
          {
            "comment_code_range": "89-123",
            "comment_linenumber": "88",
            "comment": "Tests the execution of a query that returns an empty result set, verifying metadata and exception handling.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "125-154",
            "comment_linenumber": "124",
            "comment": "Tests the execution of a query that returns results, validating the result set and its contents.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "156-165",
            "comment_linenumber": "155",
            "comment": "Tests the behavior of closing an empty statement, ensuring it can be closed multiple times without error.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "167-183",
            "comment_linenumber": "166",
            "comment": "Tests closing an executed statement and verifies that the result set is also closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "185-203",
            "comment_linenumber": "184",
            "comment": "Tests closing a statement on completion, ensuring it closes the statement when the result set is closed.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "205-208",
            "comment_linenumber": "204",
            "comment": "Tests getting the maximum field size from the statement, ensuring proper exception handling.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "212-224",
            "comment_linenumber": "211",
            "comment": "Tests setting the maximum field size, verifying that no exceptions are thrown.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "227-238",
            "comment_linenumber": "226",
            "comment": "Tests getting the maximum rows from the statement, ensuring proper exception handling.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "242-250",
            "comment_linenumber": "241",
            "comment": "Tests clearing warnings on the statement, verifying that no exceptions are thrown.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "253-256",
            "comment_linenumber": "252",
            "comment": "Tests setting the cursor name on the statement, ensuring no exceptions are thrown.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "259-268",
            "comment_linenumber": "258",
            "comment": "Tests getting the result set from the statement, verifying that it matches the executed query's result.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "271-280",
            "comment_linenumber": "270",
            "comment": "Tests getting the update count from the statement, ensuring proper exception handling.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "283-291",
            "comment_linenumber": "282",
            "comment": "Tests getting the fetch size from the statement, ensuring proper exception handling and validation.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "295-304",
            "comment_linenumber": "294",
            "comment": "Tests getting the result set type from the statement, ensuring proper exception handling.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "307-310",
            "comment_linenumber": "306",
            "comment": "Tests getting the connection associated with the statement, ensuring proper exception handling.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "313-326",
            "comment_linenumber": "312",
            "comment": "Tests getting more results with instructions, verifying that the result set is closed appropriately.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "329-332",
            "comment_linenumber": "328",
            "comment": "Tests setting the poolable state of the statement, ensuring no exceptions are thrown.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "335-338",
            "comment_linenumber": "334",
            "comment": "Tests checking if the statement is poolable, ensuring proper exception handling.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "341-364",
            "comment_linenumber": "340",
            "comment": "Tests setting and getting the close-on-completion state of the statement, verifying behavior with result sets.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "367-370",
            "comment_linenumber": "366",
            "comment": "Tests getting the large maximum rows from the statement, ensuring proper exception handling.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'MongoStatementTest.java' is a JUnit test class designed to validate the functionality of the 'MongoStatement' class, which is part of the MongoDB JDBC driver. It employs the Mockito framework for mocking dependencies and verifying interactions. The class extends 'MongoMock', which likely provides a base setup for MongoDB-related tests. The tests cover various methods of 'MongoStatement', ensuring that they behave correctly under different scenarios, including handling exceptions, validating results, and managing resource states. The tests are structured to initialize mocks, execute queries, and assert expected outcomes, with a focus on exception handling and resource management. The class uses annotations such as @ExtendWith, @TestInstance, and @MockitoSettings to configure the testing environment and behavior. Each test method is annotated with @Test, indicating that it is a test case to be executed by the JUnit framework.",
        "file_summary": "This file contains unit tests for the MongoStatement class, ensuring its methods function correctly with respect to database interactions, exception handling, and resource management. It utilizes Mockito for mocking dependencies and JUnit for structuring the tests."
      }
    ]
  },
  "TestConnectionString.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\TestConnectionString.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\TestConnectionString.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\TestConnectionString.java",
        "chunk_id": "TestConnectionString_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2023-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc;\n<line_number-18>\n<line_number-19>import static com.mongodb.jdbc.MongoDriver.*;\n<line_number-20>import static org.junit.jupiter.api.Assertions.*;\n<line_number-21>\n<line_number-22>import com.mongodb.AuthenticationMechanism;\n<line_number-23>import com.mongodb.ConnectionString;\n<line_number-24>import java.util.Arrays;\n<line_number-25>import java.util.Properties;\n<line_number-26>import java.util.regex.Matcher;\n<line_number-27>import org.junit.jupiter.api.Test;\n<line_number-28>\n<line_number-29>class TestConnectionString {\n<line_number-30>    static final String localhost = \"mongodb://localhost\";\n<line_number-31>    static final String localhostWithOnlyDB = \"mongodb://localhost/authDB\";\n<line_number-32>    static final String onlyAuthSource = \"mongodb://localhost/?authSource=authDB\";\n<line_number-33>    static final String dbAndAuthSource = \"mongodb://localhost/pouet?authSource=authDB\";\n<line_number-34>    static final String USER_CONN_KEY = \"user\";\n<line_number-35>    static final String PWD_CONN_KEY = \"password\";\n<line_number-36>    static final String USER = \"AzureDiamond\";\n<line_number-37>    static final String PWD = \"hunter2\";\n<line_number-38>    static final String DATABASE = \"database\";\n<line_number-39>    static final String DB = \"foo\";\n<line_number-40>    static final String AUTHDB = \"authDB\";\n<line_number-41>    static final String POUET = \"pouet\";\n<line_number-42>\n<line_number-43>    @Test\n<line_number-44>    void testLocalHost() throws Exception {\n<line_number-45>        Properties p = new Properties();\n<line_number-46>        p.setProperty(USER_CONN_KEY, USER);\n<line_number-47>        p.setProperty(PWD_CONN_KEY, PWD);\n<line_number-48>        p.setProperty(DATABASE, DB);\n<line_number-49>\n<line_number-50>        MongoConnectionConfig result = getConnectionSettings(localhost, p);\n<line_number-51>\n<line_number-52>        assertEquals(USER, result.connectionString.getCredential().getUserName());\n<line_number-53>        assertEquals(DB, result.connectionString.getCredential().getSource());\n<line_number-54>    }\n<line_number-55>\n<line_number-56>    @Test\n<line_number-57>    void testLocalHostWithOnlyDBNoPropsDB() throws Exception {\n<line_number-58>        Properties p = new Properties();\n<line_number-59>        p.setProperty(USER_CONN_KEY, USER);\n<line_number-60>        p.setProperty(PWD_CONN_KEY, PWD);\n<line_number-61>\n<line_number-62>        MongoConnectionConfig result = getConnectionSettings(localhostWithOnlyDB, p);\n<line_number-63>\n<line_number-64>        assertEquals(USER, result.connectionString.getCredential().getUserName());\n<line_number-65>        assertEquals(AUTHDB, result.connectionString.getCredential().getSource());\n<line_number-66>    }\n<line_number-67>\n<line_number-68>    @Test\n<line_number-69>    void testPropsDBOverridesURIDBNoAuthSource() throws Exception {\n<line_number-70>        Properties p = new Properties();\n<line_number-71>        p.setProperty(USER_CONN_KEY, USER);\n<line_number-72>        p.setProperty(PWD_CONN_KEY, PWD);\n<line_number-73>        p.setProperty(DATABASE, DB);\n<line_number-74>\n<line_number-75>        MongoConnectionConfig result = getConnectionSettings(localhostWithOnlyDB, p);\n<line_number-76>\n<line_number-77>        assertEquals(USER, result.connectionString.getCredential().getUserName());\n<line_number-78>        assertEquals(DB, result.connectionString.getCredential().getSource());\n<line_number-79>        assertEquals(DB, result.connectionString.getDatabase());\n<line_number-80>    }\n<line_number-81>\n<line_number-82>    @Test\n<line_number-83>    void testPropsDBWithURIAuthSource() throws Exception {\n<line_number-84>        Properties p = new Properties();\n<line_number-85>        p.setProperty(USER_CONN_KEY, USER);\n<line_number-86>        p.setProperty(PWD_CONN_KEY, PWD);\n<line_number-87>        p.setProperty(DATABASE, DB);\n<line_number-88>\n<line_number-89>        MongoConnectionConfig result = getConnectionSettings(onlyAuthSource, p);\n<line_number-90>\n<line_number-91>        assertEquals(USER, result.connectionString.getCredential().getUserName());\n<line_number-92>        assertEquals(AUTHDB, result.connectionString.getCredential().getSource());\n<line_number-93>        assertEquals(DB, result.connectionString.getDatabase());\n<line_number-94>    }\n<line_number-95>\n<line_number-96>    @Test\n<line_number-97>    void testUriDBWithAuthSource() throws Exception {\n<line_number-98>        Properties p = new Properties();\n<line_number-99>        p.setProperty(USER_CONN_KEY, USER);\n<line_number-100>        p.setProperty(PWD_CONN_KEY, PWD);\n<line_number-101>\n<line_number-102>        MongoConnectionConfig result = getConnectionSettings(dbAndAuthSource, p);\n<line_number-103>\n<line_number-104>        assertEquals(USER, result.connectionString.getCredential().getUserName());\n<line_number-105>        assertEquals(AUTHDB, result.connectionString.getCredential().getSource());\n<line_number-106>        assertEquals(POUET, result.connectionString.getDatabase());\n<line_number-107>    }\n<line_number-108>\n<line_number-109>    @Test\n<line_number-110>    void testPropsOverrideURIDBWithAuthSource() throws Exception {\n<line_number-111>        Properties p = new Properties();\n<line_number-112>        p.setProperty(USER_CONN_KEY, USER);\n<line_number-113>        p.setProperty(PWD_CONN_KEY, PWD);\n<line_number-114>        p.setProperty(DATABASE, DB);\n<line_number-115>        MongoConnectionConfig result = getConnectionSettings(dbAndAuthSource, p);\n<line_number-116>\n<line_number-117>        assertEquals(USER, result.connectionString.getCredential().getUserName());\n<line_number-118>        assertEquals(AUTHDB, result.connectionString.getCredential().getSource());\n<line_number-119>        assertEquals(DB, result.connectionString.getDatabase());\n<line_number-120>    }\n<line_number-121>\n<line_number-122>    // Tests for the work-around required to be able to parse URI when the username and password is mandatory but provided as part of the properties.\n<line_number-123>    @Test\n<line_number-124>    void testBuildConnectionStringWithMissingUidPwdForAllAuthMech() throws Exception {\n<line_number-125>        for (AuthenticationMechanism authMech : AuthenticationMechanism.values()) {\n<line_number-126>            String url =\n<line_number-127>                    localhostWithOnlyDB\n<line_number-128>                            + \"?authSource=$external&authMechanism=\"\n<line_number-129>                            + authMech.getMechanismName();\n<line_number-130>            System.out.println(url);\n<line_number-131>\n<line_number-132>            Properties p = new Properties();\n<line_number-133>            p.setProperty(USER_CONN_KEY, USER);\n<line_number-134>            if (authMech != AuthenticationMechanism.MONGODB_OIDC\n<line_number-135>                    && authMech != AuthenticationMechanism.MONGODB_X509) {\n<line_number-136>                p.setProperty(PWD_CONN_KEY, PWD);\n<line_number-137>            }\n<line_number-138>\n<line_number-139>            ConnectionString result = buildConnectionString(url, p);\n<line_number-140>\n<line_number-141>            // For PLAIN,SCRAM-SHA-1, SCRAM-SHA-256 AND GSSAPI the uri must be augmented with the username and password provided in the properties\n<line_number-142>            if (Arrays.asList(\n<line_number-143>                            AuthenticationMechanism.PLAIN,\n<line_number-144>                            AuthenticationMechanism.SCRAM_SHA_1,\n<line_number-145>                            AuthenticationMechanism.SCRAM_SHA_256,\n<line_number-146>                            AuthenticationMechanism.GSSAPI)\n<line_number-147>                    .contains(authMech)) {\n<line_number-148>                assertNotEquals(\n<line_number-149>                        result.getConnectionString(),\n<line_number-150>                        url,\n<line_number-151>                        \"The original URL should have been augmented with the username and password information but it wasn't.\");\n<line_number-152>                assertNotNull(result.getCredential());\n<line_number-153>                assertNotNull(result.getCredential().getAuthenticationMechanism());\n<line_number-154>                assertEquals(\n<line_number-155>                        authMech.getMechanismName(),\n<line_number-156>                        result.getCredential().getAuthenticationMechanism().getMechanismName());\n<line_number-157>                if (null != result.getCredential().getUserName()) {\n<line_number-158>                    assertEquals(USER, result.getCredential().getUserName());\n<line_number-159>                }\n<line_number-160>                if (null != result.getCredential().getPassword()) {\n<line_number-161>                    assertEquals(PWD, new String(result.getCredential().getPassword()));\n<line_number-162>                }\n<line_number-163>            } else {\n<line_number-164>                assertEquals(\n<line_number-165>                        result.getConnectionString(),\n<line_number-166>                        url,\n<line_number-167>                        \"The original URL should stay unchanged\");\n<line_number-168>            }\n<line_number-169>        }\n<line_number-170>    }\n<line_number-171>\n<line_number-172>    /**\n<line_number-173>     * Validate that the MONGODB_URI_PATTERN is correct and work as expected.\n<line_number-174>     *\n<line_number-175>     * @param uri The uri to test.\n<line_number-176>     * @param shouldMatch True, if the uri should match the pattern. False otherwise.\n<line_number-177>     * @param hasUidPWd True, if the uri contains a username and/or password. False otherwise.\n<line_number-178>     * @param expectedAuthMech The expected authentication mechanism extracted from the uri.\n<line_number-179>     */\n<line_number-180>    void testPatternsHelper(\n<line_number-181>            String uri, boolean shouldMatch, boolean hasUidPWd, String expectedAuthMech) {\n<line_number-182>        Matcher uri_matcher = MONGODB_URI_PATTERN.matcher(uri);\n<line_number-183>        boolean match = uri_matcher.find();\n<line_number-184>\n<line_number-185>        assertEquals(\n<line_number-186>                match,\n<line_number-187>                shouldMatch,\n<line_number-188>                \"The URI \"\n<line_number-189>                        + uri\n<line_number-190>                        + \" matching result is not as expected. Expected: \"\n<line_number-191>                        + shouldMatch\n<line_number-192>                        + \" , Actual: \"\n<line_number-193>                        + match);\n<line_number-194>        if (shouldMatch) {\n<line_number-195>            String uidpwd = uri_matcher.group(\"uidpwd\");\n<line_number-196>            String options = uri_matcher.group(\"options\");\n<line_number-197>            if (hasUidPWd) {\n<line_number-198>                assertNotNull(uidpwd, \"No UID/PWD detected when expected. URI = \" + uri);\n<line_number-199>            } else {\n<line_number-200>                assertNull(uidpwd, \"UID/PWD detected when none expected. URI = \" + uri);\n<line_number-201>            }\n<line_number-202>\n<line_number-203>            if (options != null) {\n<line_number-204>                Matcher authMec_matcher = AUTH_MECH_TO_AUGMENT_PATTERN.matcher(options);\n<line_number-205>                match = authMec_matcher.find();\n<line_number-206>                assertEquals(\n<line_number-207>                        match,\n<line_number-208>                        expectedAuthMech != null,\n<line_number-209>                        \"The authentication mechanism matching result is not as expected. Expected: \"\n<line_number-210>                                + (expectedAuthMech != null)\n<line_number-211>                                + \" , Actual: \"\n<line_number-212>                                + match);\n<line_number-213>                if (match && expectedAuthMech != null) {\n<line_number-214>                    assertTrue(\n<line_number-215>                            match,\n<line_number-216>                            \"No authentication mechanism was found in the URI when \"\n<line_number-217>                                    + expectedAuthMech\n<line_number-218>                                    + \" was expected.\");\n<line_number-219>                    String authMech = authMec_matcher.group(\"authMech\");\n<line_number-220>                    assertEquals(\n<line_number-221>                            authMech,\n<line_number-222>                            expectedAuthMech,\n<line_number-223>                            \"Expected authentication mechanism \"\n<line_number-224>                                    + expectedAuthMech\n<line_number-225>                                    + \" but got \"\n<line_number-226>                                    + authMech);\n<line_number-227>                }\n<line_number-228>            }\n<line_number-229>        }\n<line_number-230>    }\n<line_number-231>\n<line_number-232>    @Test\n<line_number-233>    void testPatterns() {\n<line_number-234>        // Non matching URIs\n<line_number-235>        testPatternsHelper(\"mongodb:/localhost\", false, false, null);\n<line_number-236>        testPatternsHelper(\"blabla\", false, false, null);\n<line_number-237>\n<line_number-238>        // No user name or password\n<line_number-239>        testPatternsHelper(\"mongodb://localhost\", true, false, null);\n<line_number-240>        testPatternsHelper(\"mongodb://localhost?connectTimeoutms=600000\", true, false, null);\n<line_number-241>        testPatternsHelper(\n<line_number-242>                \"mongodb+srv://localhost?authSource=$external&connectTimeoutms=600000\",\n<line_number-243>                true,\n<line_number-244>                false,\n<line_number-245>                null);\n<line_number-246>\n<line_number-247>        // User name or password\n<line_number-248>        testPatternsHelper(\"mongodb://toto@localhost\", true, true, null);\n<line_number-249>        testPatternsHelper(\"mongodb+srv://toto:tutu@localhost\", true, true, null);\n<line_number-250>        testPatternsHelper(\n<line_number-251>                \"mongodb+srv://toto@localhost?connectTimeoutms=600000\", true, true, null);\n<line_number-252>        testPatternsHelper(\n<line_number-253>                \"mongodb://toto:tutu@localhost?connectTimeoutms=600000\", true, true, null);\n<line_number-254>\n<line_number-255>        // No user name or password, with auth mech\n<line_number-256>        for (String authMech : MECHANISMS_TO_AUGMENT) {\n<line_number-257>            testPatternsHelper(\n<line_number-258>                    \"mongodb://localhost?authSource=$external&authMechanism=\" + authMech,\n<line_number-259>                    true,\n<line_number-260>                    false,\n<line_number-261>                    authMech);\n<line_number-262>        }\n<line_number-263>        testPatternsHelper(\n<line_number-264>                \"mongodb://localhost?authSource=$external&authMechanism=MONGODB-OIDC\",\n<line_number-265>                true,\n<line_number-266>                false,\n<line_number-267>                null);\n<line_number-268>        testPatternsHelper(\n<line_number-269>                \"mongodb://localhost?authSource=$external&authMechanism=SCRAM_SHA_1\",\n<line_number-270>                true,\n<line_number-271>                false,\n<line_number-272>                null);\n<line_number-273>\n<line_number-274>        for (String authMech : MECHANISMS_TO_AUGMENT) {\n<line_number-275>            testPatternsHelper(\n<line_number-276>                    \"mongodb://localhost?authSource=$external&authMechanism=\"\n<line_number-277>                            + authMech\n<line_number-278>                            + \"&connectTimeoutms=600000\",\n<line_number-279>                    true,\n<line_number-280>                    false,\n<line_number-281>                    authMech);\n<line_number-282>        }\n<line_number-283>        testPatternsHelper(\n<line_number-284>                \"mongodb://localhost?authSource=$external&authMechanism=MONGODB-OIDC&connectTimeoutms=600000\",\n<line_number-285>                true,\n<line_number-286>                false,\n<line_number-287>                null);\n<line_number-288>        for (String authMech : MECHANISMS_TO_AUGMENT) {\n<line_number-289>            testPatternsHelper(\n<line_number-290>                    \"mongodb+srv://localhost?authMechanism=\"\n<line_number-291>                            + authMech\n<line_number-292>                            + \"&authSource=$external&connectTimeoutms=600000\",\n<line_number-293>                    true,\n<line_number-294>                    false,\n<line_number-295>                    authMech);\n<line_number-296>        }\n<line_number-297>        testPatternsHelper(\n<line_number-298>                \"mongodb+srv://localhost?authMechanism=MONGODB-OIDC&authSource=$external&connectTimeoutms=600000\",\n<line_number-299>                true,\n<line_number-300>                false,\n<line_number-301>                null);\n<line_number-302>\n<line_number-303>        for (String authMech : MECHANISMS_TO_AUGMENT) {\n<line_number-304>            testPatternsHelper(\n<line_number-305>                    \"mongodb://localhost?authMechanism=\" + authMech, true, false, authMech);\n<line_number-306>        }\n<line_number-307>        testPatternsHelper(\"mongodb://localhost?authMechanism=MONGODB-OIDC\", true, false, null);\n<line_number-308>    }\n<line_number-309>}\n",
        "comments": [
          {
            "comment_code_range": "29-309",
            "comment_linenumber": "28",
            "comment": "Test suite for validating MongoDB connection string parsing and configuration settings.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "43-54",
            "comment_linenumber": "42",
            "comment": "Tests the connection settings for a local MongoDB instance without additional database properties.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "56-66",
            "comment_linenumber": "55",
            "comment": "Tests connection settings when only the database is specified in the URI.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "68-79",
            "comment_linenumber": "67",
            "comment": "Verifies that properties override the database specified in the URI when no auth source is provided.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "82-93",
            "comment_linenumber": "81",
            "comment": "Tests connection settings when both URI and properties specify the auth source.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "96-107",
            "comment_linenumber": "95",
            "comment": "Validates connection settings when the URI specifies both database and auth source.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "109-120",
            "comment_linenumber": "108",
            "comment": "Tests properties overriding the URI database when an auth source is specified.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "122-170",
            "comment_linenumber": "121",
            "comment": "Tests the construction of connection strings when username and password are provided in properties.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "172-230",
            "comment_linenumber": "171",
            "comment": "Helper method to validate MongoDB URI patterns against expected outcomes.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "232-307",
            "comment_linenumber": "231",
            "comment": "Tests various MongoDB URI patterns for correctness and expected behavior.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'TestConnectionString.java' is a JUnit test class designed to validate the parsing and configuration of MongoDB connection strings. It employs the JUnit framework for testing various scenarios related to connection settings. The primary class, 'TestConnectionString', contains multiple test methods that check different aspects of connection string handling, including the use of properties and URI parameters. Each test method is annotated with @Test, indicating that they are test cases to be executed by the JUnit framework. The class utilizes static final strings to define various connection string formats and credentials, ensuring consistency across tests. The methods primarily interact with the 'MongoConnectionConfig' and 'ConnectionString' classes, which are assumed to be part of the MongoDB JDBC driver. The tests cover scenarios such as local connections, database overrides, and authentication mechanisms, ensuring comprehensive coverage of connection string behavior. The helper method 'testPatternsHelper' is used to validate URI patterns against expected results, enhancing code reusability and clarity. Overall, the structure is organized to facilitate easy addition of new tests and maintainability.",
        "file_summary": "This file contains a suite of JUnit tests for validating the behavior of MongoDB connection strings and their associated configurations. It tests various scenarios including local connections, database overrides, and authentication mechanisms, ensuring that the connection settings are parsed and applied correctly."
      }
    ]
  },
  "RFC8252HttpServerTest.java": {
    "java_file": ".\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\oidc\\RFC8252HttpServerTest.java",
    "chunks": [
      {
        "file_path": "src\\test\\java\\com\\mongodb\\jdbc\\oidc\\RFC8252HttpServerTest.java",
        "abs_file_path": "C:\\Users\\dheer\\Desktop\\alphonso\\examples\\mongo-jdbc-driver-master\\src\\test\\java\\com\\mongodb\\jdbc\\oidc\\RFC8252HttpServerTest.java",
        "chunk_id": "RFC8252HttpServerTest_1",
        "content": "<line_number-1>/*\n<line_number-2> * Copyright 2024-present MongoDB, Inc.\n<line_number-3> *\n<line_number-4> * Licensed under the Apache License, Version 2.0 (the \"License\");\n<line_number-5> * you may not use this file except in compliance with the License.\n<line_number-6> * You may obtain a copy of the License at\n<line_number-7> *\n<line_number-8> *   http://www.apache.org/licenses/LICENSE-2.0\n<line_number-9> *\n<line_number-10> * Unless required by applicable law or agreed to in writing, software\n<line_number-11> * distributed under the License is distributed on an \"AS IS\" BASIS,\n<line_number-12> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n<line_number-13> * See the License for the specific language governing permissions and\n<line_number-14> * limitations under the License.\n<line_number-15> */\n<line_number-16>\n<line_number-17>package com.mongodb.jdbc.oidc;\n<line_number-18>\n<line_number-19>import static org.junit.jupiter.api.Assertions.*;\n<line_number-20>\n<line_number-21>import java.io.IOException;\n<line_number-22>import java.net.HttpURLConnection;\n<line_number-23>import java.net.URL;\n<line_number-24>import org.junit.jupiter.api.AfterEach;\n<line_number-25>import org.junit.jupiter.api.BeforeEach;\n<line_number-26>import org.junit.jupiter.api.Test;\n<line_number-27>\n<line_number-28>class RFC8252HttpServerTest {\n<line_number-29>    private RFC8252HttpServer server;\n<line_number-30>\n<line_number-31>    @BeforeEach\n<line_number-32>    void setUp() throws IOException {\n<line_number-33>        server = new RFC8252HttpServer();\n<line_number-34>        server.start();\n<line_number-35>    }\n<line_number-36>\n<line_number-37>    @AfterEach\n<line_number-38>    void tearDown() {\n<line_number-39>        server.stop();\n<line_number-40>    }\n<line_number-41>\n<line_number-42>    @Test\n<line_number-43>    void testAcceptedResponse() throws OidcTimeoutException, IOException, InterruptedException {\n<line_number-44>        URL url =\n<line_number-45>                new URL(\n<line_number-46>                        \"http://localhost:\"\n<line_number-47>                                + RFC8252HttpServer.DEFAULT_REDIRECT_PORT\n<line_number-48>                                + \"/callback?code=1234&state=foo\");\n<line_number-49>        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n<line_number-50>        connection.setRequestMethod(\"GET\");\n<line_number-51>        connection.connect();\n<line_number-52>\n<line_number-53>        assertEquals(200, connection.getResponseCode());\n<line_number-54>        assertNull(connection.getHeaderField(\"Location\"));\n<line_number-55>\n<line_number-56>        OidcResponse oidcResponse = server.getOidcResponse();\n<line_number-57>        assertEquals(\"1234\", oidcResponse.getCode());\n<line_number-58>        assertEquals(\"foo\", oidcResponse.getState());\n<line_number-59>    }\n<line_number-60>\n<line_number-61>    @Test\n<line_number-62>    void testErrorResponse() throws OidcTimeoutException, IOException, InterruptedException {\n<line_number-63>        URL url =\n<line_number-64>                new URL(\n<line_number-65>                        \"http://localhost:\"\n<line_number-66>                                + RFC8252HttpServer.DEFAULT_REDIRECT_PORT\n<line_number-67>                                + \"/callback?error=1234&error_description=foo\");\n<line_number-68>        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n<line_number-69>        connection.setRequestMethod(\"GET\");\n<line_number-70>        connection.connect();\n<line_number-71>\n<line_number-72>        assertEquals(400, connection.getResponseCode());\n<line_number-73>\n<line_number-74>        OidcResponse oidcResponse = server.getOidcResponse();\n<line_number-75>        assertEquals(\"1234\", oidcResponse.getError());\n<line_number-76>        assertEquals(\"foo\", oidcResponse.getErrorDescription());\n<line_number-77>    }\n<line_number-78>\n<line_number-79>    @Test\n<line_number-80>    void testMissingParameters() throws OidcTimeoutException, IOException, InterruptedException {\n<line_number-81>        URL url =\n<line_number-82>                new URL(\n<line_number-83>                        \"http://localhost:\"\n<line_number-84>                                + RFC8252HttpServer.DEFAULT_REDIRECT_PORT\n<line_number-85>                                + \"/callback\");\n<line_number-86>        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n<line_number-87>        connection.setRequestMethod(\"GET\");\n<line_number-88>        connection.connect();\n<line_number-89>\n<line_number-90>        assertEquals(404, connection.getResponseCode());\n<line_number-91>\n<line_number-92>        OidcResponse oidcResponse = server.getOidcResponse();\n<line_number-93>        assertNull(oidcResponse.getCode());\n<line_number-94>        assertNull(oidcResponse.getState());\n<line_number-95>        assert (oidcResponse.getError().equals(\"Not found\"));\n<line_number-96>        assert (oidcResponse.getErrorDescription().equals(\"Not found. Parameters: No parameters\"));\n<line_number-97>    }\n<line_number-98>\n<line_number-99>    @Test\n<line_number-100>    void testRedirectUnknownParameters()\n<line_number-101>            throws OidcTimeoutException, IOException, InterruptedException {\n<line_number-102>        URL url =\n<line_number-103>                new URL(\n<line_number-104>                        \"http://localhost:\"\n<line_number-105>                                + RFC8252HttpServer.DEFAULT_REDIRECT_PORT\n<line_number-106>                                + \"/redirect?foo=bar\");\n<line_number-107>        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n<line_number-108>        connection.setRequestMethod(\"GET\");\n<line_number-109>        connection.connect();\n<line_number-110>\n<line_number-111>        assertEquals(404, connection.getResponseCode());\n<line_number-112>\n<line_number-113>        OidcResponse oidcResponse = server.getOidcResponse();\n<line_number-114>        assertNull(oidcResponse.getCode());\n<line_number-115>        assertNull(oidcResponse.getState());\n<line_number-116>        assert (oidcResponse.getError().equals(\"Not found\"));\n<line_number-117>        assert (oidcResponse.getErrorDescription().equals(\"Not found. Parameters: foo=bar\"));\n<line_number-118>    }\n<line_number-119>\n<line_number-120>    @Test\n<line_number-121>    void testAmpersandInParameterValue()\n<line_number-122>            throws OidcTimeoutException, IOException, InterruptedException {\n<line_number-123>        URL url =\n<line_number-124>                new URL(\n<line_number-125>                        \"http://localhost:\"\n<line_number-126>                                + RFC8252HttpServer.DEFAULT_REDIRECT_PORT\n<line_number-127>                                + \"/callback?code=1234&state=foo%26bar\");\n<line_number-128>        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n<line_number-129>        connection.setRequestMethod(\"GET\");\n<line_number-130>        connection.connect();\n<line_number-131>\n<line_number-132>        assertEquals(200, connection.getResponseCode());\n<line_number-133>        OidcResponse oidcResponse = server.getOidcResponse();\n<line_number-134>        assertEquals(\"1234\", oidcResponse.getCode());\n<line_number-135>        assertEquals(\"foo&bar\", oidcResponse.getState());\n<line_number-136>    }\n<line_number-137>\n<line_number-138>    @Test\n<line_number-139>    void testEqualsInParameterValue()\n<line_number-140>            throws OidcTimeoutException, IOException, InterruptedException {\n<line_number-141>        URL url =\n<line_number-142>                new URL(\n<line_number-143>                        \"http://localhost:\"\n<line_number-144>                                + RFC8252HttpServer.DEFAULT_REDIRECT_PORT\n<line_number-145>                                + \"/callback?code=1234&state=foo%3Dbar\");\n<line_number-146>        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n<line_number-147>        connection.setRequestMethod(\"GET\");\n<line_number-148>        connection.connect();\n<line_number-149>\n<line_number-150>        assertEquals(200, connection.getResponseCode());\n<line_number-151>        OidcResponse oidcResponse = server.getOidcResponse();\n<line_number-152>        assertEquals(\"1234\", oidcResponse.getCode());\n<line_number-153>        assertEquals(\"foo=bar\", oidcResponse.getState());\n<line_number-154>    }\n<line_number-155>}\n",
        "comments": [
          {
            "comment_code_range": "28-155",
            "comment_linenumber": "27",
            "comment": "Test class for RFC8252HttpServer, responsible for validating the server's response handling for various OIDC callback scenarios.",
            "comment_kind": "class"
          },
          {
            "comment_code_range": "31-35",
            "comment_linenumber": "30",
            "comment": "Sets up the RFC8252HttpServer instance before each test, ensuring the server is started for testing.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "37-40",
            "comment_linenumber": "36",
            "comment": "Stops the RFC8252HttpServer instance after each test to clean up resources.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "42-58",
            "comment_linenumber": "41",
            "comment": "Tests the server's response when a valid authorization code is provided, expecting a 200 response and correct OIDC response values.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "61-76",
            "comment_linenumber": "60",
            "comment": "Tests the server's response when an error is provided in the callback, expecting a 400 response and correct error details.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "79-96",
            "comment_linenumber": "78",
            "comment": "Tests the server's response when no parameters are provided, expecting a 404 response and appropriate error messages.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "99-117",
            "comment_linenumber": "98",
            "comment": "Tests the server's response when unknown parameters are included in the redirect, expecting a 404 response and error details.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "121-135",
            "comment_linenumber": "120",
            "comment": "Tests the server's handling of ampersands in parameter values, expecting a 200 response and correct decoding of the state.",
            "comment_kind": "method"
          },
          {
            "comment_code_range": "139-153",
            "comment_linenumber": "138",
            "comment": "Tests the server's handling of equals signs in parameter values, expecting a 200 response and correct decoding of the state.",
            "comment_kind": "method"
          }
        ],
        "structural_analysis": "The file 'RFC8252HttpServerTest.java' is a JUnit test class designed to validate the behavior of the 'RFC8252HttpServer' class, specifically focusing on its handling of OpenID Connect (OIDC) callback responses. The class follows a standard structure for unit tests, utilizing annotations from the JUnit framework to manage test lifecycle methods and assertions. \n\n### Top-Level Types\n- **Class**: RFC8252HttpServerTest\n  - **Role**: This class is responsible for testing the functionality of the RFC8252HttpServer, ensuring it correctly processes OIDC callback requests and returns appropriate responses based on the input parameters.\n  - **Lifecycle Notes**: The class is not a singleton and is instantiated for each test run, ensuring isolation between tests.\n\n### Members\n- **Field**: server\n  - **Type**: RFC8252HttpServer\n  - **Visibility**: private\n  - **Purpose**: Holds the instance of the RFC8252HttpServer being tested.\n\n### Method Deep-Dive\n- **Method**: setUp\n  - **Parameters**: None\n  - **Return Type**: void\n  - **Behaviour**: Initializes the server instance and starts it before each test. Throws IOException if the server fails to start.\n  - **Internal Calls**: Calls server.start().\n\n- **Method**: tearDown\n  - **Parameters**: None\n  - **Return Type**: void\n  - **Behaviour**: Stops the server after each test to clean up resources.\n  - **Internal Calls**: Calls server.stop().\n\n- **Method**: testAcceptedResponse\n  - **Parameters**: None\n  - **Return Type**: void\n  - **Behaviour**: Sends a valid callback request to the server and asserts that the response code is 200 and the OIDC response contains the expected values.\n  - **Internal Calls**: Uses HttpURLConnection to send requests and server.getOidcResponse() to retrieve the response.\n  - **Key Control Flow**: Validates the response code and checks the OIDC response fields.\n\n- **Method**: testErrorResponse\n  - **Parameters**: None\n  - **Return Type**: void\n  - **Behaviour**: Sends a callback request with an error and asserts that the response code is 400 and the OIDC response contains the expected error details.\n\n- **Method**: testMissingParameters\n  - **Parameters**: None\n  - **Return Type**: void\n  - **Behaviour**: Sends a request without parameters and asserts that the response code is 404 and the OIDC response indicates missing parameters.\n\n- **Method**: testRedirectUnknownParameters\n  - **Parameters**: None\n  - **Return Type**: void\n  - **Behaviour**: Sends a request with unknown parameters and asserts that the response code is 404 and the OIDC response indicates the unknown parameters.\n\n- **Method**: testAmpersandInParameterValue\n  - **Parameters**: None\n  - **Return Type**: void\n  - **Behaviour**: Tests the server's handling of ampersands in parameter values, asserting the correct decoding of the state.\n\n- **Method**: testEqualsInParameterValue\n  - **Parameters**: None\n  - **Return Type**: void\n  - **Behaviour**: Tests the server's handling of equals signs in parameter values, asserting the correct decoding of the state.\n\n### Relationships\n- The test methods directly invoke the server's methods and validate the responses based on the HTTP requests sent to the server.\n\n### External Touchpoints\n- Utilizes JUnit for testing framework functionalities, including assertions and lifecycle management.\n\n### Observations & Caveats\n- The tests assume that the server is correctly implemented and running on the specified port. Any issues with the server implementation may lead to test failures.",
        "file_summary": "The 'RFC8252HttpServerTest.java' file contains unit tests for the RFC8252HttpServer class, focusing on validating the server's response to various OpenID Connect callback scenarios. It ensures that the server correctly handles valid and invalid requests, returning appropriate HTTP status codes and response data."
      }
    ]
  }
}